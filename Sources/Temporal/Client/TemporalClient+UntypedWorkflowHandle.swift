//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Temporal SDK open source project
//
// Copyright (c) 2025 Apple Inc. and the Swift Temporal SDK project authors
// Licensed under MIT License
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift Temporal SDK project authors
//
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

extension TemporalClient {
    // MARK: - Start Workflow

    /// Starts a workflow execution and returns a handle for managing the workflow instance.
    ///
    /// This method initiates a new workflow execution on the Temporal cluster and immediately returns a handle
    /// that can be used to monitor, query, signal, or wait for the workflow's completion.
    ///
    /// The returned handle provides access to the workflow's result through ``WorkflowHandle/result(followRuns:callOptions:)`` and
    /// supports various control operations like signaling and querying. The handle's ``WorkflowHandle/runID``
    /// is not set by this method; use ``workflowHandle(type:id:runID:firstExecutionRunID:)`` if you need to
    /// specify a particular run ID.
    ///
    /// ## Run ID Behavior
    ///
    /// The run ID generated by the Temporal server is available in both ``WorkflowHandle/resultRunID`` and
    /// ``WorkflowHandle/firstExecutionRunID`` properties of the returned handle. This run ID uniquely
    /// identifies this specific execution attempt of the workflow.
    ///
    /// - Parameters:
    ///   - name: The workflow name that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow.
    /// - Returns: A ``WorkflowHandle`` for monitoring and controlling the started workflow.
    /// - Throws: An error if the workflow cannot be started due to validation failures or server issues.
    public func startWorkflow<each Input: Sendable>(
        name: String,
        options: WorkflowOptions,
        input: repeat each Input,
    ) async throws -> UntypedWorkflowHandle {
        let runID = try await self.interceptedService.startWorkflow(
            name: name,
            options: options,
            input: repeat each input
        )

        // TODO: Once `StartSignal` as a `WorkflowOptions` is supported, set `resultRunID` to signal run ID and don't set `firstExecutionRunID`
        return UntypedWorkflowHandle(
            interceptor: self.interceptor,
            id: options.id,
            runID: nil,  // runID is not set
            resultRunID: runID,
            firstExecutionRunID: runID
        )
    }

    /// Starts a workflow execution with no input and returns a handle for managing the workflow instance.
    ///
    /// This convenience method starts a workflow that requires no input parameters. It provides the same
    /// functionality as ``startWorkflow(type:options:input:)`` but is specifically designed for workflows
    /// that have `Void` as their input type.
    ///
    /// - Parameters:
    ///   - name: The workflow name that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    /// - Returns: A ``WorkflowHandle`` for monitoring and controlling the started workflow.
    /// - Throws: An error if the workflow cannot be started due to validation failures or server issues.
    public func startWorkflow(
        name: String,
        options: WorkflowOptions
    ) async throws -> UntypedWorkflowHandle {
        try await self.startWorkflow(name: name, options: options, input: ())
    }

    // MARK: - Start Workflow and get result

    /// Executes a workflow and waits for its completion, returning the result.
    ///
    /// This method provides a convenient way to start a workflow and wait for its completion in a single call.
    /// It combines the functionality of ``startWorkflow(type:options:input:)`` and ``WorkflowHandle/result(followRuns:callOptions:)``
    /// into one operation.
    ///
    /// The method suspends until the workflow completes successfully, fails, or is terminated. For long-running
    /// workflows, consider using ``startWorkflow(type:options:input:)`` instead to get immediate access to
    /// the workflow handle for monitoring and control operations.
    ///
    /// This approach is ideal for workflows that complete quickly or when you only need the final result
    /// without intermediate monitoring or control.
    ///
    /// - Parameters:
    ///   - name: The workflow name that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow's run method.
    ///   - resultTypes: The expected return types from the workflow.
    /// - Returns: The output value produced by the completed workflow execution.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<each Input: Sendable, each Result: Sendable>(
        name: String,
        options: WorkflowOptions,
        input: repeat each Input,
        resultTypes: repeat (each Result).Type
    ) async throws -> (repeat each Result) {
        try await self.startWorkflow(
            name: name,
            options: options,
            input: repeat each input
        ).result(
            resultTypes: repeat each resultTypes
        )
    }

    /// Executes a workflow with no input and waits for its completion, returning the result.
    ///
    /// This convenience method combines workflow starting and result waiting for workflows that require no input.
    /// It provides the same functionality as ``executeWorkflow(type:options:input:)->_`` but is specifically
    /// designed for workflows with `Void` input type.
    ///
    /// - Parameters:
    ///   - name: The workflow name that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - resultTypes: The expected return types from the workflow.
    /// - Returns: The output value produced by the completed workflow execution.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<each Result: Sendable>(
        name: String,
        options: WorkflowOptions,
        resultTypes: repeat (each Result).Type,
    ) async throws -> (repeat each Result) {
        try await self.startWorkflow(
            name: name,
            options: options,
            input: ()
        ).result(
            resultTypes: repeat each resultTypes
        )
    }

    /// Executes a workflow and waits for its completion without returning a result.
    ///
    /// This convenience method combines workflow starting and result waiting for workflows that produce no output.
    /// It provides the same functionality as ``executeWorkflow(type:options:input:)->_`` but is specifically
    /// designed for workflows with `Void` output type.
    ///
    /// - Parameters:
    ///   - name: The workflow name that defines the business logic to execute.
    ///   - options: Configuration options including workflow ID, task queue, and execution policies.
    ///   - input: The input data to pass to the workflow's run method.
    /// - Throws: An error if the workflow fails to start, encounters an execution error, or is terminated.
    public func executeWorkflow<each Input: Sendable>(
        name: String,
        options: WorkflowOptions,
        input: repeat each Input
    ) async throws {
        let _: Void = try await self.startWorkflow(  // explicit return type sadly necessary
            name: name,
            options: options,
            input: repeat each input
        ).result()
    }

    // MARK: - Get Workflow Handle

    /// Creates a handle for accessing and managing an existing workflow execution.
    ///
    /// This method creates a handle for an already-running or completed workflow execution without starting
    /// a new workflow. Use this when you have the workflow ID and want to interact with an existing workflow
    /// instance through queries, signals, or to wait for its completion.
    ///
    /// Unlike handles returned by ``startWorkflow(type:options:input:)``, this method allows you to specify
    /// the exact run ID you want to target. This is useful when you need to interact with a specific
    /// execution attempt of a workflow that may have been retried or continued as a new execution.
    ///
    /// ## Run ID Configuration
    ///
    /// This method sets both ``WorkflowHandle/runID`` and ``WorkflowHandle/firstExecutionRunID`` based on
    /// the provided parameters. The ``WorkflowHandle/resultRunID`` is set to `nil` since no new execution
    /// is being started.
    ///
    /// - Parameters:
    ///   - id: The unique identifier of the workflow execution.
    ///   - runID: Run ID of the specific workflow execution or `nil` for the latest execution.
    ///   - firstExecutionRunID: The run ID of the first execution in the workflow chain, used for
    ///   cancellation and termination operations.
    /// - Returns: A ``WorkflowHandle`` configured for the specified workflow execution.
    public func untypedWorkflowHandle(
        id: String,
        runID: String? = nil,
        firstExecutionRunID: String? = nil
    ) -> UntypedWorkflowHandle {
        UntypedWorkflowHandle(
            interceptor: self.interceptor,
            id: id,
            runID: runID,
            resultRunID: nil,  // `resultRunID` is not set
            firstExecutionRunID: firstExecutionRunID
        )
    }

    // TODO: Possibly support `StartUpdateWithStartWorkflow`
    // Start an update using its name, possibly starting the workflow at the same time.
    // Also add interceptors.
}

extension TemporalClient.Interceptor {
    func startWorkflow<each Input>(
        _ input: StartWorkflowInput<repeat each Input>
    ) async throws -> UntypedWorkflowHandle {
        try await withInterceptors(interceptors, input: input, call: (any ClientOutboundInterceptor).startWorkflow) { input in
            let runID = try await self.workflowService.startWorkflow(
                name: input.name,
                options: input.options,
                headers: input.headers,
                input: input.input
            )

            // TODO: Once `StartSignal` as a `WorkflowOptions` is supported, set `resultRunID` to signal run ID and don't set `firstExecutionRunID`
            return UntypedWorkflowHandle(
                interceptor: self,
                id: input.options.id,
                runID: nil,  // runID is not set
                resultRunID: runID,
                firstExecutionRunID: runID
            )
        }
    }
}
