// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/failure/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Failure_V1_ApplicationFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var type: String = String()

  package var nonRetryable: Bool = false

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// next_retry_delay can be used by the client to override the activity
  /// retry interval calculated by the retry policy. Retry attempts will
  /// still be subject to the maximum retries limit and total time limit
  /// defined by the policy.
  package var nextRetryDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _nextRetryDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_nextRetryDelay = newValue}
  }
  /// Returns true if `nextRetryDelay` has been explicitly set.
  package var hasNextRetryDelay: Bool {return self._nextRetryDelay != nil}
  /// Clears the value of `nextRetryDelay`. Subsequent reads from it will return its default value.
  package mutating func clearNextRetryDelay() {self._nextRetryDelay = nil}

  package var category: Temporal_Api_Enums_V1_ApplicationErrorCategory = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _nextRetryDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Failure_V1_TimeoutFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var timeoutType: Temporal_Api_Enums_V1_TimeoutType = .unspecified

  package var lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _lastHeartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_lastHeartbeatDetails = newValue}
  }
  /// Returns true if `lastHeartbeatDetails` has been explicitly set.
  package var hasLastHeartbeatDetails: Bool {return self._lastHeartbeatDetails != nil}
  /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Failure_V1_CanceledFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Failure_V1_TerminatedFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Failure_V1_ServerFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var nonRetryable: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Failure_V1_ResetWorkflowFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _lastHeartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_lastHeartbeatDetails = newValue}
  }
  /// Returns true if `lastHeartbeatDetails` has been explicitly set.
  package var hasLastHeartbeatDetails: Bool {return self._lastHeartbeatDetails != nil}
  /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Failure_V1_ActivityFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var scheduledEventID: Int64 = 0

  package var startedEventID: Int64 = 0

  package var identity: String = String()

  package var activityType: Temporal_Api_Common_V1_ActivityType {
    get {return _activityType ?? Temporal_Api_Common_V1_ActivityType()}
    set {_activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  package var hasActivityType: Bool {return self._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  package mutating func clearActivityType() {self._activityType = nil}

  package var activityID: String = String()

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _activityType: Temporal_Api_Common_V1_ActivityType? = nil
}

package struct Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  package var initiatedEventID: Int64 = 0

  package var startedEventID: Int64 = 0

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_Failure_V1_NexusOperationFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The NexusOperationScheduled event ID.
  package var scheduledEventID: Int64 = 0

  /// Endpoint name.
  package var endpoint: String = String()

  /// Service name.
  package var service: String = String()

  /// Operation name.
  package var operation: String = String()

  /// Operation ID - may be empty if the operation completed synchronously.
  ///
  /// Deprecated. Renamed to operation_token.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var operationID: String = String()

  /// Operation token - may be empty if the operation completed synchronously.
  package var operationToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Failure_V1_NexusHandlerFailureInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Nexus error type as defined in the spec:
  /// https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
  package var type: String = String()

  /// Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
  package var retryBehavior: Temporal_Api_Enums_V1_NexusHandlerErrorRetryBehavior = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Failure_V1_Failure: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var message: String {
    get {return _storage._message}
    set {_uniqueStorage()._message = newValue}
  }

  /// The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
  /// In some SDKs this is used to rehydrate the stack trace into an exception object.
  package var source: String {
    get {return _storage._source}
    set {_uniqueStorage()._source = newValue}
  }

  package var stackTrace: String {
    get {return _storage._stackTrace}
    set {_uniqueStorage()._stackTrace = newValue}
  }

  /// Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
  /// errors originating in user code which might contain sensitive information.
  /// The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
  /// message.
  ///
  /// SDK authors:
  /// - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
  ///   - Uses a JSON object to represent `{ message, stack_trace }`.
  ///   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
  ///   - Overwrites the original stack_trace with an empty string.
  ///   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
  ///     by the user-provided PayloadCodec
  ///
  /// - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
  /// (-- api-linter: core::0203::optional=disabled --)
  package var encodedAttributes: Temporal_Api_Common_V1_Payload {
    get {return _storage._encodedAttributes ?? Temporal_Api_Common_V1_Payload()}
    set {_uniqueStorage()._encodedAttributes = newValue}
  }
  /// Returns true if `encodedAttributes` has been explicitly set.
  package var hasEncodedAttributes: Bool {return _storage._encodedAttributes != nil}
  /// Clears the value of `encodedAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearEncodedAttributes() {_uniqueStorage()._encodedAttributes = nil}

  package var cause: Temporal_Api_Failure_V1_Failure {
    get {return _storage._cause ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._cause = newValue}
  }
  /// Returns true if `cause` has been explicitly set.
  package var hasCause: Bool {return _storage._cause != nil}
  /// Clears the value of `cause`. Subsequent reads from it will return its default value.
  package mutating func clearCause() {_uniqueStorage()._cause = nil}

  package var failureInfo: OneOf_FailureInfo? {
    get {return _storage._failureInfo}
    set {_uniqueStorage()._failureInfo = newValue}
  }

  package var applicationFailureInfo: Temporal_Api_Failure_V1_ApplicationFailureInfo {
    get {
      if case .applicationFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_ApplicationFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .applicationFailureInfo(newValue)}
  }

  package var timeoutFailureInfo: Temporal_Api_Failure_V1_TimeoutFailureInfo {
    get {
      if case .timeoutFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_TimeoutFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .timeoutFailureInfo(newValue)}
  }

  package var canceledFailureInfo: Temporal_Api_Failure_V1_CanceledFailureInfo {
    get {
      if case .canceledFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_CanceledFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .canceledFailureInfo(newValue)}
  }

  package var terminatedFailureInfo: Temporal_Api_Failure_V1_TerminatedFailureInfo {
    get {
      if case .terminatedFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_TerminatedFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .terminatedFailureInfo(newValue)}
  }

  package var serverFailureInfo: Temporal_Api_Failure_V1_ServerFailureInfo {
    get {
      if case .serverFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_ServerFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .serverFailureInfo(newValue)}
  }

  package var resetWorkflowFailureInfo: Temporal_Api_Failure_V1_ResetWorkflowFailureInfo {
    get {
      if case .resetWorkflowFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_ResetWorkflowFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .resetWorkflowFailureInfo(newValue)}
  }

  package var activityFailureInfo: Temporal_Api_Failure_V1_ActivityFailureInfo {
    get {
      if case .activityFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_ActivityFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .activityFailureInfo(newValue)}
  }

  package var childWorkflowExecutionFailureInfo: Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo {
    get {
      if case .childWorkflowExecutionFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .childWorkflowExecutionFailureInfo(newValue)}
  }

  package var nexusOperationExecutionFailureInfo: Temporal_Api_Failure_V1_NexusOperationFailureInfo {
    get {
      if case .nexusOperationExecutionFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_NexusOperationFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .nexusOperationExecutionFailureInfo(newValue)}
  }

  package var nexusHandlerFailureInfo: Temporal_Api_Failure_V1_NexusHandlerFailureInfo {
    get {
      if case .nexusHandlerFailureInfo(let v)? = _storage._failureInfo {return v}
      return Temporal_Api_Failure_V1_NexusHandlerFailureInfo()
    }
    set {_uniqueStorage()._failureInfo = .nexusHandlerFailureInfo(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_FailureInfo: Equatable, Sendable {
    case applicationFailureInfo(Temporal_Api_Failure_V1_ApplicationFailureInfo)
    case timeoutFailureInfo(Temporal_Api_Failure_V1_TimeoutFailureInfo)
    case canceledFailureInfo(Temporal_Api_Failure_V1_CanceledFailureInfo)
    case terminatedFailureInfo(Temporal_Api_Failure_V1_TerminatedFailureInfo)
    case serverFailureInfo(Temporal_Api_Failure_V1_ServerFailureInfo)
    case resetWorkflowFailureInfo(Temporal_Api_Failure_V1_ResetWorkflowFailureInfo)
    case activityFailureInfo(Temporal_Api_Failure_V1_ActivityFailureInfo)
    case childWorkflowExecutionFailureInfo(Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo)
    case nexusOperationExecutionFailureInfo(Temporal_Api_Failure_V1_NexusOperationFailureInfo)
    case nexusHandlerFailureInfo(Temporal_Api_Failure_V1_NexusHandlerFailureInfo)

  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Failure_V1_MultiOperationExecutionAborted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.failure.v1"

extension Temporal_Api_Failure_V1_ApplicationFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApplicationFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}non_retryable\0\u{1}details\0\u{3}next_retry_delay\0\u{1}category\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.nonRetryable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nextRetryDelay) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.nonRetryable != false {
      try visitor.visitSingularBoolField(value: self.nonRetryable, fieldNumber: 2)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nextRetryDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_ApplicationFailureInfo, rhs: Temporal_Api_Failure_V1_ApplicationFailureInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.nonRetryable != rhs.nonRetryable {return false}
    if lhs._details != rhs._details {return false}
    if lhs._nextRetryDelay != rhs._nextRetryDelay {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_TimeoutFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimeoutFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timeout_type\0\u{3}last_heartbeat_details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.timeoutType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeoutType != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeoutType, fieldNumber: 1)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_TimeoutFailureInfo, rhs: Temporal_Api_Failure_V1_TimeoutFailureInfo) -> Bool {
    if lhs.timeoutType != rhs.timeoutType {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_CanceledFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CanceledFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_CanceledFailureInfo, rhs: Temporal_Api_Failure_V1_CanceledFailureInfo) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_TerminatedFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TerminatedFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_TerminatedFailureInfo, rhs: Temporal_Api_Failure_V1_TerminatedFailureInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_ServerFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ServerFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}non_retryable\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.nonRetryable) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonRetryable != false {
      try visitor.visitSingularBoolField(value: self.nonRetryable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_ServerFailureInfo, rhs: Temporal_Api_Failure_V1_ServerFailureInfo) -> Bool {
    if lhs.nonRetryable != rhs.nonRetryable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_ResetWorkflowFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetWorkflowFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_heartbeat_details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_ResetWorkflowFailureInfo, rhs: Temporal_Api_Failure_V1_ResetWorkflowFailureInfo) -> Bool {
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_ActivityFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}activity_type\0\u{3}activity_id\0\u{3}retry_state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._activityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 5)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_ActivityFailureInfo, rhs: Temporal_Api_Failure_V1_ActivityFailureInfo) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._activityType != rhs._activityType {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}retry_state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 4)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 5)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo, rhs: Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_NexusOperationFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{3}operation_id\0\u{3}operation_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.operationToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 3)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 4)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 5)
    }
    if !self.operationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.operationToken, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_NexusOperationFailureInfo, rhs: Temporal_Api_Failure_V1_NexusOperationFailureInfo) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.operationToken != rhs.operationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_NexusHandlerFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusHandlerFailureInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}retry_behavior\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.retryBehavior) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.retryBehavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryBehavior, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_NexusHandlerFailureInfo, rhs: Temporal_Api_Failure_V1_NexusHandlerFailureInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.retryBehavior != rhs.retryBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Failure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}source\0\u{3}stack_trace\0\u{1}cause\0\u{3}application_failure_info\0\u{3}timeout_failure_info\0\u{3}canceled_failure_info\0\u{3}terminated_failure_info\0\u{3}server_failure_info\0\u{3}reset_workflow_failure_info\0\u{3}activity_failure_info\0\u{3}child_workflow_execution_failure_info\0\u{3}nexus_operation_execution_failure_info\0\u{3}nexus_handler_failure_info\0\u{4}\u{6}encoded_attributes\0")

  fileprivate class _StorageClass {
    var _message: String = String()
    var _source: String = String()
    var _stackTrace: String = String()
    var _encodedAttributes: Temporal_Api_Common_V1_Payload? = nil
    var _cause: Temporal_Api_Failure_V1_Failure? = nil
    var _failureInfo: Temporal_Api_Failure_V1_Failure.OneOf_FailureInfo?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _source = source._source
      _stackTrace = source._stackTrace
      _encodedAttributes = source._encodedAttributes
      _cause = source._cause
      _failureInfo = source._failureInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stackTrace) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cause) }()
        case 5: try {
          var v: Temporal_Api_Failure_V1_ApplicationFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .applicationFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .applicationFailureInfo(v)
          }
        }()
        case 6: try {
          var v: Temporal_Api_Failure_V1_TimeoutFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .timeoutFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .timeoutFailureInfo(v)
          }
        }()
        case 7: try {
          var v: Temporal_Api_Failure_V1_CanceledFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .canceledFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .canceledFailureInfo(v)
          }
        }()
        case 8: try {
          var v: Temporal_Api_Failure_V1_TerminatedFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .terminatedFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .terminatedFailureInfo(v)
          }
        }()
        case 9: try {
          var v: Temporal_Api_Failure_V1_ServerFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .serverFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .serverFailureInfo(v)
          }
        }()
        case 10: try {
          var v: Temporal_Api_Failure_V1_ResetWorkflowFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .resetWorkflowFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .resetWorkflowFailureInfo(v)
          }
        }()
        case 11: try {
          var v: Temporal_Api_Failure_V1_ActivityFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .activityFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .activityFailureInfo(v)
          }
        }()
        case 12: try {
          var v: Temporal_Api_Failure_V1_ChildWorkflowExecutionFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .childWorkflowExecutionFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .childWorkflowExecutionFailureInfo(v)
          }
        }()
        case 13: try {
          var v: Temporal_Api_Failure_V1_NexusOperationFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .nexusOperationExecutionFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .nexusOperationExecutionFailureInfo(v)
          }
        }()
        case 14: try {
          var v: Temporal_Api_Failure_V1_NexusHandlerFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .nexusHandlerFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .nexusHandlerFailureInfo(v)
          }
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._encodedAttributes) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 1)
      }
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 2)
      }
      if !_storage._stackTrace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stackTrace, fieldNumber: 3)
      }
      try { if let v = _storage._cause {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      switch _storage._failureInfo {
      case .applicationFailureInfo?: try {
        guard case .applicationFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .timeoutFailureInfo?: try {
        guard case .timeoutFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .canceledFailureInfo?: try {
        guard case .canceledFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .terminatedFailureInfo?: try {
        guard case .terminatedFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .serverFailureInfo?: try {
        guard case .serverFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .resetWorkflowFailureInfo?: try {
        guard case .resetWorkflowFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .activityFailureInfo?: try {
        guard case .activityFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .childWorkflowExecutionFailureInfo?: try {
        guard case .childWorkflowExecutionFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .nexusOperationExecutionFailureInfo?: try {
        guard case .nexusOperationExecutionFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .nexusHandlerFailureInfo?: try {
        guard case .nexusHandlerFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._encodedAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_Failure, rhs: Temporal_Api_Failure_V1_Failure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._stackTrace != rhs_storage._stackTrace {return false}
        if _storage._encodedAttributes != rhs_storage._encodedAttributes {return false}
        if _storage._cause != rhs_storage._cause {return false}
        if _storage._failureInfo != rhs_storage._failureInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Failure_V1_MultiOperationExecutionAborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".MultiOperationExecutionAborted"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Failure_V1_MultiOperationExecutionAborted, rhs: Temporal_Api_Failure_V1_MultiOperationExecutionAborted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
