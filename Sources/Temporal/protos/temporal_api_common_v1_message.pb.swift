// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/common/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Common_V1_DataBlob: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var encodingType: Temporal_Api_Enums_V1_EncodingType = .unspecified

  package var data: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// See `Payload`
package struct Temporal_Api_Common_V1_Payloads: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var payloads: [Temporal_Api_Common_V1_Payload] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Represents some binary (byte array) data (ex: activity input parameters or workflow result) with
/// metadata which describes this binary data (format, encoding, encryption, etc). Serialization
/// of the data may be user-defined.
package struct Temporal_Api_Common_V1_Payload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var metadata: Dictionary<String,Data> = [:]

  package var data: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A user-defined set of *indexed* fields that are used/exposed when listing/searching workflows.
/// The payload is not serialized in a user-defined way.
package struct Temporal_Api_Common_V1_SearchAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var indexedFields: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A user-defined set of *unindexed* fields that are exposed when listing/searching workflows
package struct Temporal_Api_Common_V1_Memo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var fields: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Contains metadata that can be attached to a variety of requests, like starting a workflow, and
/// can be propagated between, for example, workflows and activities.
package struct Temporal_Api_Common_V1_Header: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var fields: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Identifies a specific workflow within a namespace. Practically speaking, because run_id is a
/// uuid, a workflow execution is globally unique. Note that many commands allow specifying an empty
/// run id as a way of saying "target the latest run of the workflow".
package struct Temporal_Api_Common_V1_WorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workflowID: String = String()

  package var runID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Represents the identifier used by a workflow author to define the workflow. Typically, the
/// name of a function. This is sometimes referred to as the workflow's "name"
package struct Temporal_Api_Common_V1_WorkflowType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Represents the identifier used by a activity author to define the activity. Typically, the
/// name of a function. This is sometimes referred to as the activity's "name"
package struct Temporal_Api_Common_V1_ActivityType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// How retries ought to be handled, usable by both workflows and activities
package struct Temporal_Api_Common_V1_RetryPolicy: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Interval of the first retry. If retryBackoffCoefficient is 1.0 then it is used for all retries.
  package var initialInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _initialInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_initialInterval = newValue}
  }
  /// Returns true if `initialInterval` has been explicitly set.
  package var hasInitialInterval: Bool {return self._initialInterval != nil}
  /// Clears the value of `initialInterval`. Subsequent reads from it will return its default value.
  package mutating func clearInitialInterval() {self._initialInterval = nil}

  /// Coefficient used to calculate the next retry interval.
  /// The next retry interval is previous interval multiplied by the coefficient.
  /// Must be 1 or larger.
  package var backoffCoefficient: Double = 0

  /// Maximum interval between retries. Exponential backoff leads to interval increase.
  /// This value is the cap of the increase. Default is 100x of the initial interval.
  package var maximumInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _maximumInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_maximumInterval = newValue}
  }
  /// Returns true if `maximumInterval` has been explicitly set.
  package var hasMaximumInterval: Bool {return self._maximumInterval != nil}
  /// Clears the value of `maximumInterval`. Subsequent reads from it will return its default value.
  package mutating func clearMaximumInterval() {self._maximumInterval = nil}

  /// Maximum number of attempts. When exceeded the retries stop even if not expired yet.
  /// 1 disables retries. 0 means unlimited (up to the timeouts)
  package var maximumAttempts: Int32 = 0

  /// Non-Retryable errors types. Will stop retrying if the error type matches this list. Note that
  /// this is not a substring match, the error *type* (not message) must match exactly.
  package var nonRetryableErrorTypes: [String] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _initialInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _maximumInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Metadata relevant for metering purposes
package struct Temporal_Api_Common_V1_MeteringMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Count of local activities which have begun an execution attempt during this workflow task,
  /// and whose first attempt occurred in some previous task. This is used for metering
  /// purposes, and does not affect workflow state.
  ///
  /// (-- api-linter: core::0141::forbidden-types=disabled
  ///     aip.dev/not-precedent: Negative values make no sense to represent. --)
  package var nonfirstLocalActivityExecutionAttempts: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Deprecated. This message is replaced with `Deployment` and `VersioningBehavior`.
/// Identifies the version(s) of a worker that processed a task
package struct Temporal_Api_Common_V1_WorkerVersionStamp: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An opaque whole-worker identifier. Replaces the deprecated `binary_checksum` field when this
  /// message is included in requests which previously used that.
  package var buildID: String = String()

  /// If set, the worker is opting in to worker versioning. Otherwise, this is used only as a
  /// marker for workflow reset points and the BuildIDs search attribute.
  package var useVersioning: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Identifies the version that a worker is compatible with when polling or identifying itself,
/// and whether or not this worker is opting into the build-id based versioning feature. This is
/// used by matching to determine which workers ought to receive what tasks.
/// Deprecated. Use WorkerDeploymentOptions instead.
package struct Temporal_Api_Common_V1_WorkerVersionCapabilities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An opaque whole-worker identifier
  package var buildID: String = String()

  /// If set, the worker is opting in to worker versioning, and wishes to only receive appropriate
  /// tasks.
  package var useVersioning: Bool = false

  /// Must be sent if user has set a deployment series name (versioning-3).
  package var deploymentSeriesName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Describes where and how to reset a workflow, used for batch reset currently
/// and may be used for single-workflow reset later.
package struct Temporal_Api_Common_V1_ResetOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Which workflow task to reset to.
  package var target: Temporal_Api_Common_V1_ResetOptions.OneOf_Target? = nil

  /// Resets to the first workflow task completed or started event.
  package var firstWorkflowTask: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .firstWorkflowTask(let v)? = target {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {target = .firstWorkflowTask(newValue)}
  }

  /// Resets to the last workflow task completed or started event.
  package var lastWorkflowTask: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .lastWorkflowTask(let v)? = target {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {target = .lastWorkflowTask(newValue)}
  }

  /// The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
  /// `WORKFLOW_TASK_STARTED` event to reset to.
  /// Note that this option doesn't make sense when used as part of a batch request.
  package var workflowTaskID: Int64 {
    get {
      if case .workflowTaskID(let v)? = target {return v}
      return 0
    }
    set {target = .workflowTaskID(newValue)}
  }

  /// Resets to the first workflow task processed by this build id.
  /// If the workflow was not processed by the build id, or the workflow task can't be
  /// determined, no reset will be performed.
  /// Note that by default, this reset is allowed to be to a prior run in a chain of
  /// continue-as-new.
  package var buildID: String {
    get {
      if case .buildID(let v)? = target {return v}
      return String()
    }
    set {target = .buildID(newValue)}
  }

  /// Deprecated. Use `options`.
  /// Default: RESET_REAPPLY_TYPE_SIGNAL
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var resetReapplyType: Temporal_Api_Enums_V1_ResetReapplyType = .unspecified

  /// If true, limit the reset to only within the current run. (Applies to build_id targets and
  /// possibly others in the future.)
  package var currentRunOnly: Bool = false

  /// Event types not to be reapplied
  package var resetReapplyExcludeTypes: [Temporal_Api_Enums_V1_ResetReapplyExcludeType] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Which workflow task to reset to.
  package enum OneOf_Target: Equatable, Sendable {
    /// Resets to the first workflow task completed or started event.
    case firstWorkflowTask(SwiftProtobuf.Google_Protobuf_Empty)
    /// Resets to the last workflow task completed or started event.
    case lastWorkflowTask(SwiftProtobuf.Google_Protobuf_Empty)
    /// The id of a specific `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
    /// `WORKFLOW_TASK_STARTED` event to reset to.
    /// Note that this option doesn't make sense when used as part of a batch request.
    case workflowTaskID(Int64)
    /// Resets to the first workflow task processed by this build id.
    /// If the workflow was not processed by the build id, or the workflow task can't be
    /// determined, no reset will be performed.
    /// Note that by default, this reset is allowed to be to a prior run in a chain of
    /// continue-as-new.
    case buildID(String)

  }

  package init() {}
}

/// Callback to attach to various events in the system, e.g. workflow run completion.
package struct Temporal_Api_Common_V1_Callback: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var variant: Temporal_Api_Common_V1_Callback.OneOf_Variant? = nil

  package var nexus: Temporal_Api_Common_V1_Callback.Nexus {
    get {
      if case .nexus(let v)? = variant {return v}
      return Temporal_Api_Common_V1_Callback.Nexus()
    }
    set {variant = .nexus(newValue)}
  }

  package var `internal`: Temporal_Api_Common_V1_Callback.Internal {
    get {
      if case .internal(let v)? = variant {return v}
      return Temporal_Api_Common_V1_Callback.Internal()
    }
    set {variant = .internal(newValue)}
  }

  /// Links associated with the callback. It can be used to link to underlying resources of the
  /// callback.
  package var links: [Temporal_Api_Common_V1_Link] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    case nexus(Temporal_Api_Common_V1_Callback.Nexus)
    case `internal`(Temporal_Api_Common_V1_Callback.Internal)

  }

  package struct Nexus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Callback URL.
    package var url: String = String()

    /// Header to attach to callback request.
    package var header: Dictionary<String,String> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  /// Callbacks to be delivered internally within the system.
  /// This variant is not settable in the API and will be rejected by the service with an INVALID_ARGUMENT error.
  /// The only reason that this is exposed is because callbacks are replicated across clusters via the
  /// WorkflowExecutionStarted event, which is defined in the public API.
  package struct Internal: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Opaque internal data.
    package var data: Data = Data()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

/// Link can be associated with history events. It might contain information about an external entity
/// related to the history event. For example, workflow A makes a Nexus call that starts workflow B:
/// in this case, a history event in workflow A could contain a Link to the workflow started event in
/// workflow B, and vice-versa.
package struct Temporal_Api_Common_V1_Link: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var variant: Temporal_Api_Common_V1_Link.OneOf_Variant? = nil

  package var workflowEvent: Temporal_Api_Common_V1_Link.WorkflowEvent {
    get {
      if case .workflowEvent(let v)? = variant {return v}
      return Temporal_Api_Common_V1_Link.WorkflowEvent()
    }
    set {variant = .workflowEvent(newValue)}
  }

  package var batchJob: Temporal_Api_Common_V1_Link.BatchJob {
    get {
      if case .batchJob(let v)? = variant {return v}
      return Temporal_Api_Common_V1_Link.BatchJob()
    }
    set {variant = .batchJob(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    case workflowEvent(Temporal_Api_Common_V1_Link.WorkflowEvent)
    case batchJob(Temporal_Api_Common_V1_Link.BatchJob)

  }

  package struct WorkflowEvent: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var namespace: String = String()

    package var workflowID: String = String()

    package var runID: String = String()

    /// Additional information about the workflow event.
    /// Eg: the caller workflow can send the history event details that made the Nexus call.
    package var reference: Temporal_Api_Common_V1_Link.WorkflowEvent.OneOf_Reference? = nil

    package var eventRef: Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference {
      get {
        if case .eventRef(let v)? = reference {return v}
        return Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference()
      }
      set {reference = .eventRef(newValue)}
    }

    package var requestIDRef: Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference {
      get {
        if case .requestIDRef(let v)? = reference {return v}
        return Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference()
      }
      set {reference = .requestIDRef(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Additional information about the workflow event.
    /// Eg: the caller workflow can send the history event details that made the Nexus call.
    package enum OneOf_Reference: Equatable, Sendable {
      case eventRef(Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference)
      case requestIDRef(Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference)

    }

    /// EventReference is a direct reference to a history event through the event ID.
    package struct EventReference: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      package var eventID: Int64 = 0

      package var eventType: Temporal_Api_Enums_V1_EventType = .unspecified

      package var unknownFields = SwiftProtobuf.UnknownStorage()

      package init() {}
    }

    /// RequestIdReference is a indirect reference to a history event through the request ID.
    package struct RequestIdReference: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      package var requestID: String = String()

      package var eventType: Temporal_Api_Enums_V1_EventType = .unspecified

      package var unknownFields = SwiftProtobuf.UnknownStorage()

      package init() {}
    }

    package init() {}
  }

  /// A link to a built-in batch job.
  /// Batch jobs can be used to perform operations on a set of workflows (e.g. terminate, signal, cancel, etc).
  /// This link can be put on workflow history events generated by actions taken by a batch job.
  package struct BatchJob: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var jobID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

/// Priority contains metadata that controls relative ordering of task processing
/// when tasks are backed up in a queue. Initially, Priority will be used in
/// matching (workflow and activity) task queues. Later it may be used in history
/// task queues and in rate limiting decisions.
///
/// Priority is attached to workflows and activities. By default, activities
/// inherit Priority from the workflow that created them, but may override fields
/// when an activity is started or modified.
///
/// Despite being named "Priority", this message also contains fields that
/// control "fairness" mechanisms.
///
/// For all fields, the field not present or equal to zero/empty string means to
/// inherit the value from the calling workflow, or if there is no calling
/// workflow, then use the default value.
///
/// For all fields other than fairness_key, the zero value isn't meaningful so
/// there's no confusion between inherit/default and a meaningful value. For
/// fairness_key, the empty string will be interpreted as "inherit". This means
/// that if a workflow has a non-empty fairness key, you can't override the
/// fairness key of its activity to the empty string.
///
/// The overall semantics of Priority are:
/// 1. First, consider "priority": higher priority (lower number) goes first.
/// 2. Then, consider fairness: try to dispatch tasks for different fairness keys
///    in proportion to their weight.
///
/// Applications may use any subset of mechanisms that are useful to them and
/// leave the other fields to use default values.
///
/// Not all queues in the system may support the "full" semantics of all priority
/// fields. (Currently only support in matching task queues is planned.)
package struct Temporal_Api_Common_V1_Priority: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Priority key is a positive integer from 1 to n, where smaller integers
  /// correspond to higher priorities (tasks run sooner). In general, tasks in
  /// a queue should be processed in close to priority order, although small
  /// deviations are possible.
  ///
  /// The maximum priority value (minimum priority) is determined by server
  /// configuration, and defaults to 5.
  ///
  /// If priority is not present (or zero), then the effective priority will be
  /// the default priority, which is is calculated by (min+max)/2. With the
  /// default max of 5, and min of 1, that comes out to 3.
  package var priorityKey: Int32 = 0

  /// Fairness key is a short string that's used as a key for a fairness
  /// balancing mechanism. It may correspond to a tenant id, or to a fixed
  /// string like "high" or "low". The default is the empty string.
  ///
  /// The fairness mechanism attempts to dispatch tasks for a given key in
  /// proportion to its weight. For example, using a thousand distinct tenant
  /// ids, each with a weight of 1.0 (the default) will result in each tenant
  /// getting a roughly equal share of task dispatch throughput.
  ///
  /// (Note: this does not imply equal share of worker capacity! Fairness
  /// decisions are made based on queue statistics, not
  /// current worker load.)
  ///
  /// As another example, using keys "high" and "low" with weight 9.0 and 1.0
  /// respectively will prefer dispatching "high" tasks over "low" tasks at a
  /// 9:1 ratio, while allowing either key to use all worker capacity if the
  /// other is not present.
  ///
  /// All fairness mechanisms, including rate limits, are best-effort and
  /// probabilistic. The results may not match what a "perfect" algorithm with
  /// infinite resources would produce. The more unique keys are used, the less
  /// accurate the results will be.
  ///
  /// Fairness keys are limited to 64 bytes.
  package var fairnessKey: String = String()

  /// Fairness weight for a task can come from multiple sources for
  /// flexibility. From highest to lowest precedence:
  /// 1. Weights for a small set of keys can be overridden in task queue
  ///    configuration with an API.
  /// 2. It can be attached to the workflow/activity in this field.
  /// 3. The default weight of 1.0 will be used.
  ///
  /// Weight values are clamped to the range [0.001, 1000].
  package var fairnessWeight: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// This is used to send commands to a specific worker or a group of workers.
/// Right now, it is used to send commands to a specific worker instance.
/// Will be extended to be able to send command to multiple workers.
package struct Temporal_Api_Common_V1_WorkerSelector: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Options are:
  /// - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
  /// - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
  /// - etc.
  ///   All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
  /// string query = 5;
  /// string task_queue = 6;
  /// ...
  package var selector: Temporal_Api_Common_V1_WorkerSelector.OneOf_Selector? = nil

  /// Worker instance key to which the command should be sent.
  package var workerInstanceKey: String {
    get {
      if case .workerInstanceKey(let v)? = selector {return v}
      return String()
    }
    set {selector = .workerInstanceKey(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Options are:
  /// - query (will be used as query to ListWorkers, same format as in ListWorkersRequest.query)
  /// - task queue (just a shortcut. Same as query=' "TaskQueue"="my-task-queue" ')
  /// - etc.
  ///   All but 'query' are shortcuts, can be replaced with a query, but it is not convenient.
  /// string query = 5;
  /// string task_queue = 6;
  /// ...
  package enum OneOf_Selector: Equatable, Sendable {
    /// Worker instance key to which the command should be sent.
    case workerInstanceKey(String)

  }

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.common.v1"

extension Temporal_Api_Common_V1_DataBlob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DataBlob"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}encoding_type\0\u{1}data\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.encodingType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.encodingType != .unspecified {
      try visitor.visitSingularEnumField(value: self.encodingType, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_DataBlob, rhs: Temporal_Api_Common_V1_DataBlob) -> Bool {
    if lhs.encodingType != rhs.encodingType {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Payloads: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Payloads"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}payloads\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.payloads) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.payloads.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payloads, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Payloads, rhs: Temporal_Api_Common_V1_Payloads) -> Bool {
    if lhs.payloads != rhs.payloads {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Payload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Payload"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}metadata\0\u{1}data\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: &self.metadata) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufBytes>.self, value: self.metadata, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Payload, rhs: Temporal_Api_Common_V1_Payload) -> Bool {
    if lhs.metadata != rhs.metadata {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_SearchAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SearchAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}indexed_fields\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.indexedFields) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.indexedFields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.indexedFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_SearchAttributes, rhs: Temporal_Api_Common_V1_SearchAttributes) -> Bool {
    if lhs.indexedFields != rhs.indexedFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Memo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Memo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fields\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Memo, rhs: Temporal_Api_Common_V1_Memo) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Header"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}fields\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Header, rhs: Temporal_Api_Common_V1_Header) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_WorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_WorkflowExecution, rhs: Temporal_Api_Common_V1_WorkflowExecution) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_WorkflowType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowType"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_WorkflowType, rhs: Temporal_Api_Common_V1_WorkflowType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_ActivityType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityType"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_ActivityType, rhs: Temporal_Api_Common_V1_ActivityType) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_RetryPolicy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RetryPolicy"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}initial_interval\0\u{3}backoff_coefficient\0\u{3}maximum_interval\0\u{3}maximum_attempts\0\u{3}non_retryable_error_types\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initialInterval) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.backoffCoefficient) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._maximumInterval) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.maximumAttempts) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.nonRetryableErrorTypes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initialInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.backoffCoefficient.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.backoffCoefficient, fieldNumber: 2)
    }
    try { if let v = self._maximumInterval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.maximumAttempts != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumAttempts, fieldNumber: 4)
    }
    if !self.nonRetryableErrorTypes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.nonRetryableErrorTypes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_RetryPolicy, rhs: Temporal_Api_Common_V1_RetryPolicy) -> Bool {
    if lhs._initialInterval != rhs._initialInterval {return false}
    if lhs.backoffCoefficient != rhs.backoffCoefficient {return false}
    if lhs._maximumInterval != rhs._maximumInterval {return false}
    if lhs.maximumAttempts != rhs.maximumAttempts {return false}
    if lhs.nonRetryableErrorTypes != rhs.nonRetryableErrorTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_MeteringMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".MeteringMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{4}\u{d}nonfirst_local_activity_execution_attempts\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 13: try { try decoder.decodeSingularUInt32Field(value: &self.nonfirstLocalActivityExecutionAttempts) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonfirstLocalActivityExecutionAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.nonfirstLocalActivityExecutionAttempts, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_MeteringMetadata, rhs: Temporal_Api_Common_V1_MeteringMetadata) -> Bool {
    if lhs.nonfirstLocalActivityExecutionAttempts != rhs.nonfirstLocalActivityExecutionAttempts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_WorkerVersionStamp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerVersionStamp"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id\0\u{4}\u{2}use_versioning\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.useVersioning) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 1)
    }
    if self.useVersioning != false {
      try visitor.visitSingularBoolField(value: self.useVersioning, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_WorkerVersionStamp, rhs: Temporal_Api_Common_V1_WorkerVersionStamp) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.useVersioning != rhs.useVersioning {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_WorkerVersionCapabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerVersionCapabilities"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id\0\u{3}use_versioning\0\u{4}\u{2}deployment_series_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.useVersioning) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deploymentSeriesName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 1)
    }
    if self.useVersioning != false {
      try visitor.visitSingularBoolField(value: self.useVersioning, fieldNumber: 2)
    }
    if !self.deploymentSeriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentSeriesName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_WorkerVersionCapabilities, rhs: Temporal_Api_Common_V1_WorkerVersionCapabilities) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.useVersioning != rhs.useVersioning {return false}
    if lhs.deploymentSeriesName != rhs.deploymentSeriesName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_ResetOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}first_workflow_task\0\u{3}last_workflow_task\0\u{3}workflow_task_id\0\u{3}build_id\0\u{4}\u{6}reset_reapply_type\0\u{3}current_run_only\0\u{3}reset_reapply_exclude_types\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .firstWorkflowTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .firstWorkflowTask(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .lastWorkflowTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .lastWorkflowTask(v)
        }
      }()
      case 3: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .workflowTaskID(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .buildID(v)
        }
      }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.resetReapplyType) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.currentRunOnly) }()
      case 12: try { try decoder.decodeRepeatedEnumField(value: &self.resetReapplyExcludeTypes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.target {
    case .firstWorkflowTask?: try {
      guard case .firstWorkflowTask(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .lastWorkflowTask?: try {
      guard case .lastWorkflowTask(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .workflowTaskID?: try {
      guard case .workflowTaskID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    }()
    case .buildID?: try {
      guard case .buildID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if self.resetReapplyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetReapplyType, fieldNumber: 10)
    }
    if self.currentRunOnly != false {
      try visitor.visitSingularBoolField(value: self.currentRunOnly, fieldNumber: 11)
    }
    if !self.resetReapplyExcludeTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.resetReapplyExcludeTypes, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_ResetOptions, rhs: Temporal_Api_Common_V1_ResetOptions) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.resetReapplyType != rhs.resetReapplyType {return false}
    if lhs.currentRunOnly != rhs.currentRunOnly {return false}
    if lhs.resetReapplyExcludeTypes != rhs.resetReapplyExcludeTypes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Callback: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Callback"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}nexus\0\u{1}internal\0\u{2}a\u{1}links\0\u{c}\u{1}\u{1}")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Temporal_Api_Common_V1_Callback.Nexus?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .nexus(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .nexus(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Common_V1_Callback.Internal?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .internal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .internal(v)
        }
      }()
      case 100: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .nexus?: try {
      guard case .nexus(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .internal?: try {
      guard case .internal(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Callback, rhs: Temporal_Api_Common_V1_Callback) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Callback.Nexus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Callback.protoMessageName + ".Nexus"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}url\0\u{1}header\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.header) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.header.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.header, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Callback.Nexus, rhs: Temporal_Api_Common_V1_Callback.Nexus) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.header != rhs.header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Callback.Internal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Callback.protoMessageName + ".Internal"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Callback.Internal, rhs: Temporal_Api_Common_V1_Callback.Internal) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Link: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Link"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_event\0\u{3}batch_job\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Common_V1_Link.WorkflowEvent?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .workflowEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .workflowEvent(v)
        }
      }()
      case 2: try {
        var v: Temporal_Api_Common_V1_Link.BatchJob?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .batchJob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .batchJob(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .workflowEvent?: try {
      guard case .workflowEvent(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .batchJob?: try {
      guard case .batchJob(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Link, rhs: Temporal_Api_Common_V1_Link) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Link.WorkflowEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Link.protoMessageName + ".WorkflowEvent"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{4}a\u{1}event_ref\0\u{3}request_id_ref\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 100: try {
        var v: Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .eventRef(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .eventRef(v)
        }
      }()
      case 101: try {
        var v: Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference?
        var hadOneofValue = false
        if let current = self.reference {
          hadOneofValue = true
          if case .requestIDRef(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.reference = .requestIDRef(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    switch self.reference {
    case .eventRef?: try {
      guard case .eventRef(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    }()
    case .requestIDRef?: try {
      guard case .requestIDRef(let v)? = self.reference else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Link.WorkflowEvent, rhs: Temporal_Api_Common_V1_Link.WorkflowEvent) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.reference != rhs.reference {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Link.WorkflowEvent.protoMessageName + ".EventReference"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}event_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.eventID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventID != 0 {
      try visitor.visitSingularInt64Field(value: self.eventID, fieldNumber: 1)
    }
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference, rhs: Temporal_Api_Common_V1_Link.WorkflowEvent.EventReference) -> Bool {
    if lhs.eventID != rhs.eventID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Link.WorkflowEvent.protoMessageName + ".RequestIdReference"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}request_id\0\u{3}event_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference, rhs: Temporal_Api_Common_V1_Link.WorkflowEvent.RequestIdReference) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Link.BatchJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Common_V1_Link.protoMessageName + ".BatchJob"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Link.BatchJob, rhs: Temporal_Api_Common_V1_Link.BatchJob) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_Priority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Priority"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}priority_key\0\u{3}fairness_key\0\u{3}fairness_weight\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.priorityKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.fairnessKey) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.fairnessWeight) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.priorityKey != 0 {
      try visitor.visitSingularInt32Field(value: self.priorityKey, fieldNumber: 1)
    }
    if !self.fairnessKey.isEmpty {
      try visitor.visitSingularStringField(value: self.fairnessKey, fieldNumber: 2)
    }
    if self.fairnessWeight.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.fairnessWeight, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_Priority, rhs: Temporal_Api_Common_V1_Priority) -> Bool {
    if lhs.priorityKey != rhs.priorityKey {return false}
    if lhs.fairnessKey != rhs.fairnessKey {return false}
    if lhs.fairnessWeight != rhs.fairnessWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Common_V1_WorkerSelector: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerSelector"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_instance_key\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.selector != nil {try decoder.handleConflictingOneOf()}
          self.selector = .workerInstanceKey(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .workerInstanceKey(let v)? = self.selector {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Common_V1_WorkerSelector, rhs: Temporal_Api_Common_V1_WorkerSelector) -> Bool {
    if lhs.selector != rhs.selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
