// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/nexus/nexus.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Coresdk_Nexus_NexusTaskCancelReason: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// The nexus task is known to have timed out
  case timedOut // = 0

  /// The worker is shutting down
  case workerShutdown // = 1
  case UNRECOGNIZED(Int)

  package init() {
    self = .timedOut
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .timedOut
    case 1: self = .workerShutdown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .timedOut: return 0
    case .workerShutdown: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_Nexus_NexusTaskCancelReason] = [
    .timedOut,
    .workerShutdown,
  ]

}

/// Controls at which point to report back to lang when a nexus operation is cancelled
package enum Coresdk_Nexus_NexusOperationCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Wait for operation cancellation completion. Default.
  case waitCancellationCompleted // = 0

  /// Do not request cancellation of the nexus operation if already scheduled
  case abandon // = 1

  /// Initiate a cancellation request for the Nexus operation and immediately report cancellation
  /// to the caller. Note that it doesn't guarantee that cancellation is delivered to the operation if calling workflow exits before the delivery is done.
  /// If you want to ensure that cancellation is delivered to the operation, use WAIT_CANCELLATION_REQUESTED.
  case tryCancel // = 2

  /// Request cancellation of the operation and wait for confirmation that the request was received.
  case waitCancellationRequested // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .waitCancellationCompleted
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .waitCancellationCompleted
    case 1: self = .abandon
    case 2: self = .tryCancel
    case 3: self = .waitCancellationRequested
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .waitCancellationCompleted: return 0
    case .abandon: return 1
    case .tryCancel: return 2
    case .waitCancellationRequested: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_Nexus_NexusOperationCancellationType] = [
    .waitCancellationCompleted,
    .abandon,
    .tryCancel,
    .waitCancellationRequested,
  ]

}

/// Used by core to resolve nexus operations.
package struct Coresdk_Nexus_NexusOperationResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var status: Coresdk_Nexus_NexusOperationResult.OneOf_Status? = nil

  package var completed: Temporal_Api_Common_V1_Payload {
    get {
      if case .completed(let v)? = status {return v}
      return Temporal_Api_Common_V1_Payload()
    }
    set {status = .completed(newValue)}
  }

  package var failed: Temporal_Api_Failure_V1_Failure {
    get {
      if case .failed(let v)? = status {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {status = .failed(newValue)}
  }

  package var cancelled: Temporal_Api_Failure_V1_Failure {
    get {
      if case .cancelled(let v)? = status {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {status = .cancelled(newValue)}
  }

  package var timedOut: Temporal_Api_Failure_V1_Failure {
    get {
      if case .timedOut(let v)? = status {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {status = .timedOut(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    case completed(Temporal_Api_Common_V1_Payload)
    case failed(Temporal_Api_Failure_V1_Failure)
    case cancelled(Temporal_Api_Failure_V1_Failure)
    case timedOut(Temporal_Api_Failure_V1_Failure)

  }

  package init() {}
}

/// A response to a Nexus task
package struct Coresdk_Nexus_NexusTaskCompletion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique identifier for this task provided in the poll response
  package var taskToken: Data = Data()

  package var status: Coresdk_Nexus_NexusTaskCompletion.OneOf_Status? = nil

  /// The handler completed (successfully or not). Note that the response kind must match the
  /// request kind (start or cancel).
  package var completed: Temporal_Api_Nexus_V1_Response {
    get {
      if case .completed(let v)? = status {return v}
      return Temporal_Api_Nexus_V1_Response()
    }
    set {status = .completed(newValue)}
  }

  /// The handler could not complete the request for some reason.
  package var error: Temporal_Api_Nexus_V1_HandlerError {
    get {
      if case .error(let v)? = status {return v}
      return Temporal_Api_Nexus_V1_HandlerError()
    }
    set {status = .error(newValue)}
  }

  /// The lang SDK acknowledges that it is responding to a `CancelNexusTask` and thus the
  /// response is irrelevant. This is not the only way to respond to a cancel, the other
  /// variants can still be used, but this variant should be used when the handler was aborted
  /// by cancellation.
  package var ackCancel: Bool {
    get {
      if case .ackCancel(let v)? = status {return v}
      return false
    }
    set {status = .ackCancel(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    /// The handler completed (successfully or not). Note that the response kind must match the
    /// request kind (start or cancel).
    case completed(Temporal_Api_Nexus_V1_Response)
    /// The handler could not complete the request for some reason.
    case error(Temporal_Api_Nexus_V1_HandlerError)
    /// The lang SDK acknowledges that it is responding to a `CancelNexusTask` and thus the
    /// response is irrelevant. This is not the only way to respond to a cancel, the other
    /// variants can still be used, but this variant should be used when the handler was aborted
    /// by cancellation.
    case ackCancel(Bool)

  }

  package init() {}
}

package struct Coresdk_Nexus_NexusTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var variant: Coresdk_Nexus_NexusTask.OneOf_Variant? = nil

  /// A nexus task from server
  package var task: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse {
    get {
      if case .task(let v)? = variant {return v}
      return Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse()
    }
    set {variant = .task(newValue)}
  }

  /// A request by Core to notify an in-progress operation handler that it should cancel. This
  /// is distinct from a `CancelOperationRequest` from the server, which results from the user
  /// requesting the cancellation of an operation. Handling this variant should result in
  /// something like cancelling a cancellation token given to the user's operation handler.
  ///
  /// These do not count as a separate task for the purposes of completing all issued tasks,
  /// but rather count as a sort of modification to the already-issued task which is being
  /// cancelled.
  ///
  /// EX: Core knows the nexus operation has timed out, and it does not make sense for the
  /// user's operation handler to continue doing work.
  package var cancelTask: Coresdk_Nexus_CancelNexusTask {
    get {
      if case .cancelTask(let v)? = variant {return v}
      return Coresdk_Nexus_CancelNexusTask()
    }
    set {variant = .cancelTask(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    /// A nexus task from server
    case task(Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse)
    /// A request by Core to notify an in-progress operation handler that it should cancel. This
    /// is distinct from a `CancelOperationRequest` from the server, which results from the user
    /// requesting the cancellation of an operation. Handling this variant should result in
    /// something like cancelling a cancellation token given to the user's operation handler.
    ///
    /// These do not count as a separate task for the purposes of completing all issued tasks,
    /// but rather count as a sort of modification to the already-issued task which is being
    /// cancelled.
    ///
    /// EX: Core knows the nexus operation has timed out, and it does not make sense for the
    /// user's operation handler to continue doing work.
    case cancelTask(Coresdk_Nexus_CancelNexusTask)

  }

  package init() {}
}

package struct Coresdk_Nexus_CancelNexusTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token from the PollNexusTaskQueueResponse
  package var taskToken: Data = Data()

  /// Why Core is asking for this operation to be cancelled
  package var reason: Coresdk_Nexus_NexusTaskCancelReason = .timedOut

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.nexus"

extension Coresdk_Nexus_NexusTaskCancelReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TIMED_OUT\0\u{1}WORKER_SHUTDOWN\0")
}

extension Coresdk_Nexus_NexusOperationCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WAIT_CANCELLATION_COMPLETED\0\u{1}ABANDON\0\u{1}TRY_CANCEL\0\u{1}WAIT_CANCELLATION_REQUESTED\0")
}

extension Coresdk_Nexus_NexusOperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{3}timed_out\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Common_V1_Payload?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .timedOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .timedOut(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .timedOut?: try {
      guard case .timedOut(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_Nexus_NexusOperationResult, rhs: Coresdk_Nexus_NexusOperationResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_Nexus_NexusTaskCompletion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusTaskCompletion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}completed\0\u{1}error\0\u{3}ack_cancel\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try {
        var v: Temporal_Api_Nexus_V1_Response?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Nexus_V1_HandlerError?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .error(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.status != nil {try decoder.handleConflictingOneOf()}
          self.status = .ackCancel(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .ackCancel?: try {
      guard case .ackCancel(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_Nexus_NexusTaskCompletion, rhs: Coresdk_Nexus_NexusTaskCompletion) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_Nexus_NexusTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}task\0\u{3}cancel_task\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .task(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .task(v)
        }
      }()
      case 2: try {
        var v: Coresdk_Nexus_CancelNexusTask?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelTask(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelTask(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .task?: try {
      guard case .task(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .cancelTask?: try {
      guard case .cancelTask(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_Nexus_NexusTask, rhs: Coresdk_Nexus_NexusTask) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_Nexus_CancelNexusTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelNexusTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.reason != .timedOut {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_Nexus_CancelNexusTask, rhs: Coresdk_Nexus_CancelNexusTask) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
