// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/cloudservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUsersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100. 
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  /// Filter users by email address - optional.
  package var email: String = String()

  /// Filter users by the namespace they have access to - optional.
  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUsersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of users in ascending ids order
  package var users: [Temporal_Api_Cloud_Identity_V1_User] = []

  /// The next page's token
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user to get
  package var userID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The user
  package var user: Temporal_Api_Cloud_Identity_V1_User {
    get {return _user ?? Temporal_Api_Cloud_Identity_V1_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  package var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  package mutating func clearUser() {self._user = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _user: Temporal_Api_Cloud_Identity_V1_User? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The spec for the user to invite
  package var spec: Temporal_Api_Cloud_Identity_V1_UserSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_UserSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation - optional
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_UserSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user that was invited
  package var userID: String = String()

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user to update
  package var userID: String = String()

  /// The new user specification
  package var spec: Temporal_Api_Cloud_Identity_V1_UserSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_UserSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the user for which this update is intended for
  /// The latest version can be found in the GetUser operation response
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_UserSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteUserRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user to delete
  package var userID: String = String()

  /// The version of the user for which this delete is intended for
  /// The latest version can be found in the GetUser operation response
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteUserResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to set permissions for
  package var namespace: String = String()

  /// The id of the user to set permissions for
  package var userID: String = String()

  /// The namespace access to assign the user
  package var access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_NamespaceAccess()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  /// The version of the user for which this update is intended for
  /// The latest version can be found in the GetUser operation response
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the async operation to get
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace specification.
  package var spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec {
    get {return _spec ?? Temporal_Api_Cloud_Namespace_V1_NamespaceSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  /// The tags to add to the namespace.
  /// Note: This field can be set by global admins or account owners only.
  package var tags: Dictionary<String,String> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace that was created.
  package var namespace: String = String()

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve.
  /// Cannot exceed 1000. 
  /// Optional, defaults to 100. 
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response.
  /// Optional, defaults to empty.
  package var pageToken: String = String()

  /// Filter namespaces by their name.
  /// Optional, defaults to empty.
  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of namespaces in ascending name order.
  package var namespaces: [Temporal_Api_Cloud_Namespace_V1_Namespace] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to get.
  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace.
  package var namespace: Temporal_Api_Cloud_Namespace_V1_Namespace {
    get {return _namespace ?? Temporal_Api_Cloud_Namespace_V1_Namespace()}
    set {_namespace = newValue}
  }
  /// Returns true if `namespace` has been explicitly set.
  package var hasNamespace: Bool {return self._namespace != nil}
  /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
  package mutating func clearNamespace() {self._namespace = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _namespace: Temporal_Api_Cloud_Namespace_V1_Namespace? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to update.
  package var namespace: String = String()

  /// The new namespace specification.
  package var spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec {
    get {return _spec ?? Temporal_Api_Cloud_Namespace_V1_NamespaceSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the namespace for which this update is intended for.
  /// The latest version can be found in the namespace status.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to rename the custom search attribute for.
  package var namespace: String = String()

  /// The existing name of the custom search attribute to be renamed.
  package var existingCustomSearchAttributeName: String = String()

  /// The new name of the custom search attribute.
  package var newCustomSearchAttributeName: String = String()

  /// The version of the namespace for which this update is intended for.
  /// The latest version can be found in the namespace status.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to delete.
  package var namespace: String = String()

  /// The version of the namespace for which this delete is intended for.
  /// The latest version can be found in the namespace status.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to failover.
  package var namespace: String = String()

  /// The id of the region to failover to.
  /// Must be a region that the namespace is currently available in.
  package var region: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to add the region to.
  package var namespace: String = String()

  /// The id of the standby region to add to the namespace.
  /// The GetRegions API can be used to get the list of valid region ids.
  /// Example: "aws-us-west-2".
  package var region: String = String()

  /// The version of the namespace for which this add region operation is intended for.
  /// The latest version can be found in the GetNamespace operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to delete a region.
  package var namespace: String = String()

  /// The id of the standby region to be deleted.
  /// The GetRegions API can be used to get the list of valid region ids.
  /// Example: "aws-us-west-2".
  package var region: String = String()

  /// The version of the namespace for which this delete region operation is intended for.
  /// The latest version can be found in the GetNamespace operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetRegionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetRegionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The temporal cloud regions.
  package var regions: [Temporal_Api_Cloud_Region_V1_Region] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetRegionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the region to get.
  package var region: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetRegionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The temporal cloud region.
  package var region: Temporal_Api_Cloud_Region_V1_Region {
    get {return _region ?? Temporal_Api_Cloud_Region_V1_Region()}
    set {_region = newValue}
  }
  /// Returns true if `region` has been explicitly set.
  package var hasRegion: Bool {return self._region != nil}
  /// Clears the value of `region`. Subsequent reads from it will return its default value.
  package mutating func clearRegion() {self._region = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _region: Temporal_Api_Cloud_Region_V1_Region? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  /// Filter api keys by owner id - optional.
  package var ownerID: String = String()

  /// Filter api keys by owner type - optional.
  /// Possible values: user, service-account
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var ownerTypeDeprecated: String = String()

  /// Filter api keys by owner type - optional.
  /// temporal:enums:replaces=owner_type_deprecated
  package var ownerType: Temporal_Api_Cloud_Identity_V1_OwnerType = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of api keys in ascending id order.
  package var apiKeys: [Temporal_Api_Cloud_Identity_V1_ApiKey] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the api key to get.
  package var keyID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The api key.
  package var apiKey: Temporal_Api_Cloud_Identity_V1_ApiKey {
    get {return _apiKey ?? Temporal_Api_Cloud_Identity_V1_ApiKey()}
    set {_apiKey = newValue}
  }
  /// Returns true if `apiKey` has been explicitly set.
  package var hasApiKey: Bool {return self._apiKey != nil}
  /// Clears the value of `apiKey`. Subsequent reads from it will return its default value.
  package mutating func clearApiKey() {self._apiKey = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _apiKey: Temporal_Api_Cloud_Identity_V1_ApiKey? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The spec for the api key to create.
  /// Create api key only supports service-account owner type for now.
  package var spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_ApiKeySpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the api key created.
  package var keyID: String = String()

  /// The token of the api key created.
  /// This is a secret and should be stored securely.
  /// It will not be retrievable after this response.
  package var token: String = String()

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the api key to update.
  package var keyID: String = String()

  /// The new api key specification.
  package var spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_ApiKeySpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the api key for which this update is intended for.
  /// The latest version can be found in the GetApiKey operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the api key to delete.
  package var keyID: String = String()

  /// The version of the api key for which this delete is intended for.
  /// The latest version can be found in the GetApiKey operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100. 
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  /// optional, treated as an AND if specified
  package var targetNamespaceID: String = String()

  /// optional, treated as an AND if specified
  package var targetTaskQueue: String = String()

  /// Filter endpoints by their name - optional, treated as an AND if specified. Specifying this will result in zero or one results.
  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of endpoints in ascending id order.
  package var endpoints: [Temporal_Api_Cloud_Nexus_V1_Endpoint] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the nexus endpoint to get.
  package var endpointID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The nexus endpoint.
  package var endpoint: Temporal_Api_Cloud_Nexus_V1_Endpoint {
    get {return _endpoint ?? Temporal_Api_Cloud_Nexus_V1_Endpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  package var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  package mutating func clearEndpoint() {self._endpoint = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _endpoint: Temporal_Api_Cloud_Nexus_V1_Endpoint? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The spec for the nexus endpoint.
  package var spec: Temporal_Api_Cloud_Nexus_V1_EndpointSpec {
    get {return _spec ?? Temporal_Api_Cloud_Nexus_V1_EndpointSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Nexus_V1_EndpointSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the endpoint that was created.
  package var endpointID: String = String()

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the nexus endpoint to update.
  package var endpointID: String = String()

  /// The updated nexus endpoint specification.
  package var spec: Temporal_Api_Cloud_Nexus_V1_EndpointSpec {
    get {return _spec ?? Temporal_Api_Cloud_Nexus_V1_EndpointSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the nexus endpoint for which this update is intended for.
  /// The latest version can be found in the GetNexusEndpoint operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Nexus_V1_EndpointSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the nexus endpoint to delete.
  package var endpointID: String = String()

  /// The version of the endpoint for which this delete is intended for.
  /// The latest version can be found in the GetNexusEndpoint operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  /// Filter groups by the namespace they have access to - optional.
  package var namespace: String = String()

  /// Filter groups by the display name - optional.
  package var displayName: String = String()

  /// Filter groups by the google group specification - optional.
  package var googleGroup: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter {
    get {return _googleGroup ?? Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter()}
    set {_googleGroup = newValue}
  }
  /// Returns true if `googleGroup` has been explicitly set.
  package var hasGoogleGroup: Bool {return self._googleGroup != nil}
  /// Clears the value of `googleGroup`. Subsequent reads from it will return its default value.
  package mutating func clearGoogleGroup() {self._googleGroup = nil}

  /// Filter groups by the SCIM group specification - optional.
  package var scimGroup: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter {
    get {return _scimGroup ?? Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter()}
    set {_scimGroup = newValue}
  }
  /// Returns true if `scimGroup` has been explicitly set.
  package var hasScimGroup: Bool {return self._scimGroup != nil}
  /// Clears the value of `scimGroup`. Subsequent reads from it will return its default value.
  package mutating func clearScimGroup() {self._scimGroup = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct GoogleGroupFilter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter groups by the google group email - optional.
    package var emailAddress: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package struct SCIMGroupFilter: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter groups by the SCIM IDP id - optional.
    package var idpID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}

  fileprivate var _googleGroup: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter? = nil
  fileprivate var _scimGroup: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of groups in ascending name order.
  package var groups: [Temporal_Api_Cloud_Identity_V1_UserGroup] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group to get.
  package var groupID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The group.
  package var group: Temporal_Api_Cloud_Identity_V1_UserGroup {
    get {return _group ?? Temporal_Api_Cloud_Identity_V1_UserGroup()}
    set {_group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  package var hasGroup: Bool {return self._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  package mutating func clearGroup() {self._group = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _group: Temporal_Api_Cloud_Identity_V1_UserGroup? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The spec for the group to create.
  package var spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_UserGroupSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group that was created.
  package var groupID: String = String()

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group to update.
  package var groupID: String = String()

  /// The new group specification.
  package var spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_UserGroupSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the group for which this update is intended for.
  /// The latest version can be found in the GetGroup operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group to delete.
  package var groupID: String = String()

  /// The version of the group for which this delete is intended for.
  /// The latest version can be found in the GetGroup operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to set permissions for.
  package var namespace: String = String()

  /// The id of the group to set permissions for.
  package var groupID: String = String()

  /// The namespace access to assign the group. If left empty, the group will be removed from the namespace access.
  package var access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_NamespaceAccess()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  /// The version of the group for which this update is intended for.
  /// The latest version can be found in the GetGroup operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group to add the member for.
  package var groupID: String = String()

  /// The member id to add to the group.
  package var memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId {
    get {return _memberID ?? Temporal_Api_Cloud_Identity_V1_UserGroupMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  package var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  package mutating func clearMemberID() {self._memberID = nil}

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group to add the member for.
  package var groupID: String = String()

  /// The member id to add to the group.
  package var memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId {
    get {return _memberID ?? Temporal_Api_Cloud_Identity_V1_UserGroupMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  package var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  package mutating func clearMemberID() {self._memberID = nil}

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  /// The group id to list members of.
  package var groupID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of group members
  package var members: [Temporal_Api_Cloud_Identity_V1_UserGroupMember] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The spec of the service account to create.
  package var spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The ID to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the created service account.
  package var serviceAccountID: String = String()

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ID of the service account to retrieve.
  package var serviceAccountID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The service account retrieved.
  package var serviceAccount: Temporal_Api_Cloud_Identity_V1_ServiceAccount {
    get {return _serviceAccount ?? Temporal_Api_Cloud_Identity_V1_ServiceAccount()}
    set {_serviceAccount = newValue}
  }
  /// Returns true if `serviceAccount` has been explicitly set.
  package var hasServiceAccount: Bool {return self._serviceAccount != nil}
  /// Clears the value of `serviceAccount`. Subsequent reads from it will return its default value.
  package mutating func clearServiceAccount() {self._serviceAccount = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _serviceAccount: Temporal_Api_Cloud_Identity_V1_ServiceAccount? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve - optional.
  /// Cannot exceed 1000. Defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of service accounts in ascending ID order.
  package var serviceAccount: [Temporal_Api_Cloud_Identity_V1_ServiceAccount] = []

  /// The next page token, set if there is another page.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the service account to update.
  package var serviceAccountID: String = String()

  /// The new service account specification.
  package var spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the service account for which this update is intended for.
  /// The latest version can be found in the GetServiceAccount response.
  package var resourceVersion: String = String()

  /// The ID to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the service account to delete;
  package var serviceAccountID: String = String()

  /// The version of the service account for which this update is intended for.
  /// The latest version can be found in the GetServiceAccount response.
  package var resourceVersion: String = String()

  /// The ID to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUsageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Filter for UTC time >= - optional.
  /// Defaults to: start of the current month.
  /// Must be: within the last 90 days from the current date.
  /// Must be: midnight UTC time.
  package var startTimeInclusive: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTimeInclusive ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTimeInclusive = newValue}
  }
  /// Returns true if `startTimeInclusive` has been explicitly set.
  package var hasStartTimeInclusive: Bool {return self._startTimeInclusive != nil}
  /// Clears the value of `startTimeInclusive`. Subsequent reads from it will return its default value.
  package mutating func clearStartTimeInclusive() {self._startTimeInclusive = nil}

  /// Filter for UTC time < - optional.
  /// Defaults to: start of the next UTC day.
  /// Must be: within the last 90 days from the current date.
  /// Must be: midnight UTC time.
  package var endTimeExclusive: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTimeExclusive ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTimeExclusive = newValue}
  }
  /// Returns true if `endTimeExclusive` has been explicitly set.
  package var hasEndTimeExclusive: Bool {return self._endTimeExclusive != nil}
  /// Clears the value of `endTimeExclusive`. Subsequent reads from it will return its default value.
  package mutating func clearEndTimeExclusive() {self._endTimeExclusive = nil}

  /// The requested size of the page to retrieve - optional.
  /// Each count corresponds to a single object - per day per namespace
  /// Cannot exceed 1000. Defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTimeInclusive: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTimeExclusive: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetUsageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of data based on granularity (per Day for now)
  /// Ordered by: time range in ascending order
  package var summaries: [Temporal_Api_Cloud_Usage_V1_Summary] = []

  /// The next page's token.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account.
  package var account: Temporal_Api_Cloud_Account_V1_Account {
    get {return _account ?? Temporal_Api_Cloud_Account_V1_Account()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  package var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  package mutating func clearAccount() {self._account = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _account: Temporal_Api_Cloud_Account_V1_Account? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The updated account specification to apply.
  package var spec: Temporal_Api_Cloud_Account_V1_AccountSpec {
    get {return _spec ?? Temporal_Api_Cloud_Account_V1_AccountSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the account for which this update is intended for.
  /// The latest version can be found in the GetAccount operation response.
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Account_V1_AccountSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace under which the sink is configured.
  package var namespace: String = String()

  /// The specification for the export sink.
  package var spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec {
    get {return _spec ?? Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// Optional. The ID to use for this async operation.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to which the sink belongs.
  package var namespace: String = String()

  /// The name of the sink to retrieve.
  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The export sink retrieved.
  package var sink: Temporal_Api_Cloud_Namespace_V1_ExportSink {
    get {return _sink ?? Temporal_Api_Cloud_Namespace_V1_ExportSink()}
    set {_sink = newValue}
  }
  /// Returns true if `sink` has been explicitly set.
  package var hasSink: Bool {return self._sink != nil}
  /// Clears the value of `sink`. Subsequent reads from it will return its default value.
  package mutating func clearSink() {self._sink = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _sink: Temporal_Api_Cloud_Namespace_V1_ExportSink? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to which the sinks belong.
  package var namespace: String = String()

  /// The requested size of the page to retrieve. Cannot exceed 1000.
  /// Defaults to 100 if not specified.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response - optional.
  package var pageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of export sinks retrieved.
  package var sinks: [Temporal_Api_Cloud_Namespace_V1_ExportSink] = []

  /// The next page token, set if there is another page.
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to which the sink belongs.
  package var namespace: String = String()

  /// The updated export sink specification.
  package var spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec {
    get {return _spec ?? Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The version of the sink to update. The latest version can be
  /// retrieved using the GetNamespaceExportSink call.
  package var resourceVersion: String = String()

  /// The ID to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to which the sink belongs.
  package var namespace: String = String()

  /// The name of the sink to delete.
  package var name: String = String()

  /// The version of the sink to delete. The latest version can be
  /// retrieved using the GetNamespaceExportSink call.
  package var resourceVersion: String = String()

  /// The ID to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to which the sink belongs.
  package var namespace: String = String()

  /// The export sink specification to validate.
  package var spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec {
    get {return _spec ?? Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to set tags for.
  package var namespace: String = String()

  /// A list of tags to add or update. 
  /// If a key of an existing tag is added, the tag's value is updated. 
  /// At least one of tags_to_upsert or tags_to_remove must be specified.
  package var tagsToUpsert: Dictionary<String,String> = [:]

  /// A list of tag keys to remove. 
  /// If a tag key doesn't exist, it is silently ignored.
  /// At least one of tags_to_upsert or tags_to_remove must be specified.
  package var tagsToRemove: [String] = []

  /// The id to use for this async operation - optional.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation.
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The connectivity rule specification.
  package var spec: Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRuleSpec {
    get {return _spec ?? Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRuleSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRuleSpec? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the connectivity rule that was created.
  package var connectivityRuleID: String = String()

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the connectivity rule to get.
  package var connectivityRuleID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var connectivityRule: Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule {
    get {return _connectivityRule ?? Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule()}
    set {_connectivityRule = newValue}
  }
  /// Returns true if `connectivityRule` has been explicitly set.
  package var hasConnectivityRule: Bool {return self._connectivityRule != nil}
  /// Clears the value of `connectivityRule`. Subsequent reads from it will return its default value.
  package mutating func clearConnectivityRule() {self._connectivityRule = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _connectivityRule: Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule? = nil
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The requested size of the page to retrieve.
  /// Optional, defaults to 100.
  package var pageSize: Int32 = 0

  /// The page token if this is continuing from another response.
  /// Optional, defaults to empty.
  package var pageToken: String = String()

  /// Filter connectivity rule by the namespace id.
  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// connectivity_rules returned
  package var connectivityRules: [Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule] = []

  /// The next page token
  package var nextPageToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the connectivity rule that need be deleted, required.
  package var connectivityRuleID: String = String()

  /// The resource version which should be the same from the the db, required
  /// The latest version can be found in the GetConnectivityRule operation response
  package var resourceVersion: String = String()

  /// The id to use for this async operation.
  /// Optional, if not provided a random id will be generated.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The async operation
  package var asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation {
    get {return _asyncOperation ?? Temporal_Api_Cloud_Operation_V1_AsyncOperation()}
    set {_asyncOperation = newValue}
  }
  /// Returns true if `asyncOperation` has been explicitly set.
  package var hasAsyncOperation: Bool {return self._asyncOperation != nil}
  /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
  package mutating func clearAsyncOperation() {self._asyncOperation = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _asyncOperation: Temporal_Api_Cloud_Operation_V1_AsyncOperation? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.cloudservice.v1"

extension Temporal_Api_Cloud_Cloudservice_V1_GetUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUsersRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}email\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsersRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.email != rhs.email {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUsersResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}users\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsersResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsersResponse) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}user\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateUserRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateUserResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserResponse) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateUserRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateUserResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteUserResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetUserNamespaceAccessRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}user_id\0\u{1}access\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._access != rhs._access {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetUserNamespaceAccessResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserNamespaceAccessResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetAsyncOperationRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationRequest) -> Bool {
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetAsyncOperationResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetAsyncOperationResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}spec\0\u{3}async_operation_id\0\u{1}tags\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceResponse) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespacesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespacesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespaces\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.namespaces) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaces, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespacesResponse) -> Bool {
    if lhs.namespaces != rhs.namespaces {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._namespace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceResponse) -> Bool {
    if lhs._namespace != rhs._namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RenameCustomSearchAttributeRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}existing_custom_search_attribute_name\0\u{3}new_custom_search_attribute_name\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.existingCustomSearchAttributeName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newCustomSearchAttributeName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.existingCustomSearchAttributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.existingCustomSearchAttributeName, fieldNumber: 2)
    }
    if !self.newCustomSearchAttributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.newCustomSearchAttributeName, fieldNumber: 3)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.existingCustomSearchAttributeName != rhs.existingCustomSearchAttributeName {return false}
    if lhs.newCustomSearchAttributeName != rhs.newCustomSearchAttributeName {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RenameCustomSearchAttributeResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_RenameCustomSearchAttributeResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailoverNamespaceRegionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailoverNamespaceRegionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_FailoverNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddNamespaceRegionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddNamespaceRegionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_AddNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRegionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRegionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetRegionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetRegionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionsRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetRegionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetRegionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}regions\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.regions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionsResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionsResponse) -> Bool {
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetRegionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionRequest) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetRegionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._region) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._region {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetRegionResponse) -> Bool {
    if lhs._region != rhs._region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetApiKeysRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}owner_id\0\u{3}owner_type_deprecated\0\u{3}owner_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ownerTypeDeprecated) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.ownerType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 3)
    }
    if !self.ownerTypeDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerTypeDeprecated, fieldNumber: 4)
    }
    if self.ownerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.ownerType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerTypeDeprecated != rhs.ownerTypeDeprecated {return false}
    if lhs.ownerType != rhs.ownerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetApiKeysResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}api_keys\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.apiKeys) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apiKeys, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeysResponse) -> Bool {
    if lhs.apiKeys != rhs.apiKeys {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetApiKeyRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetApiKeyResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}api_key\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._apiKey) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._apiKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetApiKeyResponse) -> Bool {
    if lhs._apiKey != rhs._apiKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateApiKeyRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateApiKeyResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{1}token\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateApiKeyResponse) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.token != rhs.token {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateApiKeyRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateApiKeyResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateApiKeyResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteApiKeyRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteApiKeyResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteApiKeyResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}target_namespace_id\0\u{3}target_task_queue\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetNamespaceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetTaskQueue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.targetNamespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNamespaceID, fieldNumber: 3)
    }
    if !self.targetTaskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.targetTaskQueue, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.targetNamespaceID != rhs.targetNamespaceID {return false}
    if lhs.targetTaskQueue != rhs.targetTaskQueue {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoints\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointsResponse) -> Bool {
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNexusEndpointResponse) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNexusEndpointResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNexusEndpointResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}namespace\0\u{3}display_name\0\u{3}google_group\0\u{3}scim_group\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._googleGroup) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._scimGroup) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    try { if let v = self._googleGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scimGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._googleGroup != rhs._googleGroup {return false}
    if lhs._scimGroup != rhs._scimGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.protoMessageName + ".GoogleGroupFilter"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}email_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.GoogleGroupFilter) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.protoMessageName + ".SCIMGroupFilter"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}idp_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idpID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idpID.isEmpty {
      try visitor.visitSingularStringField(value: self.idpID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsRequest.SCIMGroupFilter) -> Bool {
    if lhs.idpID != rhs.idpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}groups\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupsResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}group\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupResponse) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateUserGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateUserGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateUserGroupResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateUserGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateUserGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateUserGroupResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteUserGroupRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteUserGroupResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteUserGroupResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetUserGroupNamespaceAccessRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}group_id\0\u{1}access\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 2)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs._access != rhs._access {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetUserGroupNamespaceAccessResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_SetUserGroupNamespaceAccessResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddUserGroupMemberRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}member_id\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddUserGroupMemberResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_AddUserGroupMemberResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveUserGroupMemberRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}member_id\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveUserGroupMemberResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_RemoveUserGroupMemberResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupMembersRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}group_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUserGroupMembersResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}members\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUserGroupMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateServiceAccountResponse) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetServiceAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetServiceAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceAccount) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountResponse) -> Bool {
    if lhs._serviceAccount != rhs._serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetServiceAccountsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetServiceAccountsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceAccount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceAccount, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetServiceAccountsResponse) -> Bool {
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateServiceAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateServiceAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateServiceAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteServiceAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUsageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUsageRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_time_inclusive\0\u{3}end_time_exclusive\0\u{3}page_size\0\u{3}page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeInclusive) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTimeExclusive) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTimeInclusive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTimeExclusive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsageRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsageRequest) -> Bool {
    if lhs._startTimeInclusive != rhs._startTimeInclusive {return false}
    if lhs._endTimeExclusive != rhs._endTimeExclusive {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetUsageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetUsageResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}summaries\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.summaries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.summaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsageResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetUsageResponse) -> Bool {
    if lhs.summaries != rhs.summaries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetAccountResponse) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateAccountRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateAccountResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNamespaceExportSinkRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNamespaceExportSinkResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinkRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinkResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sink\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sink) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinkResponse) -> Bool {
    if lhs._sink != rhs._sink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinksRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinksResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sinks\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sinks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sinks, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetNamespaceExportSinksResponse) -> Bool {
    if lhs.sinks != rhs.sinks {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceExportSinkRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceExportSinkResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceExportSinkRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}name\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.name != rhs.name {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceExportSinkResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ValidateNamespaceExportSinkRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ValidateNamespaceExportSinkResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_ValidateNamespaceExportSinkResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceTagsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}tags_to_upsert\0\u{3}tags_to_remove\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tagsToUpsert) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tagsToRemove) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.tagsToUpsert.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tagsToUpsert, fieldNumber: 2)
    }
    if !self.tagsToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagsToRemove, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.tagsToUpsert != rhs.tagsToUpsert {return false}
    if lhs.tagsToRemove != rhs.tagsToRemove {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceTagsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_UpdateNamespaceTagsResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateConnectivityRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateConnectivityRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_CreateConnectivityRuleResponse) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetConnectivityRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleRequest) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetConnectivityRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectivityRule) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connectivityRule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRuleResponse) -> Bool {
    if lhs._connectivityRule != rhs._connectivityRule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetConnectivityRulesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetConnectivityRulesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rules\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connectivityRules) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connectivityRules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_GetConnectivityRulesResponse) -> Bool {
    if lhs.connectivityRules != rhs.connectivityRules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteConnectivityRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleRequest, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleRequest) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteConnectivityRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleResponse, rhs: Temporal_Api_Cloud_Cloudservice_V1_DeleteConnectivityRuleResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
