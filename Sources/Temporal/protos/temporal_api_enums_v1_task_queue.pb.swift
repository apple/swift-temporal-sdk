// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/task_queue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Temporal_Api_Enums_V1_TaskQueueKind: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Tasks from a normal workflow task queue always include complete workflow history
  ///
  /// The task queue specified by the user is always a normal task queue. There can be as many
  /// workers as desired for a single normal task queue. All those workers may pick up tasks from
  /// that queue.
  case normal // = 1

  /// A sticky queue only includes new history since the last workflow task, and they are
  /// per-worker.
  ///
  /// Sticky queues are created dynamically by each worker during their start up. They only exist
  /// for the lifetime of the worker process. Tasks in a sticky task queue are only available to
  /// the worker that created the sticky queue.
  ///
  /// Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
  case sticky // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .normal
    case 2: self = .sticky
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .normal: return 1
    case .sticky: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_TaskQueueKind] = [
    .unspecified,
    .normal,
    .sticky,
  ]

}

package enum Temporal_Api_Enums_V1_TaskQueueType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Workflow type of task queue.
  case workflow // = 1

  /// Activity type of task queue.
  case activity // = 2

  /// Task queue type for dispatching Nexus requests.
  case nexus // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .workflow
    case 2: self = .activity
    case 3: self = .nexus
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .workflow: return 1
    case .activity: return 2
    case .nexus: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_TaskQueueType] = [
    .unspecified,
    .workflow,
    .activity,
    .nexus,
  ]

}

/// Specifies which category of tasks may reach a worker on a versioned task queue.
/// Used both in a reachability query and its response.
/// Deprecated.
package enum Temporal_Api_Enums_V1_TaskReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
  case newWorkflows // = 1

  /// There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
  /// should *not* be retired.
  /// This enum value does not distinguish between open and closed workflows.
  case existingWorkflows // = 2

  /// There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
  /// should *not* be retired.
  case openWorkflows // = 3

  /// There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
  /// retired dependending on application requirements. For example, if there's no need to query closed workflows.
  case closedWorkflows // = 4
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .newWorkflows
    case 2: self = .existingWorkflows
    case 3: self = .openWorkflows
    case 4: self = .closedWorkflows
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .newWorkflows: return 1
    case .existingWorkflows: return 2
    case .openWorkflows: return 3
    case .closedWorkflows: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_TaskReachability] = [
    .unspecified,
    .newWorkflows,
    .existingWorkflows,
    .openWorkflows,
    .closedWorkflows,
  ]

}

/// Specifies which category of tasks may reach a versioned worker of a certain Build ID.
///
/// Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
/// converges to the most accurate value but it is designed in a way to take the more conservative
/// side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
///
/// Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
/// accounted for reachability as server cannot know if they'll happen as they do not use
/// assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
/// who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
/// sure to query reachability for the parent/previous workflow's Task Queue as well.
package enum Temporal_Api_Enums_V1_BuildIdTaskReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Task reachability is not reported
  case unspecified // = 0

  /// Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
  /// be open workflows or backlogged activities assigned to it.
  case reachable // = 1

  /// Build ID does not have open workflows and is not reachable by new workflows,
  /// but MAY have closed workflows within the namespace retention period.
  /// Not applicable to activity-only task queues.
  case closedWorkflowsOnly // = 2

  /// Build ID is not used for new executions, nor it has been used by any existing execution
  /// within the retention period.
  case unreachable // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reachable
    case 2: self = .closedWorkflowsOnly
    case 3: self = .unreachable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reachable: return 1
    case .closedWorkflowsOnly: return 2
    case .unreachable: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_BuildIdTaskReachability] = [
    .unspecified,
    .reachable,
    .closedWorkflowsOnly,
    .unreachable,
  ]

}

package enum Temporal_Api_Enums_V1_DescribeTaskQueueMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Unspecified means legacy behavior.
  case unspecified // = 0

  /// Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
  case enhanced // = 1
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .enhanced
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .enhanced: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_DescribeTaskQueueMode] = [
    .unspecified,
    .enhanced,
  ]

}

/// Source for the effective rate limit.
package enum Temporal_Api_Enums_V1_RateLimitSource: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// The value was set by the API.
  case api // = 1

  /// The value was set by a worker.
  case worker // = 2

  /// The value was set as the system default.
  case system // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .api
    case 2: self = .worker
    case 3: self = .system
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .api: return 1
    case .worker: return 2
    case .system: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_RateLimitSource] = [
    .unspecified,
    .api,
    .worker,
    .system,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Temporal_Api_Enums_V1_TaskQueueKind: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_QUEUE_KIND_UNSPECIFIED\0\u{1}TASK_QUEUE_KIND_NORMAL\0\u{1}TASK_QUEUE_KIND_STICKY\0")
}

extension Temporal_Api_Enums_V1_TaskQueueType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_QUEUE_TYPE_UNSPECIFIED\0\u{1}TASK_QUEUE_TYPE_WORKFLOW\0\u{1}TASK_QUEUE_TYPE_ACTIVITY\0\u{1}TASK_QUEUE_TYPE_NEXUS\0")
}

extension Temporal_Api_Enums_V1_TaskReachability: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_REACHABILITY_UNSPECIFIED\0\u{1}TASK_REACHABILITY_NEW_WORKFLOWS\0\u{1}TASK_REACHABILITY_EXISTING_WORKFLOWS\0\u{1}TASK_REACHABILITY_OPEN_WORKFLOWS\0\u{1}TASK_REACHABILITY_CLOSED_WORKFLOWS\0")
}

extension Temporal_Api_Enums_V1_BuildIdTaskReachability: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BUILD_ID_TASK_REACHABILITY_UNSPECIFIED\0\u{1}BUILD_ID_TASK_REACHABILITY_REACHABLE\0\u{1}BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY\0\u{1}BUILD_ID_TASK_REACHABILITY_UNREACHABLE\0")
}

extension Temporal_Api_Enums_V1_DescribeTaskQueueMode: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED\0\u{1}DESCRIBE_TASK_QUEUE_MODE_ENHANCED\0")
}

extension Temporal_Api_Enums_V1_RateLimitSource: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RATE_LIMIT_SOURCE_UNSPECIFIED\0\u{1}RATE_LIMIT_SOURCE_API\0\u{1}RATE_LIMIT_SOURCE_WORKER\0\u{1}RATE_LIMIT_SOURCE_SYSTEM\0")
}
