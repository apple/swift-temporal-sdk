// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/workflow.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Defines whether to allow re-using a workflow id from a previously *closed* workflow.
/// If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
///
/// See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
package enum Temporal_Api_Enums_V1_WorkflowIdReusePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Allow starting a workflow execution using the same workflow id.
  case allowDuplicate // = 1

  /// Allow starting a workflow execution using the same workflow id, only when the last
  /// execution's final state is one of [terminated, cancelled, timed out, failed].
  case allowDuplicateFailedOnly // = 2

  /// Do not permit re-use of the workflow id for this workflow. Future start workflow requests
  /// could potentially change the policy, allowing re-use of the workflow id.
  case rejectDuplicate // = 3

  /// This option belongs in WorkflowIdConflictPolicy but is here for backwards compatibility.
  /// If specified, it acts like ALLOW_DUPLICATE, but also the WorkflowId*Conflict*Policy on
  /// the request is treated as WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING.
  /// If no running workflow, then the behavior is the same as ALLOW_DUPLICATE.
  case terminateIfRunning // = 4
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .allowDuplicate
    case 2: self = .allowDuplicateFailedOnly
    case 3: self = .rejectDuplicate
    case 4: self = .terminateIfRunning
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .allowDuplicate: return 1
    case .allowDuplicateFailedOnly: return 2
    case .rejectDuplicate: return 3
    case .terminateIfRunning: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkflowIdReusePolicy] = [
    .unspecified,
    .allowDuplicate,
    .allowDuplicateFailedOnly,
    .rejectDuplicate,
    .terminateIfRunning,
  ]

}

/// Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
/// Note that it is *never* valid to have two actively running instances of the same workflow id.
///
/// See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
package enum Temporal_Api_Enums_V1_WorkflowIdConflictPolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
  case fail // = 1

  /// Don't start a new workflow; instead return a workflow handle for the running workflow.
  case useExisting // = 2

  /// Terminate the running workflow before starting a new one.
  case terminateExisting // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .fail
    case 2: self = .useExisting
    case 3: self = .terminateExisting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .fail: return 1
    case .useExisting: return 2
    case .terminateExisting: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkflowIdConflictPolicy] = [
    .unspecified,
    .fail,
    .useExisting,
    .terminateExisting,
  ]

}

/// Defines how child workflows will react to their parent completing
package enum Temporal_Api_Enums_V1_ParentClosePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// The child workflow will also terminate
  case terminate // = 1

  /// The child workflow will do nothing
  case abandon // = 2

  /// Cancellation will be requested of the child workflow
  case requestCancel // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .terminate
    case 2: self = .abandon
    case 3: self = .requestCancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .terminate: return 1
    case .abandon: return 2
    case .requestCancel: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_ParentClosePolicy] = [
    .unspecified,
    .terminate,
    .abandon,
    .requestCancel,
  ]

}

package enum Temporal_Api_Enums_V1_ContinueAsNewInitiator: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// The workflow itself requested to continue as new
  case workflow // = 1

  /// The workflow continued as new because it is retrying
  case retry // = 2

  /// The workflow continued as new because cron has triggered a new execution
  case cronSchedule // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .workflow
    case 2: self = .retry
    case 3: self = .cronSchedule
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .workflow: return 1
    case .retry: return 2
    case .cronSchedule: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_ContinueAsNewInitiator] = [
    .unspecified,
    .workflow,
    .retry,
    .cronSchedule,
  ]

}

/// (-- api-linter: core::0216::synonyms=disabled
///     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
package enum Temporal_Api_Enums_V1_WorkflowExecutionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Value 1 is hardcoded in SQL persistence.
  case running // = 1
  case completed // = 2
  case failed // = 3
  case canceled // = 4
  case terminated // = 5
  case continuedAsNew // = 6
  case timedOut // = 7
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .running
    case 2: self = .completed
    case 3: self = .failed
    case 4: self = .canceled
    case 5: self = .terminated
    case 6: self = .continuedAsNew
    case 7: self = .timedOut
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .running: return 1
    case .completed: return 2
    case .failed: return 3
    case .canceled: return 4
    case .terminated: return 5
    case .continuedAsNew: return 6
    case .timedOut: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkflowExecutionStatus] = [
    .unspecified,
    .running,
    .completed,
    .failed,
    .canceled,
    .terminated,
    .continuedAsNew,
    .timedOut,
  ]

}

package enum Temporal_Api_Enums_V1_PendingActivityState: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case scheduled // = 1
  case started // = 2
  case cancelRequested // = 3

  /// PAUSED means activity is paused on the server, and is not running in the worker
  case paused // = 4

  /// PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
  case pauseRequested // = 5
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .scheduled
    case 2: self = .started
    case 3: self = .cancelRequested
    case 4: self = .paused
    case 5: self = .pauseRequested
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .scheduled: return 1
    case .started: return 2
    case .cancelRequested: return 3
    case .paused: return 4
    case .pauseRequested: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_PendingActivityState] = [
    .unspecified,
    .scheduled,
    .started,
    .cancelRequested,
    .paused,
    .pauseRequested,
  ]

}

package enum Temporal_Api_Enums_V1_PendingWorkflowTaskState: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case scheduled // = 1
  case started // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .scheduled
    case 2: self = .started
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .scheduled: return 1
    case .started: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_PendingWorkflowTaskState] = [
    .unspecified,
    .scheduled,
    .started,
  ]

}

package enum Temporal_Api_Enums_V1_HistoryEventFilterType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case allEvent // = 1
  case closeEvent // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .allEvent
    case 2: self = .closeEvent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .allEvent: return 1
    case .closeEvent: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_HistoryEventFilterType] = [
    .unspecified,
    .allEvent,
    .closeEvent,
  ]

}

package enum Temporal_Api_Enums_V1_RetryState: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case inProgress // = 1
  case nonRetryableFailure // = 2
  case timeout // = 3
  case maximumAttemptsReached // = 4
  case retryPolicyNotSet // = 5
  case internalServerError // = 6
  case cancelRequested // = 7
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .inProgress
    case 2: self = .nonRetryableFailure
    case 3: self = .timeout
    case 4: self = .maximumAttemptsReached
    case 5: self = .retryPolicyNotSet
    case 6: self = .internalServerError
    case 7: self = .cancelRequested
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .inProgress: return 1
    case .nonRetryableFailure: return 2
    case .timeout: return 3
    case .maximumAttemptsReached: return 4
    case .retryPolicyNotSet: return 5
    case .internalServerError: return 6
    case .cancelRequested: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_RetryState] = [
    .unspecified,
    .inProgress,
    .nonRetryableFailure,
    .timeout,
    .maximumAttemptsReached,
    .retryPolicyNotSet,
    .internalServerError,
    .cancelRequested,
  ]

}

package enum Temporal_Api_Enums_V1_TimeoutType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case startToClose // = 1
  case scheduleToStart // = 2
  case scheduleToClose // = 3
  case heartbeat // = 4
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .startToClose
    case 2: self = .scheduleToStart
    case 3: self = .scheduleToClose
    case 4: self = .heartbeat
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .startToClose: return 1
    case .scheduleToStart: return 2
    case .scheduleToClose: return 3
    case .heartbeat: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_TimeoutType] = [
    .unspecified,
    .startToClose,
    .scheduleToStart,
    .scheduleToClose,
    .heartbeat,
  ]

}

/// Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
/// Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
/// who completes the first task of the execution, but is also overridable manually for new and
/// existing workflows (see VersioningOverride).
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package enum Temporal_Api_Enums_V1_VersioningBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
  /// legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
  /// `WorkerVersioningMode`.)
  /// User needs to use Patching to keep the new code compatible with prior versions when dealing
  /// with Unversioned workflows.
  case unspecified // = 0

  /// Workflow will start on the Current Deployment Version of its Task Queue, and then
  /// will be pinned to that same Deployment Version until completion (the Version that
  /// this Workflow is pinned to is specified in `versioning_info.version`).
  /// This behavior eliminates most of compatibility concerns users face when changing their code.
  /// Patching is not needed when pinned workflows code change.
  /// Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
  /// execution to another Deployment Version.
  /// Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
  /// would be when the activity Task Queue workers are not present in the workflow's Deployment
  /// Version, in which case the activity will be sent to the Current Deployment Version of its own
  /// task queue.
  case pinned // = 1

  /// Workflow will automatically move to the Current Deployment Version of its Task Queue when the
  /// next workflow task is dispatched.
  /// AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
  /// latest Deployment Version, but the user still needs to use Patching to keep the new code
  /// compatible with prior versions for changed workflow types.
  /// Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
  /// execution (as specified in versioning_info.version based on the last completed
  /// workflow task). Exception to this would be when the activity Task Queue workers are not
  /// present in the workflow's Deployment Version, in which case, the activity will be sent to a
  /// different Deployment Version according to the Current Deployment Version of its own task
  /// queue.
  /// Workflows stuck on a backlogged activity will still auto-upgrade if the Current Deployment
  /// Version of their Task Queue changes, without having to wait for the backlogged activity to
  /// complete on the old Version.
  case autoUpgrade // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .pinned
    case 2: self = .autoUpgrade
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .pinned: return 1
    case .autoUpgrade: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_VersioningBehavior] = [
    .unspecified,
    .pinned,
    .autoUpgrade,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Temporal_Api_Enums_V1_WorkflowIdReusePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED\0\u{1}WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE\0\u{1}WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY\0\u{1}WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE\0\u{1}WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING\0")
}

extension Temporal_Api_Enums_V1_WorkflowIdConflictPolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_FAIL\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING\0")
}

extension Temporal_Api_Enums_V1_ParentClosePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARENT_CLOSE_POLICY_UNSPECIFIED\0\u{1}PARENT_CLOSE_POLICY_TERMINATE\0\u{1}PARENT_CLOSE_POLICY_ABANDON\0\u{1}PARENT_CLOSE_POLICY_REQUEST_CANCEL\0")
}

extension Temporal_Api_Enums_V1_ContinueAsNewInitiator: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED\0\u{1}CONTINUE_AS_NEW_INITIATOR_WORKFLOW\0\u{1}CONTINUE_AS_NEW_INITIATOR_RETRY\0\u{1}CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE\0")
}

extension Temporal_Api_Enums_V1_WorkflowExecutionStatus: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_EXECUTION_STATUS_UNSPECIFIED\0\u{1}WORKFLOW_EXECUTION_STATUS_RUNNING\0\u{1}WORKFLOW_EXECUTION_STATUS_COMPLETED\0\u{1}WORKFLOW_EXECUTION_STATUS_FAILED\0\u{1}WORKFLOW_EXECUTION_STATUS_CANCELED\0\u{1}WORKFLOW_EXECUTION_STATUS_TERMINATED\0\u{1}WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW\0\u{1}WORKFLOW_EXECUTION_STATUS_TIMED_OUT\0")
}

extension Temporal_Api_Enums_V1_PendingActivityState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PENDING_ACTIVITY_STATE_UNSPECIFIED\0\u{1}PENDING_ACTIVITY_STATE_SCHEDULED\0\u{1}PENDING_ACTIVITY_STATE_STARTED\0\u{1}PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\0\u{1}PENDING_ACTIVITY_STATE_PAUSED\0\u{1}PENDING_ACTIVITY_STATE_PAUSE_REQUESTED\0")
}

extension Temporal_Api_Enums_V1_PendingWorkflowTaskState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED\0\u{1}PENDING_WORKFLOW_TASK_STATE_SCHEDULED\0\u{1}PENDING_WORKFLOW_TASK_STATE_STARTED\0")
}

extension Temporal_Api_Enums_V1_HistoryEventFilterType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED\0\u{1}HISTORY_EVENT_FILTER_TYPE_ALL_EVENT\0\u{1}HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT\0")
}

extension Temporal_Api_Enums_V1_RetryState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RETRY_STATE_UNSPECIFIED\0\u{1}RETRY_STATE_IN_PROGRESS\0\u{1}RETRY_STATE_NON_RETRYABLE_FAILURE\0\u{1}RETRY_STATE_TIMEOUT\0\u{1}RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED\0\u{1}RETRY_STATE_RETRY_POLICY_NOT_SET\0\u{1}RETRY_STATE_INTERNAL_SERVER_ERROR\0\u{1}RETRY_STATE_CANCEL_REQUESTED\0")
}

extension Temporal_Api_Enums_V1_TimeoutType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TIMEOUT_TYPE_UNSPECIFIED\0\u{1}TIMEOUT_TYPE_START_TO_CLOSE\0\u{1}TIMEOUT_TYPE_SCHEDULE_TO_START\0\u{1}TIMEOUT_TYPE_SCHEDULE_TO_CLOSE\0\u{1}TIMEOUT_TYPE_HEARTBEAT\0")
}

extension Temporal_Api_Enums_V1_VersioningBehavior: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VERSIONING_BEHAVIOR_UNSPECIFIED\0\u{1}VERSIONING_BEHAVIOR_PINNED\0\u{1}VERSIONING_BEHAVIOR_AUTO_UPGRADE\0")
}
