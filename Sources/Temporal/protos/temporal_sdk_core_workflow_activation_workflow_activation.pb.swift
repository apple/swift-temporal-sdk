// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/workflow_activation/workflow_activation.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// An instruction to the lang sdk to run some workflow code, whether for the first time or from
/// a cached state.
///
/// ## Job ordering guarantees and semantics
///
/// Core will, by default, order jobs within the activation as follows:
/// 1. init workflow
/// 2. patches
/// 3. random-seed-updates
/// 4. signals/updates
/// 5. all others
/// 6. local activity resolutions
/// 7. queries
/// 8. evictions
///
/// This is because:
/// * Patches are expected to apply to the entire activation
/// * Signal and update handlers should be invoked before workflow routines are iterated. That is to
///  say before the users' main workflow function and anything spawned by it is allowed to continue.
/// * Local activities resolutions go after other normal jobs because while *not* replaying, they
///  will always take longer than anything else that produces an immediate job (which is
///  effectively instant). When *replaying* we need to scan ahead for LA markers so that we can
///  resolve them in the same activation that they completed in when not replaying. However, doing
///  so would, by default, put those resolutions *before* any other immediate jobs that happened
///  in that same activation (prime example: cancelling not-wait-for-cancel activities). So, we do
///  this to ensure the LA resolution happens after that cancel (or whatever else it may be) as it
///  normally would have when executing.
/// * Queries always go last (and, in fact, always come in their own activation)
/// * Evictions also always come in their own activation
///
/// Core does this reordering to ensure that langs observe jobs in the same order during replay as
/// they would have during execution. However, in principle, this ordering is not necessary
/// (excepting queries/evictions, which definitely must come last) if lang layers apply all jobs to
/// state *first* (by resolving promises/futures, marking handlers to be invoked, etc as they iterate
/// over the jobs) and then only *after* that is done, drive coroutines/threads/whatever. If
/// execution works this way, then determinism is only impacted by the order routines are driven in
/// (which must be stable based on lang implementation or convention), rather than the order jobs are
/// processed.
///
/// ## Evictions
///
/// Evictions appear as an activations that contains only a `remove_from_cache` job. Such activations
/// should not cause the workflow code to be invoked and may be responded to with an empty command
/// list.
package struct Coresdk_WorkflowActivation_WorkflowActivation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the currently active run of the workflow. Also used as a cache key. There may
  /// only ever be one active workflow task (and hence activation) of a run at one time.
  package var runID: String = String()

  /// The current time as understood by the workflow, which is set by workflow task started events
  package var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  package var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  package mutating func clearTimestamp() {self._timestamp = nil}

  /// Whether or not the activation is replaying past events
  package var isReplaying: Bool = false

  /// Current history length as determined by the event id of the most recently processed event.
  /// This ensures that the number is always deterministic
  package var historyLength: UInt32 = 0

  /// The things to do upon activating the workflow
  package var jobs: [Coresdk_WorkflowActivation_WorkflowActivationJob] = []

  /// Internal flags which are available for use by lang. If `is_replaying` is false, all
  /// internal flags may be used. This is not a delta - all previously used flags always
  /// appear since this representation is cheap.
  package var availableInternalFlags: [UInt32] = []

  /// The history size in bytes as of the last WFT started event
  package var historySizeBytes: UInt64 = 0

  /// Set true if the most recent WFT started event had this suggestion
  package var continueAsNewSuggested: Bool = false

  /// Set to the deployment version of the worker that processed this task,
  /// which may be empty. During replay this version may not equal the version
  /// of the replaying worker. If not replaying and this worker has a defined
  /// Deployment Version, it will equal that. It will also be empty for
  /// evict-only activations. The deployment name may be empty, but not the
  /// build id, if this worker was using the deprecated Build ID-only
  /// feature(s).
  package var deploymentVersionForCurrentTask: Coresdk_Common_WorkerDeploymentVersion {
    get {return _deploymentVersionForCurrentTask ?? Coresdk_Common_WorkerDeploymentVersion()}
    set {_deploymentVersionForCurrentTask = newValue}
  }
  /// Returns true if `deploymentVersionForCurrentTask` has been explicitly set.
  package var hasDeploymentVersionForCurrentTask: Bool {return self._deploymentVersionForCurrentTask != nil}
  /// Clears the value of `deploymentVersionForCurrentTask`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersionForCurrentTask() {self._deploymentVersionForCurrentTask = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deploymentVersionForCurrentTask: Coresdk_Common_WorkerDeploymentVersion? = nil
}

package struct Coresdk_WorkflowActivation_WorkflowActivationJob: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var variant: Coresdk_WorkflowActivation_WorkflowActivationJob.OneOf_Variant? = nil

  /// A workflow is starting, record all of the information from its start event
  package var initializeWorkflow: Coresdk_WorkflowActivation_InitializeWorkflow {
    get {
      if case .initializeWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_InitializeWorkflow()
    }
    set {variant = .initializeWorkflow(newValue)}
  }

  /// A timer has fired, allowing whatever was waiting on it (if anything) to proceed
  package var fireTimer: Coresdk_WorkflowActivation_FireTimer {
    get {
      if case .fireTimer(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_FireTimer()
    }
    set {variant = .fireTimer(newValue)}
  }

  /// Workflow was reset. The randomness seed must be updated.
  package var updateRandomSeed: Coresdk_WorkflowActivation_UpdateRandomSeed {
    get {
      if case .updateRandomSeed(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_UpdateRandomSeed()
    }
    set {variant = .updateRandomSeed(newValue)}
  }

  /// A request to query the workflow was received. It is guaranteed that queries (one or more)
  /// always come in their own activation after other mutating jobs.
  package var queryWorkflow: Coresdk_WorkflowActivation_QueryWorkflow {
    get {
      if case .queryWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_QueryWorkflow()
    }
    set {variant = .queryWorkflow(newValue)}
  }

  /// A request to cancel the workflow was received.
  package var cancelWorkflow: Coresdk_WorkflowActivation_CancelWorkflow {
    get {
      if case .cancelWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_CancelWorkflow()
    }
    set {variant = .cancelWorkflow(newValue)}
  }

  /// A request to signal the workflow was received.
  package var signalWorkflow: Coresdk_WorkflowActivation_SignalWorkflow {
    get {
      if case .signalWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_SignalWorkflow()
    }
    set {variant = .signalWorkflow(newValue)}
  }

  /// An activity was resolved, result could be completed, failed or cancelled
  package var resolveActivity: Coresdk_WorkflowActivation_ResolveActivity {
    get {
      if case .resolveActivity(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveActivity()
    }
    set {variant = .resolveActivity(newValue)}
  }

  /// A patch marker has been detected and lang is being told that change exists. This
  /// job is strange in that it is sent pre-emptively to lang without any corresponding
  /// command being sent first.
  package var notifyHasPatch: Coresdk_WorkflowActivation_NotifyHasPatch {
    get {
      if case .notifyHasPatch(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_NotifyHasPatch()
    }
    set {variant = .notifyHasPatch(newValue)}
  }

  /// A child workflow execution has started or failed to start
  package var resolveChildWorkflowExecutionStart: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart {
    get {
      if case .resolveChildWorkflowExecutionStart(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart()
    }
    set {variant = .resolveChildWorkflowExecutionStart(newValue)}
  }

  /// A child workflow was resolved, result could be completed or failed
  package var resolveChildWorkflowExecution: Coresdk_WorkflowActivation_ResolveChildWorkflowExecution {
    get {
      if case .resolveChildWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveChildWorkflowExecution()
    }
    set {variant = .resolveChildWorkflowExecution(newValue)}
  }

  /// An attempt to signal an external workflow resolved
  package var resolveSignalExternalWorkflow: Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow {
    get {
      if case .resolveSignalExternalWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow()
    }
    set {variant = .resolveSignalExternalWorkflow(newValue)}
  }

  /// An attempt to cancel an external workflow resolved
  package var resolveRequestCancelExternalWorkflow: Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow {
    get {
      if case .resolveRequestCancelExternalWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow()
    }
    set {variant = .resolveRequestCancelExternalWorkflow(newValue)}
  }

  /// A request to handle a workflow update.
  package var doUpdate: Coresdk_WorkflowActivation_DoUpdate {
    get {
      if case .doUpdate(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_DoUpdate()
    }
    set {variant = .doUpdate(newValue)}
  }

  /// A nexus operation started.
  package var resolveNexusOperationStart: Coresdk_WorkflowActivation_ResolveNexusOperationStart {
    get {
      if case .resolveNexusOperationStart(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveNexusOperationStart()
    }
    set {variant = .resolveNexusOperationStart(newValue)}
  }

  /// A nexus operation resolved.
  package var resolveNexusOperation: Coresdk_WorkflowActivation_ResolveNexusOperation {
    get {
      if case .resolveNexusOperation(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_ResolveNexusOperation()
    }
    set {variant = .resolveNexusOperation(newValue)}
  }

  /// Remove the workflow identified by the [WorkflowActivation] containing this job from the
  /// cache after performing the activation. It is guaranteed that this will be the only job
  /// in the activation if present.
  package var removeFromCache: Coresdk_WorkflowActivation_RemoveFromCache {
    get {
      if case .removeFromCache(let v)? = variant {return v}
      return Coresdk_WorkflowActivation_RemoveFromCache()
    }
    set {variant = .removeFromCache(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    /// A workflow is starting, record all of the information from its start event
    case initializeWorkflow(Coresdk_WorkflowActivation_InitializeWorkflow)
    /// A timer has fired, allowing whatever was waiting on it (if anything) to proceed
    case fireTimer(Coresdk_WorkflowActivation_FireTimer)
    /// Workflow was reset. The randomness seed must be updated.
    case updateRandomSeed(Coresdk_WorkflowActivation_UpdateRandomSeed)
    /// A request to query the workflow was received. It is guaranteed that queries (one or more)
    /// always come in their own activation after other mutating jobs.
    case queryWorkflow(Coresdk_WorkflowActivation_QueryWorkflow)
    /// A request to cancel the workflow was received.
    case cancelWorkflow(Coresdk_WorkflowActivation_CancelWorkflow)
    /// A request to signal the workflow was received.
    case signalWorkflow(Coresdk_WorkflowActivation_SignalWorkflow)
    /// An activity was resolved, result could be completed, failed or cancelled
    case resolveActivity(Coresdk_WorkflowActivation_ResolveActivity)
    /// A patch marker has been detected and lang is being told that change exists. This
    /// job is strange in that it is sent pre-emptively to lang without any corresponding
    /// command being sent first.
    case notifyHasPatch(Coresdk_WorkflowActivation_NotifyHasPatch)
    /// A child workflow execution has started or failed to start
    case resolveChildWorkflowExecutionStart(Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart)
    /// A child workflow was resolved, result could be completed or failed
    case resolveChildWorkflowExecution(Coresdk_WorkflowActivation_ResolveChildWorkflowExecution)
    /// An attempt to signal an external workflow resolved
    case resolveSignalExternalWorkflow(Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow)
    /// An attempt to cancel an external workflow resolved
    case resolveRequestCancelExternalWorkflow(Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow)
    /// A request to handle a workflow update.
    case doUpdate(Coresdk_WorkflowActivation_DoUpdate)
    /// A nexus operation started.
    case resolveNexusOperationStart(Coresdk_WorkflowActivation_ResolveNexusOperationStart)
    /// A nexus operation resolved.
    case resolveNexusOperation(Coresdk_WorkflowActivation_ResolveNexusOperation)
    /// Remove the workflow identified by the [WorkflowActivation] containing this job from the
    /// cache after performing the activation. It is guaranteed that this will be the only job
    /// in the activation if present.
    case removeFromCache(Coresdk_WorkflowActivation_RemoveFromCache)

  }

  package init() {}
}

/// Initialize a new workflow
package struct Coresdk_WorkflowActivation_InitializeWorkflow: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier the lang-specific sdk uses to execute workflow code
  package var workflowType: String {
    get {return _storage._workflowType}
    set {_uniqueStorage()._workflowType = newValue}
  }

  /// The workflow id used on the temporal server
  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  /// Inputs to the workflow code
  package var arguments: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// The seed must be used to initialize the random generator used by SDK.
  /// RandomSeedUpdatedAttributes are used to deliver seed updates.
  package var randomnessSeed: UInt64 {
    get {return _storage._randomnessSeed}
    set {_uniqueStorage()._randomnessSeed = newValue}
  }

  /// Used to add metadata e.g. for tracing and auth, meant to be read and written to by interceptors.
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  /// Identity of the client who requested this execution
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// If this workflow is a child, information about the parent
  package var parentWorkflowInfo: Coresdk_Common_NamespacedWorkflowExecution {
    get {return _storage._parentWorkflowInfo ?? Coresdk_Common_NamespacedWorkflowExecution()}
    set {_uniqueStorage()._parentWorkflowInfo = newValue}
  }
  /// Returns true if `parentWorkflowInfo` has been explicitly set.
  package var hasParentWorkflowInfo: Bool {return _storage._parentWorkflowInfo != nil}
  /// Clears the value of `parentWorkflowInfo`. Subsequent reads from it will return its default value.
  package mutating func clearParentWorkflowInfo() {_uniqueStorage()._parentWorkflowInfo = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Run id of the previous workflow which continued-as-new or retired or cron executed into this
  /// workflow, if any.
  package var continuedFromExecutionRunID: String {
    get {return _storage._continuedFromExecutionRunID}
    set {_uniqueStorage()._continuedFromExecutionRunID = newValue}
  }

  /// If this workflow was a continuation, indicates the type of continuation.
  package var continuedInitiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator {
    get {return _storage._continuedInitiator}
    set {_uniqueStorage()._continuedInitiator = newValue}
  }

  /// If this workflow was a continuation and that continuation failed, the details of that.
  package var continuedFailure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._continuedFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._continuedFailure = newValue}
  }
  /// Returns true if `continuedFailure` has been explicitly set.
  package var hasContinuedFailure: Bool {return _storage._continuedFailure != nil}
  /// Clears the value of `continuedFailure`. Subsequent reads from it will return its default value.
  package mutating func clearContinuedFailure() {_uniqueStorage()._continuedFailure = nil}

  /// If this workflow was a continuation and that continuation completed, the details of that.
  package var lastCompletionResult: Temporal_Api_Common_V1_Payloads {
    get {return _storage._lastCompletionResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._lastCompletionResult = newValue}
  }
  /// Returns true if `lastCompletionResult` has been explicitly set.
  package var hasLastCompletionResult: Bool {return _storage._lastCompletionResult != nil}
  /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
  package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

  /// This is the very first run id the workflow ever had, following continuation chains.
  package var firstExecutionRunID: String {
    get {return _storage._firstExecutionRunID}
    set {_uniqueStorage()._firstExecutionRunID = newValue}
  }

  /// This workflow's retry policy
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Starting at 1, the number of times we have tried to execute this workflow
  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// If this workflow runs on a cron schedule, it will appear here
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  /// The absolute time at which the workflow will be timed out.
  /// This is passed without change to the next run/retry of a workflow.
  package var workflowExecutionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._workflowExecutionExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._workflowExecutionExpirationTime = newValue}
  }
  /// Returns true if `workflowExecutionExpirationTime` has been explicitly set.
  package var hasWorkflowExecutionExpirationTime: Bool {return _storage._workflowExecutionExpirationTime != nil}
  /// Clears the value of `workflowExecutionExpirationTime`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionExpirationTime() {_uniqueStorage()._workflowExecutionExpirationTime = nil}

  /// For a cron workflow, this contains the amount of time between when this iteration of
  /// the cron workflow was scheduled and when it should run next per its cron_schedule.
  package var cronScheduleToScheduleInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._cronScheduleToScheduleInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._cronScheduleToScheduleInterval = newValue}
  }
  /// Returns true if `cronScheduleToScheduleInterval` has been explicitly set.
  package var hasCronScheduleToScheduleInterval: Bool {return _storage._cronScheduleToScheduleInterval != nil}
  /// Clears the value of `cronScheduleToScheduleInterval`. Subsequent reads from it will return its default value.
  package mutating func clearCronScheduleToScheduleInterval() {_uniqueStorage()._cronScheduleToScheduleInterval = nil}

  /// User-defined memo
  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  /// Search attributes created/updated when this workflow was started
  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// When the workflow execution started event was first written
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Contains information about the root workflow execution. It is possible for the namespace to
  /// be different than this workflow if using OSS and cross-namespace children, but this
  /// information is not retained. Users should take care to track it by other means in such
  /// situations.
  ///
  /// The root workflow execution is defined as follows:
  ///   1. A workflow without parent workflow is its own root workflow.
  ///   2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
  ///
  /// See field in WorkflowExecutionStarted for more detail.
  package var rootWorkflow: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._rootWorkflow ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._rootWorkflow = newValue}
  }
  /// Returns true if `rootWorkflow` has been explicitly set.
  package var hasRootWorkflow: Bool {return _storage._rootWorkflow != nil}
  /// Clears the value of `rootWorkflow`. Subsequent reads from it will return its default value.
  package mutating func clearRootWorkflow() {_uniqueStorage()._rootWorkflow = nil}

  /// Priority of this workflow execution
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Notify a workflow that a timer has fired
package struct Coresdk_WorkflowActivation_FireTimer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding StartTimer command
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Notify a workflow that an activity has been resolved
package struct Coresdk_WorkflowActivation_ResolveActivity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding ScheduleActivity command
  package var seq: UInt32 = 0

  package var result: Coresdk_ActivityResult_ActivityResolution {
    get {return _result ?? Coresdk_ActivityResult_ActivityResolution()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// Set to true if the resolution is for a local activity. This is used internally by Core and
  /// lang does not need to care about it.
  package var isLocal: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Coresdk_ActivityResult_ActivityResolution? = nil
}

/// Notify a workflow that a start child workflow execution request has succeeded, failed or was
/// cancelled.
package struct Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  package var seq: UInt32 = 0

  package var status: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart.OneOf_Status? = nil

  package var succeeded: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess {
    get {
      if case .succeeded(let v)? = status {return v}
      return Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess()
    }
    set {status = .succeeded(newValue)}
  }

  package var failed: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure {
    get {
      if case .failed(let v)? = status {return v}
      return Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure()
    }
    set {status = .failed(newValue)}
  }

  package var cancelled: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled {
    get {
      if case .cancelled(let v)? = status {return v}
      return Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled()
    }
    set {status = .cancelled(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    case succeeded(Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess)
    case failed(Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure)
    case cancelled(Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled)

  }

  package init() {}
}

/// Simply pass the run_id to lang
package struct Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var runID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Provide lang the cause of failure
package struct Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang should have this information but it's more convenient to pass it back
  /// for error construction on the lang side.
  package var workflowID: String = String()

  package var workflowType: String = String()

  package var cause: Coresdk_ChildWorkflow_StartChildWorkflowExecutionFailedCause = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// `failure` should be ChildWorkflowFailure with cause set to CancelledFailure.
/// The failure is constructed in core for lang's convenience.
package struct Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Notify a workflow that a child workflow execution has been resolved
package struct Coresdk_WorkflowActivation_ResolveChildWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding StartChildWorkflowExecution command
  package var seq: UInt32 = 0

  package var result: Coresdk_ChildWorkflow_ChildWorkflowResult {
    get {return _result ?? Coresdk_ChildWorkflow_ChildWorkflowResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Coresdk_ChildWorkflow_ChildWorkflowResult? = nil
}

/// Update the workflow's random seed
package struct Coresdk_WorkflowActivation_UpdateRandomSeed: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var randomnessSeed: UInt64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Query a workflow
package struct Coresdk_WorkflowActivation_QueryWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// For PollWFTResp `query` field, this will be set to the special value `legacy`. For the
  /// `queries` field, the server provides a unique identifier. If it is a `legacy` query,
  /// lang cannot issue any commands in response other than to answer the query.
  package var queryID: String = String()

  /// The query's function/method/etc name
  package var queryType: String = String()

  package var arguments: [Temporal_Api_Common_V1_Payload] = []

  /// Headers attached to the query
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Cancel a running workflow
package struct Coresdk_WorkflowActivation_CancelWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User-specified reason the cancel request was issued
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Send a signal to a workflow
package struct Coresdk_WorkflowActivation_SignalWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var signalName: String = String()

  package var input: [Temporal_Api_Common_V1_Payload] = []

  /// Identity of the sender of the signal
  package var identity: String = String()

  /// Headers attached to the signal
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Inform lang what the result of a call to `patched` or similar API should be -- this is always
/// sent pre-emptively, so any time it is sent the change is present
package struct Coresdk_WorkflowActivation_NotifyHasPatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var patchID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding SignalExternalWorkflowExecution
  /// command
  package var seq: UInt32 = 0

  /// If populated, this signal either failed to be sent or was cancelled depending on failure
  /// type / info.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding
  /// RequestCancelExternalWorkflowExecution command
  package var seq: UInt32 = 0

  /// If populated, this signal either failed to be sent or was cancelled depending on failure
  /// type / info.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Lang is requested to invoke an update handler on the workflow. Lang should invoke the update
/// validator first (if requested). If it accepts the update, immediately invoke the update handler.
/// Lang must reply to the activation containing this job with an `UpdateResponse`.
package struct Coresdk_WorkflowActivation_DoUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A workflow-unique identifier for this update
  package var id: String = String()

  /// The protocol message instance ID - this is used to uniquely track the ID server side and
  /// internally.
  package var protocolInstanceID: String = String()

  /// The name of the update handler
  package var name: String = String()

  /// The input to the update
  package var input: [Temporal_Api_Common_V1_Payload] = []

  /// Headers attached to the update
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  /// Remaining metadata associated with the update. The `update_id` field is stripped from here
  /// and moved to `id`, since it is guaranteed to be present.
  package var meta: Temporal_Api_Update_V1_Meta {
    get {return _meta ?? Temporal_Api_Update_V1_Meta()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  package var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  package mutating func clearMeta() {self._meta = nil}

  /// If set true, lang must run the update's validator before running the handler. This will be
  /// set false during replay, since validation is not re-run during replay.
  package var runValidator: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _meta: Temporal_Api_Update_V1_Meta? = nil
}

package struct Coresdk_WorkflowActivation_ResolveNexusOperationStart: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding ScheduleNexusOperation command
  package var seq: UInt32 = 0

  package var status: Coresdk_WorkflowActivation_ResolveNexusOperationStart.OneOf_Status? = nil

  /// The operation started asynchronously. Contains a token that can be used to perform
  /// operations on the started operation by, ex, clients. A `ResolveNexusOperation` job will
  /// follow at some point.
  package var operationToken: String {
    get {
      if case .operationToken(let v)? = status {return v}
      return String()
    }
    set {status = .operationToken(newValue)}
  }

  /// If true the operation "started" but only because it's also already resolved. A
  /// `ResolveNexusOperation` job will be in the same activation.
  package var startedSync: Bool {
    get {
      if case .startedSync(let v)? = status {return v}
      return false
    }
    set {status = .startedSync(newValue)}
  }

  /// The operation either failed to start, was cancelled before it started, timed out, or
  /// failed synchronously. Details are included inside the message. In this case, the
  /// subsequent ResolveNexusOperation will never be sent.
  package var failed: Temporal_Api_Failure_V1_Failure {
    get {
      if case .failed(let v)? = status {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {status = .failed(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    /// The operation started asynchronously. Contains a token that can be used to perform
    /// operations on the started operation by, ex, clients. A `ResolveNexusOperation` job will
    /// follow at some point.
    case operationToken(String)
    /// If true the operation "started" but only because it's also already resolved. A
    /// `ResolveNexusOperation` job will be in the same activation.
    case startedSync(Bool)
    /// The operation either failed to start, was cancelled before it started, timed out, or
    /// failed synchronously. Details are included inside the message. In this case, the
    /// subsequent ResolveNexusOperation will never be sent.
    case failed(Temporal_Api_Failure_V1_Failure)

  }

  package init() {}
}

package struct Coresdk_WorkflowActivation_ResolveNexusOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as provided by lang in the corresponding ScheduleNexusOperation command
  package var seq: UInt32 = 0

  package var result: Coresdk_Nexus_NexusOperationResult {
    get {return _result ?? Coresdk_Nexus_NexusOperationResult()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Coresdk_Nexus_NexusOperationResult? = nil
}

package struct Coresdk_WorkflowActivation_RemoveFromCache: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var message: String = String()

  package var reason: Coresdk_WorkflowActivation_RemoveFromCache.EvictionReason = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum EvictionReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Workflow cache is full
    case cacheFull // = 1

    /// Workflow received a partial task but was not in the cache. Typically it won't be in the
    /// lang cache either at this point, but we send an eviction to be sure.
    case cacheMiss // = 2

    /// The workflow produced results inconsistent with history.
    case nondeterminism // = 3

    /// The lang side completed the workflow activation with a failure.
    case langFail // = 4

    /// The lang side explicitly requested this workflow be evicted.
    case langRequested // = 5

    /// The workflow task we tried to respond to didn't exist. The workflow might have already
    /// finished, or the WFT timed out but we didn't learn about that yet.
    case taskNotFound // = 6

    /// There was new work that must be handled while we attempted to complete the WFT. Ex:
    /// a new signal came in while trying to complete the workflow.
    case unhandledCommand // = 7

    /// There was some fatal error processing the workflow, typically an internal error, but
    /// can also happen if then network drops out while paginating. Check message string.
    case fatal // = 8

    /// Something went wrong attempting to fetch more history events.
    case paginationOrHistoryFetch // = 9

    /// The workflow is being completed with a terminal command and we sent the WFT completion
    /// to server successfully.
    case workflowExecutionEnding // = 10
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .cacheFull
      case 2: self = .cacheMiss
      case 3: self = .nondeterminism
      case 4: self = .langFail
      case 5: self = .langRequested
      case 6: self = .taskNotFound
      case 7: self = .unhandledCommand
      case 8: self = .fatal
      case 9: self = .paginationOrHistoryFetch
      case 10: self = .workflowExecutionEnding
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .cacheFull: return 1
      case .cacheMiss: return 2
      case .nondeterminism: return 3
      case .langFail: return 4
      case .langRequested: return 5
      case .taskNotFound: return 6
      case .unhandledCommand: return 7
      case .fatal: return 8
      case .paginationOrHistoryFetch: return 9
      case .workflowExecutionEnding: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk_WorkflowActivation_RemoveFromCache.EvictionReason] = [
      .unspecified,
      .cacheFull,
      .cacheMiss,
      .nondeterminism,
      .langFail,
      .langRequested,
      .taskNotFound,
      .unhandledCommand,
      .fatal,
      .paginationOrHistoryFetch,
      .workflowExecutionEnding,
    ]

  }

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.workflow_activation"

extension Coresdk_WorkflowActivation_WorkflowActivation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowActivation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}timestamp\0\u{3}is_replaying\0\u{3}history_length\0\u{1}jobs\0\u{3}available_internal_flags\0\u{3}history_size_bytes\0\u{3}continue_as_new_suggested\0\u{3}deployment_version_for_current_task\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isReplaying) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.historyLength) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.jobs) }()
      case 6: try { try decoder.decodeRepeatedUInt32Field(value: &self.availableInternalFlags) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.historySizeBytes) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.continueAsNewSuggested) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersionForCurrentTask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isReplaying != false {
      try visitor.visitSingularBoolField(value: self.isReplaying, fieldNumber: 3)
    }
    if self.historyLength != 0 {
      try visitor.visitSingularUInt32Field(value: self.historyLength, fieldNumber: 4)
    }
    if !self.jobs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.jobs, fieldNumber: 5)
    }
    if !self.availableInternalFlags.isEmpty {
      try visitor.visitPackedUInt32Field(value: self.availableInternalFlags, fieldNumber: 6)
    }
    if self.historySizeBytes != 0 {
      try visitor.visitSingularUInt64Field(value: self.historySizeBytes, fieldNumber: 7)
    }
    if self.continueAsNewSuggested != false {
      try visitor.visitSingularBoolField(value: self.continueAsNewSuggested, fieldNumber: 8)
    }
    try { if let v = self._deploymentVersionForCurrentTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_WorkflowActivation, rhs: Coresdk_WorkflowActivation_WorkflowActivation) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.isReplaying != rhs.isReplaying {return false}
    if lhs.historyLength != rhs.historyLength {return false}
    if lhs.jobs != rhs.jobs {return false}
    if lhs.availableInternalFlags != rhs.availableInternalFlags {return false}
    if lhs.historySizeBytes != rhs.historySizeBytes {return false}
    if lhs.continueAsNewSuggested != rhs.continueAsNewSuggested {return false}
    if lhs._deploymentVersionForCurrentTask != rhs._deploymentVersionForCurrentTask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_WorkflowActivationJob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowActivationJob"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}initialize_workflow\0\u{3}fire_timer\0\u{4}\u{2}update_random_seed\0\u{3}query_workflow\0\u{3}cancel_workflow\0\u{3}signal_workflow\0\u{3}resolve_activity\0\u{3}notify_has_patch\0\u{3}resolve_child_workflow_execution_start\0\u{3}resolve_child_workflow_execution\0\u{3}resolve_signal_external_workflow\0\u{3}resolve_request_cancel_external_workflow\0\u{3}do_update\0\u{3}resolve_nexus_operation_start\0\u{3}resolve_nexus_operation\0\u{4}\"remove_from_cache\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk_WorkflowActivation_InitializeWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .initializeWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .initializeWorkflow(v)
        }
      }()
      case 2: try {
        var v: Coresdk_WorkflowActivation_FireTimer?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .fireTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .fireTimer(v)
        }
      }()
      case 4: try {
        var v: Coresdk_WorkflowActivation_UpdateRandomSeed?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .updateRandomSeed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .updateRandomSeed(v)
        }
      }()
      case 5: try {
        var v: Coresdk_WorkflowActivation_QueryWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .queryWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .queryWorkflow(v)
        }
      }()
      case 6: try {
        var v: Coresdk_WorkflowActivation_CancelWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelWorkflow(v)
        }
      }()
      case 7: try {
        var v: Coresdk_WorkflowActivation_SignalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .signalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .signalWorkflow(v)
        }
      }()
      case 8: try {
        var v: Coresdk_WorkflowActivation_ResolveActivity?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveActivity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveActivity(v)
        }
      }()
      case 9: try {
        var v: Coresdk_WorkflowActivation_NotifyHasPatch?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .notifyHasPatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .notifyHasPatch(v)
        }
      }()
      case 10: try {
        var v: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveChildWorkflowExecutionStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveChildWorkflowExecutionStart(v)
        }
      }()
      case 11: try {
        var v: Coresdk_WorkflowActivation_ResolveChildWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveChildWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveChildWorkflowExecution(v)
        }
      }()
      case 12: try {
        var v: Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveSignalExternalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveSignalExternalWorkflow(v)
        }
      }()
      case 13: try {
        var v: Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveRequestCancelExternalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveRequestCancelExternalWorkflow(v)
        }
      }()
      case 14: try {
        var v: Coresdk_WorkflowActivation_DoUpdate?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .doUpdate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .doUpdate(v)
        }
      }()
      case 15: try {
        var v: Coresdk_WorkflowActivation_ResolveNexusOperationStart?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveNexusOperationStart(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveNexusOperationStart(v)
        }
      }()
      case 16: try {
        var v: Coresdk_WorkflowActivation_ResolveNexusOperation?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .resolveNexusOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .resolveNexusOperation(v)
        }
      }()
      case 50: try {
        var v: Coresdk_WorkflowActivation_RemoveFromCache?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .removeFromCache(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .removeFromCache(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .initializeWorkflow?: try {
      guard case .initializeWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .fireTimer?: try {
      guard case .fireTimer(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateRandomSeed?: try {
      guard case .updateRandomSeed(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .queryWorkflow?: try {
      guard case .queryWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .cancelWorkflow?: try {
      guard case .cancelWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .signalWorkflow?: try {
      guard case .signalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .resolveActivity?: try {
      guard case .resolveActivity(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .notifyHasPatch?: try {
      guard case .notifyHasPatch(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .resolveChildWorkflowExecutionStart?: try {
      guard case .resolveChildWorkflowExecutionStart(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .resolveChildWorkflowExecution?: try {
      guard case .resolveChildWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .resolveSignalExternalWorkflow?: try {
      guard case .resolveSignalExternalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .resolveRequestCancelExternalWorkflow?: try {
      guard case .resolveRequestCancelExternalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .doUpdate?: try {
      guard case .doUpdate(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .resolveNexusOperationStart?: try {
      guard case .resolveNexusOperationStart(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .resolveNexusOperation?: try {
      guard case .resolveNexusOperation(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .removeFromCache?: try {
      guard case .removeFromCache(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_WorkflowActivationJob, rhs: Coresdk_WorkflowActivation_WorkflowActivationJob) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_InitializeWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".InitializeWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}workflow_id\0\u{1}arguments\0\u{3}randomness_seed\0\u{1}headers\0\u{1}identity\0\u{3}parent_workflow_info\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}continued_from_execution_run_id\0\u{3}continued_initiator\0\u{3}continued_failure\0\u{3}last_completion_result\0\u{3}first_execution_run_id\0\u{3}retry_policy\0\u{1}attempt\0\u{3}cron_schedule\0\u{3}workflow_execution_expiration_time\0\u{3}cron_schedule_to_schedule_interval\0\u{1}memo\0\u{3}search_attributes\0\u{3}start_time\0\u{3}root_workflow\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _workflowType: String = String()
    var _workflowID: String = String()
    var _arguments: [Temporal_Api_Common_V1_Payload] = []
    var _randomnessSeed: UInt64 = 0
    var _headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _identity: String = String()
    var _parentWorkflowInfo: Coresdk_Common_NamespacedWorkflowExecution? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _continuedFromExecutionRunID: String = String()
    var _continuedInitiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator = .unspecified
    var _continuedFailure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastCompletionResult: Temporal_Api_Common_V1_Payloads? = nil
    var _firstExecutionRunID: String = String()
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _attempt: Int32 = 0
    var _cronSchedule: String = String()
    var _workflowExecutionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cronScheduleToScheduleInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rootWorkflow: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _workflowID = source._workflowID
      _arguments = source._arguments
      _randomnessSeed = source._randomnessSeed
      _headers = source._headers
      _identity = source._identity
      _parentWorkflowInfo = source._parentWorkflowInfo
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _continuedFromExecutionRunID = source._continuedFromExecutionRunID
      _continuedInitiator = source._continuedInitiator
      _continuedFailure = source._continuedFailure
      _lastCompletionResult = source._lastCompletionResult
      _firstExecutionRunID = source._firstExecutionRunID
      _retryPolicy = source._retryPolicy
      _attempt = source._attempt
      _cronSchedule = source._cronSchedule
      _workflowExecutionExpirationTime = source._workflowExecutionExpirationTime
      _cronScheduleToScheduleInterval = source._cronScheduleToScheduleInterval
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _startTime = source._startTime
      _rootWorkflow = source._rootWorkflow
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 4: try { try decoder.decodeSingularUInt64Field(value: &_storage._randomnessSeed) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headers) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._parentWorkflowInfo) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._continuedFromExecutionRunID) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._continuedInitiator) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._continuedFailure) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._firstExecutionRunID) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 17: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionExpirationTime) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._cronScheduleToScheduleInterval) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._rootWorkflow) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 3)
      }
      if _storage._randomnessSeed != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._randomnessSeed, fieldNumber: 4)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headers, fieldNumber: 5)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 6)
      }
      try { if let v = _storage._parentWorkflowInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._continuedFromExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._continuedFromExecutionRunID, fieldNumber: 11)
      }
      if _storage._continuedInitiator != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._continuedInitiator, fieldNumber: 12)
      }
      try { if let v = _storage._continuedFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._firstExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstExecutionRunID, fieldNumber: 15)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 17)
      }
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 18)
      }
      try { if let v = _storage._workflowExecutionExpirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._cronScheduleToScheduleInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._rootWorkflow {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_InitializeWorkflow, rhs: Coresdk_WorkflowActivation_InitializeWorkflow) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._randomnessSeed != rhs_storage._randomnessSeed {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._parentWorkflowInfo != rhs_storage._parentWorkflowInfo {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._continuedFromExecutionRunID != rhs_storage._continuedFromExecutionRunID {return false}
        if _storage._continuedInitiator != rhs_storage._continuedInitiator {return false}
        if _storage._continuedFailure != rhs_storage._continuedFailure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._firstExecutionRunID != rhs_storage._firstExecutionRunID {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._workflowExecutionExpirationTime != rhs_storage._workflowExecutionExpirationTime {return false}
        if _storage._cronScheduleToScheduleInterval != rhs_storage._cronScheduleToScheduleInterval {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._rootWorkflow != rhs_storage._rootWorkflow {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_FireTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FireTimer"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_FireTimer, rhs: Coresdk_WorkflowActivation_FireTimer) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}result\0\u{3}is_local\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isLocal) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isLocal != false {
      try visitor.visitSingularBoolField(value: self.isLocal, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveActivity, rhs: Coresdk_WorkflowActivation_ResolveActivity) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._result != rhs._result {return false}
    if lhs.isLocal != rhs.isLocal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveChildWorkflowExecutionStart"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}succeeded\0\u{1}failed\0\u{1}cancelled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try {
        var v: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .succeeded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .succeeded(v)
        }
      }()
      case 3: try {
        var v: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 4: try {
        var v: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    switch self.status {
    case .succeeded?: try {
      guard case .succeeded(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart, rhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStart) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveChildWorkflowExecutionStartSuccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess, rhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartSuccess) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveChildWorkflowExecutionStartFailure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}workflow_type\0\u{1}cause\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowType) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    if !self.workflowType.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowType, fieldNumber: 2)
    }
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure, rhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartFailure) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.workflowType != rhs.workflowType {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveChildWorkflowExecutionStartCancelled"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled, rhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecutionStartCancelled) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveChildWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveChildWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecution, rhs: Coresdk_WorkflowActivation_ResolveChildWorkflowExecution) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_UpdateRandomSeed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateRandomSeed"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}randomness_seed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.randomnessSeed) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.randomnessSeed != 0 {
      try visitor.visitSingularUInt64Field(value: self.randomnessSeed, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_UpdateRandomSeed, rhs: Coresdk_WorkflowActivation_UpdateRandomSeed) -> Bool {
    if lhs.randomnessSeed != rhs.randomnessSeed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_QueryWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QueryWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}query_id\0\u{3}query_type\0\u{1}arguments\0\u{2}\u{2}headers\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.queryID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.queryType) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.arguments) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.queryID.isEmpty {
      try visitor.visitSingularStringField(value: self.queryID, fieldNumber: 1)
    }
    if !self.queryType.isEmpty {
      try visitor.visitSingularStringField(value: self.queryType, fieldNumber: 2)
    }
    if !self.arguments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.arguments, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.headers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_QueryWorkflow, rhs: Coresdk_WorkflowActivation_QueryWorkflow) -> Bool {
    if lhs.queryID != rhs.queryID {return false}
    if lhs.queryType != rhs.queryType {return false}
    if lhs.arguments != rhs.arguments {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_CancelWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_CancelWorkflow, rhs: Coresdk_WorkflowActivation_CancelWorkflow) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_SignalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_name\0\u{1}input\0\u{1}identity\0\u{2}\u{2}headers\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.input) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 1)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.input, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.headers, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_SignalWorkflow, rhs: Coresdk_WorkflowActivation_SignalWorkflow) -> Bool {
    if lhs.signalName != rhs.signalName {return false}
    if lhs.input != rhs.input {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_NotifyHasPatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NotifyHasPatch"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}patch_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.patchID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchID.isEmpty {
      try visitor.visitSingularStringField(value: self.patchID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_NotifyHasPatch, rhs: Coresdk_WorkflowActivation_NotifyHasPatch) -> Bool {
    if lhs.patchID != rhs.patchID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveSignalExternalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow, rhs: Coresdk_WorkflowActivation_ResolveSignalExternalWorkflow) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveRequestCancelExternalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow, rhs: Coresdk_WorkflowActivation_ResolveRequestCancelExternalWorkflow) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_DoUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DoUpdate"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}protocol_instance_id\0\u{1}name\0\u{1}input\0\u{1}headers\0\u{1}meta\0\u{3}run_validator\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.protocolInstanceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.input) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.headers) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.runValidator) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.protocolInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolInstanceID, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    if !self.input.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.input, fieldNumber: 4)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.headers, fieldNumber: 5)
    }
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.runValidator != false {
      try visitor.visitSingularBoolField(value: self.runValidator, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_DoUpdate, rhs: Coresdk_WorkflowActivation_DoUpdate) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.protocolInstanceID != rhs.protocolInstanceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.input != rhs.input {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs._meta != rhs._meta {return false}
    if lhs.runValidator != rhs.runValidator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveNexusOperationStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveNexusOperationStart"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}operation_token\0\u{3}started_sync\0\u{1}failed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.status != nil {try decoder.handleConflictingOneOf()}
          self.status = .operationToken(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.status != nil {try decoder.handleConflictingOneOf()}
          self.status = .startedSync(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    switch self.status {
    case .operationToken?: try {
      guard case .operationToken(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .startedSync?: try {
      guard case .startedSync(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveNexusOperationStart, rhs: Coresdk_WorkflowActivation_ResolveNexusOperationStart) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_ResolveNexusOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResolveNexusOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_ResolveNexusOperation, rhs: Coresdk_WorkflowActivation_ResolveNexusOperation) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_RemoveFromCache: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveFromCache"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.reason != .unspecified {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowActivation_RemoveFromCache, rhs: Coresdk_WorkflowActivation_RemoveFromCache) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowActivation_RemoveFromCache.EvictionReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}CACHE_FULL\0\u{1}CACHE_MISS\0\u{1}NONDETERMINISM\0\u{1}LANG_FAIL\0\u{1}LANG_REQUESTED\0\u{1}TASK_NOT_FOUND\0\u{1}UNHANDLED_COMMAND\0\u{1}FATAL\0\u{1}PAGINATION_OR_HISTORY_FETCH\0\u{1}WORKFLOW_EXECUTION_ENDING\0")
}
