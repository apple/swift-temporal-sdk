// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/identity/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Temporal_Api_Cloud_Identity_V1_OwnerType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// The owner is a user.
  case user // = 1

  /// The owner is a service account.
  case serviceAccount // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .user
    case 2: self = .serviceAccount
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .user: return 1
    case .serviceAccount: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Cloud_Identity_V1_OwnerType] = [
    .unspecified,
    .user,
    .serviceAccount,
  ]

}

package struct Temporal_Api_Cloud_Identity_V1_AccountAccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The role on the account, should be one of [owner, admin, developer, financeadmin, read, metricsread]
  /// owner - gives full access to the account, including users, namespaces, and billing
  /// admin - gives full access the account, including users and namespaces
  /// developer - gives access to create namespaces on the account
  /// financeadmin - gives read only access and write access for billing
  /// read - gives read only access to the account
  /// metricsread - gives read only access to all namespace metrics
  /// Deprecated: Not supported after v0.3.0 api version. Use role instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var roleDeprecated: String = String()

  /// The role on the account.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=role_deprecated
  package var role: Temporal_Api_Cloud_Identity_V1_AccountAccess.Role = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum Role: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Gives full access to the account, including users, namespaces, and billing.
    case owner // = 1

    /// Gives full access to the account, including users and namespaces.
    case admin // = 2

    /// Gives access to create namespaces on the account.
    case developer // = 3

    /// Gives read only access and write access for billing.
    case financeAdmin // = 4

    /// Gives read only access to the account.
    case read // = 5

    /// Gives read only access to the account metrics.
    case metricsRead // = 6
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .owner
      case 2: self = .admin
      case 3: self = .developer
      case 4: self = .financeAdmin
      case 5: self = .read
      case 6: self = .metricsRead
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .owner: return 1
      case .admin: return 2
      case .developer: return 3
      case .financeAdmin: return 4
      case .read: return 5
      case .metricsRead: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Cloud_Identity_V1_AccountAccess.Role] = [
      .unspecified,
      .owner,
      .admin,
      .developer,
      .financeAdmin,
      .read,
      .metricsRead,
    ]

  }

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_NamespaceAccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The permission to the namespace, should be one of [admin, write, read]
  /// admin - gives full access to the namespace, including assigning namespace access to other users
  /// write - gives write access to the namespace configuration and workflows within the namespace
  /// read - gives read only access to the namespace configuration and workflows within the namespace
  /// Deprecated: Not supported after v0.3.0 api version. Use permission instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var permissionDeprecated: String = String()

  /// The permission to the namespace.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=permission_deprecated
  package var permission: Temporal_Api_Cloud_Identity_V1_NamespaceAccess.Permission = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum Permission: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Gives full access to the namespace, including assigning namespace access to other users.
    case admin // = 1

    /// Gives write access to the namespace configuration and workflows within the namespace.
    case write // = 2

    /// Gives read only access to the namespace configuration and workflows within the namespace.
    case read // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .admin
      case 2: self = .write
      case 3: self = .read
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .admin: return 1
      case .write: return 2
      case .read: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Cloud_Identity_V1_NamespaceAccess.Permission] = [
      .unspecified,
      .admin,
      .write,
      .read,
    ]

  }

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_Access: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The account access
  package var accountAccess: Temporal_Api_Cloud_Identity_V1_AccountAccess {
    get {return _accountAccess ?? Temporal_Api_Cloud_Identity_V1_AccountAccess()}
    set {_accountAccess = newValue}
  }
  /// Returns true if `accountAccess` has been explicitly set.
  package var hasAccountAccess: Bool {return self._accountAccess != nil}
  /// Clears the value of `accountAccess`. Subsequent reads from it will return its default value.
  package mutating func clearAccountAccess() {self._accountAccess = nil}

  /// The map of namespace accesses
  /// The key is the namespace name and the value is the access to the namespace
  package var namespaceAccesses: Dictionary<String,Temporal_Api_Cloud_Identity_V1_NamespaceAccess> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _accountAccess: Temporal_Api_Cloud_Identity_V1_AccountAccess? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace the service account is assigned to - immutable.
  package var namespace: String = String()

  /// The namespace access assigned to the service account - mutable.
  package var access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_NamespaceAccess()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_NamespaceAccess? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_UserSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The email address associated to the user
  package var email: String = String()

  /// The access to assigned to the user
  package var access: Temporal_Api_Cloud_Identity_V1_Access {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_Access()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_Access? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_Invitation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The date and time when the user was created
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return self._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {self._createdTime = nil}

  /// The date and time when the invitation expires or has expired
  package var expiredTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiredTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiredTime = newValue}
  }
  /// Returns true if `expiredTime` has been explicitly set.
  package var hasExpiredTime: Bool {return self._expiredTime != nil}
  /// Clears the value of `expiredTime`. Subsequent reads from it will return its default value.
  package mutating func clearExpiredTime() {self._expiredTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expiredTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_User: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the user
  package var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The current version of the user specification
  /// The next update operation will have to include this version
  package var resourceVersion: String {
    get {return _storage._resourceVersion}
    set {_uniqueStorage()._resourceVersion = newValue}
  }

  /// The user specification
  package var spec: Temporal_Api_Cloud_Identity_V1_UserSpec {
    get {return _storage._spec ?? Temporal_Api_Cloud_Identity_V1_UserSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The current state of the user
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String {
    get {return _storage._stateDeprecated}
    set {_uniqueStorage()._stateDeprecated = newValue}
  }

  /// The current state of the user.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The id of the async operation that is creating/updating/deleting the user, if any
  package var asyncOperationID: String {
    get {return _storage._asyncOperationID}
    set {_uniqueStorage()._asyncOperationID = newValue}
  }

  /// The details of the open invitation sent to the user, if any
  package var invitation: Temporal_Api_Cloud_Identity_V1_Invitation {
    get {return _storage._invitation ?? Temporal_Api_Cloud_Identity_V1_Invitation()}
    set {_uniqueStorage()._invitation = newValue}
  }
  /// Returns true if `invitation` has been explicitly set.
  package var hasInvitation: Bool {return _storage._invitation != nil}
  /// Clears the value of `invitation`. Subsequent reads from it will return its default value.
  package mutating func clearInvitation() {_uniqueStorage()._invitation = nil}

  /// The date and time when the user was created
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  /// The date and time when the user was last modified
  /// Will not be set if the user has never been modified
  package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  package var hasLastModifiedTime: Bool {return _storage._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The email address of the Google group.
  /// The email address is immutable. Once set during creation, it cannot be changed.
  package var emailAddress: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id used in the upstream identity provider.
  package var idpID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_CloudGroupSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_UserGroupSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The display name of the group.
  package var displayName: String = String()

  /// The access assigned to the group.
  package var access: Temporal_Api_Cloud_Identity_V1_Access {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_Access()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  package var groupType: Temporal_Api_Cloud_Identity_V1_UserGroupSpec.OneOf_GroupType? = nil

  /// The specification of the google group that this group is associated with.
  package var googleGroup: Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec {
    get {
      if case .googleGroup(let v)? = groupType {return v}
      return Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec()
    }
    set {groupType = .googleGroup(newValue)}
  }

  /// The specification of the SCIM group that this group is associated with.
  /// SCIM groups cannot be created or deleted directly, but their access can be managed.
  package var scimGroup: Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec {
    get {
      if case .scimGroup(let v)? = groupType {return v}
      return Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec()
    }
    set {groupType = .scimGroup(newValue)}
  }

  /// The specification for a Cloud group. Cloud groups can manage members using
  /// the add and remove member APIs.
  package var cloudGroup: Temporal_Api_Cloud_Identity_V1_CloudGroupSpec {
    get {
      if case .cloudGroup(let v)? = groupType {return v}
      return Temporal_Api_Cloud_Identity_V1_CloudGroupSpec()
    }
    set {groupType = .cloudGroup(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_GroupType: Equatable, Sendable {
    /// The specification of the google group that this group is associated with.
    case googleGroup(Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec)
    /// The specification of the SCIM group that this group is associated with.
    /// SCIM groups cannot be created or deleted directly, but their access can be managed.
    case scimGroup(Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec)
    /// The specification for a Cloud group. Cloud groups can manage members using
    /// the add and remove member APIs.
    case cloudGroup(Temporal_Api_Cloud_Identity_V1_CloudGroupSpec)

  }

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_Access? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_UserGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the group
  package var id: String = String()

  /// The current version of the group specification
  /// The next update operation will have to include this version
  package var resourceVersion: String = String()

  /// The group specification
  package var spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec {
    get {return _spec ?? Temporal_Api_Cloud_Identity_V1_UserGroupSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// The current state of the group.
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String = String()

  /// The current state of the group.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified

  /// The id of the async operation that is creating/updating/deleting the group, if any
  package var asyncOperationID: String = String()

  /// The date and time when the group was created
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return self._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {self._createdTime = nil}

  /// The date and time when the group was last modified
  /// Will not be set if the group has never been modified
  package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  package var hasLastModifiedTime: Bool {return self._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastModifiedTime() {self._lastModifiedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Cloud_Identity_V1_UserGroupSpec? = nil
  fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_UserGroupMemberId: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var memberType: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId.OneOf_MemberType? = nil

  package var userID: String {
    get {
      if case .userID(let v)? = memberType {return v}
      return String()
    }
    set {memberType = .userID(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_MemberType: Equatable, Sendable {
    case userID(String)

  }

  package init() {}
}

package struct Temporal_Api_Cloud_Identity_V1_UserGroupMember: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId {
    get {return _memberID ?? Temporal_Api_Cloud_Identity_V1_UserGroupMemberId()}
    set {_memberID = newValue}
  }
  /// Returns true if `memberID` has been explicitly set.
  package var hasMemberID: Bool {return self._memberID != nil}
  /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
  package mutating func clearMemberID() {self._memberID = nil}

  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return self._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {self._createdTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _memberID: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId? = nil
  fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_ServiceAccount: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the service account.
  package var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The current version of the service account specification.
  /// The next update operation will have to include this version.
  package var resourceVersion: String {
    get {return _storage._resourceVersion}
    set {_uniqueStorage()._resourceVersion = newValue}
  }

  /// The service account specification.
  package var spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec {
    get {return _storage._spec ?? Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The current state of the service account.
  /// Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String {
    get {return _storage._stateDeprecated}
    set {_uniqueStorage()._stateDeprecated = newValue}
  }

  /// The current state of the service account.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The id of the async operation that is creating/updating/deleting the service account, if any.
  package var asyncOperationID: String {
    get {return _storage._asyncOperationID}
    set {_uniqueStorage()._asyncOperationID = newValue}
  }

  /// The date and time when the service account was created.
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  /// The date and time when the service account was last modified
  /// Will not be set if the service account has never been modified.
  package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  package var hasLastModifiedTime: Bool {return _storage._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name associated with the service account.
  /// The name is mutable, but must be unique across all your active service accounts.
  package var name: String = String()

  /// Note: one of `Access` or `NamespaceScopedAccess` must be provided, but not both.
  /// The access assigned to the service account.
  /// If set, creates an account scoped service account.
  /// The access is mutable.
  package var access: Temporal_Api_Cloud_Identity_V1_Access {
    get {return _access ?? Temporal_Api_Cloud_Identity_V1_Access()}
    set {_access = newValue}
  }
  /// Returns true if `access` has been explicitly set.
  package var hasAccess: Bool {return self._access != nil}
  /// Clears the value of `access`. Subsequent reads from it will return its default value.
  package mutating func clearAccess() {self._access = nil}

  /// The namespace scoped access assigned to the service account.
  /// If set, creates a namespace scoped service account (limited to a single namespace).
  /// The namespace scoped access is partially mutable.
  /// Refer to `NamespaceScopedAccess` for details.
  package var namespaceScopedAccess: Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess {
    get {return _namespaceScopedAccess ?? Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess()}
    set {_namespaceScopedAccess = newValue}
  }
  /// Returns true if `namespaceScopedAccess` has been explicitly set.
  package var hasNamespaceScopedAccess: Bool {return self._namespaceScopedAccess != nil}
  /// Clears the value of `namespaceScopedAccess`. Subsequent reads from it will return its default value.
  package mutating func clearNamespaceScopedAccess() {self._namespaceScopedAccess = nil}

  /// The description associated with the service account - optional.
  /// The description is mutable.
  package var description_p: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _access: Temporal_Api_Cloud_Identity_V1_Access? = nil
  fileprivate var _namespaceScopedAccess: Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess? = nil
}

package struct Temporal_Api_Cloud_Identity_V1_ApiKey: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the API Key.
  package var id: String {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The current version of the API key specification.
  /// The next update operation will have to include this version.
  package var resourceVersion: String {
    get {return _storage._resourceVersion}
    set {_uniqueStorage()._resourceVersion = newValue}
  }

  /// The API key specification.
  package var spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec {
    get {return _storage._spec ?? Temporal_Api_Cloud_Identity_V1_ApiKeySpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The current state of the API key.
  /// Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String {
    get {return _storage._stateDeprecated}
    set {_uniqueStorage()._stateDeprecated = newValue}
  }

  /// The current state of the API key.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The id of the async operation that is creating/updating/deleting the API key, if any.
  package var asyncOperationID: String {
    get {return _storage._asyncOperationID}
    set {_uniqueStorage()._asyncOperationID = newValue}
  }

  /// The date and time when the API key was created.
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  /// The date and time when the API key was last modified.
  /// Will not be set if the API key has never been modified.
  package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  package var hasLastModifiedTime: Bool {return _storage._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Cloud_Identity_V1_ApiKeySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the owner to create the API key for.
  /// The owner id is immutable. Once set during creation, it cannot be changed.
  /// The owner id is the id of the user when the owner type is user.
  /// The owner id is the id of the service account when the owner type is service account.
  package var ownerID: String = String()

  /// The type of the owner to create the API key for.
  /// The owner type is immutable. Once set during creation, it cannot be changed.
  /// Possible values: user, service-account.
  /// Deprecated: Not supported after v0.3.0 api version. Use owner_type instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var ownerTypeDeprecated: String = String()

  /// The type of the owner to create the API key for.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=owner_type_deprecated
  package var ownerType: Temporal_Api_Cloud_Identity_V1_OwnerType = .unspecified

  /// The display name of the API key.
  package var displayName: String = String()

  /// The description of the API key.
  package var description_p: String = String()

  /// The expiry time of the API key.
  package var expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expiryTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expiryTime = newValue}
  }
  /// Returns true if `expiryTime` has been explicitly set.
  package var hasExpiryTime: Bool {return self._expiryTime != nil}
  /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
  package mutating func clearExpiryTime() {self._expiryTime = nil}

  /// True if the API key is disabled.
  package var disabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.identity.v1"

extension Temporal_Api_Cloud_Identity_V1_OwnerType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OWNER_TYPE_UNSPECIFIED\0\u{1}OWNER_TYPE_USER\0\u{1}OWNER_TYPE_SERVICE_ACCOUNT\0")
}

extension Temporal_Api_Cloud_Identity_V1_AccountAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AccountAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_deprecated\0\u{1}role\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roleDeprecated) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.roleDeprecated, fieldNumber: 1)
    }
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_AccountAccess, rhs: Temporal_Api_Cloud_Identity_V1_AccountAccess) -> Bool {
    if lhs.roleDeprecated != rhs.roleDeprecated {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_AccountAccess.Role: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ROLE_UNSPECIFIED\0\u{1}ROLE_OWNER\0\u{1}ROLE_ADMIN\0\u{1}ROLE_DEVELOPER\0\u{1}ROLE_FINANCE_ADMIN\0\u{1}ROLE_READ\0\u{1}ROLE_METRICS_READ\0")
}

extension Temporal_Api_Cloud_Identity_V1_NamespaceAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}permission_deprecated\0\u{1}permission\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.permissionDeprecated) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.permission) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissionDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.permissionDeprecated, fieldNumber: 1)
    }
    if self.permission != .unspecified {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_NamespaceAccess, rhs: Temporal_Api_Cloud_Identity_V1_NamespaceAccess) -> Bool {
    if lhs.permissionDeprecated != rhs.permissionDeprecated {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_NamespaceAccess.Permission: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PERMISSION_UNSPECIFIED\0\u{1}PERMISSION_ADMIN\0\u{1}PERMISSION_WRITE\0\u{1}PERMISSION_READ\0")
}

extension Temporal_Api_Cloud_Identity_V1_Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Access"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}account_access\0\u{3}namespace_accesses\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountAccess) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Identity_V1_NamespaceAccess>.self, value: &self.namespaceAccesses) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountAccess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namespaceAccesses.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Identity_V1_NamespaceAccess>.self, value: self.namespaceAccesses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_Access, rhs: Temporal_Api_Cloud_Identity_V1_Access) -> Bool {
    if lhs._accountAccess != rhs._accountAccess {return false}
    if lhs.namespaceAccesses != rhs.namespaceAccesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceScopedAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess, rhs: Temporal_Api_Cloud_Identity_V1_NamespaceScopedAccess) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._access != rhs._access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_UserSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}email\0\u{1}access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_UserSpec, rhs: Temporal_Api_Cloud_Identity_V1_UserSpec) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs._access != rhs._access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_Invitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Invitation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}created_time\0\u{3}expired_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiredTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expiredTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_Invitation, rhs: Temporal_Api_Cloud_Identity_V1_Invitation) -> Bool {
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs._expiredTime != rhs._expiredTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".User"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}invitation\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Temporal_Api_Cloud_Identity_V1_UserSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _invitation: Temporal_Api_Cloud_Identity_V1_Invitation? = nil
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _invitation = source._invitation
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._invitation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._invitation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_User, rhs: Temporal_Api_Cloud_Identity_V1_User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._invitation != rhs_storage._invitation {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GoogleGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}email_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec, rhs: Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SCIMGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}idp_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idpID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idpID.isEmpty {
      try visitor.visitSingularStringField(value: self.idpID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec, rhs: Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec) -> Bool {
    if lhs.idpID != rhs.idpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_CloudGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CloudGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_CloudGroupSpec, rhs: Temporal_Api_Cloud_Identity_V1_CloudGroupSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_UserGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}display_name\0\u{1}access\0\u{3}google_group\0\u{3}scim_group\0\u{3}cloud_group\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 3: try {
        var v: Temporal_Api_Cloud_Identity_V1_GoogleGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .googleGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .googleGroup(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Cloud_Identity_V1_SCIMGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .scimGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .scimGroup(v)
        }
      }()
      case 5: try {
        var v: Temporal_Api_Cloud_Identity_V1_CloudGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .cloudGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .cloudGroup(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.groupType {
    case .googleGroup?: try {
      guard case .googleGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .scimGroup?: try {
      guard case .scimGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .cloudGroup?: try {
      guard case .cloudGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_UserGroupSpec, rhs: Temporal_Api_Cloud_Identity_V1_UserGroupSpec) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs._access != rhs._access {return false}
    if lhs.groupType != rhs.groupType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_UserGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroup"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.stateDeprecated) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedTime) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.stateDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDeprecated, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastModifiedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_UserGroup, rhs: Temporal_Api_Cloud_Identity_V1_UserGroup) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.stateDeprecated != rhs.stateDeprecated {return false}
    if lhs.state != rhs.state {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs._lastModifiedTime != rhs._lastModifiedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_UserGroupMemberId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupMemberId"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.memberType != nil {try decoder.handleConflictingOneOf()}
          self.memberType = .userID(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .userID(let v)? = self.memberType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId, rhs: Temporal_Api_Cloud_Identity_V1_UserGroupMemberId) -> Bool {
    if lhs.memberType != rhs.memberType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_UserGroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupMember"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}member_id\0\u{3}created_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_UserGroupMember, rhs: Temporal_Api_Cloud_Identity_V1_UserGroupMember) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_ServiceAccount, rhs: Temporal_Api_Cloud_Identity_V1_ServiceAccount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ServiceAccountSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}access\0\u{1}description\0\u{3}namespace_scoped_access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._namespaceScopedAccess) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._namespaceScopedAccess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec, rhs: Temporal_Api_Cloud_Identity_V1_ServiceAccountSpec) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._access != rhs._access {return false}
    if lhs._namespaceScopedAccess != rhs._namespaceScopedAccess {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_ApiKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApiKey"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Temporal_Api_Cloud_Identity_V1_ApiKeySpec? = nil
    var _stateDeprecated: String = String()
    var _state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_ApiKey, rhs: Temporal_Api_Cloud_Identity_V1_ApiKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Identity_V1_ApiKeySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApiKeySpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}owner_type_deprecated\0\u{3}display_name\0\u{1}description\0\u{3}expiry_time\0\u{1}disabled\0\u{3}owner_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerTypeDeprecated) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.ownerType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 1)
    }
    if !self.ownerTypeDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerTypeDeprecated, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try { if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 6)
    }
    if self.ownerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.ownerType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Identity_V1_ApiKeySpec, rhs: Temporal_Api_Cloud_Identity_V1_ApiKeySpec) -> Bool {
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerTypeDeprecated != rhs.ownerTypeDeprecated {return false}
    if lhs.ownerType != rhs.ownerType {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
