// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/failed_cause.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Workflow tasks can fail for various reasons. Note that some of these reasons can only originate
/// from the server, and some of them can only originate from the SDK/worker.
package enum Temporal_Api_Enums_V1_WorkflowTaskFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Between starting and completing the workflow task (with a workflow completion command), some
  /// new command (like a signal) was processed into workflow history. The outstanding task will be
  /// failed with this reason, and a worker must pick up a new task.
  case unhandledCommand // = 1
  case badScheduleActivityAttributes // = 2
  case badRequestCancelActivityAttributes // = 3
  case badStartTimerAttributes // = 4
  case badCancelTimerAttributes // = 5
  case badRecordMarkerAttributes // = 6
  case badCompleteWorkflowExecutionAttributes // = 7
  case badFailWorkflowExecutionAttributes // = 8
  case badCancelWorkflowExecutionAttributes // = 9
  case badRequestCancelExternalWorkflowExecutionAttributes // = 10
  case badContinueAsNewAttributes // = 11
  case startTimerDuplicateID // = 12

  /// The worker wishes to fail the task and have the next one be generated on a normal, not sticky
  /// queue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.
  case resetStickyTaskQueue // = 13
  case workflowWorkerUnhandledFailure // = 14
  case badSignalWorkflowExecutionAttributes // = 15
  case badStartChildExecutionAttributes // = 16
  case forceCloseCommand // = 17
  case failoverCloseCommand // = 18
  case badSignalInputSize // = 19
  case resetWorkflow // = 20
  case badBinary // = 21
  case scheduleActivityDuplicateID // = 22
  case badSearchAttributes // = 23

  /// The worker encountered a mismatch while replaying history between what was expected, and
  /// what the workflow code actually did.
  case nonDeterministicError // = 24
  case badModifyWorkflowPropertiesAttributes // = 25

  /// We send the below error codes to users when their requests would violate a size constraint
  /// of their workflow. We do this to ensure that the state of their workflow does not become too
  /// large because that can cause severe performance degradation. You can modify the thresholds for
  /// each of these errors within your dynamic config.
  ///
  /// Spawning a new child workflow would cause this workflow to exceed its limit of pending child
  /// workflows.
  case pendingChildWorkflowsLimitExceeded // = 26

  /// Starting a new activity would cause this workflow to exceed its limit of pending activities
  /// that we track.
  case pendingActivitiesLimitExceeded // = 27

  /// A workflow has a buffer of signals that have not yet reached their destination. We return this
  /// error when sending a new signal would exceed the capacity of this buffer.
  case pendingSignalsLimitExceeded // = 28

  /// Similarly, we have a buffer of pending requests to cancel other workflows. We return this error
  /// when our capacity for pending cancel requests is already reached.
  case pendingRequestCancelLimitExceeded // = 29

  /// Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)
  /// has wrong format, or missing required fields.
  case badUpdateWorkflowExecutionMessage // = 30

  /// Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.
  case unhandledUpdate // = 31

  /// A workflow task completed with an invalid ScheduleNexusOperation command.
  case badScheduleNexusOperationAttributes // = 32

  /// A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.
  case pendingNexusOperationsLimitExceeded // = 33

  /// A workflow task completed with an invalid RequestCancelNexusOperation command.
  case badRequestCancelNexusOperationAttributes // = 34

  /// A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -
  /// for the workflow's namespace).
  /// Check the workflow task failure message for more information.
  case featureDisabled // = 35

  /// A workflow task failed because a grpc message was too large.
  case grpcMessageTooLarge // = 36
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .unhandledCommand
    case 2: self = .badScheduleActivityAttributes
    case 3: self = .badRequestCancelActivityAttributes
    case 4: self = .badStartTimerAttributes
    case 5: self = .badCancelTimerAttributes
    case 6: self = .badRecordMarkerAttributes
    case 7: self = .badCompleteWorkflowExecutionAttributes
    case 8: self = .badFailWorkflowExecutionAttributes
    case 9: self = .badCancelWorkflowExecutionAttributes
    case 10: self = .badRequestCancelExternalWorkflowExecutionAttributes
    case 11: self = .badContinueAsNewAttributes
    case 12: self = .startTimerDuplicateID
    case 13: self = .resetStickyTaskQueue
    case 14: self = .workflowWorkerUnhandledFailure
    case 15: self = .badSignalWorkflowExecutionAttributes
    case 16: self = .badStartChildExecutionAttributes
    case 17: self = .forceCloseCommand
    case 18: self = .failoverCloseCommand
    case 19: self = .badSignalInputSize
    case 20: self = .resetWorkflow
    case 21: self = .badBinary
    case 22: self = .scheduleActivityDuplicateID
    case 23: self = .badSearchAttributes
    case 24: self = .nonDeterministicError
    case 25: self = .badModifyWorkflowPropertiesAttributes
    case 26: self = .pendingChildWorkflowsLimitExceeded
    case 27: self = .pendingActivitiesLimitExceeded
    case 28: self = .pendingSignalsLimitExceeded
    case 29: self = .pendingRequestCancelLimitExceeded
    case 30: self = .badUpdateWorkflowExecutionMessage
    case 31: self = .unhandledUpdate
    case 32: self = .badScheduleNexusOperationAttributes
    case 33: self = .pendingNexusOperationsLimitExceeded
    case 34: self = .badRequestCancelNexusOperationAttributes
    case 35: self = .featureDisabled
    case 36: self = .grpcMessageTooLarge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .unhandledCommand: return 1
    case .badScheduleActivityAttributes: return 2
    case .badRequestCancelActivityAttributes: return 3
    case .badStartTimerAttributes: return 4
    case .badCancelTimerAttributes: return 5
    case .badRecordMarkerAttributes: return 6
    case .badCompleteWorkflowExecutionAttributes: return 7
    case .badFailWorkflowExecutionAttributes: return 8
    case .badCancelWorkflowExecutionAttributes: return 9
    case .badRequestCancelExternalWorkflowExecutionAttributes: return 10
    case .badContinueAsNewAttributes: return 11
    case .startTimerDuplicateID: return 12
    case .resetStickyTaskQueue: return 13
    case .workflowWorkerUnhandledFailure: return 14
    case .badSignalWorkflowExecutionAttributes: return 15
    case .badStartChildExecutionAttributes: return 16
    case .forceCloseCommand: return 17
    case .failoverCloseCommand: return 18
    case .badSignalInputSize: return 19
    case .resetWorkflow: return 20
    case .badBinary: return 21
    case .scheduleActivityDuplicateID: return 22
    case .badSearchAttributes: return 23
    case .nonDeterministicError: return 24
    case .badModifyWorkflowPropertiesAttributes: return 25
    case .pendingChildWorkflowsLimitExceeded: return 26
    case .pendingActivitiesLimitExceeded: return 27
    case .pendingSignalsLimitExceeded: return 28
    case .pendingRequestCancelLimitExceeded: return 29
    case .badUpdateWorkflowExecutionMessage: return 30
    case .unhandledUpdate: return 31
    case .badScheduleNexusOperationAttributes: return 32
    case .pendingNexusOperationsLimitExceeded: return 33
    case .badRequestCancelNexusOperationAttributes: return 34
    case .featureDisabled: return 35
    case .grpcMessageTooLarge: return 36
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkflowTaskFailedCause] = [
    .unspecified,
    .unhandledCommand,
    .badScheduleActivityAttributes,
    .badRequestCancelActivityAttributes,
    .badStartTimerAttributes,
    .badCancelTimerAttributes,
    .badRecordMarkerAttributes,
    .badCompleteWorkflowExecutionAttributes,
    .badFailWorkflowExecutionAttributes,
    .badCancelWorkflowExecutionAttributes,
    .badRequestCancelExternalWorkflowExecutionAttributes,
    .badContinueAsNewAttributes,
    .startTimerDuplicateID,
    .resetStickyTaskQueue,
    .workflowWorkerUnhandledFailure,
    .badSignalWorkflowExecutionAttributes,
    .badStartChildExecutionAttributes,
    .forceCloseCommand,
    .failoverCloseCommand,
    .badSignalInputSize,
    .resetWorkflow,
    .badBinary,
    .scheduleActivityDuplicateID,
    .badSearchAttributes,
    .nonDeterministicError,
    .badModifyWorkflowPropertiesAttributes,
    .pendingChildWorkflowsLimitExceeded,
    .pendingActivitiesLimitExceeded,
    .pendingSignalsLimitExceeded,
    .pendingRequestCancelLimitExceeded,
    .badUpdateWorkflowExecutionMessage,
    .unhandledUpdate,
    .badScheduleNexusOperationAttributes,
    .pendingNexusOperationsLimitExceeded,
    .badRequestCancelNexusOperationAttributes,
    .featureDisabled,
    .grpcMessageTooLarge,
  ]

}

package enum Temporal_Api_Enums_V1_StartChildWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case workflowAlreadyExists // = 1
  case namespaceNotFound // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .workflowAlreadyExists
    case 2: self = .namespaceNotFound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .workflowAlreadyExists: return 1
    case .namespaceNotFound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_StartChildWorkflowExecutionFailedCause] = [
    .unspecified,
    .workflowAlreadyExists,
    .namespaceNotFound,
  ]

}

package enum Temporal_Api_Enums_V1_CancelExternalWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case externalWorkflowExecutionNotFound // = 1
  case namespaceNotFound // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .externalWorkflowExecutionNotFound
    case 2: self = .namespaceNotFound
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .externalWorkflowExecutionNotFound: return 1
    case .namespaceNotFound: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_CancelExternalWorkflowExecutionFailedCause] = [
    .unspecified,
    .externalWorkflowExecutionNotFound,
    .namespaceNotFound,
  ]

}

package enum Temporal_Api_Enums_V1_SignalExternalWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case externalWorkflowExecutionNotFound // = 1
  case namespaceNotFound // = 2

  /// Signal count limit is per workflow and controlled by server dynamic config "history.maximumSignalsPerExecution"
  case signalCountLimitExceeded // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .externalWorkflowExecutionNotFound
    case 2: self = .namespaceNotFound
    case 3: self = .signalCountLimitExceeded
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .externalWorkflowExecutionNotFound: return 1
    case .namespaceNotFound: return 2
    case .signalCountLimitExceeded: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_SignalExternalWorkflowExecutionFailedCause] = [
    .unspecified,
    .externalWorkflowExecutionNotFound,
    .namespaceNotFound,
    .signalCountLimitExceeded,
  ]

}

package enum Temporal_Api_Enums_V1_ResourceExhaustedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Caller exceeds request per second limit.
  case rpsLimit // = 1

  /// Caller exceeds max concurrent request limit.
  case concurrentLimit // = 2

  /// System overloaded.
  case systemOverloaded // = 3

  /// Namespace exceeds persistence rate limit.
  case persistenceLimit // = 4

  /// Workflow is busy
  case busyWorkflow // = 5

  /// Caller exceeds action per second limit.
  case apsLimit // = 6

  /// Persistence storage limit exceeded.
  case persistenceStorageLimit // = 7

  /// Circuit breaker is open/half-open.
  case circuitBreakerOpen // = 8

  /// Namespace exceeds operations rate limit.
  case opsLimit // = 9
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .rpsLimit
    case 2: self = .concurrentLimit
    case 3: self = .systemOverloaded
    case 4: self = .persistenceLimit
    case 5: self = .busyWorkflow
    case 6: self = .apsLimit
    case 7: self = .persistenceStorageLimit
    case 8: self = .circuitBreakerOpen
    case 9: self = .opsLimit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .rpsLimit: return 1
    case .concurrentLimit: return 2
    case .systemOverloaded: return 3
    case .persistenceLimit: return 4
    case .busyWorkflow: return 5
    case .apsLimit: return 6
    case .persistenceStorageLimit: return 7
    case .circuitBreakerOpen: return 8
    case .opsLimit: return 9
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_ResourceExhaustedCause] = [
    .unspecified,
    .rpsLimit,
    .concurrentLimit,
    .systemOverloaded,
    .persistenceLimit,
    .busyWorkflow,
    .apsLimit,
    .persistenceStorageLimit,
    .circuitBreakerOpen,
    .opsLimit,
  ]

}

package enum Temporal_Api_Enums_V1_ResourceExhaustedScope: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Exhausted resource is a system-level resource.
  case namespace // = 1

  /// Exhausted resource is a namespace-level resource.
  case system // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .namespace
    case 2: self = .system
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .namespace: return 1
    case .system: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_ResourceExhaustedScope] = [
    .unspecified,
    .namespace,
    .system,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Temporal_Api_Enums_V1_WorkflowTaskFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE\0")
}

extension Temporal_Api_Enums_V1_StartChildWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0")
}

extension Temporal_Api_Enums_V1_CancelExternalWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND\0\u{1}CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0")
}

extension Temporal_Api_Enums_V1_SignalExternalWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED\0")
}

extension Temporal_Api_Enums_V1_ResourceExhaustedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RESOURCE_EXHAUSTED_CAUSE_UNSPECIFIED\0\u{1}RESOURCE_EXHAUSTED_CAUSE_RPS_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_CONCURRENT_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_SYSTEM_OVERLOADED\0\u{1}RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_BUSY_WORKFLOW\0\u{1}RESOURCE_EXHAUSTED_CAUSE_APS_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_STORAGE_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_CIRCUIT_BREAKER_OPEN\0\u{1}RESOURCE_EXHAUSTED_CAUSE_OPS_LIMIT\0")
}

extension Temporal_Api_Enums_V1_ResourceExhaustedScope: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RESOURCE_EXHAUSTED_SCOPE_UNSPECIFIED\0\u{1}RESOURCE_EXHAUSTED_SCOPE_NAMESPACE\0\u{1}RESOURCE_EXHAUSTED_SCOPE_SYSTEM\0")
}
