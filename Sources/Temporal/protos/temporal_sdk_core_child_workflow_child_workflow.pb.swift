// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/child_workflow/child_workflow.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Used by the service to determine the fate of a child workflow
/// in case its parent is closed.
package enum Coresdk_ChildWorkflow_ParentClosePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Let's the server set the default.
  case unspecified // = 0

  /// Terminate means terminating the child workflow.
  case terminate // = 1

  /// Abandon means not doing anything on the child workflow.
  case abandon // = 2

  /// Cancel means requesting cancellation on the child workflow.
  case requestCancel // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .terminate
    case 2: self = .abandon
    case 3: self = .requestCancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .terminate: return 1
    case .abandon: return 2
    case .requestCancel: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_ChildWorkflow_ParentClosePolicy] = [
    .unspecified,
    .terminate,
    .abandon,
    .requestCancel,
  ]

}

/// Possible causes of failure to start a child workflow
package enum Coresdk_ChildWorkflow_StartChildWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0
  case workflowAlreadyExists // = 1
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .workflowAlreadyExists
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .workflowAlreadyExists: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_ChildWorkflow_StartChildWorkflowExecutionFailedCause] = [
    .unspecified,
    .workflowAlreadyExists,
  ]

}

/// Controls at which point to report back to lang when a child workflow is cancelled
package enum Coresdk_ChildWorkflow_ChildWorkflowCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Do not request cancellation of the child workflow if already scheduled
  case abandon // = 0

  /// Initiate a cancellation request and immediately report cancellation to the parent.
  case tryCancel // = 1

  /// Wait for child cancellation completion.
  case waitCancellationCompleted // = 2

  /// Request cancellation of the child and wait for confirmation that the request was received.
  case waitCancellationRequested // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .abandon
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .abandon
    case 1: self = .tryCancel
    case 2: self = .waitCancellationCompleted
    case 3: self = .waitCancellationRequested
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .abandon: return 0
    case .tryCancel: return 1
    case .waitCancellationCompleted: return 2
    case .waitCancellationRequested: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_ChildWorkflow_ChildWorkflowCancellationType] = [
    .abandon,
    .tryCancel,
    .waitCancellationCompleted,
    .waitCancellationRequested,
  ]

}

/// Used by core to resolve child workflow executions.
package struct Coresdk_ChildWorkflow_ChildWorkflowResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var status: Coresdk_ChildWorkflow_ChildWorkflowResult.OneOf_Status? = nil

  package var completed: Coresdk_ChildWorkflow_Success {
    get {
      if case .completed(let v)? = status {return v}
      return Coresdk_ChildWorkflow_Success()
    }
    set {status = .completed(newValue)}
  }

  package var failed: Coresdk_ChildWorkflow_Failure {
    get {
      if case .failed(let v)? = status {return v}
      return Coresdk_ChildWorkflow_Failure()
    }
    set {status = .failed(newValue)}
  }

  package var cancelled: Coresdk_ChildWorkflow_Cancellation {
    get {
      if case .cancelled(let v)? = status {return v}
      return Coresdk_ChildWorkflow_Cancellation()
    }
    set {status = .cancelled(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    case completed(Coresdk_ChildWorkflow_Success)
    case failed(Coresdk_ChildWorkflow_Failure)
    case cancelled(Coresdk_ChildWorkflow_Cancellation)

  }

  package init() {}
}

/// Used in ChildWorkflowResult to report successful completion.
package struct Coresdk_ChildWorkflow_Success: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var result: Temporal_Api_Common_V1_Payload {
    get {return _result ?? Temporal_Api_Common_V1_Payload()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payload? = nil
}

/// Used in ChildWorkflowResult to report non successful outcomes such as
/// application failures, timeouts, terminations, and cancellations.
package struct Coresdk_ChildWorkflow_Failure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Used in ChildWorkflowResult to report cancellation.
/// Failure should be ChildWorkflowFailure with a CanceledFailure cause.
package struct Coresdk_ChildWorkflow_Cancellation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.child_workflow"

extension Coresdk_ChildWorkflow_ParentClosePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARENT_CLOSE_POLICY_UNSPECIFIED\0\u{1}PARENT_CLOSE_POLICY_TERMINATE\0\u{1}PARENT_CLOSE_POLICY_ABANDON\0\u{1}PARENT_CLOSE_POLICY_REQUEST_CANCEL\0")
}

extension Coresdk_ChildWorkflow_StartChildWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\0")
}

extension Coresdk_ChildWorkflow_ChildWorkflowCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ABANDON\0\u{1}TRY_CANCEL\0\u{1}WAIT_CANCELLATION_COMPLETED\0\u{1}WAIT_CANCELLATION_REQUESTED\0")
}

extension Coresdk_ChildWorkflow_ChildWorkflowResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk_ChildWorkflow_Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk_ChildWorkflow_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk_ChildWorkflow_Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ChildWorkflow_ChildWorkflowResult, rhs: Coresdk_ChildWorkflow_ChildWorkflowResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ChildWorkflow_Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Success"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ChildWorkflow_Success, rhs: Coresdk_ChildWorkflow_Success) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ChildWorkflow_Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Failure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ChildWorkflow_Failure, rhs: Coresdk_ChildWorkflow_Failure) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ChildWorkflow_Cancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancellation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ChildWorkflow_Cancellation, rhs: Coresdk_ChildWorkflow_Cancellation) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
