// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/schedule/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// (-- api-linter: core::0203::optional=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
// (-- api-linter: core::0203::input-only=disabled
//     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// CalendarSpec describes an event specification relative to the calendar,
/// similar to a traditional cron specification, but with labeled fields. Each
/// field can be one of:
///   *: matches always
///   x: matches when the field equals x
///   x/y : matches when the field equals x+n*y where n is an integer
///   x-z: matches when the field is between x and z inclusive
///   w,x,y,...: matches when the field is one of the listed values
/// Each x, y, z, ... is either a decimal integer, or a month or day of week name
/// or abbreviation (in the appropriate fields).
/// A timestamp matches if all fields match.
/// Note that fields have different default values, for convenience.
/// Note that the special case that some cron implementations have for treating
/// day_of_month and day_of_week as "or" instead of "and" when both are set is
/// not implemented.
/// day_of_week can accept 0 or 7 as Sunday
/// CalendarSpec gets compiled into StructuredCalendarSpec, which is what will be
/// returned if you describe the schedule.
package struct Temporal_Api_Schedule_V1_CalendarSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Expression to match seconds. Default: 0
  package var second: String = String()

  /// Expression to match minutes. Default: 0
  package var minute: String = String()

  /// Expression to match hours. Default: 0
  package var hour: String = String()

  /// Expression to match days of the month. Default: *
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: standard name of field --)
  package var dayOfMonth: String = String()

  /// Expression to match months. Default: *
  package var month: String = String()

  /// Expression to match years. Default: *
  package var year: String = String()

  /// Expression to match days of the week. Default: *
  package var dayOfWeek: String = String()

  /// Free-form comment describing the intention of this spec.
  package var comment: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Range represents a set of integer values, used to match fields of a calendar
/// time in StructuredCalendarSpec. If end < start, then end is interpreted as
/// equal to start. This means you can use a Range with start set to a value, and
/// end and step unset (defaulting to 0) to represent a single value.
package struct Temporal_Api_Schedule_V1_Range: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Start of range (inclusive).
  package var start: Int32 = 0

  /// End of range (inclusive).
  package var end: Int32 = 0

  /// Step (optional, default 1).
  package var step: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// StructuredCalendarSpec describes an event specification relative to the
/// calendar, in a form that's easy to work with programmatically. Each field can
/// be one or more ranges.
/// A timestamp matches if at least one range of each field matches the
/// corresponding fields of the timestamp, except for year: if year is missing,
/// that means all years match. For all fields besides year, at least one Range
/// must be present to match anything.
/// TODO: add relative-to-end-of-month
/// TODO: add nth day-of-week in month
package struct Temporal_Api_Schedule_V1_StructuredCalendarSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Match seconds (0-59)
  package var second: [Temporal_Api_Schedule_V1_Range] = []

  /// Match minutes (0-59)
  package var minute: [Temporal_Api_Schedule_V1_Range] = []

  /// Match hours (0-23)
  package var hour: [Temporal_Api_Schedule_V1_Range] = []

  /// Match days of the month (1-31)
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: standard name of field --)
  package var dayOfMonth: [Temporal_Api_Schedule_V1_Range] = []

  /// Match months (1-12)
  package var month: [Temporal_Api_Schedule_V1_Range] = []

  /// Match years.
  package var year: [Temporal_Api_Schedule_V1_Range] = []

  /// Match days of the week (0-6; 0 is Sunday).
  package var dayOfWeek: [Temporal_Api_Schedule_V1_Range] = []

  /// Free-form comment describing the intention of this spec.
  package var comment: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// IntervalSpec matches times that can be expressed as:
/// epoch + n * interval + phase
/// where n is an integer.
/// phase defaults to zero if missing. interval is required.
/// Both interval and phase must be non-negative and are truncated to the nearest
/// second before any calculations.
/// For example, an interval of 1 hour with phase of zero would match every hour,
/// on the hour. The same interval but a phase of 19 minutes would match every
/// xx:19:00. An interval of 28 days with phase zero would match
/// 2022-02-17T00:00:00Z (among other times). The same interval with a phase of 3
/// days, 5 hours, and 23 minutes would match 2022-02-20T05:23:00Z instead.
package struct Temporal_Api_Schedule_V1_IntervalSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var interval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _interval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  package var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  package mutating func clearInterval() {self._interval = nil}

  package var phase: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _phase ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_phase = newValue}
  }
  /// Returns true if `phase` has been explicitly set.
  package var hasPhase: Bool {return self._phase != nil}
  /// Clears the value of `phase`. Subsequent reads from it will return its default value.
  package mutating func clearPhase() {self._phase = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _interval: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _phase: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// ScheduleSpec is a complete description of a set of absolute timestamps
/// (possibly infinite) that an action should occur at. The meaning of a
/// ScheduleSpec depends only on its contents and never changes, except that the
/// definition of a time zone can change over time (most commonly, when daylight
/// saving time policy changes for an area). To create a totally self-contained
/// ScheduleSpec, use UTC or include timezone_data.
///
/// For input, you can provide zero or more of: structured_calendar, calendar,
/// cron_string, interval, and exclude_structured_calendar, and all of them will
/// be used (the schedule will take action at the union of all of their times,
/// minus the ones that match exclude_structured_calendar).
///
/// On input, calendar and cron_string fields will be compiled into
/// structured_calendar (and maybe interval and timezone_name), so if you
/// Describe a schedule, you'll see only structured_calendar, interval, etc.
///
/// If a spec has no matching times after the current time, then the schedule
/// will be subject to automatic deletion (after several days).
package struct Temporal_Api_Schedule_V1_ScheduleSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Calendar-based specifications of times.
  package var structuredCalendar: [Temporal_Api_Schedule_V1_StructuredCalendarSpec] = []

  /// cron_string holds a traditional cron specification as a string. It
  /// accepts 5, 6, or 7 fields, separated by spaces, and interprets them the
  /// same way as CalendarSpec.
  /// 5 fields:         minute, hour, day_of_month, month, day_of_week
  /// 6 fields:         minute, hour, day_of_month, month, day_of_week, year
  /// 7 fields: second, minute, hour, day_of_month, month, day_of_week, year
  /// If year is not given, it defaults to *. If second is not given, it
  /// defaults to 0.
  /// Shorthands @yearly, @monthly, @weekly, @daily, and @hourly are also
  /// accepted instead of the 5-7 time fields.
  /// Optionally, the string can be preceded by CRON_TZ=<timezone name> or
  /// TZ=<timezone name>, which will get copied to timezone_name. (There must
  /// not also be a timezone_name present.)
  /// Optionally "#" followed by a comment can appear at the end of the string.
  /// Note that the special case that some cron implementations have for
  /// treating day_of_month and day_of_week as "or" instead of "and" when both
  /// are set is not implemented.
  /// @every <interval>[/<phase>] is accepted and gets compiled into an
  /// IntervalSpec instead. <interval> and <phase> should be a decimal integer
  /// with a unit suffix s, m, h, or d.
  package var cronString: [String] = []

  /// Calendar-based specifications of times.
  package var calendar: [Temporal_Api_Schedule_V1_CalendarSpec] = []

  /// Interval-based specifications of times.
  package var interval: [Temporal_Api_Schedule_V1_IntervalSpec] = []

  /// Any timestamps matching any of exclude_* will be skipped.
  /// Deprecated. Use exclude_structured_calendar.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var excludeCalendar: [Temporal_Api_Schedule_V1_CalendarSpec] = []

  package var excludeStructuredCalendar: [Temporal_Api_Schedule_V1_StructuredCalendarSpec] = []

  /// If start_time is set, any timestamps before start_time will be skipped.
  /// (Together, start_time and end_time make an inclusive interval.)
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {self._startTime = nil}

  /// If end_time is set, any timestamps after end_time will be skipped.
  package var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  package var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  package mutating func clearEndTime() {self._endTime = nil}

  /// All timestamps will be incremented by a random value from 0 to this
  /// amount of jitter. Default: 0
  package var jitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_jitter = newValue}
  }
  /// Returns true if `jitter` has been explicitly set.
  package var hasJitter: Bool {return self._jitter != nil}
  /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
  package mutating func clearJitter() {self._jitter = nil}

  /// Time zone to interpret all calendar-based specs in.
  ///
  /// If unset, defaults to UTC. We recommend using UTC for your application if
  /// at all possible, to avoid various surprising properties of time zones.
  ///
  /// Time zones may be provided by name, corresponding to names in the IANA
  /// time zone database (see https://www.iana.org/time-zones). The definition
  /// will be loaded by the Temporal server from the environment it runs in.
  ///
  /// If your application requires more control over the time zone definition
  /// used, it may pass in a complete definition in the form of a TZif file
  /// from the time zone database. If present, this will be used instead of
  /// loading anything from the environment. You are then responsible for
  /// updating timezone_data when the definition changes.
  ///
  /// Calendar spec matching is based on literal matching of the clock time
  /// with no special handling of DST: if you write a calendar spec that fires
  /// at 2:30am and specify a time zone that follows DST, that action will not
  /// be triggered on the day that has no 2:30am. Similarly, an action that
  /// fires at 1:30am will be triggered twice on the day that has two 1:30s.
  ///
  /// Also note that no actions are taken on leap-seconds (e.g. 23:59:60 UTC).
  package var timezoneName: String = String()

  package var timezoneData: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Schedule_V1_SchedulePolicies: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Policy for overlaps.
  /// Note that this can be changed after a schedule has taken some actions,
  /// and some changes might produce unintuitive results. In general, the later
  /// policy overrides the earlier policy.
  package var overlapPolicy: Temporal_Api_Enums_V1_ScheduleOverlapPolicy = .unspecified

  /// Policy for catchups:
  /// If the Temporal server misses an action due to one or more components
  /// being down, and comes back up, the action will be run if the scheduled
  /// time is within this window from the current time.
  /// This value defaults to one year, and can't be less than 10 seconds.
  package var catchupWindow: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _catchupWindow ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_catchupWindow = newValue}
  }
  /// Returns true if `catchupWindow` has been explicitly set.
  package var hasCatchupWindow: Bool {return self._catchupWindow != nil}
  /// Clears the value of `catchupWindow`. Subsequent reads from it will return its default value.
  package mutating func clearCatchupWindow() {self._catchupWindow = nil}

  /// If true, and a workflow run fails or times out, turn on "paused".
  /// This applies after retry policies: the full chain of retries must fail to
  /// trigger a pause here.
  package var pauseOnFailure: Bool = false

  /// If true, and the action would start a workflow, a timestamp will not be
  /// appended to the scheduled workflow id.
  package var keepOriginalWorkflowID: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _catchupWindow: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Schedule_V1_ScheduleAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var action: Temporal_Api_Schedule_V1_ScheduleAction.OneOf_Action? = nil

  /// All fields of NewWorkflowExecutionInfo are valid except for:
  /// - workflow_id_reuse_policy
  /// - cron_schedule
  /// The workflow id of the started workflow may not match this exactly,
  /// it may have a timestamp appended for uniqueness.
  package var startWorkflow: Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo {
    get {
      if case .startWorkflow(let v)? = action {return v}
      return Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo()
    }
    set {action = .startWorkflow(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Action: Equatable, Sendable {
    /// All fields of NewWorkflowExecutionInfo are valid except for:
    /// - workflow_id_reuse_policy
    /// - cron_schedule
    /// The workflow id of the started workflow may not match this exactly,
    /// it may have a timestamp appended for uniqueness.
    case startWorkflow(Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo)

  }

  package init() {}
}

package struct Temporal_Api_Schedule_V1_ScheduleActionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time that the action was taken (according to the schedule, including jitter).
  package var scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _scheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_scheduleTime = newValue}
  }
  /// Returns true if `scheduleTime` has been explicitly set.
  package var hasScheduleTime: Bool {return self._scheduleTime != nil}
  /// Clears the value of `scheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleTime() {self._scheduleTime = nil}

  /// Time that the action was taken (real time).
  package var actualTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _actualTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_actualTime = newValue}
  }
  /// Returns true if `actualTime` has been explicitly set.
  package var hasActualTime: Bool {return self._actualTime != nil}
  /// Clears the value of `actualTime`. Subsequent reads from it will return its default value.
  package mutating func clearActualTime() {self._actualTime = nil}

  /// If action was start_workflow:
  package var startWorkflowResult: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _startWorkflowResult ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_startWorkflowResult = newValue}
  }
  /// Returns true if `startWorkflowResult` has been explicitly set.
  package var hasStartWorkflowResult: Bool {return self._startWorkflowResult != nil}
  /// Clears the value of `startWorkflowResult`. Subsequent reads from it will return its default value.
  package mutating func clearStartWorkflowResult() {self._startWorkflowResult = nil}

  /// If the action was start_workflow, this field will reflect an
  /// eventually-consistent view of the started workflow's status.
  package var startWorkflowStatus: Temporal_Api_Enums_V1_WorkflowExecutionStatus = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _actualTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startWorkflowResult: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Schedule_V1_ScheduleState: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Informative human-readable message with contextual notes, e.g. the reason
  /// a schedule is paused. The system may overwrite this message on certain
  /// conditions, e.g. when pause-on-failure happens.
  package var notes: String = String()

  /// If true, do not take any actions based on the schedule spec.
  package var paused: Bool = false

  /// If limited_actions is true, decrement remaining_actions after each
  /// action, and do not take any more scheduled actions if remaining_actions
  /// is zero. Actions may still be taken by explicit request (i.e. trigger
  /// immediately or backfill). Skipped actions (due to overlap policy) do not
  /// count against remaining actions.
  /// If a schedule has no more remaining actions, then the schedule will be
  /// subject to automatic deletion (after several days).
  package var limitedActions: Bool = false

  package var remainingActions: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Schedule_V1_TriggerImmediatelyRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, override overlap policy for this one request.
  package var overlapPolicy: Temporal_Api_Enums_V1_ScheduleOverlapPolicy = .unspecified

  /// Timestamp used for the identity of the target workflow.
  /// If not set the default value is the current time.
  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return self._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {self._scheduledTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Schedule_V1_BackfillRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time range to evaluate schedule in. Currently, this time range is
  /// exclusive on start_time and inclusive on end_time. (This is admittedly
  /// counterintuitive and it may change in the future, so to be safe, use a
  /// start time strictly before a scheduled time.) Also note that an action
  /// nominally scheduled in the interval but with jitter that pushes it after
  /// end_time will not be included.
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {self._startTime = nil}

  package var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  package var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  package mutating func clearEndTime() {self._endTime = nil}

  /// If set, override overlap policy for this request.
  package var overlapPolicy: Temporal_Api_Enums_V1_ScheduleOverlapPolicy = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Schedule_V1_SchedulePatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, trigger one action immediately.
  package var triggerImmediately: Temporal_Api_Schedule_V1_TriggerImmediatelyRequest {
    get {return _triggerImmediately ?? Temporal_Api_Schedule_V1_TriggerImmediatelyRequest()}
    set {_triggerImmediately = newValue}
  }
  /// Returns true if `triggerImmediately` has been explicitly set.
  package var hasTriggerImmediately: Bool {return self._triggerImmediately != nil}
  /// Clears the value of `triggerImmediately`. Subsequent reads from it will return its default value.
  package mutating func clearTriggerImmediately() {self._triggerImmediately = nil}

  /// If set, runs though the specified time period(s) and takes actions as if that time
  /// passed by right now, all at once. The overlap policy can be overridden for the
  /// scope of the backfill.
  package var backfillRequest: [Temporal_Api_Schedule_V1_BackfillRequest] = []

  /// If set, change the state to paused or unpaused (respectively) and set the
  /// notes field to the value of the string.
  package var pause: String = String()

  package var unpause: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _triggerImmediately: Temporal_Api_Schedule_V1_TriggerImmediatelyRequest? = nil
}

package struct Temporal_Api_Schedule_V1_ScheduleInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of actions taken so far.
  package var actionCount: Int64 = 0

  /// Number of times a scheduled action was skipped due to missing the catchup window.
  package var missedCatchupWindow: Int64 = 0

  /// Number of skipped actions due to overlap.
  package var overlapSkipped: Int64 = 0

  /// Number of dropped actions due to buffer limit.
  package var bufferDropped: Int64 = 0

  /// Number of actions in the buffer. The buffer holds the actions that cannot
  /// be immediately triggered (due to the overlap policy). These actions can be a result of
  /// the normal schedule or a backfill.
  package var bufferSize: Int64 = 0

  /// Currently-running workflows started by this schedule. (There might be
  /// more than one if the overlap policy allows overlaps.)
  /// Note that the run_ids in here are the original execution run ids as
  /// started by the schedule. If the workflows retried, did continue-as-new,
  /// or were reset, they might still be running but with a different run_id.
  package var runningWorkflows: [Temporal_Api_Common_V1_WorkflowExecution] = []

  /// Most recent ten actual action times (including manual triggers).
  package var recentActions: [Temporal_Api_Schedule_V1_ScheduleActionResult] = []

  /// Next ten scheduled action times.
  package var futureActionTimes: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  /// Timestamps of schedule creation and last update.
  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  package var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  package var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateTime() {self._updateTime = nil}

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var invalidScheduleError: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Schedule_V1_Schedule: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var spec: Temporal_Api_Schedule_V1_ScheduleSpec {
    get {return _storage._spec ?? Temporal_Api_Schedule_V1_ScheduleSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  package var action: Temporal_Api_Schedule_V1_ScheduleAction {
    get {return _storage._action ?? Temporal_Api_Schedule_V1_ScheduleAction()}
    set {_uniqueStorage()._action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  package var hasAction: Bool {return _storage._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  package mutating func clearAction() {_uniqueStorage()._action = nil}

  package var policies: Temporal_Api_Schedule_V1_SchedulePolicies {
    get {return _storage._policies ?? Temporal_Api_Schedule_V1_SchedulePolicies()}
    set {_uniqueStorage()._policies = newValue}
  }
  /// Returns true if `policies` has been explicitly set.
  package var hasPolicies: Bool {return _storage._policies != nil}
  /// Clears the value of `policies`. Subsequent reads from it will return its default value.
  package mutating func clearPolicies() {_uniqueStorage()._policies = nil}

  package var state: Temporal_Api_Schedule_V1_ScheduleState {
    get {return _storage._state ?? Temporal_Api_Schedule_V1_ScheduleState()}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  package var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  package mutating func clearState() {_uniqueStorage()._state = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ScheduleListInfo is an abbreviated set of values from Schedule and ScheduleInfo
/// that's returned in ListSchedules.
package struct Temporal_Api_Schedule_V1_ScheduleListInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// From spec:
  /// Some fields are dropped from this copy of spec: timezone_data
  package var spec: Temporal_Api_Schedule_V1_ScheduleSpec {
    get {return _storage._spec ?? Temporal_Api_Schedule_V1_ScheduleSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// From action:
  /// Action is a oneof field, but we need to encode this in JSON and oneof fields don't work
  /// well with JSON. If action is start_workflow, this is set:
  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  /// From state:
  package var notes: String {
    get {return _storage._notes}
    set {_uniqueStorage()._notes = newValue}
  }

  package var paused: Bool {
    get {return _storage._paused}
    set {_uniqueStorage()._paused = newValue}
  }

  /// From info (maybe fewer entries):
  package var recentActions: [Temporal_Api_Schedule_V1_ScheduleActionResult] {
    get {return _storage._recentActions}
    set {_uniqueStorage()._recentActions = newValue}
  }

  package var futureActionTimes: [SwiftProtobuf.Google_Protobuf_Timestamp] {
    get {return _storage._futureActionTimes}
    set {_uniqueStorage()._futureActionTimes = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// ScheduleListEntry is returned by ListSchedules.
package struct Temporal_Api_Schedule_V1_ScheduleListEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var scheduleID: String = String()

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _memo ?? Temporal_Api_Common_V1_Memo()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {self._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return self._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {self._searchAttributes = nil}

  package var info: Temporal_Api_Schedule_V1_ScheduleListInfo {
    get {return _info ?? Temporal_Api_Schedule_V1_ScheduleListInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  package var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  package mutating func clearInfo() {self._info = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _memo: Temporal_Api_Common_V1_Memo? = nil
  fileprivate var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
  fileprivate var _info: Temporal_Api_Schedule_V1_ScheduleListInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.schedule.v1"

extension Temporal_Api_Schedule_V1_CalendarSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CalendarSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}second\0\u{1}minute\0\u{1}hour\0\u{3}day_of_month\0\u{1}month\0\u{1}year\0\u{3}day_of_week\0\u{1}comment\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.second) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.minute) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.hour) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.dayOfMonth) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.month) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.year) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.dayOfWeek) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.second.isEmpty {
      try visitor.visitSingularStringField(value: self.second, fieldNumber: 1)
    }
    if !self.minute.isEmpty {
      try visitor.visitSingularStringField(value: self.minute, fieldNumber: 2)
    }
    if !self.hour.isEmpty {
      try visitor.visitSingularStringField(value: self.hour, fieldNumber: 3)
    }
    if !self.dayOfMonth.isEmpty {
      try visitor.visitSingularStringField(value: self.dayOfMonth, fieldNumber: 4)
    }
    if !self.month.isEmpty {
      try visitor.visitSingularStringField(value: self.month, fieldNumber: 5)
    }
    if !self.year.isEmpty {
      try visitor.visitSingularStringField(value: self.year, fieldNumber: 6)
    }
    if !self.dayOfWeek.isEmpty {
      try visitor.visitSingularStringField(value: self.dayOfWeek, fieldNumber: 7)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_CalendarSpec, rhs: Temporal_Api_Schedule_V1_CalendarSpec) -> Bool {
    if lhs.second != rhs.second {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.dayOfMonth != rhs.dayOfMonth {return false}
    if lhs.month != rhs.month {return false}
    if lhs.year != rhs.year {return false}
    if lhs.dayOfWeek != rhs.dayOfWeek {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Range"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0\u{1}step\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.step) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    if self.step != 0 {
      try visitor.visitSingularInt32Field(value: self.step, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_Range, rhs: Temporal_Api_Schedule_V1_Range) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.step != rhs.step {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_StructuredCalendarSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StructuredCalendarSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}second\0\u{1}minute\0\u{1}hour\0\u{3}day_of_month\0\u{1}month\0\u{1}year\0\u{3}day_of_week\0\u{1}comment\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.second) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.minute) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.hour) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.dayOfMonth) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.month) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.year) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.dayOfWeek) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.comment) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.second.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.second, fieldNumber: 1)
    }
    if !self.minute.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.minute, fieldNumber: 2)
    }
    if !self.hour.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.hour, fieldNumber: 3)
    }
    if !self.dayOfMonth.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dayOfMonth, fieldNumber: 4)
    }
    if !self.month.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.month, fieldNumber: 5)
    }
    if !self.year.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.year, fieldNumber: 6)
    }
    if !self.dayOfWeek.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dayOfWeek, fieldNumber: 7)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_StructuredCalendarSpec, rhs: Temporal_Api_Schedule_V1_StructuredCalendarSpec) -> Bool {
    if lhs.second != rhs.second {return false}
    if lhs.minute != rhs.minute {return false}
    if lhs.hour != rhs.hour {return false}
    if lhs.dayOfMonth != rhs.dayOfMonth {return false}
    if lhs.month != rhs.month {return false}
    if lhs.year != rhs.year {return false}
    if lhs.dayOfWeek != rhs.dayOfWeek {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_IntervalSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".IntervalSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}interval\0\u{1}phase\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._interval) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._phase) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._interval {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._phase {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_IntervalSpec, rhs: Temporal_Api_Schedule_V1_IntervalSpec) -> Bool {
    if lhs._interval != rhs._interval {return false}
    if lhs._phase != rhs._phase {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}calendar\0\u{1}interval\0\u{3}exclude_calendar\0\u{3}start_time\0\u{3}end_time\0\u{1}jitter\0\u{3}structured_calendar\0\u{3}cron_string\0\u{3}exclude_structured_calendar\0\u{3}timezone_name\0\u{3}timezone_data\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.calendar) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.interval) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.excludeCalendar) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.structuredCalendar) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.cronString) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.excludeStructuredCalendar) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.timezoneName) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.timezoneData) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.calendar.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.calendar, fieldNumber: 1)
    }
    if !self.interval.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interval, fieldNumber: 2)
    }
    if !self.excludeCalendar.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludeCalendar, fieldNumber: 3)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.structuredCalendar.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.structuredCalendar, fieldNumber: 7)
    }
    if !self.cronString.isEmpty {
      try visitor.visitRepeatedStringField(value: self.cronString, fieldNumber: 8)
    }
    if !self.excludeStructuredCalendar.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.excludeStructuredCalendar, fieldNumber: 9)
    }
    if !self.timezoneName.isEmpty {
      try visitor.visitSingularStringField(value: self.timezoneName, fieldNumber: 10)
    }
    if !self.timezoneData.isEmpty {
      try visitor.visitSingularBytesField(value: self.timezoneData, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleSpec, rhs: Temporal_Api_Schedule_V1_ScheduleSpec) -> Bool {
    if lhs.structuredCalendar != rhs.structuredCalendar {return false}
    if lhs.cronString != rhs.cronString {return false}
    if lhs.calendar != rhs.calendar {return false}
    if lhs.interval != rhs.interval {return false}
    if lhs.excludeCalendar != rhs.excludeCalendar {return false}
    if lhs.excludeStructuredCalendar != rhs.excludeStructuredCalendar {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.timezoneName != rhs.timezoneName {return false}
    if lhs.timezoneData != rhs.timezoneData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_SchedulePolicies: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchedulePolicies"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}overlap_policy\0\u{3}catchup_window\0\u{3}pause_on_failure\0\u{3}keep_original_workflow_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.overlapPolicy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._catchupWindow) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.pauseOnFailure) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.keepOriginalWorkflowID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.overlapPolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.overlapPolicy, fieldNumber: 1)
    }
    try { if let v = self._catchupWindow {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pauseOnFailure != false {
      try visitor.visitSingularBoolField(value: self.pauseOnFailure, fieldNumber: 3)
    }
    if self.keepOriginalWorkflowID != false {
      try visitor.visitSingularBoolField(value: self.keepOriginalWorkflowID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_SchedulePolicies, rhs: Temporal_Api_Schedule_V1_SchedulePolicies) -> Bool {
    if lhs.overlapPolicy != rhs.overlapPolicy {return false}
    if lhs._catchupWindow != rhs._catchupWindow {return false}
    if lhs.pauseOnFailure != rhs.pauseOnFailure {return false}
    if lhs.keepOriginalWorkflowID != rhs.keepOriginalWorkflowID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleAction"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_workflow\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .startWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .startWorkflow(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .startWorkflow(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleAction, rhs: Temporal_Api_Schedule_V1_ScheduleAction) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleActionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleActionResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_time\0\u{3}actual_time\0\u{4}\u{9}start_workflow_result\0\u{3}start_workflow_status\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._scheduleTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._actualTime) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._startWorkflowResult) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.startWorkflowStatus) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._scheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._actualTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startWorkflowResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    if self.startWorkflowStatus != .unspecified {
      try visitor.visitSingularEnumField(value: self.startWorkflowStatus, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleActionResult, rhs: Temporal_Api_Schedule_V1_ScheduleActionResult) -> Bool {
    if lhs._scheduleTime != rhs._scheduleTime {return false}
    if lhs._actualTime != rhs._actualTime {return false}
    if lhs._startWorkflowResult != rhs._startWorkflowResult {return false}
    if lhs.startWorkflowStatus != rhs.startWorkflowStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleState"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}notes\0\u{1}paused\0\u{3}limited_actions\0\u{3}remaining_actions\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.notes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.paused) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.limitedActions) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.remainingActions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.notes.isEmpty {
      try visitor.visitSingularStringField(value: self.notes, fieldNumber: 1)
    }
    if self.paused != false {
      try visitor.visitSingularBoolField(value: self.paused, fieldNumber: 2)
    }
    if self.limitedActions != false {
      try visitor.visitSingularBoolField(value: self.limitedActions, fieldNumber: 3)
    }
    if self.remainingActions != 0 {
      try visitor.visitSingularInt64Field(value: self.remainingActions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleState, rhs: Temporal_Api_Schedule_V1_ScheduleState) -> Bool {
    if lhs.notes != rhs.notes {return false}
    if lhs.paused != rhs.paused {return false}
    if lhs.limitedActions != rhs.limitedActions {return false}
    if lhs.remainingActions != rhs.remainingActions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_TriggerImmediatelyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TriggerImmediatelyRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}overlap_policy\0\u{3}scheduled_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.overlapPolicy) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduledTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.overlapPolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.overlapPolicy, fieldNumber: 1)
    }
    try { if let v = self._scheduledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_TriggerImmediatelyRequest, rhs: Temporal_Api_Schedule_V1_TriggerImmediatelyRequest) -> Bool {
    if lhs.overlapPolicy != rhs.overlapPolicy {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_BackfillRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BackfillRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_time\0\u{3}end_time\0\u{3}overlap_policy\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.overlapPolicy) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.overlapPolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.overlapPolicy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_BackfillRequest, rhs: Temporal_Api_Schedule_V1_BackfillRequest) -> Bool {
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.overlapPolicy != rhs.overlapPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_SchedulePatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SchedulePatch"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}trigger_immediately\0\u{3}backfill_request\0\u{1}pause\0\u{1}unpause\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._triggerImmediately) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.backfillRequest) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pause) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unpause) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._triggerImmediately {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.backfillRequest.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.backfillRequest, fieldNumber: 2)
    }
    if !self.pause.isEmpty {
      try visitor.visitSingularStringField(value: self.pause, fieldNumber: 3)
    }
    if !self.unpause.isEmpty {
      try visitor.visitSingularStringField(value: self.unpause, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_SchedulePatch, rhs: Temporal_Api_Schedule_V1_SchedulePatch) -> Bool {
    if lhs._triggerImmediately != rhs._triggerImmediately {return false}
    if lhs.backfillRequest != rhs.backfillRequest {return false}
    if lhs.pause != rhs.pause {return false}
    if lhs.unpause != rhs.unpause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}action_count\0\u{3}missed_catchup_window\0\u{3}overlap_skipped\0\u{3}recent_actions\0\u{3}future_action_times\0\u{3}create_time\0\u{3}update_time\0\u{3}invalid_schedule_error\0\u{3}running_workflows\0\u{3}buffer_dropped\0\u{3}buffer_size\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.actionCount) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.missedCatchupWindow) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.overlapSkipped) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.recentActions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.futureActionTimes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.invalidScheduleError) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.runningWorkflows) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.bufferDropped) }()
      case 11: try { try decoder.decodeSingularInt64Field(value: &self.bufferSize) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.actionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.actionCount, fieldNumber: 1)
    }
    if self.missedCatchupWindow != 0 {
      try visitor.visitSingularInt64Field(value: self.missedCatchupWindow, fieldNumber: 2)
    }
    if self.overlapSkipped != 0 {
      try visitor.visitSingularInt64Field(value: self.overlapSkipped, fieldNumber: 3)
    }
    if !self.recentActions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.recentActions, fieldNumber: 4)
    }
    if !self.futureActionTimes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.futureActionTimes, fieldNumber: 5)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.invalidScheduleError.isEmpty {
      try visitor.visitSingularStringField(value: self.invalidScheduleError, fieldNumber: 8)
    }
    if !self.runningWorkflows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.runningWorkflows, fieldNumber: 9)
    }
    if self.bufferDropped != 0 {
      try visitor.visitSingularInt64Field(value: self.bufferDropped, fieldNumber: 10)
    }
    if self.bufferSize != 0 {
      try visitor.visitSingularInt64Field(value: self.bufferSize, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleInfo, rhs: Temporal_Api_Schedule_V1_ScheduleInfo) -> Bool {
    if lhs.actionCount != rhs.actionCount {return false}
    if lhs.missedCatchupWindow != rhs.missedCatchupWindow {return false}
    if lhs.overlapSkipped != rhs.overlapSkipped {return false}
    if lhs.bufferDropped != rhs.bufferDropped {return false}
    if lhs.bufferSize != rhs.bufferSize {return false}
    if lhs.runningWorkflows != rhs.runningWorkflows {return false}
    if lhs.recentActions != rhs.recentActions {return false}
    if lhs.futureActionTimes != rhs.futureActionTimes {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.invalidScheduleError != rhs.invalidScheduleError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_Schedule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Schedule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{1}action\0\u{1}policies\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _spec: Temporal_Api_Schedule_V1_ScheduleSpec? = nil
    var _action: Temporal_Api_Schedule_V1_ScheduleAction? = nil
    var _policies: Temporal_Api_Schedule_V1_SchedulePolicies? = nil
    var _state: Temporal_Api_Schedule_V1_ScheduleState? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _spec = source._spec
      _action = source._action
      _policies = source._policies
      _state = source._state
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._action) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._policies) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._action {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._policies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_Schedule, rhs: Temporal_Api_Schedule_V1_Schedule) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._policies != rhs_storage._policies {return false}
        if _storage._state != rhs_storage._state {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleListInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleListInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}workflow_type\0\u{1}notes\0\u{1}paused\0\u{3}recent_actions\0\u{3}future_action_times\0")

  fileprivate class _StorageClass {
    var _spec: Temporal_Api_Schedule_V1_ScheduleSpec? = nil
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _notes: String = String()
    var _paused: Bool = false
    var _recentActions: [Temporal_Api_Schedule_V1_ScheduleActionResult] = []
    var _futureActionTimes: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _spec = source._spec
      _workflowType = source._workflowType
      _notes = source._notes
      _paused = source._paused
      _recentActions = source._recentActions
      _futureActionTimes = source._futureActionTimes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._notes) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._recentActions) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._futureActionTimes) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._notes.isEmpty {
        try visitor.visitSingularStringField(value: _storage._notes, fieldNumber: 3)
      }
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 4)
      }
      if !_storage._recentActions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._recentActions, fieldNumber: 5)
      }
      if !_storage._futureActionTimes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._futureActionTimes, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleListInfo, rhs: Temporal_Api_Schedule_V1_ScheduleListInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._notes != rhs_storage._notes {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._recentActions != rhs_storage._recentActions {return false}
        if _storage._futureActionTimes != rhs_storage._futureActionTimes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Schedule_V1_ScheduleListEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleListEntry"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}schedule_id\0\u{1}memo\0\u{3}search_attributes\0\u{1}info\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 1)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Schedule_V1_ScheduleListEntry, rhs: Temporal_Api_Schedule_V1_ScheduleListEntry) -> Bool {
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
