// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/activity_task/activity_task.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Coresdk_ActivityTask_ActivityCancelReason: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// The activity no longer exists according to server (may be already completed)
  case notFound // = 0

  /// Activity was explicitly cancelled
  case cancelled // = 1

  /// Activity timed out
  case timedOut // = 2

  /// Core is shutting down and the graceful timeout has elapsed
  case workerShutdown // = 3

  /// Activity was paused
  case paused // = 4

  /// Activity was reset
  case reset // = 5
  case UNRECOGNIZED(Int)

  package init() {
    self = .notFound
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notFound
    case 1: self = .cancelled
    case 2: self = .timedOut
    case 3: self = .workerShutdown
    case 4: self = .paused
    case 5: self = .reset
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .notFound: return 0
    case .cancelled: return 1
    case .timedOut: return 2
    case .workerShutdown: return 3
    case .paused: return 4
    case .reset: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_ActivityTask_ActivityCancelReason] = [
    .notFound,
    .cancelled,
    .timedOut,
    .workerShutdown,
    .paused,
    .reset,
  ]

}

package struct Coresdk_ActivityTask_ActivityTask: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this task
  package var taskToken: Data = Data()

  package var variant: Coresdk_ActivityTask_ActivityTask.OneOf_Variant? = nil

  /// Start activity execution.
  package var start: Coresdk_ActivityTask_Start {
    get {
      if case .start(let v)? = variant {return v}
      return Coresdk_ActivityTask_Start()
    }
    set {variant = .start(newValue)}
  }

  /// Attempt to cancel activity execution.
  package var cancel: Coresdk_ActivityTask_Cancel {
    get {
      if case .cancel(let v)? = variant {return v}
      return Coresdk_ActivityTask_Cancel()
    }
    set {variant = .cancel(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    /// Start activity execution.
    case start(Coresdk_ActivityTask_Start)
    /// Attempt to cancel activity execution.
    case cancel(Coresdk_ActivityTask_Cancel)

  }

  package init() {}
}

/// Begin executing an activity
package struct Coresdk_ActivityTask_Start: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace the workflow lives in
  package var workflowNamespace: String {
    get {return _storage._workflowNamespace}
    set {_uniqueStorage()._workflowNamespace = newValue}
  }

  /// The workflow's type name or function identifier
  package var workflowType: String {
    get {return _storage._workflowType}
    set {_uniqueStorage()._workflowType = newValue}
  }

  /// The workflow execution which requested this activity
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return _storage._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

  /// The activity's ID
  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  /// The activity's type name or function identifier
  package var activityType: String {
    get {return _storage._activityType}
    set {_uniqueStorage()._activityType = newValue}
  }

  package var headerFields: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headerFields}
    set {_uniqueStorage()._headerFields = newValue}
  }

  /// Arguments to the activity
  package var input: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  /// The last details that were recorded by a heartbeat when this task was generated
  package var heartbeatDetails: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._heartbeatDetails}
    set {_uniqueStorage()._heartbeatDetails = newValue}
  }

  /// When the task was *first* scheduled
  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return _storage._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

  /// When this current attempt at the task was scheduled
  package var currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._currentAttemptScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._currentAttemptScheduledTime = newValue}
  }
  /// Returns true if `currentAttemptScheduledTime` has been explicitly set.
  package var hasCurrentAttemptScheduledTime: Bool {return _storage._currentAttemptScheduledTime != nil}
  /// Clears the value of `currentAttemptScheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentAttemptScheduledTime() {_uniqueStorage()._currentAttemptScheduledTime = nil}

  /// When this attempt was started, which is to say when core received it by polling.
  package var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  package var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  package var attempt: UInt32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// Timeout from the first schedule time to completion
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Timeout from starting an attempt to reporting its result
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// If set a heartbeat must be reported within this interval
  package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._heartbeatTimeout = newValue}
  }
  /// Returns true if `heartbeatTimeout` has been explicitly set.
  package var hasHeartbeatTimeout: Bool {return _storage._heartbeatTimeout != nil}
  /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

  /// This is an actual retry policy the service uses. It can be different from the one provided
  /// (or not) during activity scheduling as the service can override the provided one in case its
  /// values are not specified or exceed configured system limits.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Priority of this activity. Local activities will always have this field set to the default.
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  /// Set to true if this is a local activity. Note that heartbeating does not apply to local
  /// activities.
  package var isLocal: Bool {
    get {return _storage._isLocal}
    set {_uniqueStorage()._isLocal = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Attempt to cancel a running activity
package struct Coresdk_ActivityTask_Cancel: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Primary cancellation reason
  package var reason: Coresdk_ActivityTask_ActivityCancelReason = .notFound

  /// Activity cancellation details, surfaces all cancellation reasons.
  package var details: Coresdk_ActivityTask_ActivityCancellationDetails {
    get {return _details ?? Coresdk_ActivityTask_ActivityCancellationDetails()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Coresdk_ActivityTask_ActivityCancellationDetails? = nil
}

package struct Coresdk_ActivityTask_ActivityCancellationDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var isNotFound: Bool = false

  package var isCancelled: Bool = false

  package var isPaused: Bool = false

  package var isTimedOut: Bool = false

  package var isWorkerShutdown: Bool = false

  package var isReset: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.activity_task"

extension Coresdk_ActivityTask_ActivityCancelReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_FOUND\0\u{1}CANCELLED\0\u{1}TIMED_OUT\0\u{1}WORKER_SHUTDOWN\0\u{1}PAUSED\0\u{1}RESET\0")
}

extension Coresdk_ActivityTask_ActivityTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{2}\u{2}start\0\u{1}cancel\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 3: try {
        var v: Coresdk_ActivityTask_Start?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .start(v)
        }
      }()
      case 4: try {
        var v: Coresdk_ActivityTask_Cancel?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancel(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    switch self.variant {
    case .start?: try {
      guard case .start(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cancel?: try {
      guard case .cancel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityTask_ActivityTask, rhs: Coresdk_ActivityTask_ActivityTask) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityTask_Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Start"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_namespace\0\u{3}workflow_type\0\u{3}workflow_execution\0\u{3}activity_id\0\u{3}activity_type\0\u{3}header_fields\0\u{1}input\0\u{3}heartbeat_details\0\u{3}scheduled_time\0\u{3}current_attempt_scheduled_time\0\u{3}started_time\0\u{1}attempt\0\u{3}schedule_to_close_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}is_local\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _workflowNamespace: String = String()
    var _workflowType: String = String()
    var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _activityID: String = String()
    var _activityType: String = String()
    var _headerFields: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _input: [Temporal_Api_Common_V1_Payload] = []
    var _heartbeatDetails: [Temporal_Api_Common_V1_Payload] = []
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: UInt32 = 0
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil
    var _isLocal: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowNamespace = source._workflowNamespace
      _workflowType = source._workflowType
      _workflowExecution = source._workflowExecution
      _activityID = source._activityID
      _activityType = source._activityType
      _headerFields = source._headerFields
      _input = source._input
      _heartbeatDetails = source._heartbeatDetails
      _scheduledTime = source._scheduledTime
      _currentAttemptScheduledTime = source._currentAttemptScheduledTime
      _startedTime = source._startedTime
      _attempt = source._attempt
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _priority = source._priority
      _isLocal = source._isLocal
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowNamespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headerFields) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._input) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._heartbeatDetails) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._currentAttemptScheduledTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._attempt) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isLocal) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowNamespace, fieldNumber: 1)
      }
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 2)
      }
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 4)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 5)
      }
      if !_storage._headerFields.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headerFields, fieldNumber: 6)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._input, fieldNumber: 7)
      }
      if !_storage._heartbeatDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._heartbeatDetails, fieldNumber: 8)
      }
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._currentAttemptScheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._attempt, fieldNumber: 12)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._isLocal != false {
        try visitor.visitSingularBoolField(value: _storage._isLocal, fieldNumber: 17)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityTask_Start, rhs: Coresdk_ActivityTask_Start) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowNamespace != rhs_storage._workflowNamespace {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._headerFields != rhs_storage._headerFields {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._currentAttemptScheduledTime != rhs_storage._currentAttemptScheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._isLocal != rhs_storage._isLocal {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityTask_Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancel"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.reason != .notFound {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityTask_Cancel, rhs: Coresdk_ActivityTask_Cancel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityTask_ActivityCancellationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityCancellationDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_not_found\0\u{3}is_cancelled\0\u{3}is_paused\0\u{3}is_timed_out\0\u{3}is_worker_shutdown\0\u{3}is_reset\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isNotFound) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isCancelled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isPaused) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isTimedOut) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWorkerShutdown) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isReset) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isNotFound != false {
      try visitor.visitSingularBoolField(value: self.isNotFound, fieldNumber: 1)
    }
    if self.isCancelled != false {
      try visitor.visitSingularBoolField(value: self.isCancelled, fieldNumber: 2)
    }
    if self.isPaused != false {
      try visitor.visitSingularBoolField(value: self.isPaused, fieldNumber: 3)
    }
    if self.isTimedOut != false {
      try visitor.visitSingularBoolField(value: self.isTimedOut, fieldNumber: 4)
    }
    if self.isWorkerShutdown != false {
      try visitor.visitSingularBoolField(value: self.isWorkerShutdown, fieldNumber: 5)
    }
    if self.isReset != false {
      try visitor.visitSingularBoolField(value: self.isReset, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityTask_ActivityCancellationDetails, rhs: Coresdk_ActivityTask_ActivityCancellationDetails) -> Bool {
    if lhs.isNotFound != rhs.isNotFound {return false}
    if lhs.isCancelled != rhs.isCancelled {return false}
    if lhs.isPaused != rhs.isPaused {return false}
    if lhs.isTimedOut != rhs.isTimedOut {return false}
    if lhs.isWorkerShutdown != rhs.isWorkerShutdown {return false}
    if lhs.isReset != rhs.isReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
