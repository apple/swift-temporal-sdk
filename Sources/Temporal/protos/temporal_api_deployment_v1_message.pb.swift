// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/deployment/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Worker Deployment options set in SDK that need to be sent to server in every poll.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package struct Temporal_Api_Deployment_V1_WorkerDeploymentOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Required. Worker Deployment name.
  package var deploymentName: String = String()

  /// The Build ID of the worker. Required when `worker_versioning_mode==VERSIONED`, in which case,
  /// the worker will be part of a Deployment Version.
  package var buildID: String = String()

  /// Required. Versioning Mode for this worker. Must be the same for all workers with the
  /// same `deployment_name` and `build_id` combination, across all Task Queues.
  /// When `worker_versioning_mode==VERSIONED`, the worker will be part of a Deployment Version.
  package var workerVersioningMode: Temporal_Api_Enums_V1_WorkerVersioningMode = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// `Deployment` identifies a deployment of Temporal workers. The combination of deployment series
/// name + build ID serves as the identifier. User can use `WorkerDeploymentOptions` in their worker
/// programs to specify these values.
/// Deprecated.
package struct Temporal_Api_Deployment_V1_Deployment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Different versions of the same worker service/application are related together by having a
  /// shared series name.
  /// Out of all deployments of a series, one can be designated as the current deployment, which
  /// receives new workflow executions and new tasks of workflows with
  /// `VERSIONING_BEHAVIOR_AUTO_UPGRADE` versioning behavior.
  package var seriesName: String = String()

  /// Build ID changes with each version of the worker when the worker program code and/or config
  /// changes.
  package var buildID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// `DeploymentInfo` holds information about a deployment. Deployment information is tracked
/// automatically by server as soon as the first poll from that deployment reaches the server. There
/// can be multiple task queue workers in a single deployment which are listed in this message.
/// Deprecated.
package struct Temporal_Api_Deployment_V1_DeploymentInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  package var taskQueueInfos: [Temporal_Api_Deployment_V1_DeploymentInfo.TaskQueueInfo] = []

  /// A user-defined set of key-values. Can be updated as part of write operations to the
  /// deployment, such as `SetCurrentDeployment`.
  package var metadata: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  /// If this deployment is the current deployment of its deployment series.
  package var isCurrent: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct TaskQueueInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var name: String = String()

    package var type: Temporal_Api_Enums_V1_TaskQueueType = .unspecified

    /// When server saw the first poller for this task queue in this deployment.
    package var firstPollerTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _firstPollerTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_firstPollerTime = newValue}
    }
    /// Returns true if `firstPollerTime` has been explicitly set.
    package var hasFirstPollerTime: Bool {return self._firstPollerTime != nil}
    /// Clears the value of `firstPollerTime`. Subsequent reads from it will return its default value.
    package mutating func clearFirstPollerTime() {self._firstPollerTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _firstPollerTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Used as part of Deployment write APIs to update metadata attached to a deployment.
/// Deprecated.
package struct Temporal_Api_Deployment_V1_UpdateDeploymentMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var upsertEntries: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  /// List of keys to remove from the metadata.
  package var removeEntries: [String] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// DeploymentListInfo is an abbreviated set of fields from DeploymentInfo that's returned in
/// ListDeployments.
/// Deprecated.
package struct Temporal_Api_Deployment_V1_DeploymentListInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  /// If this deployment is the current deployment of its deployment series.
  package var isCurrent: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A Worker Deployment Version (Version, for short) represents all workers of the same 
/// code and config within a Deployment. Workers of the same Version are expected to 
/// behave exactly the same so when executions move between them there are no 
/// non-determinism issues.
/// Worker Deployment Versions are created in Temporal server automatically when 
/// their first poller arrives to the server.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package struct Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The status of the Worker Deployment Version.
  package var status: Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Required.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return _storage._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

  package var deploymentName: String {
    get {return _storage._deploymentName}
    set {_uniqueStorage()._deploymentName = newValue}
  }

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  /// Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
  package var routingChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._routingChangedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._routingChangedTime = newValue}
  }
  /// Returns true if `routingChangedTime` has been explicitly set.
  package var hasRoutingChangedTime: Bool {return _storage._routingChangedTime != nil}
  /// Clears the value of `routingChangedTime`. Subsequent reads from it will return its default value.
  package mutating func clearRoutingChangedTime() {_uniqueStorage()._routingChangedTime = nil}

  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
  /// Unset if not current.
  package var currentSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._currentSinceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._currentSinceTime = newValue}
  }
  /// Returns true if `currentSinceTime` has been explicitly set.
  package var hasCurrentSinceTime: Bool {return _storage._currentSinceTime != nil}
  /// Clears the value of `currentSinceTime`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentSinceTime() {_uniqueStorage()._currentSinceTime = nil}

  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
  /// Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
  package var rampingSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._rampingSinceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._rampingSinceTime = newValue}
  }
  /// Returns true if `rampingSinceTime` has been explicitly set.
  package var hasRampingSinceTime: Bool {return _storage._rampingSinceTime != nil}
  /// Clears the value of `rampingSinceTime`. Subsequent reads from it will return its default value.
  package mutating func clearRampingSinceTime() {_uniqueStorage()._rampingSinceTime = nil}

  /// Timestamp when this version first became current or ramping.
  package var firstActivationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._firstActivationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._firstActivationTime = newValue}
  }
  /// Returns true if `firstActivationTime` has been explicitly set.
  package var hasFirstActivationTime: Bool {return _storage._firstActivationTime != nil}
  /// Clears the value of `firstActivationTime`. Subsequent reads from it will return its default value.
  package mutating func clearFirstActivationTime() {_uniqueStorage()._firstActivationTime = nil}

  /// Timestamp when this version last stopped being current or ramping.
  package var lastDeactivationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastDeactivationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastDeactivationTime = newValue}
  }
  /// Returns true if `lastDeactivationTime` has been explicitly set.
  package var hasLastDeactivationTime: Bool {return _storage._lastDeactivationTime != nil}
  /// Clears the value of `lastDeactivationTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastDeactivationTime() {_uniqueStorage()._lastDeactivationTime = nil}

  /// Range: [0, 100]. Must be zero if the version is not ramping (i.e. `ramping_since_time` is nil).
  /// Can be in the range [0, 100] if the version is ramping.
  package var rampPercentage: Float {
    get {return _storage._rampPercentage}
    set {_uniqueStorage()._rampPercentage = newValue}
  }

  /// All the Task Queues that have ever polled from this Deployment version.
  /// Deprecated. Use `version_task_queues` in DescribeWorkerDeploymentVersionResponse instead.
  package var taskQueueInfos: [Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.VersionTaskQueueInfo] {
    get {return _storage._taskQueueInfos}
    set {_uniqueStorage()._taskQueueInfos = newValue}
  }

  /// Helps user determine when it is safe to decommission the workers of this
  /// Version. Not present when version is current or ramping.
  /// Current limitations:
  /// - Not supported for Unversioned mode.
  /// - Periodically refreshed, may have delays up to few minutes (consult the
  ///   last_checked_time value).
  /// - Refreshed only when version is not current or ramping AND the status is not
  ///   "drained" yet.
  /// - Once the status is changed to "drained", it is not changed until the Version
  ///   becomes Current or Ramping again, at which time the drainage info is cleared.
  ///   This means if the Version is "drained" but new workflows are sent to it via
  ///   Pinned Versioning Override, the status does not account for those Pinned-override
  ///   executions and remains "drained".
  package var drainageInfo: Temporal_Api_Deployment_V1_VersionDrainageInfo {
    get {return _storage._drainageInfo ?? Temporal_Api_Deployment_V1_VersionDrainageInfo()}
    set {_uniqueStorage()._drainageInfo = newValue}
  }
  /// Returns true if `drainageInfo` has been explicitly set.
  package var hasDrainageInfo: Bool {return _storage._drainageInfo != nil}
  /// Clears the value of `drainageInfo`. Subsequent reads from it will return its default value.
  package mutating func clearDrainageInfo() {_uniqueStorage()._drainageInfo = nil}

  /// Arbitrary user-provided metadata attached to this version.
  package var metadata: Temporal_Api_Deployment_V1_VersionMetadata {
    get {return _storage._metadata ?? Temporal_Api_Deployment_V1_VersionMetadata()}
    set {_uniqueStorage()._metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  package var hasMetadata: Bool {return _storage._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  package mutating func clearMetadata() {_uniqueStorage()._metadata = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct VersionTaskQueueInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var name: String = String()

    package var type: Temporal_Api_Enums_V1_TaskQueueType = .unspecified

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Information about workflow drainage to help the user determine when it is safe
/// to decommission a Version. Not present while version is current or ramping.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package struct Temporal_Api_Deployment_V1_VersionDrainageInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Set to DRAINING when the version first stops accepting new executions (is no longer current or ramping).
  /// Set to DRAINED when no more open pinned workflows exist on this version.
  package var status: Temporal_Api_Enums_V1_VersionDrainageStatus = .unspecified

  /// Last time the drainage status changed.
  package var lastChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastChangedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastChangedTime = newValue}
  }
  /// Returns true if `lastChangedTime` has been explicitly set.
  package var hasLastChangedTime: Bool {return self._lastChangedTime != nil}
  /// Clears the value of `lastChangedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastChangedTime() {self._lastChangedTime = nil}

  /// Last time the system checked for drainage of this version.
  package var lastCheckedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastCheckedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastCheckedTime = newValue}
  }
  /// Returns true if `lastCheckedTime` has been explicitly set.
  package var hasLastCheckedTime: Bool {return self._lastCheckedTime != nil}
  /// Clears the value of `lastCheckedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastCheckedTime() {self._lastCheckedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastCheckedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A Worker Deployment (Deployment, for short) represents all workers serving 
/// a shared set of Task Queues. Typically, a Deployment represents one service or 
/// application.
/// A Deployment contains multiple Deployment Versions, each representing a different 
/// version of workers. (see documentation of WorkerDeploymentVersionInfo)
/// Deployment records are created in Temporal server automatically when their
/// first poller arrives to the server.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package struct Temporal_Api_Deployment_V1_WorkerDeploymentInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies a Worker Deployment. Must be unique within the namespace.
  package var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// Deployment Versions that are currently tracked in this Deployment. A DeploymentVersion will be
  /// cleaned up automatically if all the following conditions meet:
  /// - It does not receive new executions (is not current or ramping)
  /// - It has no active pollers (see WorkerDeploymentVersionInfo.pollers_status) 
  /// - It is drained (see WorkerDeploymentVersionInfo.drainage_status) 
  package var versionSummaries: [Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary] {
    get {return _storage._versionSummaries}
    set {_uniqueStorage()._versionSummaries = newValue}
  }

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return _storage._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

  package var routingConfig: Temporal_Api_Deployment_V1_RoutingConfig {
    get {return _storage._routingConfig ?? Temporal_Api_Deployment_V1_RoutingConfig()}
    set {_uniqueStorage()._routingConfig = newValue}
  }
  /// Returns true if `routingConfig` has been explicitly set.
  package var hasRoutingConfig: Bool {return _storage._routingConfig != nil}
  /// Clears the value of `routingConfig`. Subsequent reads from it will return its default value.
  package mutating func clearRoutingConfig() {_uniqueStorage()._routingConfig = nil}

  /// Identity of the last client who modified the configuration of this Deployment. Set to the
  /// `identity` value sent by APIs such as `SetWorkerDeploymentCurrentVersion` and
  /// `SetWorkerDeploymentRampingVersion`.
  package var lastModifierIdentity: String {
    get {return _storage._lastModifierIdentity}
    set {_uniqueStorage()._lastModifierIdentity = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct WorkerDeploymentVersionSummary: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var version: String {
      get {return _storage._version}
      set {_uniqueStorage()._version = newValue}
    }

    /// The status of the Worker Deployment Version.
    package var status: Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus {
      get {return _storage._status}
      set {_uniqueStorage()._status = newValue}
    }

    /// Required.
    package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
      get {return _storage._deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
      set {_uniqueStorage()._deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    package var hasDeploymentVersion: Bool {return _storage._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    package mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

    package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createTime = newValue}
    }
    /// Returns true if `createTime` has been explicitly set.
    package var hasCreateTime: Bool {return _storage._createTime != nil}
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

    /// Deprecated. Use `drainage_info` instead.
    package var drainageStatus: Temporal_Api_Enums_V1_VersionDrainageStatus {
      get {return _storage._drainageStatus}
      set {_uniqueStorage()._drainageStatus = newValue}
    }

    /// Information about workflow drainage to help the user determine when it is safe
    /// to decommission a Version. Not present while version is current or ramping
    package var drainageInfo: Temporal_Api_Deployment_V1_VersionDrainageInfo {
      get {return _storage._drainageInfo ?? Temporal_Api_Deployment_V1_VersionDrainageInfo()}
      set {_uniqueStorage()._drainageInfo = newValue}
    }
    /// Returns true if `drainageInfo` has been explicitly set.
    package var hasDrainageInfo: Bool {return _storage._drainageInfo != nil}
    /// Clears the value of `drainageInfo`. Subsequent reads from it will return its default value.
    package mutating func clearDrainageInfo() {_uniqueStorage()._drainageInfo = nil}

    /// Unset if not current.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
    package var currentSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._currentSinceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._currentSinceTime = newValue}
    }
    /// Returns true if `currentSinceTime` has been explicitly set.
    package var hasCurrentSinceTime: Bool {return _storage._currentSinceTime != nil}
    /// Clears the value of `currentSinceTime`. Subsequent reads from it will return its default value.
    package mutating func clearCurrentSinceTime() {_uniqueStorage()._currentSinceTime = nil}

    /// Unset if not ramping. Updated when the version first starts ramping, not on each ramp change.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: 'Since' captures the field semantics despite being a preposition. --)
    package var rampingSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._rampingSinceTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._rampingSinceTime = newValue}
    }
    /// Returns true if `rampingSinceTime` has been explicitly set.
    package var hasRampingSinceTime: Bool {return _storage._rampingSinceTime != nil}
    /// Clears the value of `rampingSinceTime`. Subsequent reads from it will return its default value.
    package mutating func clearRampingSinceTime() {_uniqueStorage()._rampingSinceTime = nil}

    /// Last time `current_since_time`, `ramping_since_time, or `ramp_percentage` of this version changed.
    package var routingUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._routingUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._routingUpdateTime = newValue}
    }
    /// Returns true if `routingUpdateTime` has been explicitly set.
    package var hasRoutingUpdateTime: Bool {return _storage._routingUpdateTime != nil}
    /// Clears the value of `routingUpdateTime`. Subsequent reads from it will return its default value.
    package mutating func clearRoutingUpdateTime() {_uniqueStorage()._routingUpdateTime = nil}

    /// Timestamp when this version first became current or ramping.
    package var firstActivationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._firstActivationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._firstActivationTime = newValue}
    }
    /// Returns true if `firstActivationTime` has been explicitly set.
    package var hasFirstActivationTime: Bool {return _storage._firstActivationTime != nil}
    /// Clears the value of `firstActivationTime`. Subsequent reads from it will return its default value.
    package mutating func clearFirstActivationTime() {_uniqueStorage()._firstActivationTime = nil}

    /// Timestamp when this version last stopped being current or ramping.
    package var lastDeactivationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._lastDeactivationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastDeactivationTime = newValue}
    }
    /// Returns true if `lastDeactivationTime` has been explicitly set.
    package var hasLastDeactivationTime: Bool {return _storage._lastDeactivationTime != nil}
    /// Clears the value of `lastDeactivationTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastDeactivationTime() {_uniqueStorage()._lastDeactivationTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A Worker Deployment Version (Version, for short) represents a
/// version of workers within a Worker Deployment. (see documentation of WorkerDeploymentVersionInfo)
/// Version records are created in Temporal server automatically when their
/// first poller arrives to the server.
/// Experimental. Worker Deployment Versions are experimental and might significantly change in the future.
package struct Temporal_Api_Deployment_V1_WorkerDeploymentVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this Version within the Deployment it is a part of.
  /// Not necessarily unique within the namespace.
  /// The combination of `deployment_name` and `build_id` uniquely identifies this
  /// Version within the namespace, because Deployment names are unique within a namespace.
  package var buildID: String = String()

  /// Identifies the Worker Deployment this Version is part of.
  package var deploymentName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Deployment_V1_VersionMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Arbitrary key-values.
  package var entries: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Deployment_V1_RoutingConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies which Deployment Version should receive new workflow executions and tasks of
  /// existing unversioned or AutoUpgrade workflows.
  /// Nil value means no Version in this Deployment (except Ramping Version, if present) receives traffic other than tasks of previously Pinned workflows. In absence of a Current Version, remaining traffic after any ramp (if set)  goes to unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.). 
  /// Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
  /// is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
  package var currentDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _currentDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_currentDeploymentVersion = newValue}
  }
  /// Returns true if `currentDeploymentVersion` has been explicitly set.
  package var hasCurrentDeploymentVersion: Bool {return self._currentDeploymentVersion != nil}
  /// Clears the value of `currentDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentDeploymentVersion() {self._currentDeploymentVersion = nil}

  /// Deprecated. Use `current_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var currentVersion: String = String()

  /// When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
  /// Must always be different from `current_deployment_version` unless both are nil.
  /// Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
  /// Note that it is possible to ramp from one Version to another Version, or from unversioned
  /// workers to a particular Version, or from a particular Version to unversioned workers.
  package var rampingDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _rampingDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_rampingDeploymentVersion = newValue}
  }
  /// Returns true if `rampingDeploymentVersion` has been explicitly set.
  package var hasRampingDeploymentVersion: Bool {return self._rampingDeploymentVersion != nil}
  /// Clears the value of `rampingDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearRampingDeploymentVersion() {self._rampingDeploymentVersion = nil}

  /// Deprecated. Use `ramping_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var rampingVersion: String = String()

  /// Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
  /// Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
  /// not yet "promoted" to be the Current Version, likely due to pending validations.
  /// A 0% value means the Ramping Version is receiving no traffic.
  package var rampingVersionPercentage: Float = 0

  /// Last time current version was changed.
  package var currentVersionChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _currentVersionChangedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_currentVersionChangedTime = newValue}
  }
  /// Returns true if `currentVersionChangedTime` has been explicitly set.
  package var hasCurrentVersionChangedTime: Bool {return self._currentVersionChangedTime != nil}
  /// Clears the value of `currentVersionChangedTime`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentVersionChangedTime() {self._currentVersionChangedTime = nil}

  /// Last time ramping version was changed. Not updated if only the ramp percentage changes.
  package var rampingVersionChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _rampingVersionChangedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_rampingVersionChangedTime = newValue}
  }
  /// Returns true if `rampingVersionChangedTime` has been explicitly set.
  package var hasRampingVersionChangedTime: Bool {return self._rampingVersionChangedTime != nil}
  /// Clears the value of `rampingVersionChangedTime`. Subsequent reads from it will return its default value.
  package mutating func clearRampingVersionChangedTime() {self._rampingVersionChangedTime = nil}

  /// Last time ramping version percentage was changed.
  /// If ramping version is changed, this is also updated, even if the percentage stays the same.
  package var rampingVersionPercentageChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _rampingVersionPercentageChangedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_rampingVersionPercentageChangedTime = newValue}
  }
  /// Returns true if `rampingVersionPercentageChangedTime` has been explicitly set.
  package var hasRampingVersionPercentageChangedTime: Bool {return self._rampingVersionPercentageChangedTime != nil}
  /// Clears the value of `rampingVersionPercentageChangedTime`. Subsequent reads from it will return its default value.
  package mutating func clearRampingVersionPercentageChangedTime() {self._rampingVersionPercentageChangedTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _currentDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
  fileprivate var _rampingDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
  fileprivate var _currentVersionChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _rampingVersionChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _rampingVersionPercentageChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.deployment.v1"

extension Temporal_Api_Deployment_V1_WorkerDeploymentOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerDeploymentOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deployment_name\0\u{3}build_id\0\u{3}worker_versioning_mode\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.workerVersioningMode) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 1)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 2)
    }
    if self.workerVersioningMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.workerVersioningMode, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentOptions, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentOptions) -> Bool {
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.workerVersioningMode != rhs.workerVersioningMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_Deployment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Deployment"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}series_name\0\u{3}build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.seriesName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.seriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesName, fieldNumber: 1)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_Deployment, rhs: Temporal_Api_Deployment_V1_Deployment) -> Bool {
    if lhs.seriesName != rhs.seriesName {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_DeploymentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeploymentInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deployment\0\u{3}create_time\0\u{3}task_queue_infos\0\u{1}metadata\0\u{3}is_current\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.taskQueueInfos) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.metadata) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isCurrent) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.taskQueueInfos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskQueueInfos, fieldNumber: 3)
    }
    if !self.metadata.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.metadata, fieldNumber: 4)
    }
    if self.isCurrent != false {
      try visitor.visitSingularBoolField(value: self.isCurrent, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_DeploymentInfo, rhs: Temporal_Api_Deployment_V1_DeploymentInfo) -> Bool {
    if lhs._deployment != rhs._deployment {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.taskQueueInfos != rhs.taskQueueInfos {return false}
    if lhs.metadata != rhs.metadata {return false}
    if lhs.isCurrent != rhs.isCurrent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_DeploymentInfo.TaskQueueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Deployment_V1_DeploymentInfo.protoMessageName + ".TaskQueueInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0\u{3}first_poller_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._firstPollerTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._firstPollerTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_DeploymentInfo.TaskQueueInfo, rhs: Temporal_Api_Deployment_V1_DeploymentInfo.TaskQueueInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._firstPollerTime != rhs._firstPollerTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_UpdateDeploymentMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateDeploymentMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upsert_entries\0\u{3}remove_entries\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.upsertEntries) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.removeEntries) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.upsertEntries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.upsertEntries, fieldNumber: 1)
    }
    if !self.removeEntries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removeEntries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_UpdateDeploymentMetadata, rhs: Temporal_Api_Deployment_V1_UpdateDeploymentMetadata) -> Bool {
    if lhs.upsertEntries != rhs.upsertEntries {return false}
    if lhs.removeEntries != rhs.removeEntries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_DeploymentListInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeploymentListInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deployment\0\u{3}create_time\0\u{3}is_current\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isCurrent) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isCurrent != false {
      try visitor.visitSingularBoolField(value: self.isCurrent, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_DeploymentListInfo, rhs: Temporal_Api_Deployment_V1_DeploymentListInfo) -> Bool {
    if lhs._deployment != rhs._deployment {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.isCurrent != rhs.isCurrent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerDeploymentVersionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}deployment_name\0\u{3}create_time\0\u{3}routing_changed_time\0\u{3}current_since_time\0\u{3}ramping_since_time\0\u{3}ramp_percentage\0\u{3}task_queue_infos\0\u{3}drainage_info\0\u{1}metadata\0\u{3}deployment_version\0\u{3}first_activation_time\0\u{3}last_deactivation_time\0\u{1}status\0")

  fileprivate class _StorageClass {
    var _version: String = String()
    var _status: Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus = .unspecified
    var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _deploymentName: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routingChangedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rampingSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _firstActivationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastDeactivationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rampPercentage: Float = 0
    var _taskQueueInfos: [Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.VersionTaskQueueInfo] = []
    var _drainageInfo: Temporal_Api_Deployment_V1_VersionDrainageInfo? = nil
    var _metadata: Temporal_Api_Deployment_V1_VersionMetadata? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _status = source._status
      _deploymentVersion = source._deploymentVersion
      _deploymentName = source._deploymentName
      _createTime = source._createTime
      _routingChangedTime = source._routingChangedTime
      _currentSinceTime = source._currentSinceTime
      _rampingSinceTime = source._rampingSinceTime
      _firstActivationTime = source._firstActivationTime
      _lastDeactivationTime = source._lastDeactivationTime
      _rampPercentage = source._rampPercentage
      _taskQueueInfos = source._taskQueueInfos
      _drainageInfo = source._drainageInfo
      _metadata = source._metadata
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._deploymentName) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._routingChangedTime) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._currentSinceTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rampingSinceTime) }()
        case 7: try { try decoder.decodeSingularFloatField(value: &_storage._rampPercentage) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._taskQueueInfos) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._drainageInfo) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._metadata) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._firstActivationTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeactivationTime) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      if !_storage._deploymentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deploymentName, fieldNumber: 2)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._routingChangedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._currentSinceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._rampingSinceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._rampPercentage.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._rampPercentage, fieldNumber: 7)
      }
      if !_storage._taskQueueInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._taskQueueInfos, fieldNumber: 8)
      }
      try { if let v = _storage._drainageInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._metadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._firstActivationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastDeactivationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        if _storage._deploymentName != rhs_storage._deploymentName {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._routingChangedTime != rhs_storage._routingChangedTime {return false}
        if _storage._currentSinceTime != rhs_storage._currentSinceTime {return false}
        if _storage._rampingSinceTime != rhs_storage._rampingSinceTime {return false}
        if _storage._firstActivationTime != rhs_storage._firstActivationTime {return false}
        if _storage._lastDeactivationTime != rhs_storage._lastDeactivationTime {return false}
        if _storage._rampPercentage != rhs_storage._rampPercentage {return false}
        if _storage._taskQueueInfos != rhs_storage._taskQueueInfos {return false}
        if _storage._drainageInfo != rhs_storage._drainageInfo {return false}
        if _storage._metadata != rhs_storage._metadata {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.VersionTaskQueueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.protoMessageName + ".VersionTaskQueueInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.VersionTaskQueueInfo, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo.VersionTaskQueueInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_VersionDrainageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".VersionDrainageInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status\0\u{3}last_changed_time\0\u{3}last_checked_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastChangedTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastCheckedTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 1)
    }
    try { if let v = self._lastChangedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._lastCheckedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_VersionDrainageInfo, rhs: Temporal_Api_Deployment_V1_VersionDrainageInfo) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs._lastChangedTime != rhs._lastChangedTime {return false}
    if lhs._lastCheckedTime != rhs._lastCheckedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_WorkerDeploymentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerDeploymentInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}version_summaries\0\u{3}create_time\0\u{3}routing_config\0\u{3}last_modifier_identity\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _versionSummaries: [Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary] = []
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routingConfig: Temporal_Api_Deployment_V1_RoutingConfig? = nil
    var _lastModifierIdentity: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _versionSummaries = source._versionSummaries
      _createTime = source._createTime
      _routingConfig = source._routingConfig
      _lastModifierIdentity = source._lastModifierIdentity
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._versionSummaries) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._routingConfig) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastModifierIdentity) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._versionSummaries.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._versionSummaries, fieldNumber: 2)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._routingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._lastModifierIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastModifierIdentity, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentInfo, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._versionSummaries != rhs_storage._versionSummaries {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._routingConfig != rhs_storage._routingConfig {return false}
        if _storage._lastModifierIdentity != rhs_storage._lastModifierIdentity {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Deployment_V1_WorkerDeploymentInfo.protoMessageName + ".WorkerDeploymentVersionSummary"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}create_time\0\u{3}drainage_status\0\u{3}deployment_version\0\u{3}drainage_info\0\u{3}current_since_time\0\u{3}ramping_since_time\0\u{3}routing_update_time\0\u{3}first_activation_time\0\u{3}last_deactivation_time\0\u{1}status\0")

  fileprivate class _StorageClass {
    var _version: String = String()
    var _status: Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus = .unspecified
    var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _drainageStatus: Temporal_Api_Enums_V1_VersionDrainageStatus = .unspecified
    var _drainageInfo: Temporal_Api_Deployment_V1_VersionDrainageInfo? = nil
    var _currentSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _rampingSinceTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routingUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _firstActivationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastDeactivationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _status = source._status
      _deploymentVersion = source._deploymentVersion
      _createTime = source._createTime
      _drainageStatus = source._drainageStatus
      _drainageInfo = source._drainageInfo
      _currentSinceTime = source._currentSinceTime
      _rampingSinceTime = source._rampingSinceTime
      _routingUpdateTime = source._routingUpdateTime
      _firstActivationTime = source._firstActivationTime
      _lastDeactivationTime = source._lastDeactivationTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._drainageStatus) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._drainageInfo) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._currentSinceTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._rampingSinceTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._routingUpdateTime) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._firstActivationTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeactivationTime) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 1)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._drainageStatus != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._drainageStatus, fieldNumber: 3)
      }
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._drainageInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._currentSinceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._rampingSinceTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._routingUpdateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._firstActivationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastDeactivationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._drainageStatus != rhs_storage._drainageStatus {return false}
        if _storage._drainageInfo != rhs_storage._drainageInfo {return false}
        if _storage._currentSinceTime != rhs_storage._currentSinceTime {return false}
        if _storage._rampingSinceTime != rhs_storage._rampingSinceTime {return false}
        if _storage._routingUpdateTime != rhs_storage._routingUpdateTime {return false}
        if _storage._firstActivationTime != rhs_storage._firstActivationTime {return false}
        if _storage._lastDeactivationTime != rhs_storage._lastDeactivationTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_WorkerDeploymentVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerDeploymentVersion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id\0\u{3}deployment_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersion, rhs: Temporal_Api_Deployment_V1_WorkerDeploymentVersion) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_VersionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".VersionMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}entries\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.entries) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_VersionMetadata, rhs: Temporal_Api_Deployment_V1_VersionMetadata) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Deployment_V1_RoutingConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RoutingConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_version\0\u{3}ramping_version\0\u{3}ramping_version_percentage\0\u{3}current_version_changed_time\0\u{3}ramping_version_changed_time\0\u{3}ramping_version_percentage_changed_time\0\u{3}current_deployment_version\0\u{4}\u{2}ramping_deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currentVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rampingVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.rampingVersionPercentage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentVersionChangedTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._rampingVersionChangedTime) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._rampingVersionPercentageChangedTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._rampingDeploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.currentVersion, fieldNumber: 1)
    }
    if !self.rampingVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.rampingVersion, fieldNumber: 2)
    }
    if self.rampingVersionPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rampingVersionPercentage, fieldNumber: 3)
    }
    try { if let v = self._currentVersionChangedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._rampingVersionChangedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._rampingVersionPercentageChangedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._currentDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._rampingDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Deployment_V1_RoutingConfig, rhs: Temporal_Api_Deployment_V1_RoutingConfig) -> Bool {
    if lhs._currentDeploymentVersion != rhs._currentDeploymentVersion {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs._rampingDeploymentVersion != rhs._rampingDeploymentVersion {return false}
    if lhs.rampingVersion != rhs.rampingVersion {return false}
    if lhs.rampingVersionPercentage != rhs.rampingVersionPercentage {return false}
    if lhs._currentVersionChangedTime != rhs._currentVersionChangedTime {return false}
    if lhs._rampingVersionChangedTime != rhs._rampingVersionChangedTime {return false}
    if lhs._rampingVersionPercentageChangedTime != rhs._rampingVersionPercentageChangedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
