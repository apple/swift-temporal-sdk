// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/operatorservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Operatorservice_V1_AddSearchAttributesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mapping between search attribute name and its IndexedValueType.
  package var searchAttributes: Dictionary<String,Temporal_Api_Enums_V1_IndexedValueType> = [:]

  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_AddSearchAttributesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_RemoveSearchAttributesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Search attribute names to delete.
  package var searchAttributes: [String] = []

  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_RemoveSearchAttributesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListSearchAttributesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListSearchAttributesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Mapping between custom (user-registered) search attribute name to its IndexedValueType.
  package var customAttributes: Dictionary<String,Temporal_Api_Enums_V1_IndexedValueType> = [:]

  /// Mapping between system (predefined) search attribute name to its IndexedValueType.
  package var systemAttributes: Dictionary<String,Temporal_Api_Enums_V1_IndexedValueType> = [:]

  /// Mapping from the attribute name to the visibility storage native type.
  package var storageSchema: Dictionary<String,String> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_DeleteNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Only one of namespace or namespace_id must be specified to identify namespace.
  package var namespace: String = String()

  package var namespaceID: String = String()

  /// If provided, the deletion of namespace info will be delayed for the given duration (0 means no delay).
  /// If not provided, the default delay configured in the cluster will be used.
  package var namespaceDeleteDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _namespaceDeleteDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_namespaceDeleteDelay = newValue}
  }
  /// Returns true if `namespaceDeleteDelay` has been explicitly set.
  package var hasNamespaceDeleteDelay: Bool {return self._namespaceDeleteDelay != nil}
  /// Clears the value of `namespaceDeleteDelay`. Subsequent reads from it will return its default value.
  package mutating func clearNamespaceDeleteDelay() {self._namespaceDeleteDelay = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _namespaceDeleteDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Operatorservice_V1_DeleteNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Temporary namespace name that is used during reclaim resources step.
  package var deletedNamespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Frontend Address is a cross cluster accessible address for gRPC traffic. This field is required.
  package var frontendAddress: String = String()

  /// Flag to enable / disable the cross cluster connection.
  package var enableRemoteClusterConnection: Bool = false

  /// Frontend HTTP Address is a cross cluster accessible address for HTTP traffic. This field is optional. If not provided
  ///  on update, the existing HTTP address will be removed.
  package var frontendHTTPAddress: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_RemoveRemoteClusterRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Remote cluster name to be removed.
  package var clusterName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_RemoveRemoteClusterResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListClustersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListClustersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// List of all cluster information
  package var clusters: [Temporal_Api_Operatorservice_V1_ClusterMetadata] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ClusterMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of the cluster name.
  package var clusterName: String = String()

  /// Id of the cluster.
  package var clusterID: String = String()

  /// gRPC address.
  package var address: String = String()

  /// HTTP address, if one exists.
  package var httpAddress: String = String()

  /// A unique failover version across all connected clusters.
  package var initialFailoverVersion: Int64 = 0

  /// History service shard number.
  package var historyShardCount: Int32 = 0

  /// A flag to indicate if a connection is active.
  package var isConnectionEnabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_GetNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server-generated unique endpoint ID.
  package var id: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_GetNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var endpoint: Temporal_Api_Nexus_V1_Endpoint {
    get {return _endpoint ?? Temporal_Api_Nexus_V1_Endpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  package var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  package mutating func clearEndpoint() {self._endpoint = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _endpoint: Temporal_Api_Nexus_V1_Endpoint? = nil
}

package struct Temporal_Api_Operatorservice_V1_CreateNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint definition to create.
  package var spec: Temporal_Api_Nexus_V1_EndpointSpec {
    get {return _spec ?? Temporal_Api_Nexus_V1_EndpointSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Nexus_V1_EndpointSpec? = nil
}

package struct Temporal_Api_Operatorservice_V1_CreateNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data post acceptance. Can be used to issue additional updates to this record.
  package var endpoint: Temporal_Api_Nexus_V1_Endpoint {
    get {return _endpoint ?? Temporal_Api_Nexus_V1_Endpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  package var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  package mutating func clearEndpoint() {self._endpoint = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _endpoint: Temporal_Api_Nexus_V1_Endpoint? = nil
}

package struct Temporal_Api_Operatorservice_V1_UpdateNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server-generated unique endpoint ID.
  package var id: String = String()

  /// Data version for this endpoint. Must match current version.
  package var version: Int64 = 0

  package var spec: Temporal_Api_Nexus_V1_EndpointSpec {
    get {return _spec ?? Temporal_Api_Nexus_V1_EndpointSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Nexus_V1_EndpointSpec? = nil
}

package struct Temporal_Api_Operatorservice_V1_UpdateNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Data post acceptance. Can be used to issue additional updates to this record.
  package var endpoint: Temporal_Api_Nexus_V1_Endpoint {
    get {return _endpoint ?? Temporal_Api_Nexus_V1_Endpoint()}
    set {_endpoint = newValue}
  }
  /// Returns true if `endpoint` has been explicitly set.
  package var hasEndpoint: Bool {return self._endpoint != nil}
  /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
  package mutating func clearEndpoint() {self._endpoint = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _endpoint: Temporal_Api_Nexus_V1_Endpoint? = nil
}

package struct Temporal_Api_Operatorservice_V1_DeleteNexusEndpointRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server-generated unique endpoint ID.
  package var id: String = String()

  /// Data version for this endpoint. Must match current version.
  package var version: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_DeleteNexusEndpointResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListNexusEndpointsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var pageSize: Int32 = 0

  /// To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
  /// response, the token will be empty if there's no other page.
  /// Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.
  package var nextPageToken: Data = Data()

  /// Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.
  /// (-- api-linter: core::203::field-behavior-required=disabled
  ///     aip.dev/not-precedent: Not following linter rules. --)
  package var name: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Operatorservice_V1_ListNexusEndpointsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Token for getting the next page.
  package var nextPageToken: Data = Data()

  package var endpoints: [Temporal_Api_Nexus_V1_Endpoint] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.operatorservice.v1"

extension Temporal_Api_Operatorservice_V1_AddSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddSearchAttributesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: &self.searchAttributes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: self.searchAttributes, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_AddSearchAttributesRequest, rhs: Temporal_Api_Operatorservice_V1_AddSearchAttributesRequest) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_AddSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddSearchAttributesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_AddSearchAttributesResponse, rhs: Temporal_Api_Operatorservice_V1_AddSearchAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_RemoveSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveSearchAttributesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.searchAttributes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchAttributes, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_RemoveSearchAttributesRequest, rhs: Temporal_Api_Operatorservice_V1_RemoveSearchAttributesRequest) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_RemoveSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveSearchAttributesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_RemoveSearchAttributesResponse, rhs: Temporal_Api_Operatorservice_V1_RemoveSearchAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSearchAttributesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListSearchAttributesRequest, rhs: Temporal_Api_Operatorservice_V1_ListSearchAttributesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSearchAttributesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}custom_attributes\0\u{3}system_attributes\0\u{3}storage_schema\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: &self.customAttributes) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: &self.systemAttributes) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.storageSchema) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.customAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: self.customAttributes, fieldNumber: 1)
    }
    if !self.systemAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: self.systemAttributes, fieldNumber: 2)
    }
    if !self.storageSchema.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.storageSchema, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListSearchAttributesResponse, rhs: Temporal_Api_Operatorservice_V1_ListSearchAttributesResponse) -> Bool {
    if lhs.customAttributes != rhs.customAttributes {return false}
    if lhs.systemAttributes != rhs.systemAttributes {return false}
    if lhs.storageSchema != rhs.storageSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_DeleteNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}namespace_id\0\u{3}namespace_delete_delay\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._namespaceDeleteDelay) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 2)
    }
    try { if let v = self._namespaceDeleteDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_DeleteNamespaceRequest, rhs: Temporal_Api_Operatorservice_V1_DeleteNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._namespaceDeleteDelay != rhs._namespaceDeleteDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_DeleteNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deleted_namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deletedNamespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.deletedNamespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_DeleteNamespaceResponse, rhs: Temporal_Api_Operatorservice_V1_DeleteNamespaceResponse) -> Bool {
    if lhs.deletedNamespace != rhs.deletedNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddOrUpdateRemoteClusterRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frontend_address\0\u{3}enable_remote_cluster_connection\0\u{3}frontend_http_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.frontendAddress) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableRemoteClusterConnection) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.frontendHTTPAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frontendAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.frontendAddress, fieldNumber: 1)
    }
    if self.enableRemoteClusterConnection != false {
      try visitor.visitSingularBoolField(value: self.enableRemoteClusterConnection, fieldNumber: 2)
    }
    if !self.frontendHTTPAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.frontendHTTPAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterRequest, rhs: Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterRequest) -> Bool {
    if lhs.frontendAddress != rhs.frontendAddress {return false}
    if lhs.enableRemoteClusterConnection != rhs.enableRemoteClusterConnection {return false}
    if lhs.frontendHTTPAddress != rhs.frontendHTTPAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AddOrUpdateRemoteClusterResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterResponse, rhs: Temporal_Api_Operatorservice_V1_AddOrUpdateRemoteClusterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_RemoveRemoteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveRemoteClusterRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_RemoveRemoteClusterRequest, rhs: Temporal_Api_Operatorservice_V1_RemoveRemoteClusterRequest) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_RemoveRemoteClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RemoveRemoteClusterResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_RemoveRemoteClusterResponse, rhs: Temporal_Api_Operatorservice_V1_RemoveRemoteClusterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListClustersRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListClustersRequest, rhs: Temporal_Api_Operatorservice_V1_ListClustersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListClustersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListClustersResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}clusters\0\u{4}\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListClustersResponse, rhs: Temporal_Api_Operatorservice_V1_ListClustersResponse) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ClusterMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ClusterMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_name\0\u{3}cluster_id\0\u{1}address\0\u{3}initial_failover_version\0\u{3}history_shard_count\0\u{3}is_connection_enabled\0\u{3}http_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initialFailoverVersion) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.historyShardCount) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isConnectionEnabled) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.httpAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.initialFailoverVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.initialFailoverVersion, fieldNumber: 4)
    }
    if self.historyShardCount != 0 {
      try visitor.visitSingularInt32Field(value: self.historyShardCount, fieldNumber: 5)
    }
    if self.isConnectionEnabled != false {
      try visitor.visitSingularBoolField(value: self.isConnectionEnabled, fieldNumber: 6)
    }
    if !self.httpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.httpAddress, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ClusterMetadata, rhs: Temporal_Api_Operatorservice_V1_ClusterMetadata) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.httpAddress != rhs.httpAddress {return false}
    if lhs.initialFailoverVersion != rhs.initialFailoverVersion {return false}
    if lhs.historyShardCount != rhs.historyShardCount {return false}
    if lhs.isConnectionEnabled != rhs.isConnectionEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_GetNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_GetNexusEndpointRequest, rhs: Temporal_Api_Operatorservice_V1_GetNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_GetNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_GetNexusEndpointResponse, rhs: Temporal_Api_Operatorservice_V1_GetNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_CreateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_CreateNexusEndpointRequest, rhs: Temporal_Api_Operatorservice_V1_CreateNexusEndpointRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_CreateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_CreateNexusEndpointResponse, rhs: Temporal_Api_Operatorservice_V1_CreateNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_UpdateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}version\0\u{1}spec\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_UpdateNexusEndpointRequest, rhs: Temporal_Api_Operatorservice_V1_UpdateNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_UpdateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_UpdateNexusEndpointResponse, rhs: Temporal_Api_Operatorservice_V1_UpdateNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_DeleteNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_DeleteNexusEndpointRequest, rhs: Temporal_Api_Operatorservice_V1_DeleteNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_DeleteNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_DeleteNexusEndpointResponse, rhs: Temporal_Api_Operatorservice_V1_DeleteNexusEndpointResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListNexusEndpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListNexusEndpointsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0\u{1}name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListNexusEndpointsRequest, rhs: Temporal_Api_Operatorservice_V1_ListNexusEndpointsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Operatorservice_V1_ListNexusEndpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListNexusEndpointsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{1}endpoints\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Operatorservice_V1_ListNexusEndpointsResponse, rhs: Temporal_Api_Operatorservice_V1_ListNexusEndpointsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
