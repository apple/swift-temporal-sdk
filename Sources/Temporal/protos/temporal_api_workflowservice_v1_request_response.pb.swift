// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/workflowservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Workflowservice_V1_RegisterNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var description_p: String = String()

  package var ownerEmail: String = String()

  package var workflowExecutionRetentionPeriod: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _workflowExecutionRetentionPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_workflowExecutionRetentionPeriod = newValue}
  }
  /// Returns true if `workflowExecutionRetentionPeriod` has been explicitly set.
  package var hasWorkflowExecutionRetentionPeriod: Bool {return self._workflowExecutionRetentionPeriod != nil}
  /// Clears the value of `workflowExecutionRetentionPeriod`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionRetentionPeriod() {self._workflowExecutionRetentionPeriod = nil}

  package var clusters: [Temporal_Api_Replication_V1_ClusterReplicationConfig] = []

  package var activeClusterName: String = String()

  /// A key-value map for any customized purpose.
  package var data: Dictionary<String,String> = [:]

  package var securityToken: String = String()

  package var isGlobalNamespace: Bool = false

  /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  package var historyArchivalState: Temporal_Api_Enums_V1_ArchivalState = .unspecified

  package var historyArchivalUri: String = String()

  /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
  package var visibilityArchivalState: Temporal_Api_Enums_V1_ArchivalState = .unspecified

  package var visibilityArchivalUri: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecutionRetentionPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Workflowservice_V1_RegisterNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListNamespacesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var namespaceFilter: Temporal_Api_Namespace_V1_NamespaceFilter {
    get {return _namespaceFilter ?? Temporal_Api_Namespace_V1_NamespaceFilter()}
    set {_namespaceFilter = newValue}
  }
  /// Returns true if `namespaceFilter` has been explicitly set.
  package var hasNamespaceFilter: Bool {return self._namespaceFilter != nil}
  /// Clears the value of `namespaceFilter`. Subsequent reads from it will return its default value.
  package mutating func clearNamespaceFilter() {self._namespaceFilter = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _namespaceFilter: Temporal_Api_Namespace_V1_NamespaceFilter? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListNamespacesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespaces: [Temporal_Api_Workflowservice_V1_DescribeNamespaceResponse] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var id: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeNamespaceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespaceInfo: Temporal_Api_Namespace_V1_NamespaceInfo {
    get {return _storage._namespaceInfo ?? Temporal_Api_Namespace_V1_NamespaceInfo()}
    set {_uniqueStorage()._namespaceInfo = newValue}
  }
  /// Returns true if `namespaceInfo` has been explicitly set.
  package var hasNamespaceInfo: Bool {return _storage._namespaceInfo != nil}
  /// Clears the value of `namespaceInfo`. Subsequent reads from it will return its default value.
  package mutating func clearNamespaceInfo() {_uniqueStorage()._namespaceInfo = nil}

  package var config: Temporal_Api_Namespace_V1_NamespaceConfig {
    get {return _storage._config ?? Temporal_Api_Namespace_V1_NamespaceConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  package var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  package mutating func clearConfig() {_uniqueStorage()._config = nil}

  package var replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig {
    get {return _storage._replicationConfig ?? Temporal_Api_Replication_V1_NamespaceReplicationConfig()}
    set {_uniqueStorage()._replicationConfig = newValue}
  }
  /// Returns true if `replicationConfig` has been explicitly set.
  package var hasReplicationConfig: Bool {return _storage._replicationConfig != nil}
  /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
  package mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

  package var failoverVersion: Int64 {
    get {return _storage._failoverVersion}
    set {_uniqueStorage()._failoverVersion = newValue}
  }

  package var isGlobalNamespace: Bool {
    get {return _storage._isGlobalNamespace}
    set {_uniqueStorage()._isGlobalNamespace = newValue}
  }

  /// Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
  /// states to ensure that the list does not grow unbounded.
  package var failoverHistory: [Temporal_Api_Replication_V1_FailoverStatus] {
    get {return _storage._failoverHistory}
    set {_uniqueStorage()._failoverHistory = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_UpdateNamespaceRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var updateInfo: Temporal_Api_Namespace_V1_UpdateNamespaceInfo {
    get {return _storage._updateInfo ?? Temporal_Api_Namespace_V1_UpdateNamespaceInfo()}
    set {_uniqueStorage()._updateInfo = newValue}
  }
  /// Returns true if `updateInfo` has been explicitly set.
  package var hasUpdateInfo: Bool {return _storage._updateInfo != nil}
  /// Clears the value of `updateInfo`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateInfo() {_uniqueStorage()._updateInfo = nil}

  package var config: Temporal_Api_Namespace_V1_NamespaceConfig {
    get {return _storage._config ?? Temporal_Api_Namespace_V1_NamespaceConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  package var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  package mutating func clearConfig() {_uniqueStorage()._config = nil}

  package var replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig {
    get {return _storage._replicationConfig ?? Temporal_Api_Replication_V1_NamespaceReplicationConfig()}
    set {_uniqueStorage()._replicationConfig = newValue}
  }
  /// Returns true if `replicationConfig` has been explicitly set.
  package var hasReplicationConfig: Bool {return _storage._replicationConfig != nil}
  /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
  package mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

  package var securityToken: String {
    get {return _storage._securityToken}
    set {_uniqueStorage()._securityToken = newValue}
  }

  package var deleteBadBinary: String {
    get {return _storage._deleteBadBinary}
    set {_uniqueStorage()._deleteBadBinary = newValue}
  }

  /// promote local namespace to global namespace. Ignored if namespace is already global namespace.
  package var promoteNamespace: Bool {
    get {return _storage._promoteNamespace}
    set {_uniqueStorage()._promoteNamespace = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_UpdateNamespaceResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespaceInfo: Temporal_Api_Namespace_V1_NamespaceInfo {
    get {return _storage._namespaceInfo ?? Temporal_Api_Namespace_V1_NamespaceInfo()}
    set {_uniqueStorage()._namespaceInfo = newValue}
  }
  /// Returns true if `namespaceInfo` has been explicitly set.
  package var hasNamespaceInfo: Bool {return _storage._namespaceInfo != nil}
  /// Clears the value of `namespaceInfo`. Subsequent reads from it will return its default value.
  package mutating func clearNamespaceInfo() {_uniqueStorage()._namespaceInfo = nil}

  package var config: Temporal_Api_Namespace_V1_NamespaceConfig {
    get {return _storage._config ?? Temporal_Api_Namespace_V1_NamespaceConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  package var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  package mutating func clearConfig() {_uniqueStorage()._config = nil}

  package var replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig {
    get {return _storage._replicationConfig ?? Temporal_Api_Replication_V1_NamespaceReplicationConfig()}
    set {_uniqueStorage()._replicationConfig = newValue}
  }
  /// Returns true if `replicationConfig` has been explicitly set.
  package var hasReplicationConfig: Bool {return _storage._replicationConfig != nil}
  /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
  package mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

  package var failoverVersion: Int64 {
    get {return _storage._failoverVersion}
    set {_uniqueStorage()._failoverVersion = newValue}
  }

  package var isGlobalNamespace: Bool {
    get {return _storage._isGlobalNamespace}
    set {_uniqueStorage()._isGlobalNamespace = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Deprecated.
package struct Temporal_Api_Workflowservice_V1_DeprecateNamespaceRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var securityToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Deprecated.
package struct Temporal_Api_Workflowservice_V1_DeprecateNamespaceResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// The identity of the client who initiated this request
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// A unique identifier for this start request. Typically UUIDv4.
  package var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
  /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  ///
  /// See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  /// Defines how to resolve a workflow id conflict with a *running* workflow.
  /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
  ///
  /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
  package var workflowIDConflictPolicy: Temporal_Api_Enums_V1_WorkflowIdConflictPolicy {
    get {return _storage._workflowIDConflictPolicy}
    set {_uniqueStorage()._workflowIDConflictPolicy = newValue}
  }

  /// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Request to get the first workflow task inline in the response bypassing matching service and worker polling.
  /// If set to `true` the caller is expected to have a worker available and capable of processing the task.
  /// The returned task will be marked as started and is expected to be completed by the specified
  /// `workflow_task_timeout`.
  package var requestEagerExecution: Bool {
    get {return _storage._requestEagerExecution}
    set {_uniqueStorage()._requestEagerExecution = newValue}
  }

  /// These values will be available as ContinuedFailure and LastCompletionResult in the
  /// WorkflowExecutionStarted event and through SDKs. The are currently only used by the
  /// server itself (for the schedules feature) and are not intended to be exposed in
  /// StartWorkflowExecution.
  package var continuedFailure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._continuedFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._continuedFailure = newValue}
  }
  /// Returns true if `continuedFailure` has been explicitly set.
  package var hasContinuedFailure: Bool {return _storage._continuedFailure != nil}
  /// Clears the value of `continuedFailure`. Subsequent reads from it will return its default value.
  package mutating func clearContinuedFailure() {_uniqueStorage()._continuedFailure = nil}

  package var lastCompletionResult: Temporal_Api_Common_V1_Payloads {
    get {return _storage._lastCompletionResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._lastCompletionResult = newValue}
  }
  /// Returns true if `lastCompletionResult` has been explicitly set.
  package var hasLastCompletionResult: Bool {return _storage._lastCompletionResult != nil}
  /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
  package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

  /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
  /// If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
  /// of the delay will be ignored.
  package var workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowStartDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowStartDelay = newValue}
  }
  /// Returns true if `workflowStartDelay` has been explicitly set.
  package var hasWorkflowStartDelay: Bool {return _storage._workflowStartDelay != nil}
  /// Clears the value of `workflowStartDelay`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowStartDelay() {_uniqueStorage()._workflowStartDelay = nil}

  /// Callbacks to be called by the server when this workflow reaches a terminal state.
  /// If the workflow continues-as-new, these callbacks will be carried over to the new execution.
  /// Callback addresses must be whitelisted in the server's dynamic configuration.
  package var completionCallbacks: [Temporal_Api_Common_V1_Callback] {
    get {return _storage._completionCallbacks}
    set {_uniqueStorage()._completionCallbacks = newValue}
  }

  /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
  /// for use by user interfaces to display the fixed as-of-start summary and details of the
  /// workflow.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _storage._userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  /// Links to be associated with the workflow.
  package var links: [Temporal_Api_Common_V1_Link] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
  /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _storage._versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_uniqueStorage()._versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return _storage._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

  /// Defines actions to be done to the existing running workflow when the conflict policy
  /// WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
  /// empty object (ie., all options with default value), it won't do anything to the existing
  /// running workflow. If set, it will add a history event to the running workflow.
  package var onConflictOptions: Temporal_Api_Workflow_V1_OnConflictOptions {
    get {return _storage._onConflictOptions ?? Temporal_Api_Workflow_V1_OnConflictOptions()}
    set {_uniqueStorage()._onConflictOptions = newValue}
  }
  /// Returns true if `onConflictOptions` has been explicitly set.
  package var hasOnConflictOptions: Bool {return _storage._onConflictOptions != nil}
  /// Clears the value of `onConflictOptions`. Subsequent reads from it will return its default value.
  package mutating func clearOnConflictOptions() {_uniqueStorage()._onConflictOptions = nil}

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
  package var runID: String = String()

  /// If true, a new workflow was started.
  package var started: Bool = false

  /// Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING
  /// unless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs).
  package var status: Temporal_Api_Enums_V1_WorkflowExecutionStatus = .unspecified

  /// When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
  /// return the first workflow task to be eagerly executed.
  /// The caller is expected to have a worker available to process the task.
  package var eagerWorkflowTask: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse {
    get {return _eagerWorkflowTask ?? Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse()}
    set {_eagerWorkflowTask = newValue}
  }
  /// Returns true if `eagerWorkflowTask` has been explicitly set.
  package var hasEagerWorkflowTask: Bool {return self._eagerWorkflowTask != nil}
  /// Clears the value of `eagerWorkflowTask`. Subsequent reads from it will return its default value.
  package mutating func clearEagerWorkflowTask() {self._eagerWorkflowTask = nil}

  /// Link to the workflow event.
  package var link: Temporal_Api_Common_V1_Link {
    get {return _link ?? Temporal_Api_Common_V1_Link()}
    set {_link = newValue}
  }
  /// Returns true if `link` has been explicitly set.
  package var hasLink: Bool {return self._link != nil}
  /// Clears the value of `link`. Subsequent reads from it will return its default value.
  package mutating func clearLink() {self._link = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _eagerWorkflowTask: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse? = nil
  fileprivate var _link: Temporal_Api_Common_V1_Link? = nil
}

package struct Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  package var maximumPageSize: Int32 = 0

  /// If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
  /// these, it should be passed here to fetch the next page.
  package var nextPageToken: Data = Data()

  /// If set to true, the RPC call will not resolve until there is a new event which matches
  /// the `history_event_filter_type`, or a timeout is hit.
  package var waitNewEvent: Bool = false

  /// Filter returned events such that they match the specified filter type.
  /// Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
  package var historyEventFilterType: Temporal_Api_Enums_V1_HistoryEventFilterType = .unspecified

  package var skipArchival: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var history: Temporal_Api_History_V1_History {
    get {return _history ?? Temporal_Api_History_V1_History()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  package var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  package mutating func clearHistory() {self._history = nil}

  /// Raw history is an alternate representation of history that may be returned if configured on
  /// the frontend. This is not supported by all SDKs. Either this or `history` will be set.
  package var rawHistory: [Temporal_Api_Common_V1_DataBlob] = []

  /// Will be set if there are more history events than were included in this response
  package var nextPageToken: Data = Data()

  package var archived: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _history: Temporal_Api_History_V1_History? = nil
}

package struct Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  package var maximumPageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var history: Temporal_Api_History_V1_History {
    get {return _history ?? Temporal_Api_History_V1_History()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  package var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  package mutating func clearHistory() {self._history = nil}

  /// Will be set if there are more history events than were included in this response
  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _history: Temporal_Api_History_V1_History? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  /// The identity of the worker/client who is polling this task queue
  package var identity: String = String()

  /// Deprecated. Use deployment_options instead.
  /// Each worker process should provide an ID unique to the specific set of code it is running
  /// "checksum" in this field name isn't very accurate, it should be though of as an id.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String = String()

  /// Deprecated. Use deployment_options instead.
  /// Information about this worker's build identifier and if it is choosing to use the versioning
  /// feature. See the `WorkerVersionCapabilities` docstring for more.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities {
    get {return _workerVersionCapabilities ?? Temporal_Api_Common_V1_WorkerVersionCapabilities()}
    set {_workerVersionCapabilities = newValue}
  }
  /// Returns true if `workerVersionCapabilities` has been explicitly set.
  package var hasWorkerVersionCapabilities: Bool {return self._workerVersionCapabilities != nil}
  /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

  /// Worker deployment options that user has set in the worker.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  /// Worker info to be sent to the server.
  package var workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat {
    get {return _workerHeartbeat ?? Temporal_Api_Worker_V1_WorkerHeartbeat()}
    set {_workerHeartbeat = newValue}
  }
  /// Returns true if `workerHeartbeat` has been explicitly set.
  package var hasWorkerHeartbeat: Bool {return self._workerHeartbeat != nil}
  /// Clears the value of `workerHeartbeat`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerHeartbeat() {self._workerHeartbeat = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
  fileprivate var _workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this task
  package var taskToken: Data {
    get {return _storage._taskToken}
    set {_uniqueStorage()._taskToken = newValue}
  }

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return _storage._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  /// The last workflow task started event which was processed by some worker for this execution.
  /// Will be zero if no task has ever started.
  package var previousStartedEventID: Int64 {
    get {return _storage._previousStartedEventID}
    set {_uniqueStorage()._previousStartedEventID = newValue}
  }

  /// The id of the most recent workflow task started event, which will have been generated as a
  /// result of this poll request being served. Will be zero if the task
  /// does not contain any events which would advance history (no new WFT started).
  /// Currently this can happen for queries.
  package var startedEventID: Int64 {
    get {return _storage._startedEventID}
    set {_uniqueStorage()._startedEventID = newValue}
  }

  /// Starting at 1, the number of attempts to complete this task by any worker.
  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// A hint that there are more tasks already present in this task queue
  /// partition. Can be used to prioritize draining a sticky queue.
  ///
  /// Specifically, the returned number is the number of tasks remaining in
  /// the in-memory buffer for this partition, which is currently capped at
  /// 1000. Because sticky queues only have one partition, this number is
  /// more useful when draining them. Normal queues, typically having more than one
  /// partition, will return a number representing only some portion of the
  /// overall backlog. Subsequent RPCs may not hit the same partition as
  /// this call.
  package var backlogCountHint: Int64 {
    get {return _storage._backlogCountHint}
    set {_uniqueStorage()._backlogCountHint = newValue}
  }

  /// The history for this workflow, which will either be complete or partial. Partial histories
  /// are sent to workers who have signaled that they are using a sticky queue when completing
  /// a workflow task.
  package var history: Temporal_Api_History_V1_History {
    get {return _storage._history ?? Temporal_Api_History_V1_History()}
    set {_uniqueStorage()._history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  package var hasHistory: Bool {return _storage._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  package mutating func clearHistory() {_uniqueStorage()._history = nil}

  /// Will be set if there are more history events than were included in this response. Such events
  /// should be fetched via `GetWorkflowExecutionHistory`.
  package var nextPageToken: Data {
    get {return _storage._nextPageToken}
    set {_uniqueStorage()._nextPageToken = newValue}
  }

  /// Legacy queries appear in this field. The query must be responded to via
  /// `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
  /// closed workflows) then the `history` field will be populated with the entire history. It
  /// may also be populated if this task originates on a non-sticky queue.
  package var query: Temporal_Api_Query_V1_WorkflowQuery {
    get {return _storage._query ?? Temporal_Api_Query_V1_WorkflowQuery()}
    set {_uniqueStorage()._query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  package var hasQuery: Bool {return _storage._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  package mutating func clearQuery() {_uniqueStorage()._query = nil}

  /// The task queue this task originated from, which will always be the original non-sticky name
  /// for the queue, even if this response came from polling a sticky queue.
  package var workflowExecutionTaskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._workflowExecutionTaskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._workflowExecutionTaskQueue = newValue}
  }
  /// Returns true if `workflowExecutionTaskQueue` has been explicitly set.
  package var hasWorkflowExecutionTaskQueue: Bool {return _storage._workflowExecutionTaskQueue != nil}
  /// Clears the value of `workflowExecutionTaskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTaskQueue() {_uniqueStorage()._workflowExecutionTaskQueue = nil}

  /// When this task was scheduled by the server
  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return _storage._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

  /// When the current workflow task started event was generated, meaning the current attempt.
  package var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  package var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  /// Queries that should be executed after applying the history in this task. Responses should be
  /// attached to `RespondWorkflowTaskCompletedRequest::query_results`
  package var queries: Dictionary<String,Temporal_Api_Query_V1_WorkflowQuery> {
    get {return _storage._queries}
    set {_uniqueStorage()._queries = newValue}
  }

  /// Protocol messages piggybacking on a WFT as a transport
  package var messages: [Temporal_Api_Protocol_V1_Message] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  /// Server-advised information the SDK may use to adjust its poller count.
  package var pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision {
    get {return _storage._pollerScalingDecision ?? Temporal_Api_Taskqueue_V1_PollerScalingDecision()}
    set {_uniqueStorage()._pollerScalingDecision = newValue}
  }
  /// Returns true if `pollerScalingDecision` has been explicitly set.
  package var hasPollerScalingDecision: Bool {return _storage._pollerScalingDecision != nil}
  /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
  package mutating func clearPollerScalingDecision() {_uniqueStorage()._pollerScalingDecision = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollWorkflowTaskQueueResponse`
  package var taskToken: Data {
    get {return _storage._taskToken}
    set {_uniqueStorage()._taskToken = newValue}
  }

  /// A list of commands generated when driving the workflow code in response to the new task
  package var commands: [Temporal_Api_Command_V1_Command] {
    get {return _storage._commands}
    set {_uniqueStorage()._commands = newValue}
  }

  /// The identity of the worker/client
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// May be set by workers to indicate that the worker desires future tasks to be provided with
  /// incremental history on a sticky queue.
  package var stickyAttributes: Temporal_Api_Taskqueue_V1_StickyExecutionAttributes {
    get {return _storage._stickyAttributes ?? Temporal_Api_Taskqueue_V1_StickyExecutionAttributes()}
    set {_uniqueStorage()._stickyAttributes = newValue}
  }
  /// Returns true if `stickyAttributes` has been explicitly set.
  package var hasStickyAttributes: Bool {return _storage._stickyAttributes != nil}
  /// Clears the value of `stickyAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearStickyAttributes() {_uniqueStorage()._stickyAttributes = nil}

  /// If set, the worker wishes to immediately receive the next workflow task as a response to
  /// this completion. This can save on polling round-trips.
  package var returnNewWorkflowTask: Bool {
    get {return _storage._returnNewWorkflowTask}
    set {_uniqueStorage()._returnNewWorkflowTask = newValue}
  }

  /// Can be used to *force* creation of a new workflow task, even if no commands have resolved or
  /// one would not otherwise have been generated. This is used when the worker knows it is doing
  /// something useful, but cannot complete it within the workflow task timeout. Local activities
  /// which run for longer than the task timeout being the prime example.
  package var forceCreateNewWorkflowTask: Bool {
    get {return _storage._forceCreateNewWorkflowTask}
    set {_uniqueStorage()._forceCreateNewWorkflowTask = newValue}
  }

  /// Deprecated. Use `deployment_options` instead.
  /// Worker process' unique binary id
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String {
    get {return _storage._binaryChecksum}
    set {_uniqueStorage()._binaryChecksum = newValue}
  }

  /// Responses to the `queries` field in the task being responded to
  package var queryResults: Dictionary<String,Temporal_Api_Query_V1_WorkflowQueryResult> {
    get {return _storage._queryResults}
    set {_uniqueStorage()._queryResults = newValue}
  }

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  /// Version info of the worker who processed this task. This message's `build_id` field should
  /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
  /// field to true. See message docstrings for more.
  /// Deprecated. Use `deployment_options` and `versioning_behavior` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _storage._workerVersionStamp ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_uniqueStorage()._workerVersionStamp = newValue}
  }
  /// Returns true if `workerVersionStamp` has been explicitly set.
  package var hasWorkerVersionStamp: Bool {return _storage._workerVersionStamp != nil}
  /// Clears the value of `workerVersionStamp`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersionStamp() {_uniqueStorage()._workerVersionStamp = nil}

  /// Protocol messages piggybacking on a WFT as a transport
  package var messages: [Temporal_Api_Protocol_V1_Message] {
    get {return _storage._messages}
    set {_uniqueStorage()._messages = newValue}
  }

  /// Data the SDK wishes to record for itself, but server need not interpret, and does not
  /// directly impact workflow state.
  package var sdkMetadata: Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata {
    get {return _storage._sdkMetadata ?? Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata()}
    set {_uniqueStorage()._sdkMetadata = newValue}
  }
  /// Returns true if `sdkMetadata` has been explicitly set.
  package var hasSdkMetadata: Bool {return _storage._sdkMetadata != nil}
  /// Clears the value of `sdkMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearSdkMetadata() {_uniqueStorage()._sdkMetadata = nil}

  /// Local usage data collected for metering
  package var meteringMetadata: Temporal_Api_Common_V1_MeteringMetadata {
    get {return _storage._meteringMetadata ?? Temporal_Api_Common_V1_MeteringMetadata()}
    set {_uniqueStorage()._meteringMetadata = newValue}
  }
  /// Returns true if `meteringMetadata` has been explicitly set.
  package var hasMeteringMetadata: Bool {return _storage._meteringMetadata != nil}
  /// Clears the value of `meteringMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearMeteringMetadata() {_uniqueStorage()._meteringMetadata = nil}

  /// All capabilities the SDK supports.
  package var capabilities: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities {
    get {return _storage._capabilities ?? Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities()}
    set {_uniqueStorage()._capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  package var hasCapabilities: Bool {return _storage._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  package mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

  /// Deployment info of the worker that completed this task. Must be present if user has set
  /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
  /// Deprecated. Replaced with `deployment_options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _storage._deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_uniqueStorage()._deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return _storage._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

  /// Versioning behavior of this workflow execution as set on the worker that completed this task.
  /// UNSPECIFIED means versioning is not enabled in the worker.
  package var versioningBehavior: Temporal_Api_Enums_V1_VersioningBehavior {
    get {return _storage._versioningBehavior}
    set {_uniqueStorage()._versioningBehavior = newValue}
  }

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _storage._deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_uniqueStorage()._deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return _storage._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {_uniqueStorage()._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// SDK capability details.
  package struct Capabilities: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// True if the SDK can handle speculative workflow task with command events. If true, the
    /// server may choose, at its discretion, to discard a speculative workflow task even if that
    /// speculative task included command events the SDK had not previously processed.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "with" used to describe the workflow task. --)
    package var discardSpeculativeWorkflowTaskWithEvents: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
  package var workflowTask: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse {
    get {return _workflowTask ?? Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse()}
    set {_workflowTask = newValue}
  }
  /// Returns true if `workflowTask` has been explicitly set.
  package var hasWorkflowTask: Bool {return self._workflowTask != nil}
  /// Clears the value of `workflowTask`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTask() {self._workflowTask = nil}

  /// See `ScheduleActivityTaskCommandAttributes::request_eager_execution`
  package var activityTasks: [Temporal_Api_Workflowservice_V1_PollActivityTaskQueueResponse] = []

  /// If non zero, indicates the server has discarded the workflow task that was being responded to.
  /// Will be the event ID of the last workflow task started event in the history before the new workflow task.
  /// Server is only expected to discard a workflow task if it could not have modified the workflow state.
  package var resetHistoryEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowTask: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollWorkflowTaskQueueResponse`
  package var taskToken: Data = Data()

  /// Why did the task fail? It's important to note that many of the variants in this enum cannot
  /// apply to worker responses. See the type's doc for more.
  package var cause: Temporal_Api_Enums_V1_WorkflowTaskFailedCause = .unspecified

  /// Failure details
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// Deprecated. Use `deployment_options` instead.
  /// Worker process' unique binary id
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String = String()

  package var namespace: String = String()

  /// Protocol messages piggybacking on a WFT as a transport
  package var messages: [Temporal_Api_Protocol_V1_Message] = []

  /// Version info of the worker who processed this task. This message's `build_id` field should
  /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
  /// field to true. See message docstrings for more.
  /// Deprecated. Use `deployment_options` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Deployment info of the worker that completed this task. Must be present if user has set
  /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
  /// Deprecated. Replaced with `deployment_options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_PollActivityTaskQueueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var taskQueueMetadata: Temporal_Api_Taskqueue_V1_TaskQueueMetadata {
    get {return _taskQueueMetadata ?? Temporal_Api_Taskqueue_V1_TaskQueueMetadata()}
    set {_taskQueueMetadata = newValue}
  }
  /// Returns true if `taskQueueMetadata` has been explicitly set.
  package var hasTaskQueueMetadata: Bool {return self._taskQueueMetadata != nil}
  /// Clears the value of `taskQueueMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueueMetadata() {self._taskQueueMetadata = nil}

  /// Information about this worker's build identifier and if it is choosing to use the versioning
  /// feature. See the `WorkerVersionCapabilities` docstring for more.
  /// Deprecated. Replaced by deployment_options.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities {
    get {return _workerVersionCapabilities ?? Temporal_Api_Common_V1_WorkerVersionCapabilities()}
    set {_workerVersionCapabilities = newValue}
  }
  /// Returns true if `workerVersionCapabilities` has been explicitly set.
  package var hasWorkerVersionCapabilities: Bool {return self._workerVersionCapabilities != nil}
  /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  /// Worker info to be sent to the server.
  package var workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat {
    get {return _workerHeartbeat ?? Temporal_Api_Worker_V1_WorkerHeartbeat()}
    set {_workerHeartbeat = newValue}
  }
  /// Returns true if `workerHeartbeat` has been explicitly set.
  package var hasWorkerHeartbeat: Bool {return self._workerHeartbeat != nil}
  /// Clears the value of `workerHeartbeat`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerHeartbeat() {self._workerHeartbeat = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _taskQueueMetadata: Temporal_Api_Taskqueue_V1_TaskQueueMetadata? = nil
  fileprivate var _workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
  fileprivate var _workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollActivityTaskQueueResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A unique identifier for this task
  package var taskToken: Data {
    get {return _storage._taskToken}
    set {_uniqueStorage()._taskToken = newValue}
  }

  /// The namespace the workflow which requested this activity lives in
  package var workflowNamespace: String {
    get {return _storage._workflowNamespace}
    set {_uniqueStorage()._workflowNamespace = newValue}
  }

  /// Type of the requesting workflow
  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  /// Execution info of the requesting workflow
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return _storage._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

  package var activityType: Temporal_Api_Common_V1_ActivityType {
    get {return _storage._activityType ?? Temporal_Api_Common_V1_ActivityType()}
    set {_uniqueStorage()._activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  package var hasActivityType: Bool {return _storage._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  package mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

  /// The autogenerated or user specified identifier of this activity. Can be used to complete the
  /// activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
  /// has resolved, but unique IDs for every activity invocation is a good idea.
  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  /// Headers specified by the scheduling workflow. Commonly used to propagate contextual info
  /// from the workflow to its activities. For example, tracing contexts.
  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Arguments to the activity invocation
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Details of the last heartbeat that was recorded for this activity as of the time this task
  /// was delivered.
  package var heartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _storage._heartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._heartbeatDetails = newValue}
  }
  /// Returns true if `heartbeatDetails` has been explicitly set.
  package var hasHeartbeatDetails: Bool {return _storage._heartbeatDetails != nil}
  /// Clears the value of `heartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatDetails() {_uniqueStorage()._heartbeatDetails = nil}

  /// When was this task first scheduled
  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return _storage._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

  /// When was this task attempt scheduled
  package var currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._currentAttemptScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._currentAttemptScheduledTime = newValue}
  }
  /// Returns true if `currentAttemptScheduledTime` has been explicitly set.
  package var hasCurrentAttemptScheduledTime: Bool {return _storage._currentAttemptScheduledTime != nil}
  /// Clears the value of `currentAttemptScheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentAttemptScheduledTime() {_uniqueStorage()._currentAttemptScheduledTime = nil}

  /// When was this task started (this attempt)
  package var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  package var hasStartedTime: Bool {return _storage._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

  /// Starting at 1, the number of attempts to perform this activity
  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// First scheduled -> final result reported timeout
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Current attempt start -> final result reported timeout
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// Window within which the activity must report a heartbeat, or be timed out.
  package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._heartbeatTimeout = newValue}
  }
  /// Returns true if `heartbeatTimeout` has been explicitly set.
  package var hasHeartbeatTimeout: Bool {return _storage._heartbeatTimeout != nil}
  /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

  /// This is the retry policy the service uses which may be different from the one provided
  /// (or not) during activity scheduling. The service can override the provided one if some
  /// values are not specified or exceed configured system limits.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Server-advised information the SDK may use to adjust its poller count.
  package var pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision {
    get {return _storage._pollerScalingDecision ?? Temporal_Api_Taskqueue_V1_PollerScalingDecision()}
    set {_uniqueStorage()._pollerScalingDecision = newValue}
  }
  /// Returns true if `pollerScalingDecision` has been explicitly set.
  package var hasPollerScalingDecision: Bool {return _storage._pollerScalingDecision != nil}
  /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
  package mutating func clearPollerScalingDecision() {_uniqueStorage()._pollerScalingDecision = nil}

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollActivityTaskQueueResponse`
  package var taskToken: Data = Data()

  /// Arbitrary data, of which the most recent call is kept, to store for this activity
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var namespace: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
  /// notify the activity of cancellation if it is still running.
  package var cancelRequested: Bool = false

  /// Will be set to true if the activity is paused.
  package var activityPaused: Bool = false

  /// Will be set to true if the activity was reset.
  /// Applies only to the current run.
  package var activityReset: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity
  package var namespace: String = String()

  /// Id of the workflow which scheduled this activity
  package var workflowID: String = String()

  /// Run Id of the workflow which scheduled this activity
  package var runID: String = String()

  /// Id of the activity we're heartbeating
  package var activityID: String = String()

  /// Arbitrary data, of which the most recent call is kept, to store for this activity
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
  /// notify the activity of cancellation if it is still running.
  package var cancelRequested: Bool = false

  /// Will be set to true if the activity is paused.
  package var activityPaused: Bool = false

  /// Will be set to true if the activity was reset.
  /// Applies only to the current run.
  package var activityReset: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollActivityTaskQueueResponse`
  package var taskToken: Data = Data()

  /// The result of successfully executing the activity
  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var namespace: String = String()

  /// Version info of the worker who processed this task. This message's `build_id` field should
  /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
  /// field to true. See message docstrings for more.
  /// Deprecated. Use `deployment_options` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Deployment info of the worker that completed this task. Must be present if user has set
  /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
  /// Deprecated. Replaced with `deployment_options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity
  package var namespace: String = String()

  /// Id of the workflow which scheduled this activity
  package var workflowID: String = String()

  /// Run Id of the workflow which scheduled this activity
  package var runID: String = String()

  /// Id of the activity to complete
  package var activityID: String = String()

  /// The serialized result of activity execution
  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollActivityTaskQueueResponse`
  package var taskToken: Data = Data()

  /// Detailed failure information
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var namespace: String = String()

  /// Additional details to be stored as last activity heartbeat
  package var lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _lastHeartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_lastHeartbeatDetails = newValue}
  }
  /// Returns true if `lastHeartbeatDetails` has been explicitly set.
  package var hasLastHeartbeatDetails: Bool {return self._lastHeartbeatDetails != nil}
  /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

  /// Version info of the worker who processed this task. This message's `build_id` field should
  /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
  /// field to true. See message docstrings for more.
  /// Deprecated. Use `deployment_options` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Deployment info of the worker that completed this task. Must be present if user has set
  /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
  /// Deprecated. Replaced with `deployment_options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server validation failures could include
  /// last_heartbeat_details payload is too large, request failure is too large
  package var failures: [Temporal_Api_Failure_V1_Failure] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity
  package var namespace: String = String()

  /// Id of the workflow which scheduled this activity
  package var workflowID: String = String()

  /// Run Id of the workflow which scheduled this activity
  package var runID: String = String()

  /// Id of the activity to fail
  package var activityID: String = String()

  /// Detailed failure information
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// Additional details to be stored as last activity heartbeat
  package var lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _lastHeartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_lastHeartbeatDetails = newValue}
  }
  /// Returns true if `lastHeartbeatDetails` has been explicitly set.
  package var hasLastHeartbeatDetails: Bool {return self._lastHeartbeatDetails != nil}
  /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _lastHeartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Server validation failures could include
  /// last_heartbeat_details payload is too large, request failure is too large
  package var failures: [Temporal_Api_Failure_V1_Failure] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task token as received in `PollActivityTaskQueueResponse`
  package var taskToken: Data = Data()

  /// Serialized additional information to attach to the cancellation
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var namespace: String = String()

  /// Version info of the worker who processed this task. This message's `build_id` field should
  /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
  /// field to true. See message docstrings for more.
  /// Deprecated. Use `deployment_options` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Deployment info of the worker that completed this task. Must be present if user has set
  /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
  /// Deprecated. Replaced with `deployment_options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity
  package var namespace: String = String()

  /// Id of the workflow which scheduled this activity
  package var workflowID: String = String()

  /// Run Id of the workflow which scheduled this activity
  package var runID: String = String()

  /// Id of the activity to confirm is cancelled
  package var activityID: String = String()

  /// Serialized additional information to attach to the cancellation
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// Used to de-dupe cancellation requests
  package var requestID: String = String()

  /// If set, this call will error if the most recent (if no run id is set on
  /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
  /// execution chain as this id.
  package var firstExecutionRunID: String = String()

  /// Reason for requesting the cancellation
  package var reason: String = String()

  /// Links to be associated with the WorkflowExecutionCanceled event.
  package var links: [Temporal_Api_Common_V1_Link] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Keep the parameters in sync with:
///   - temporal.api.batch.v1.BatchOperationSignal.
///   - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
package struct Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// The workflow author-defined name of the signal to send to the workflow
  package var signalName: String = String()

  /// Serialized value(s) to provide with the signal
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _input ?? Temporal_Api_Common_V1_Payloads()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// Used to de-dupe sent signals
  package var requestID: String = String()

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Headers that are passed with the signal to the processing workflow.
  /// These can include things like auth or tracing tokens.
  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  /// Links to be associated with the WorkflowExecutionSignaled event.
  package var links: [Temporal_Api_Common_V1_Link] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
}

package struct Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  /// The task queue to start this workflow on, if it will be started
  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// The identity of the worker/client
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// Used to de-dupe signal w/ start requests
  package var requestID: String {
    get {return _storage._requestID}
    set {_uniqueStorage()._requestID = newValue}
  }

  /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
  /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  ///
  /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  /// Defines how to resolve a workflow id conflict with a *running* workflow.
  /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
  /// Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
  ///
  /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
  package var workflowIDConflictPolicy: Temporal_Api_Enums_V1_WorkflowIdConflictPolicy {
    get {return _storage._workflowIDConflictPolicy}
    set {_uniqueStorage()._workflowIDConflictPolicy = newValue}
  }

  /// The workflow author-defined name of the signal to send to the workflow
  package var signalName: String {
    get {return _storage._signalName}
    set {_uniqueStorage()._signalName = newValue}
  }

  /// Serialized value(s) to provide with the signal
  package var signalInput: Temporal_Api_Common_V1_Payloads {
    get {return _storage._signalInput ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._signalInput = newValue}
  }
  /// Returns true if `signalInput` has been explicitly set.
  package var hasSignalInput: Bool {return _storage._signalInput != nil}
  /// Clears the value of `signalInput`. Subsequent reads from it will return its default value.
  package mutating func clearSignalInput() {_uniqueStorage()._signalInput = nil}

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String {
    get {return _storage._control}
    set {_uniqueStorage()._control = newValue}
  }

  /// Retry policy for the workflow
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
  /// Note that the signal will be delivered with the first workflow task. If the workflow gets
  /// another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
  /// and the rest of the delay period will be ignored, even if that request also had a delay.
  /// Signal via SignalWorkflowExecution will not unblock the workflow.
  package var workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowStartDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowStartDelay = newValue}
  }
  /// Returns true if `workflowStartDelay` has been explicitly set.
  package var hasWorkflowStartDelay: Bool {return _storage._workflowStartDelay != nil}
  /// Clears the value of `workflowStartDelay`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowStartDelay() {_uniqueStorage()._workflowStartDelay = nil}

  /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
  /// for use by user interfaces to display the fixed as-of-start summary and details of the
  /// workflow.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _storage._userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  /// Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events.
  package var links: [Temporal_Api_Common_V1_Link] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
  /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _storage._versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_uniqueStorage()._versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return _storage._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The run id of the workflow that was started - or just signaled, if it was already running.
  package var runID: String = String()

  /// If true, a new workflow was started.
  package var started: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// The workflow to reset. If this contains a run ID then the workflow will be reset back to the
  /// provided event ID in that run. Otherwise it will be reset to the provided event ID in the
  /// current run. In all cases the current run will be terminated and a new run started.
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var reason: String = String()

  /// The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
  /// `WORKFLOW_TASK_STARTED` event to reset to.
  package var workflowTaskFinishEventID: Int64 = 0

  /// Used to de-dupe reset requests
  package var requestID: String = String()

  /// Deprecated. Use `options`.
  /// Default: RESET_REAPPLY_TYPE_SIGNAL
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var resetReapplyType: Temporal_Api_Enums_V1_ResetReapplyType = .unspecified

  /// Event types not to be reapplied
  package var resetReapplyExcludeTypes: [Temporal_Api_Enums_V1_ResetReapplyExcludeType] = []

  /// Operations to perform after the workflow has been reset. These operations will be applied
  /// to the *new* run of the workflow execution in the order they are provided.
  /// All operations are applied to the workflow before the first new workflow task is generated
  package var postResetOperations: [Temporal_Api_Workflow_V1_PostResetOperation] = []

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var runID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var reason: String = String()

  /// Serialized additional information to attach to the termination event
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  /// If set, this call will error if the most recent (if no run id is set on
  /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
  /// execution chain as this id.
  package var firstExecutionRunID: String = String()

  /// Links to be associated with the WorkflowExecutionTerminated event.
  package var links: [Temporal_Api_Common_V1_Link] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Workflow Execution to delete. If run_id is not specified, the latest one is used.
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var maximumPageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var startTimeFilter: Temporal_Api_Filter_V1_StartTimeFilter {
    get {return _startTimeFilter ?? Temporal_Api_Filter_V1_StartTimeFilter()}
    set {_startTimeFilter = newValue}
  }
  /// Returns true if `startTimeFilter` has been explicitly set.
  package var hasStartTimeFilter: Bool {return self._startTimeFilter != nil}
  /// Clears the value of `startTimeFilter`. Subsequent reads from it will return its default value.
  package mutating func clearStartTimeFilter() {self._startTimeFilter = nil}

  package var filters: Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsRequest.OneOf_Filters? = nil

  package var executionFilter: Temporal_Api_Filter_V1_WorkflowExecutionFilter {
    get {
      if case .executionFilter(let v)? = filters {return v}
      return Temporal_Api_Filter_V1_WorkflowExecutionFilter()
    }
    set {filters = .executionFilter(newValue)}
  }

  package var typeFilter: Temporal_Api_Filter_V1_WorkflowTypeFilter {
    get {
      if case .typeFilter(let v)? = filters {return v}
      return Temporal_Api_Filter_V1_WorkflowTypeFilter()
    }
    set {filters = .typeFilter(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Filters: Equatable, Sendable {
    case executionFilter(Temporal_Api_Filter_V1_WorkflowExecutionFilter)
    case typeFilter(Temporal_Api_Filter_V1_WorkflowTypeFilter)

  }

  package init() {}

  fileprivate var _startTimeFilter: Temporal_Api_Filter_V1_StartTimeFilter? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executions: [Temporal_Api_Workflow_V1_WorkflowExecutionInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var maximumPageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var startTimeFilter: Temporal_Api_Filter_V1_StartTimeFilter {
    get {return _startTimeFilter ?? Temporal_Api_Filter_V1_StartTimeFilter()}
    set {_startTimeFilter = newValue}
  }
  /// Returns true if `startTimeFilter` has been explicitly set.
  package var hasStartTimeFilter: Bool {return self._startTimeFilter != nil}
  /// Clears the value of `startTimeFilter`. Subsequent reads from it will return its default value.
  package mutating func clearStartTimeFilter() {self._startTimeFilter = nil}

  package var filters: Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsRequest.OneOf_Filters? = nil

  package var executionFilter: Temporal_Api_Filter_V1_WorkflowExecutionFilter {
    get {
      if case .executionFilter(let v)? = filters {return v}
      return Temporal_Api_Filter_V1_WorkflowExecutionFilter()
    }
    set {filters = .executionFilter(newValue)}
  }

  package var typeFilter: Temporal_Api_Filter_V1_WorkflowTypeFilter {
    get {
      if case .typeFilter(let v)? = filters {return v}
      return Temporal_Api_Filter_V1_WorkflowTypeFilter()
    }
    set {filters = .typeFilter(newValue)}
  }

  package var statusFilter: Temporal_Api_Filter_V1_StatusFilter {
    get {
      if case .statusFilter(let v)? = filters {return v}
      return Temporal_Api_Filter_V1_StatusFilter()
    }
    set {filters = .statusFilter(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Filters: Equatable, Sendable {
    case executionFilter(Temporal_Api_Filter_V1_WorkflowExecutionFilter)
    case typeFilter(Temporal_Api_Filter_V1_WorkflowTypeFilter)
    case statusFilter(Temporal_Api_Filter_V1_StatusFilter)

  }

  package init() {}

  fileprivate var _startTimeFilter: Temporal_Api_Filter_V1_StartTimeFilter? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executions: [Temporal_Api_Workflow_V1_WorkflowExecutionInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executions: [Temporal_Api_Workflow_V1_WorkflowExecutionInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executions: [Temporal_Api_Workflow_V1_WorkflowExecutionInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Deprecated: Use with `ListWorkflowExecutions`.
package struct Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Deprecated: Use with `ListWorkflowExecutions`.
package struct Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executions: [Temporal_Api_Workflow_V1_WorkflowExecutionInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If `query` is not grouping by any field, the count is an approximate number
  /// of workflows that matches the query.
  /// If `query` is grouping by a field, the count is simply the sum of the counts
  /// of the groups returned in the response. This number can be smaller than the
  /// total number of workflows matching the query.
  package var count: Int64 = 0

  /// `groups` contains the groups if the request is grouping by a field.
  /// The list might not be complete, and the counts of each group is approximate.
  package var groups: [Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse.AggregationGroup] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct AggregationGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var groupValues: [Temporal_Api_Common_V1_Payload] = []

    package var count: Int64 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_GetSearchAttributesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_GetSearchAttributesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var keys: Dictionary<String,Temporal_Api_Enums_V1_IndexedValueType> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var taskToken: Data = Data()

  package var completedType: Temporal_Api_Enums_V1_QueryResultType = .unspecified

  /// The result of the query.
  /// Mutually exclusive with `error_message` and `failure`. Set when the query succeeds.
  package var queryResult: Temporal_Api_Common_V1_Payloads {
    get {return _queryResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_queryResult = newValue}
  }
  /// Returns true if `queryResult` has been explicitly set.
  package var hasQueryResult: Bool {return self._queryResult != nil}
  /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
  package mutating func clearQueryResult() {self._queryResult = nil}

  /// A plain error message that must be set if completed_type is QUERY_RESULT_TYPE_FAILED.
  /// SDKs should also fill in the more complete `failure` field to provide the full context and
  /// support encryption of failure information.
  /// `error_message` will be duplicated if the `failure` field is present to support callers
  /// that pre-date the addition of that field, regardless of whether or not a custom failure
  /// converter is used.
  /// Mutually exclusive with `query_result`. Set when the query fails.
  package var errorMessage: String = String()

  package var namespace: String = String()

  /// The full reason for this query failure. This field is newer than `error_message` and can be
  /// encoded by the SDK's failure converter to support E2E encryption of messages and stack
  /// traces.
  /// Mutually exclusive with `query_result`. Set when the query fails.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// Why did the task fail? It's important to note that many of the variants in this enum cannot
  /// apply to worker responses. See the type's doc for more.
  package var cause: Temporal_Api_Enums_V1_WorkflowTaskFailedCause = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _queryResult: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ShutdownWorkerRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var stickyTaskQueue: String = String()

  package var identity: String = String()

  package var reason: String = String()

  package var workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat {
    get {return _workerHeartbeat ?? Temporal_Api_Worker_V1_WorkerHeartbeat()}
    set {_workerHeartbeat = newValue}
  }
  /// Returns true if `workerHeartbeat` has been explicitly set.
  package var hasWorkerHeartbeat: Bool {return self._workerHeartbeat != nil}
  /// Clears the value of `workerHeartbeat`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerHeartbeat() {self._workerHeartbeat = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat? = nil
}

package struct Temporal_Api_Workflowservice_V1_ShutdownWorkerResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_QueryWorkflowRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  package var query: Temporal_Api_Query_V1_WorkflowQuery {
    get {return _query ?? Temporal_Api_Query_V1_WorkflowQuery()}
    set {_query = newValue}
  }
  /// Returns true if `query` has been explicitly set.
  package var hasQuery: Bool {return self._query != nil}
  /// Clears the value of `query`. Subsequent reads from it will return its default value.
  package mutating func clearQuery() {self._query = nil}

  /// QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
  /// Default: QUERY_REJECT_CONDITION_NONE.
  package var queryRejectCondition: Temporal_Api_Enums_V1_QueryRejectCondition = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _query: Temporal_Api_Query_V1_WorkflowQuery? = nil
}

package struct Temporal_Api_Workflowservice_V1_QueryWorkflowResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var queryResult: Temporal_Api_Common_V1_Payloads {
    get {return _queryResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_queryResult = newValue}
  }
  /// Returns true if `queryResult` has been explicitly set.
  package var hasQueryResult: Bool {return self._queryResult != nil}
  /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
  package mutating func clearQueryResult() {self._queryResult = nil}

  package var queryRejected: Temporal_Api_Query_V1_QueryRejected {
    get {return _queryRejected ?? Temporal_Api_Query_V1_QueryRejected()}
    set {_queryRejected = newValue}
  }
  /// Returns true if `queryRejected` has been explicitly set.
  package var hasQueryRejected: Bool {return self._queryRejected != nil}
  /// Clears the value of `queryRejected`. Subsequent reads from it will return its default value.
  package mutating func clearQueryRejected() {self._queryRejected = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _queryResult: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _queryRejected: Temporal_Api_Query_V1_QueryRejected? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var executionConfig: Temporal_Api_Workflow_V1_WorkflowExecutionConfig {
    get {return _storage._executionConfig ?? Temporal_Api_Workflow_V1_WorkflowExecutionConfig()}
    set {_uniqueStorage()._executionConfig = newValue}
  }
  /// Returns true if `executionConfig` has been explicitly set.
  package var hasExecutionConfig: Bool {return _storage._executionConfig != nil}
  /// Clears the value of `executionConfig`. Subsequent reads from it will return its default value.
  package mutating func clearExecutionConfig() {_uniqueStorage()._executionConfig = nil}

  package var workflowExecutionInfo: Temporal_Api_Workflow_V1_WorkflowExecutionInfo {
    get {return _storage._workflowExecutionInfo ?? Temporal_Api_Workflow_V1_WorkflowExecutionInfo()}
    set {_uniqueStorage()._workflowExecutionInfo = newValue}
  }
  /// Returns true if `workflowExecutionInfo` has been explicitly set.
  package var hasWorkflowExecutionInfo: Bool {return _storage._workflowExecutionInfo != nil}
  /// Clears the value of `workflowExecutionInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionInfo() {_uniqueStorage()._workflowExecutionInfo = nil}

  package var pendingActivities: [Temporal_Api_Workflow_V1_PendingActivityInfo] {
    get {return _storage._pendingActivities}
    set {_uniqueStorage()._pendingActivities = newValue}
  }

  package var pendingChildren: [Temporal_Api_Workflow_V1_PendingChildExecutionInfo] {
    get {return _storage._pendingChildren}
    set {_uniqueStorage()._pendingChildren = newValue}
  }

  package var pendingWorkflowTask: Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo {
    get {return _storage._pendingWorkflowTask ?? Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo()}
    set {_uniqueStorage()._pendingWorkflowTask = newValue}
  }
  /// Returns true if `pendingWorkflowTask` has been explicitly set.
  package var hasPendingWorkflowTask: Bool {return _storage._pendingWorkflowTask != nil}
  /// Clears the value of `pendingWorkflowTask`. Subsequent reads from it will return its default value.
  package mutating func clearPendingWorkflowTask() {_uniqueStorage()._pendingWorkflowTask = nil}

  package var callbacks: [Temporal_Api_Workflow_V1_CallbackInfo] {
    get {return _storage._callbacks}
    set {_uniqueStorage()._callbacks = newValue}
  }

  package var pendingNexusOperations: [Temporal_Api_Workflow_V1_PendingNexusOperationInfo] {
    get {return _storage._pendingNexusOperations}
    set {_uniqueStorage()._pendingNexusOperations = newValue}
  }

  package var workflowExtendedInfo: Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo {
    get {return _storage._workflowExtendedInfo ?? Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo()}
    set {_uniqueStorage()._workflowExtendedInfo = newValue}
  }
  /// Returns true if `workflowExtendedInfo` has been explicitly set.
  package var hasWorkflowExtendedInfo: Bool {return _storage._workflowExtendedInfo != nil}
  /// Clears the value of `workflowExtendedInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExtendedInfo() {_uniqueStorage()._workflowExtendedInfo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// (-- api-linter: core::0203::optional=disabled
///     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
package struct Temporal_Api_Workflowservice_V1_DescribeTaskQueueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Sticky queues are not supported in deprecated ENHANCED mode.
  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  /// If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
  /// Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
  package var taskQueueType: Temporal_Api_Enums_V1_TaskQueueType = .unspecified

  /// Report stats for the requested task queue type(s).
  package var reportStats: Bool = false

  /// Report Task Queue Config
  package var reportConfig: Bool = false

  /// Deprecated, use `report_stats` instead.
  /// If true, the task queue status will be included in the response.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var includeTaskQueueStatus: Bool = false

  /// Deprecated. ENHANCED mode is also being deprecated.
  /// Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
  /// Consult the documentation for each field to understand which mode it is supported in.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var apiMode: Temporal_Api_Enums_V1_DescribeTaskQueueMode = .unspecified

  /// Deprecated (as part of the ENHANCED mode deprecation).
  /// Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
  /// mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
  /// unversioned queue will be returned.
  /// (-- api-linter: core::0140::prepositions --)
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var versions: Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection {
    get {return _versions ?? Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection()}
    set {_versions = newValue}
  }
  /// Returns true if `versions` has been explicitly set.
  package var hasVersions: Bool {return self._versions != nil}
  /// Clears the value of `versions`. Subsequent reads from it will return its default value.
  package mutating func clearVersions() {self._versions = nil}

  /// Deprecated (as part of the ENHANCED mode deprecation).
  /// Task queue types to report info about. If not specified, all types are considered.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var taskQueueTypes: [Temporal_Api_Enums_V1_TaskQueueType] = []

  /// Deprecated (as part of the ENHANCED mode deprecation).
  /// Report list of pollers for requested task queue types and versions.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var reportPollers: Bool = false

  /// Deprecated (as part of the ENHANCED mode deprecation).
  /// Report task reachability for the requested versions and all task types (task reachability is not reported
  /// per task type).
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var reportTaskReachability: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _versions: Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var pollers: [Temporal_Api_Taskqueue_V1_PollerInfo] {
    get {return _storage._pollers}
    set {_uniqueStorage()._pollers = newValue}
  }

  /// Statistics for the task queue.
  /// Only set if `report_stats` is set on the request.
  package var stats: Temporal_Api_Taskqueue_V1_TaskQueueStats {
    get {return _storage._stats ?? Temporal_Api_Taskqueue_V1_TaskQueueStats()}
    set {_uniqueStorage()._stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  package var hasStats: Bool {return _storage._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  package mutating func clearStats() {_uniqueStorage()._stats = nil}

  /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
  /// Only set if `report_stats` is set on the request.
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
  package var statsByPriorityKey: Dictionary<Int32,Temporal_Api_Taskqueue_V1_TaskQueueStats> {
    get {return _storage._statsByPriorityKey}
    set {_uniqueStorage()._statsByPriorityKey = newValue}
  }

  /// Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
  /// When not present, it means the tasks are routed to Unversioned workers (workers with
  /// UNVERSIONED or unspecified WorkerVersioningMode.)
  /// Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
  /// and SetWorkerDeploymentRampingVersion on Worker Deployments.
  /// Note: This information is not relevant to Pinned workflow executions and their activities as
  /// they are always routed to their Pinned Deployment Version. However, new workflow executions
  /// are typically not Pinned until they complete their first task (unless they are started with
  /// a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
  package var versioningInfo: Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo {
    get {return _storage._versioningInfo ?? Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo()}
    set {_uniqueStorage()._versioningInfo = newValue}
  }
  /// Returns true if `versioningInfo` has been explicitly set.
  package var hasVersioningInfo: Bool {return _storage._versioningInfo != nil}
  /// Clears the value of `versioningInfo`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningInfo() {_uniqueStorage()._versioningInfo = nil}

  /// Only populated if report_task_queue_config is set to true.
  package var config: Temporal_Api_Taskqueue_V1_TaskQueueConfig {
    get {return _storage._config ?? Temporal_Api_Taskqueue_V1_TaskQueueConfig()}
    set {_uniqueStorage()._config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  package var hasConfig: Bool {return _storage._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  package mutating func clearConfig() {_uniqueStorage()._config = nil}

  package var effectiveRateLimit: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit {
    get {return _storage._effectiveRateLimit ?? Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit()}
    set {_uniqueStorage()._effectiveRateLimit = newValue}
  }
  /// Returns true if `effectiveRateLimit` has been explicitly set.
  package var hasEffectiveRateLimit: Bool {return _storage._effectiveRateLimit != nil}
  /// Clears the value of `effectiveRateLimit`. Subsequent reads from it will return its default value.
  package mutating func clearEffectiveRateLimit() {_uniqueStorage()._effectiveRateLimit = nil}

  /// Deprecated.
  /// Status of the task queue. Only populated when `include_task_queue_status` is set to true in the request.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var taskQueueStatus: Temporal_Api_Taskqueue_V1_TaskQueueStatus {
    get {return _storage._taskQueueStatus ?? Temporal_Api_Taskqueue_V1_TaskQueueStatus()}
    set {_uniqueStorage()._taskQueueStatus = newValue}
  }
  /// Returns true if `taskQueueStatus` has been explicitly set.
  package var hasTaskQueueStatus: Bool {return _storage._taskQueueStatus != nil}
  /// Clears the value of `taskQueueStatus`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueueStatus() {_uniqueStorage()._taskQueueStatus = nil}

  /// Deprecated.
  /// Only returned in ENHANCED mode.
  /// This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var versionsInfo: Dictionary<String,Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo> {
    get {return _storage._versionsInfo}
    set {_uniqueStorage()._versionsInfo = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct EffectiveRateLimit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The effective rate limit for the task queue.
    package var requestsPerSecond: Float = 0

    /// Source of the RateLimit Configuration,which can be one of the following values:
    /// - SOURCE_API: The rate limit that is set via the TaskQueueConfig api.
    /// - SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.
    /// - SOURCE_SYSTEM: The rate limit is the default value set by the system
    package var rateLimitSource: Temporal_Api_Enums_V1_RateLimitSource = .unspecified

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_GetClusterInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// GetClusterInfoResponse contains information about Temporal cluster.
package struct Temporal_Api_Workflowservice_V1_GetClusterInfoResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
  /// Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
  package var supportedClients: Dictionary<String,String> {
    get {return _storage._supportedClients}
    set {_uniqueStorage()._supportedClients = newValue}
  }

  package var serverVersion: String {
    get {return _storage._serverVersion}
    set {_uniqueStorage()._serverVersion = newValue}
  }

  package var clusterID: String {
    get {return _storage._clusterID}
    set {_uniqueStorage()._clusterID = newValue}
  }

  package var versionInfo: Temporal_Api_Version_V1_VersionInfo {
    get {return _storage._versionInfo ?? Temporal_Api_Version_V1_VersionInfo()}
    set {_uniqueStorage()._versionInfo = newValue}
  }
  /// Returns true if `versionInfo` has been explicitly set.
  package var hasVersionInfo: Bool {return _storage._versionInfo != nil}
  /// Clears the value of `versionInfo`. Subsequent reads from it will return its default value.
  package mutating func clearVersionInfo() {_uniqueStorage()._versionInfo = nil}

  package var clusterName: String {
    get {return _storage._clusterName}
    set {_uniqueStorage()._clusterName = newValue}
  }

  package var historyShardCount: Int32 {
    get {return _storage._historyShardCount}
    set {_uniqueStorage()._historyShardCount = newValue}
  }

  package var persistenceStore: String {
    get {return _storage._persistenceStore}
    set {_uniqueStorage()._persistenceStore = newValue}
  }

  package var visibilityStore: String {
    get {return _storage._visibilityStore}
    set {_uniqueStorage()._visibilityStore = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_GetSystemInfoRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_GetSystemInfoResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the server.
  package var serverVersion: String = String()

  /// All capabilities the system supports.
  package var capabilities: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities {
    get {return _capabilities ?? Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities()}
    set {_capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  package var hasCapabilities: Bool {return self._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  package mutating func clearCapabilities() {self._capabilities = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// System capability details.
  package struct Capabilities: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// True if signal and query headers are supported.
    package var signalAndQueryHeader: Bool = false

    /// True if internal errors are differentiated from other types of errors for purposes of
    /// retrying non-internal errors.
    ///
    /// When unset/false, clients retry all failures. When true, clients should only retry
    /// non-internal errors.
    package var internalErrorDifferentiation: Bool = false

    /// True if RespondActivityTaskFailed API supports including heartbeat details
    package var activityFailureIncludeHeartbeat: Bool = false

    /// Supports scheduled workflow features.
    package var supportsSchedules: Bool = false

    /// True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
    package var encodedFailureAttributes: Bool = false

    /// True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
    /// (see:
    /// https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
    package var buildIDBasedVersioning: Bool = false

    /// True if server supports upserting workflow memo
    package var upsertMemo: Bool = false

    /// True if server supports eager workflow task dispatching for the StartWorkflowExecution API
    package var eagerWorkflowStart: Bool = false

    /// True if the server knows about the sdk metadata field on WFT completions and will record
    /// it in history
    package var sdkMetadata: Bool = false

    /// True if the server supports count group by execution status
    /// (-- api-linter: core::0140::prepositions=disabled --)
    package var countGroupByExecutionStatus: Bool = false

    /// True if the server supports Nexus operations.
    /// This flag is dependent both on server version and for Nexus to be enabled via server configuration.
    package var nexus: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}

  fileprivate var _capabilities: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var activityTaskQueuePartitions: [Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata] = []

  package var workflowTaskQueuePartitions: [Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// (-- api-linter: core::0203::optional=disabled
///     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
package struct Temporal_Api_Workflowservice_V1_CreateScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace the schedule should be created in.
  package var namespace: String = String()

  /// The id of the new schedule.
  package var scheduleID: String = String()

  /// The schedule spec, policies, action, and initial state.
  package var schedule: Temporal_Api_Schedule_V1_Schedule {
    get {return _schedule ?? Temporal_Api_Schedule_V1_Schedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  package var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  package mutating func clearSchedule() {self._schedule = nil}

  /// Optional initial patch (e.g. to run the action once immediately).
  package var initialPatch: Temporal_Api_Schedule_V1_SchedulePatch {
    get {return _initialPatch ?? Temporal_Api_Schedule_V1_SchedulePatch()}
    set {_initialPatch = newValue}
  }
  /// Returns true if `initialPatch` has been explicitly set.
  package var hasInitialPatch: Bool {return self._initialPatch != nil}
  /// Clears the value of `initialPatch`. Subsequent reads from it will return its default value.
  package mutating func clearInitialPatch() {self._initialPatch = nil}

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// A unique identifier for this create request for idempotence. Typically UUIDv4.
  package var requestID: String = String()

  /// Memo and search attributes to attach to the schedule itself.
  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _memo ?? Temporal_Api_Common_V1_Memo()}
    set {_memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return self._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {self._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return self._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {self._searchAttributes = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _schedule: Temporal_Api_Schedule_V1_Schedule? = nil
  fileprivate var _initialPatch: Temporal_Api_Schedule_V1_SchedulePatch? = nil
  fileprivate var _memo: Temporal_Api_Common_V1_Memo? = nil
  fileprivate var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
}

package struct Temporal_Api_Workflowservice_V1_CreateScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var conflictToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the schedule to describe.
  package var namespace: String = String()

  /// The id of the schedule to describe.
  package var scheduleID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeScheduleResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The complete current schedule details. This may not match the schedule as
  /// created because:
  /// - some types of schedule specs may get compiled into others (e.g.
  ///   CronString into StructuredCalendarSpec)
  /// - some unspecified fields may be replaced by defaults
  /// - some fields in the state are modified automatically
  /// - the schedule may have been modified by UpdateSchedule or PatchSchedule
  package var schedule: Temporal_Api_Schedule_V1_Schedule {
    get {return _storage._schedule ?? Temporal_Api_Schedule_V1_Schedule()}
    set {_uniqueStorage()._schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  package var hasSchedule: Bool {return _storage._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  package mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

  /// Extra schedule state info.
  package var info: Temporal_Api_Schedule_V1_ScheduleInfo {
    get {return _storage._info ?? Temporal_Api_Schedule_V1_ScheduleInfo()}
    set {_uniqueStorage()._info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  package var hasInfo: Bool {return _storage._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  package mutating func clearInfo() {_uniqueStorage()._info = nil}

  /// The memo and search attributes that the schedule was created with.
  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// This value can be passed back to UpdateSchedule to ensure that the
  /// schedule was not modified between a Describe and an Update, which could
  /// lead to lost updates and other confusion.
  package var conflictToken: Data {
    get {return _storage._conflictToken}
    set {_uniqueStorage()._conflictToken = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflowservice_V1_UpdateScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the schedule to update.
  package var namespace: String = String()

  /// The id of the schedule to update.
  package var scheduleID: String = String()

  /// The new schedule. The four main fields of the schedule (spec, action,
  /// policies, state) are replaced completely by the values in this message.
  package var schedule: Temporal_Api_Schedule_V1_Schedule {
    get {return _schedule ?? Temporal_Api_Schedule_V1_Schedule()}
    set {_schedule = newValue}
  }
  /// Returns true if `schedule` has been explicitly set.
  package var hasSchedule: Bool {return self._schedule != nil}
  /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
  package mutating func clearSchedule() {self._schedule = nil}

  /// This can be the value of conflict_token from a DescribeScheduleResponse,
  /// which will cause this request to fail if the schedule has been modified
  /// between the Describe and this Update.
  /// If missing, the schedule will be updated unconditionally.
  package var conflictToken: Data = Data()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// A unique identifier for this update request for idempotence. Typically UUIDv4.
  package var requestID: String = String()

  /// Schedule search attributes to be updated.
  /// Do not set this field if you do not want to update the search attributes.
  /// A non-null empty object will set the search attributes to an empty map.
  /// Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
  /// you must also set the `schedule` field; otherwise, it will unset the schedule.
  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return self._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {self._searchAttributes = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _schedule: Temporal_Api_Schedule_V1_Schedule? = nil
  fileprivate var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_PatchScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the schedule to patch.
  package var namespace: String = String()

  /// The id of the schedule to patch.
  package var scheduleID: String = String()

  package var patch: Temporal_Api_Schedule_V1_SchedulePatch {
    get {return _patch ?? Temporal_Api_Schedule_V1_SchedulePatch()}
    set {_patch = newValue}
  }
  /// Returns true if `patch` has been explicitly set.
  package var hasPatch: Bool {return self._patch != nil}
  /// Clears the value of `patch`. Subsequent reads from it will return its default value.
  package mutating func clearPatch() {self._patch = nil}

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// A unique identifier for this update request for idempotence. Typically UUIDv4.
  package var requestID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _patch: Temporal_Api_Schedule_V1_SchedulePatch? = nil
}

package struct Temporal_Api_Workflowservice_V1_PatchScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the schedule to query.
  package var namespace: String = String()

  /// The id of the schedule to query.
  package var scheduleID: String = String()

  /// Time range to query.
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {self._startTime = nil}

  package var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_endTime = newValue}
  }
  /// Returns true if `endTime` has been explicitly set.
  package var hasEndTime: Bool {return self._endTime != nil}
  /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
  package mutating func clearEndTime() {self._endTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var startTime: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DeleteScheduleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the schedule to delete.
  package var namespace: String = String()

  /// The id of the schedule to delete.
  package var scheduleID: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DeleteScheduleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListSchedulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace to list schedules in.
  package var namespace: String = String()

  /// How many to return at once.
  package var maximumPageSize: Int32 = 0

  /// Token to get the next page of results.
  package var nextPageToken: Data = Data()

  /// Query to filter schedules.
  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListSchedulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var schedules: [Temporal_Api_Schedule_V1_ScheduleListEntry] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Must be set, the task queue to apply changes to. Because all workers on a given task queue
  /// must have the same set of workflow & activity implementations, there is no reason to specify
  /// a task queue type here.
  package var taskQueue: String = String()

  package var operation: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.OneOf_Operation? = nil

  /// A new build id. This operation will create a new set which will be the new overall
  /// default version for the queue, with this id as its only member. This new set is
  /// incompatible with all previous sets/versions.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: In makes perfect sense here. --)
  package var addNewBuildIDInNewDefaultSet: String {
    get {
      if case .addNewBuildIDInNewDefaultSet(let v)? = operation {return v}
      return String()
    }
    set {operation = .addNewBuildIDInNewDefaultSet(newValue)}
  }

  /// Adds a new id to an existing compatible set, see sub-message definition for more.
  package var addNewCompatibleBuildID: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion {
    get {
      if case .addNewCompatibleBuildID(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion()
    }
    set {operation = .addNewCompatibleBuildID(newValue)}
  }

  /// Promote an existing set to be the current default (if it isn't already) by targeting
  /// an existing build id within it. This field's value is the extant build id.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: Names are hard. --)
  package var promoteSetByBuildID: String {
    get {
      if case .promoteSetByBuildID(let v)? = operation {return v}
      return String()
    }
    set {operation = .promoteSetByBuildID(newValue)}
  }

  /// Promote an existing build id within some set to be the current default for that set.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: Within makes perfect sense here. --)
  package var promoteBuildIDWithinSet: String {
    get {
      if case .promoteBuildIDWithinSet(let v)? = operation {return v}
      return String()
    }
    set {operation = .promoteBuildIDWithinSet(newValue)}
  }

  /// Merge two existing sets together, thus declaring all build IDs in both sets compatible
  /// with one another. The primary set's default will become the default for the merged set.
  /// This is useful if you've accidentally declared a new ID as incompatible you meant to
  /// declare as compatible. The unusual case of incomplete replication during failover could
  /// also result in a split set, which this operation can repair.
  package var mergeSets: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets {
    get {
      if case .mergeSets(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets()
    }
    set {operation = .mergeSets(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Operation: Equatable, Sendable {
    /// A new build id. This operation will create a new set which will be the new overall
    /// default version for the queue, with this id as its only member. This new set is
    /// incompatible with all previous sets/versions.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: In makes perfect sense here. --)
    case addNewBuildIDInNewDefaultSet(String)
    /// Adds a new id to an existing compatible set, see sub-message definition for more.
    case addNewCompatibleBuildID(Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion)
    /// Promote an existing set to be the current default (if it isn't already) by targeting
    /// an existing build id within it. This field's value is the extant build id.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: Names are hard. --)
    case promoteSetByBuildID(String)
    /// Promote an existing build id within some set to be the current default for that set.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: Within makes perfect sense here. --)
    case promoteBuildIDWithinSet(String)
    /// Merge two existing sets together, thus declaring all build IDs in both sets compatible
    /// with one another. The primary set's default will become the default for the merged set.
    /// This is useful if you've accidentally declared a new ID as incompatible you meant to
    /// declare as compatible. The unusual case of incomplete replication during failover could
    /// also result in a split set, which this operation can repair.
    case mergeSets(Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets)

  }

  package struct AddNewCompatibleVersion: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A new id to be added to an existing compatible set.
    package var newBuildID: String = String()

    /// A build id which must already exist in the version sets known by the task queue. The new
    /// id will be stored in the set containing this id, marking it as compatible with
    /// the versions within.
    package var existingCompatibleBuildID: String = String()

    /// When set, establishes the compatible set being targeted as the overall default for the
    /// queue. If a different set was the current default, the targeted set will replace it as
    /// the new default.
    package var makeSetDefault: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package struct MergeSets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A build ID in the set whose default will become the merged set default
    package var primarySetBuildID: String = String()

    /// A build ID in the set which will be merged into the primary set
    package var secondarySetBuildID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Must be set, the task queue to interrogate about worker id compatibility.
  package var taskQueue: String = String()

  /// Limits how many compatible sets will be returned. Specify 1 to only return the current
  /// default major version set. 0 returns all sets.
  package var maxSets: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Major version sets, in order from oldest to newest. The last element of the list will always
  /// be the current default major version. IE: New workflows will target the most recent version
  /// in that version set.
  ///
  /// There may be fewer sets returned than exist, if the request chose to limit this response.
  package var majorVersionSets: [Temporal_Api_Taskqueue_V1_CompatibleVersionSet] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// (-- api-linter: core::0134::request-mask-required=disabled
///     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
/// (-- api-linter: core::0134::request-resource-required=disabled
///     aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var taskQueue: String = String()

  /// A valid conflict_token can be taken from the previous
  /// ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
  /// An invalid token will cause this request to fail, ensuring that if the rules
  /// for this Task Queue have been modified between the previous and current
  /// operation, the request will fail instead of causing an unpredictable mutation.
  package var conflictToken: Data = Data()

  package var operation: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.OneOf_Operation? = nil

  package var insertAssignmentRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule {
    get {
      if case .insertAssignmentRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule()
    }
    set {operation = .insertAssignmentRule(newValue)}
  }

  package var replaceAssignmentRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule {
    get {
      if case .replaceAssignmentRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule()
    }
    set {operation = .replaceAssignmentRule(newValue)}
  }

  package var deleteAssignmentRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule {
    get {
      if case .deleteAssignmentRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule()
    }
    set {operation = .deleteAssignmentRule(newValue)}
  }

  package var addCompatibleRedirectRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule {
    get {
      if case .addCompatibleRedirectRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule()
    }
    set {operation = .addCompatibleRedirectRule(newValue)}
  }

  package var replaceCompatibleRedirectRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule {
    get {
      if case .replaceCompatibleRedirectRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule()
    }
    set {operation = .replaceCompatibleRedirectRule(newValue)}
  }

  package var deleteCompatibleRedirectRule: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule {
    get {
      if case .deleteCompatibleRedirectRule(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule()
    }
    set {operation = .deleteCompatibleRedirectRule(newValue)}
  }

  package var commitBuildID: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId {
    get {
      if case .commitBuildID(let v)? = operation {return v}
      return Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId()
    }
    set {operation = .commitBuildID(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Operation: Equatable, Sendable {
    case insertAssignmentRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule)
    case replaceAssignmentRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule)
    case deleteAssignmentRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule)
    case addCompatibleRedirectRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule)
    case replaceCompatibleRedirectRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule)
    case deleteCompatibleRedirectRule(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule)
    case commitBuildID(Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId)

  }

  /// Inserts the rule to the list of assignment rules for this Task Queue.
  /// The rules are evaluated in order, starting from index 0. The first
  /// applicable rule will be applied and the rest will be ignored.
  package struct InsertBuildIdAssignmentRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Use this option to insert the rule in a particular index. By
    /// default, the new rule is inserted at the beginning of the list
    /// (index 0). If the given index is too larger the rule will be
    /// inserted at the end of the list.
    package var ruleIndex: Int32 = 0

    package var rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule {
      get {return _rule ?? Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {return self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule? = nil
  }

  /// Replaces the assignment rule at a given index.
  package struct ReplaceBuildIdAssignmentRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var ruleIndex: Int32 = 0

    package var rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule {
      get {return _rule ?? Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {return self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    /// By default presence of one unconditional rule is enforced, otherwise
    /// the replace operation will be rejected. Set `force` to true to
    /// bypass this validation. An unconditional assignment rule:
    ///   - Has no hint filter
    ///   - Has no ramp
    package var force: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule? = nil
  }

  package struct DeleteBuildIdAssignmentRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var ruleIndex: Int32 = 0

    /// By default presence of one unconditional rule is enforced, otherwise
    /// the delete operation will be rejected. Set `force` to true to
    /// bypass this validation. An unconditional assignment rule:
    ///   - Has no hint filter
    ///   - Has no ramp
    package var force: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  /// Adds the rule to the list of redirect rules for this Task Queue. There
  /// can be at most one redirect rule for each distinct Source Build ID.
  package struct AddCompatibleBuildIdRedirectRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule {
      get {return _rule ?? Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {return self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule? = nil
  }

  /// Replaces the routing rule with the given source Build ID.
  package struct ReplaceCompatibleBuildIdRedirectRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule {
      get {return _rule ?? Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {return self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule? = nil
  }

  package struct DeleteCompatibleBuildIdRedirectRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var sourceBuildID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  /// This command is intended to be used to complete the rollout of a Build
  /// ID and cleanup unnecessary rules possibly created during a gradual
  /// rollout. Specifically, this command will make the following changes
  /// atomically:
  ///  1. Adds an assignment rule (with full ramp) for the target Build ID at
  ///     the end of the list.
  ///  2. Removes all previously added assignment rules to the given target
  ///     Build ID (if any).
  ///  3. Removes any fully-ramped assignment rule for other Build IDs.
  package struct CommitBuildId: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var targetBuildID: String = String()

    /// To prevent committing invalid Build IDs, we reject the request if no
    /// pollers has been seen recently for this Build ID. Use the `force`
    /// option to disable this validation.
    package var force: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var assignmentRules: [Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule] = []

  package var compatibleRedirectRules: [Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule] = []

  /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
  /// ensure that the rules were not modified between the two updates, which
  /// could lead to lost updates and other confusion.
  package var conflictToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var taskQueue: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
package struct Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var assignmentRules: [Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule] = []

  package var compatibleRedirectRules: [Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule] = []

  /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
  /// ensure that the rules were not modified between this List and the Update,
  /// which could lead to lost updates and other confusion.
  package var conflictToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
/// Deprecated. Use `DescribeTaskQueue`.
package struct Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
  /// The number of build ids that can be queried in a single API call is limited.
  /// Open source users can adjust this limit by setting the server's dynamic config value for
  /// `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
  package var buildIds: [String] = []

  /// Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
  /// build ids in the namespace.
  /// Must specify at least one task queue if querying for an unversioned worker.
  /// The number of task queues that the server will fetch reachability information for is limited.
  /// See the `GetWorkerTaskReachabilityResponse` documentation for more information.
  package var taskQueues: [String] = []

  /// Type of reachability to query for.
  /// `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
  /// Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
  /// Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
  /// unspecified.
  /// See the TaskReachability docstring for information about each enum variant.
  package var reachability: Temporal_Api_Enums_V1_TaskReachability = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release]
/// Deprecated. Use `DescribeTaskQueue`.
package struct Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Task reachability, broken down by build id and then task queue.
  /// When requesting a large number of task queues or all task queues associated with the given build ids in a
  /// namespace, all task queues will be listed in the response but some of them may not contain reachability
  /// information due to a server enforced limit. When reaching the limit, task queues that reachability information
  /// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
  /// another call to get the reachability for those task queues.
  ///
  /// Open source users can adjust this limit by setting the server's dynamic config value for
  /// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
  package var buildIDReachability: [Temporal_Api_Taskqueue_V1_BuildIdReachability] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// (-- api-linter: core::0134=disabled
///     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
package struct Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace name of the target Workflow.
  package var namespace: String = String()

  /// The target Workflow Id and (optionally) a specific Run Id thereof.
  /// (-- api-linter: core::0203::optional=disabled
  ///     aip.dev/not-precedent: false positive triggered by the word "optional" --)
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// If set, this call will error if the most recent (if no Run Id is set on
  /// `workflow_execution`), or specified (if it is) Workflow Execution is not
  /// part of the same execution chain as this Id.
  package var firstExecutionRunID: String = String()

  /// Specifies client's intent to wait for Update results.
  /// NOTE: This field works together with API call timeout which is limited by
  /// server timeout (maximum wait time). If server timeout is expired before
  /// user specified timeout, API call returns even if specified stage is not reached.
  /// Actual reached stage will be included in the response.
  package var waitPolicy: Temporal_Api_Update_V1_WaitPolicy {
    get {return _waitPolicy ?? Temporal_Api_Update_V1_WaitPolicy()}
    set {_waitPolicy = newValue}
  }
  /// Returns true if `waitPolicy` has been explicitly set.
  package var hasWaitPolicy: Bool {return self._waitPolicy != nil}
  /// Clears the value of `waitPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearWaitPolicy() {self._waitPolicy = nil}

  /// The request information that will be delivered all the way down to the
  /// Workflow Execution.
  package var request: Temporal_Api_Update_V1_Request {
    get {return _request ?? Temporal_Api_Update_V1_Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  package var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  package mutating func clearRequest() {self._request = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _waitPolicy: Temporal_Api_Update_V1_WaitPolicy? = nil
  fileprivate var _request: Temporal_Api_Update_V1_Request? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enough information for subsequent poll calls if needed. Never null.
  package var updateRef: Temporal_Api_Update_V1_UpdateRef {
    get {return _updateRef ?? Temporal_Api_Update_V1_UpdateRef()}
    set {_updateRef = newValue}
  }
  /// Returns true if `updateRef` has been explicitly set.
  package var hasUpdateRef: Bool {return self._updateRef != nil}
  /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateRef() {self._updateRef = nil}

  /// The outcome of the Update if and only if the Workflow Update
  /// has completed. If this response is being returned before the Update has
  /// completed then this field will not be set.
  package var outcome: Temporal_Api_Update_V1_Outcome {
    get {return _outcome ?? Temporal_Api_Update_V1_Outcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  package var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  package mutating func clearOutcome() {self._outcome = nil}

  /// The most advanced lifecycle stage that the Update is known to have
  /// reached, where lifecycle stages are ordered
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
  /// UNSPECIFIED will be returned if and only if the server's maximum wait
  /// time was reached before the Update reached the stage specified in the
  /// request WaitPolicy, and before the context deadline expired; clients may
  /// may then retry the call as needed.
  package var stage: Temporal_Api_Enums_V1_UpdateWorkflowExecutionLifecycleStage = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _updateRef: Temporal_Api_Update_V1_UpdateRef? = nil
  fileprivate var _outcome: Temporal_Api_Update_V1_Outcome? = nil
}

package struct Temporal_Api_Workflowservice_V1_StartBatchOperationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace that contains the batch operation
  package var namespace: String = String()

  /// Visibility query defines the the group of workflow to apply the batch operation
  /// This field and `executions` are mutually exclusive
  package var visibilityQuery: String = String()

  /// Job ID defines the unique ID for the batch job
  package var jobID: String = String()

  /// Reason to perform the batch operation
  package var reason: String = String()

  /// Executions to apply the batch operation
  /// This field and `visibility_query` are mutually exclusive
  package var executions: [Temporal_Api_Common_V1_WorkflowExecution] = []

  /// Limit for the number of operations processed per second within this batch.
  /// Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
  /// overload and minimize potential delays in executing ongoing tasks for user workers.
  /// Note that when no explicit limit is provided, the server will operate according to its limit defined by the
  /// dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
  /// server's configured limit.
  package var maxOperationsPerSecond: Float = 0

  /// Operation input
  package var operation: Temporal_Api_Workflowservice_V1_StartBatchOperationRequest.OneOf_Operation? = nil

  package var terminationOperation: Temporal_Api_Batch_V1_BatchOperationTermination {
    get {
      if case .terminationOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationTermination()
    }
    set {operation = .terminationOperation(newValue)}
  }

  package var signalOperation: Temporal_Api_Batch_V1_BatchOperationSignal {
    get {
      if case .signalOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationSignal()
    }
    set {operation = .signalOperation(newValue)}
  }

  package var cancellationOperation: Temporal_Api_Batch_V1_BatchOperationCancellation {
    get {
      if case .cancellationOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationCancellation()
    }
    set {operation = .cancellationOperation(newValue)}
  }

  package var deletionOperation: Temporal_Api_Batch_V1_BatchOperationDeletion {
    get {
      if case .deletionOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationDeletion()
    }
    set {operation = .deletionOperation(newValue)}
  }

  package var resetOperation: Temporal_Api_Batch_V1_BatchOperationReset {
    get {
      if case .resetOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationReset()
    }
    set {operation = .resetOperation(newValue)}
  }

  package var updateWorkflowOptionsOperation: Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions {
    get {
      if case .updateWorkflowOptionsOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions()
    }
    set {operation = .updateWorkflowOptionsOperation(newValue)}
  }

  package var unpauseActivitiesOperation: Temporal_Api_Batch_V1_BatchOperationUnpauseActivities {
    get {
      if case .unpauseActivitiesOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationUnpauseActivities()
    }
    set {operation = .unpauseActivitiesOperation(newValue)}
  }

  package var resetActivitiesOperation: Temporal_Api_Batch_V1_BatchOperationResetActivities {
    get {
      if case .resetActivitiesOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationResetActivities()
    }
    set {operation = .resetActivitiesOperation(newValue)}
  }

  package var updateActivityOptionsOperation: Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions {
    get {
      if case .updateActivityOptionsOperation(let v)? = operation {return v}
      return Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions()
    }
    set {operation = .updateActivityOptionsOperation(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Operation input
  package enum OneOf_Operation: Equatable, Sendable {
    case terminationOperation(Temporal_Api_Batch_V1_BatchOperationTermination)
    case signalOperation(Temporal_Api_Batch_V1_BatchOperationSignal)
    case cancellationOperation(Temporal_Api_Batch_V1_BatchOperationCancellation)
    case deletionOperation(Temporal_Api_Batch_V1_BatchOperationDeletion)
    case resetOperation(Temporal_Api_Batch_V1_BatchOperationReset)
    case updateWorkflowOptionsOperation(Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions)
    case unpauseActivitiesOperation(Temporal_Api_Batch_V1_BatchOperationUnpauseActivities)
    case resetActivitiesOperation(Temporal_Api_Batch_V1_BatchOperationResetActivities)
    case updateActivityOptionsOperation(Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions)

  }

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_StartBatchOperationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_StopBatchOperationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace that contains the batch operation
  package var namespace: String = String()

  /// Batch job id
  package var jobID: String = String()

  /// Reason to stop a batch operation
  package var reason: String = String()

  /// Identity of the operator
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_StopBatchOperationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeBatchOperationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace that contains the batch operation
  package var namespace: String = String()

  /// Batch job id
  package var jobID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeBatchOperationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch operation type
  package var operationType: Temporal_Api_Enums_V1_BatchOperationType = .unspecified

  /// Batch job ID
  package var jobID: String = String()

  /// Batch operation state
  package var state: Temporal_Api_Enums_V1_BatchOperationState = .unspecified

  /// Batch operation start time
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {self._startTime = nil}

  /// Batch operation close time
  package var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_closeTime = newValue}
  }
  /// Returns true if `closeTime` has been explicitly set.
  package var hasCloseTime: Bool {return self._closeTime != nil}
  /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
  package mutating func clearCloseTime() {self._closeTime = nil}

  /// Total operation count
  package var totalOperationCount: Int64 = 0

  /// Complete operation count
  package var completeOperationCount: Int64 = 0

  /// Failure operation count
  package var failureOperationCount: Int64 = 0

  /// Identity indicates the operator identity
  package var identity: String = String()

  /// Reason indicates the reason to stop a operation
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListBatchOperationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace that contains the batch operation
  package var namespace: String = String()

  /// List page size
  package var pageSize: Int32 = 0

  /// Next page token
  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListBatchOperationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// BatchOperationInfo contains the basic info about batch operation
  package var operationInfo: [Temporal_Api_Batch_V1_BatchOperationInfo] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace of the Workflow Execution to which the Update was
  /// originally issued.
  package var namespace: String = String()

  /// The Update reference returned in the initial UpdateWorkflowExecutionResponse.
  package var updateRef: Temporal_Api_Update_V1_UpdateRef {
    get {return _updateRef ?? Temporal_Api_Update_V1_UpdateRef()}
    set {_updateRef = newValue}
  }
  /// Returns true if `updateRef` has been explicitly set.
  package var hasUpdateRef: Bool {return self._updateRef != nil}
  /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateRef() {self._updateRef = nil}

  /// The identity of the worker/client who is polling this Update outcome.
  package var identity: String = String()

  /// Specifies client's intent to wait for Update results.
  /// Omit to request a non-blocking poll.
  package var waitPolicy: Temporal_Api_Update_V1_WaitPolicy {
    get {return _waitPolicy ?? Temporal_Api_Update_V1_WaitPolicy()}
    set {_waitPolicy = newValue}
  }
  /// Returns true if `waitPolicy` has been explicitly set.
  package var hasWaitPolicy: Bool {return self._waitPolicy != nil}
  /// Clears the value of `waitPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearWaitPolicy() {self._waitPolicy = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _updateRef: Temporal_Api_Update_V1_UpdateRef? = nil
  fileprivate var _waitPolicy: Temporal_Api_Update_V1_WaitPolicy? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outcome of the update if and only if the update has completed. If
  /// this response is being returned before the update has completed (e.g. due
  /// to the specification of a wait policy that only waits on
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
  /// not be set.
  package var outcome: Temporal_Api_Update_V1_Outcome {
    get {return _outcome ?? Temporal_Api_Update_V1_Outcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  package var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  package mutating func clearOutcome() {self._outcome = nil}

  /// The most advanced lifecycle stage that the Update is known to have
  /// reached, where lifecycle stages are ordered
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
  /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
  /// UNSPECIFIED will be returned if and only if the server's maximum wait
  /// time was reached before the Update reached the stage specified in the
  /// request WaitPolicy, and before the context deadline expired; clients may
  /// may then retry the call as needed.
  package var stage: Temporal_Api_Enums_V1_UpdateWorkflowExecutionLifecycleStage = .unspecified

  /// Sufficient information to address this Update.
  package var updateRef: Temporal_Api_Update_V1_UpdateRef {
    get {return _updateRef ?? Temporal_Api_Update_V1_UpdateRef()}
    set {_updateRef = newValue}
  }
  /// Returns true if `updateRef` has been explicitly set.
  package var hasUpdateRef: Bool {return self._updateRef != nil}
  /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateRef() {self._updateRef = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _outcome: Temporal_Api_Update_V1_Outcome? = nil
  fileprivate var _updateRef: Temporal_Api_Update_V1_UpdateRef? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollNexusTaskQueueRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  /// Information about this worker's build identifier and if it is choosing to use the versioning
  /// feature. See the `WorkerVersionCapabilities` docstring for more.
  /// Deprecated. Replaced by deployment_options.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities {
    get {return _workerVersionCapabilities ?? Temporal_Api_Common_V1_WorkerVersionCapabilities()}
    set {_workerVersionCapabilities = newValue}
  }
  /// Returns true if `workerVersionCapabilities` has been explicitly set.
  package var hasWorkerVersionCapabilities: Bool {return self._workerVersionCapabilities != nil}
  /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

  /// Worker deployment options that user has set in the worker.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  /// Worker info to be sent to the server.
  package var workerHeartbeat: [Temporal_Api_Worker_V1_WorkerHeartbeat] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An opaque unique identifier for this task for correlating a completion request the embedded request.
  package var taskToken: Data = Data()

  /// Embedded request as translated from the incoming frontend request.
  package var request: Temporal_Api_Nexus_V1_Request {
    get {return _request ?? Temporal_Api_Nexus_V1_Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  package var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  package mutating func clearRequest() {self._request = nil}

  /// Server-advised information the SDK may use to adjust its poller count.
  package var pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision {
    get {return _pollerScalingDecision ?? Temporal_Api_Taskqueue_V1_PollerScalingDecision()}
    set {_pollerScalingDecision = newValue}
  }
  /// Returns true if `pollerScalingDecision` has been explicitly set.
  package var hasPollerScalingDecision: Bool {return self._pollerScalingDecision != nil}
  /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
  package mutating func clearPollerScalingDecision() {self._pollerScalingDecision = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _request: Temporal_Api_Nexus_V1_Request? = nil
  fileprivate var _pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// A unique identifier for this task as received via a poll response.
  package var taskToken: Data = Data()

  /// Embedded response to be translated into a frontend response.
  package var response: Temporal_Api_Nexus_V1_Response {
    get {return _response ?? Temporal_Api_Nexus_V1_Response()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  package var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  package mutating func clearResponse() {self._response = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _response: Temporal_Api_Nexus_V1_Response? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// A unique identifier for this task.
  package var taskToken: Data = Data()

  /// The error the handler failed with.
  package var error: Temporal_Api_Nexus_V1_HandlerError {
    get {return _error ?? Temporal_Api_Nexus_V1_HandlerError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  package var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  package mutating func clearError() {self._error = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _error: Temporal_Api_Nexus_V1_HandlerError? = nil
}

package struct Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// List of operations to execute within a single workflow.
  ///
  /// Preconditions:
  /// - The list of operations must not be empty.
  /// - The workflow ids must match across operations.
  /// - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
  ///
  /// Note that additional operation-specific restrictions have to be considered.
  package var operations: [Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.Operation] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct Operation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var operation: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.Operation.OneOf_Operation? = nil

    /// Additional restrictions:
    /// - setting `cron_schedule` is invalid
    /// - setting `request_eager_execution` is invalid
    /// - setting `workflow_start_delay` is invalid
    package var startWorkflow: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest {
      get {
        if case .startWorkflow(let v)? = operation {return v}
        return Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest()
      }
      set {operation = .startWorkflow(newValue)}
    }

    /// Additional restrictions:
    /// - setting `first_execution_run_id` is invalid
    /// - setting `workflow_execution.run_id` is invalid
    package var updateWorkflow: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest {
      get {
        if case .updateWorkflow(let v)? = operation {return v}
        return Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest()
      }
      set {operation = .updateWorkflow(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Operation: Equatable, Sendable {
      /// Additional restrictions:
      /// - setting `cron_schedule` is invalid
      /// - setting `request_eager_execution` is invalid
      /// - setting `workflow_start_delay` is invalid
      case startWorkflow(Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest)
      /// Additional restrictions:
      /// - setting `first_execution_run_id` is invalid
      /// - setting `workflow_execution.run_id` is invalid
      case updateWorkflow(Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest)

    }

    package init() {}
  }

  package init() {}
}

/// IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination ("Update-with-Start") when both
///   1. the workflow update for the requested update ID has already completed, and
///   2. the workflow for the requested workflow ID has already been closed,
/// then you'll receive
///   - an update response containing the update's outcome, and
///   - a start response with a `status` field that reflects the workflow's current state.
package struct Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var responses: [Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.Response] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct Response: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var response: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.Response.OneOf_Response? = nil

    package var startWorkflow: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse {
      get {
        if case .startWorkflow(let v)? = response {return v}
        return Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse()
      }
      set {response = .startWorkflow(newValue)}
    }

    package var updateWorkflow: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse {
      get {
        if case .updateWorkflow(let v)? = response {return v}
        return Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse()
      }
      set {response = .updateWorkflow(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Response: Equatable, Sendable {
      case startWorkflow(Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse)
      case updateWorkflow(Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse)

    }

    package init() {}
  }

  package init() {}
}

/// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions
package struct Temporal_Api_Workflowservice_V1_UpdateActivityOptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity
  package var namespace: String = String()

  /// Execution info of the workflow which scheduled this activity
  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// The identity of the client who initiated this request
  package var identity: String = String()

  /// Activity options. Partial updates are accepted and controlled by update_mask
  package var activityOptions: Temporal_Api_Activity_V1_ActivityOptions {
    get {return _activityOptions ?? Temporal_Api_Activity_V1_ActivityOptions()}
    set {_activityOptions = newValue}
  }
  /// Returns true if `activityOptions` has been explicitly set.
  package var hasActivityOptions: Bool {return self._activityOptions != nil}
  /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
  package mutating func clearActivityOptions() {self._activityOptions = nil}

  /// Controls which fields from `activity_options` will be applied
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  /// either activity id, activity type or update_all must be provided
  package var activity: Temporal_Api_Workflowservice_V1_UpdateActivityOptionsRequest.OneOf_Activity? = nil

  /// Only activity with this ID will be updated.
  package var id: String {
    get {
      if case .id(let v)? = activity {return v}
      return String()
    }
    set {activity = .id(newValue)}
  }

  /// Update all running activities of this type.
  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  /// Update all running activities.
  package var matchAll: Bool {
    get {
      if case .matchAll(let v)? = activity {return v}
      return false
    }
    set {activity = .matchAll(newValue)}
  }

  /// If set, the activity options will be restored to the default.
  /// Default options are then options activity was created with.
  /// They are part of the first SCHEDULE event.
  /// This flag cannot be combined with any other option; if you supply
  /// restore_original together with other options, the request will be rejected.
  package var restoreOriginal: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// either activity id, activity type or update_all must be provided
  package enum OneOf_Activity: Equatable, Sendable {
    /// Only activity with this ID will be updated.
    case id(String)
    /// Update all running activities of this type.
    case type(String)
    /// Update all running activities.
    case matchAll(Bool)

  }

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _activityOptions: Temporal_Api_Activity_V1_ActivityOptions? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateActivityOptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Activity options after an update
  package var activityOptions: Temporal_Api_Activity_V1_ActivityOptions {
    get {return _activityOptions ?? Temporal_Api_Activity_V1_ActivityOptions()}
    set {_activityOptions = newValue}
  }
  /// Returns true if `activityOptions` has been explicitly set.
  package var hasActivityOptions: Bool {return self._activityOptions != nil}
  /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
  package mutating func clearActivityOptions() {self._activityOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _activityOptions: Temporal_Api_Activity_V1_ActivityOptions? = nil
}

package struct Temporal_Api_Workflowservice_V1_PauseActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity.
  package var namespace: String = String()

  /// Execution info of the workflow which scheduled this activity
  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// either activity id or activity type must be provided
  package var activity: Temporal_Api_Workflowservice_V1_PauseActivityRequest.OneOf_Activity? = nil

  /// Only the activity with this ID will be paused.
  package var id: String {
    get {
      if case .id(let v)? = activity {return v}
      return String()
    }
    set {activity = .id(newValue)}
  }

  /// Pause all running activities of this type.
  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  /// Reason to pause the activity.
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// either activity id or activity type must be provided
  package enum OneOf_Activity: Equatable, Sendable {
    /// Only the activity with this ID will be paused.
    case id(String)
    /// Pause all running activities of this type.
    case type(String)

  }

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_PauseActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_UnpauseActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity.
  package var namespace: String = String()

  /// Execution info of the workflow which scheduled this activity
  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// either activity id or activity type must be provided
  package var activity: Temporal_Api_Workflowservice_V1_UnpauseActivityRequest.OneOf_Activity? = nil

  /// Only the activity with this ID will be unpaused.
  package var id: String {
    get {
      if case .id(let v)? = activity {return v}
      return String()
    }
    set {activity = .id(newValue)}
  }

  /// Unpause all running activities with of this type.
  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  /// Unpause all running activities.
  package var unpauseAll: Bool {
    get {
      if case .unpauseAll(let v)? = activity {return v}
      return false
    }
    set {activity = .unpauseAll(newValue)}
  }

  /// Providing this flag will also reset the number of attempts.
  package var resetAttempts: Bool = false

  /// Providing this flag will also reset the heartbeat details.
  package var resetHeartbeat: Bool = false

  /// If set, the activity will start at a random time within the specified jitter duration.
  package var jitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_jitter = newValue}
  }
  /// Returns true if `jitter` has been explicitly set.
  package var hasJitter: Bool {return self._jitter != nil}
  /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
  package mutating func clearJitter() {self._jitter = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// either activity id or activity type must be provided
  package enum OneOf_Activity: Equatable, Sendable {
    /// Only the activity with this ID will be unpaused.
    case id(String)
    /// Unpause all running activities with of this type.
    case type(String)
    /// Unpause all running activities.
    case unpauseAll(Bool)

  }

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Workflowservice_V1_UnpauseActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities
package struct Temporal_Api_Workflowservice_V1_ResetActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the workflow which scheduled this activity.
  package var namespace: String = String()

  /// Execution info of the workflow which scheduled this activity
  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// either activity id, activity type or update_all must be provided
  package var activity: Temporal_Api_Workflowservice_V1_ResetActivityRequest.OneOf_Activity? = nil

  /// Only activity with this ID will be reset.
  package var id: String {
    get {
      if case .id(let v)? = activity {return v}
      return String()
    }
    set {activity = .id(newValue)}
  }

  /// Reset all running activities with of this type.
  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  /// Reset all running activities.
  package var matchAll: Bool {
    get {
      if case .matchAll(let v)? = activity {return v}
      return false
    }
    set {activity = .matchAll(newValue)}
  }

  /// Indicates that activity should reset heartbeat details.
  /// This flag will be applied only to the new instance of the activity.
  package var resetHeartbeat: Bool = false

  /// If activity is paused, it will remain paused after reset
  package var keepPaused: Bool = false

  /// If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
  /// (unless it is paused and keep_paused is set)
  package var jitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_jitter = newValue}
  }
  /// Returns true if `jitter` has been explicitly set.
  package var hasJitter: Bool {return self._jitter != nil}
  /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
  package mutating func clearJitter() {self._jitter = nil}

  /// If set, the activity options will be restored to the defaults.
  /// Default options are then options activity was created with.
  /// They are part of the first SCHEDULE event.
  package var restoreOriginalOptions: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// either activity id, activity type or update_all must be provided
  package enum OneOf_Activity: Equatable, Sendable {
    /// Only activity with this ID will be reset.
    case id(String)
    /// Reset all running activities with of this type.
    case type(String)
    /// Reset all running activities.
    case matchAll(Bool)

  }

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Workflowservice_V1_ResetActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Keep the parameters in sync with:
///   - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
///   - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
package struct Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace name of the target Workflow.
  package var namespace: String = String()

  /// The target Workflow Id and (optionally) a specific Run Id thereof.
  /// (-- api-linter: core::0203::optional=disabled
  ///     aip.dev/not-precedent: false positive triggered by the word "optional" --)
  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// Workflow Execution options. Partial updates are accepted and controlled by update_mask.
  package var workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions {
    get {return _workflowExecutionOptions ?? Temporal_Api_Workflow_V1_WorkflowExecutionOptions()}
    set {_workflowExecutionOptions = newValue}
  }
  /// Returns true if `workflowExecutionOptions` has been explicitly set.
  package var hasWorkflowExecutionOptions: Bool {return self._workflowExecutionOptions != nil}
  /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

  /// Controls which fields from `workflow_execution_options` will be applied.
  /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Workflow Execution options after update.
  package var workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions {
    get {return _workflowExecutionOptions ?? Temporal_Api_Workflow_V1_WorkflowExecutionOptions()}
    set {_workflowExecutionOptions = newValue}
  }
  /// Returns true if `workflowExecutionOptions` has been explicitly set.
  package var hasWorkflowExecutionOptions: Bool {return self._workflowExecutionOptions != nil}
  /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_DescribeDeploymentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_DescribeDeploymentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var deploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo {
    get {return _deploymentInfo ?? Temporal_Api_Deployment_V1_DeploymentInfo()}
    set {_deploymentInfo = newValue}
  }
  /// Returns true if `deploymentInfo` has been explicitly set.
  package var hasDeploymentInfo: Bool {return self._deploymentInfo != nil}
  /// Clears the value of `deploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentInfo() {self._deploymentInfo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// Required.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return self._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

  /// Report stats for task queues which have been polled by this version.
  package var reportTaskQueueStats: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workerDeploymentVersionInfo: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo {
    get {return _workerDeploymentVersionInfo ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo()}
    set {_workerDeploymentVersionInfo = newValue}
  }
  /// Returns true if `workerDeploymentVersionInfo` has been explicitly set.
  package var hasWorkerDeploymentVersionInfo: Bool {return self._workerDeploymentVersionInfo != nil}
  /// Clears the value of `workerDeploymentVersionInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerDeploymentVersionInfo() {self._workerDeploymentVersionInfo = nil}

  /// All the Task Queues that have ever polled from this Deployment version.
  package var versionTaskQueues: [Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse.VersionTaskQueue] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (-- api-linter: core::0123::resource-annotation=disabled --)
  package struct VersionTaskQueue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var name: String = String()

    package var type: Temporal_Api_Enums_V1_TaskQueueType = .unspecified

    /// Only set if `report_task_queue_stats` is set on the request.
    package var stats: Temporal_Api_Taskqueue_V1_TaskQueueStats {
      get {return _stats ?? Temporal_Api_Taskqueue_V1_TaskQueueStats()}
      set {_stats = newValue}
    }
    /// Returns true if `stats` has been explicitly set.
    package var hasStats: Bool {return self._stats != nil}
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    package mutating func clearStats() {self._stats = nil}

    /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
    /// Only set if `report_task_queue_stats` is set to true in the request.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "by" is used to clarify the key. --)
    package var statsByPriorityKey: Dictionary<Int32,Temporal_Api_Taskqueue_V1_TaskQueueStats> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _stats: Temporal_Api_Taskqueue_V1_TaskQueueStats? = nil
  }

  package init() {}

  fileprivate var _workerDeploymentVersionInfo: Temporal_Api_Deployment_V1_WorkerDeploymentVersionInfo? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deploymentName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This value is returned so that it can be optionally passed to APIs
  /// that write to the Worker Deployment state to ensure that the state
  /// did not change between this read and a future write.
  package var conflictToken: Data = Data()

  package var workerDeploymentInfo: Temporal_Api_Deployment_V1_WorkerDeploymentInfo {
    get {return _workerDeploymentInfo ?? Temporal_Api_Deployment_V1_WorkerDeploymentInfo()}
    set {_workerDeploymentInfo = newValue}
  }
  /// Returns true if `workerDeploymentInfo` has been explicitly set.
  package var hasWorkerDeploymentInfo: Bool {return self._workerDeploymentInfo != nil}
  /// Clears the value of `workerDeploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerDeploymentInfo() {self._workerDeploymentInfo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerDeploymentInfo: Temporal_Api_Deployment_V1_WorkerDeploymentInfo? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_ListDeploymentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  /// Optional. Use to filter based on exact series name match.
  package var seriesName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_ListDeploymentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var nextPageToken: Data = Data()

  package var deployments: [Temporal_Api_Deployment_V1_DeploymentListInfo] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_SetCurrentDeploymentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  /// Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
  /// when describing a deployment. It is a good place for information such as operator name,
  /// links to internal deployment pipelines, etc.
  package var updateMetadata: Temporal_Api_Deployment_V1_UpdateDeploymentMetadata {
    get {return _updateMetadata ?? Temporal_Api_Deployment_V1_UpdateDeploymentMetadata()}
    set {_updateMetadata = newValue}
  }
  /// Returns true if `updateMetadata` has been explicitly set.
  package var hasUpdateMetadata: Bool {return self._updateMetadata != nil}
  /// Clears the value of `updateMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMetadata() {self._updateMetadata = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
  fileprivate var _updateMetadata: Temporal_Api_Deployment_V1_UpdateDeploymentMetadata? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_SetCurrentDeploymentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var currentDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo {
    get {return _currentDeploymentInfo ?? Temporal_Api_Deployment_V1_DeploymentInfo()}
    set {_currentDeploymentInfo = newValue}
  }
  /// Returns true if `currentDeploymentInfo` has been explicitly set.
  package var hasCurrentDeploymentInfo: Bool {return self._currentDeploymentInfo != nil}
  /// Clears the value of `currentDeploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentDeploymentInfo() {self._currentDeploymentInfo = nil}

  /// Info of the deployment that was current before executing this operation.
  package var previousDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo {
    get {return _previousDeploymentInfo ?? Temporal_Api_Deployment_V1_DeploymentInfo()}
    set {_previousDeploymentInfo = newValue}
  }
  /// Returns true if `previousDeploymentInfo` has been explicitly set.
  package var hasPreviousDeploymentInfo: Bool {return self._previousDeploymentInfo != nil}
  /// Clears the value of `previousDeploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearPreviousDeploymentInfo() {self._previousDeploymentInfo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _currentDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo? = nil
  fileprivate var _previousDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo? = nil
}

/// Set/unset the Current Version of a Worker Deployment.
package struct Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deploymentName: String = String()

  /// Deprecated. Use `build_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// The build id of the Version that you want to set as Current.
  /// Pass an empty value to set the Current Version to nil.
  /// A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
  package var buildID: String = String()

  /// Optional. This can be the value of conflict_token from a Describe, or another Worker
  /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
  /// Deployment's configuration has been modified between the API call that generated the
  /// token and this one.
  package var conflictToken: Data = Data()

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  /// Optional. By default this request would be rejected if not all the expected Task Queues are
  /// being polled by the new Version, to protect against accidental removal of Task Queues, or
  /// worker health issues. Pass `true` here to bypass this protection.
  /// The set of expected Task Queues is the set of all the Task Queues that were ever poller by
  /// the existing Current Version of the Deployment, with the following exclusions:
  ///   - Task Queues that are not used anymore (inferred by having empty backlog and a task
  ///     add_rate of 0.)
  ///   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
  ///     having a different Current Version than the Current Version of this deployment.)
  /// WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
  /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
  /// pollers have not reached to the server yet. Only set this if you expect those pollers to
  /// never arrive.
  package var ignoreMissingTaskQueues: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This value is returned so that it can be optionally passed to APIs
  /// that write to the Worker Deployment state to ensure that the state
  /// did not change between this API call and a future write.
  package var conflictToken: Data = Data()

  /// Deprecated. Use `previous_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var previousVersion: String = String()

  /// The version that was current before executing this operation.
  package var previousDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _previousDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_previousDeploymentVersion = newValue}
  }
  /// Returns true if `previousDeploymentVersion` has been explicitly set.
  package var hasPreviousDeploymentVersion: Bool {return self._previousDeploymentVersion != nil}
  /// Clears the value of `previousDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearPreviousDeploymentVersion() {self._previousDeploymentVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _previousDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

/// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage.
package struct Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deploymentName: String = String()

  /// Deprecated. Use `build_id`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// The build id of the Version that you want to ramp traffic to.
  /// Pass an empty value to set the Ramping Version to nil.
  /// A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
  package var buildID: String = String()

  /// Ramp percentage to set. Valid range: [0,100].
  package var percentage: Float = 0

  /// Optional. This can be the value of conflict_token from a Describe, or another Worker
  /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
  /// Deployment's configuration has been modified between the API call that generated the
  /// token and this one.
  package var conflictToken: Data = Data()

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  /// Optional. By default this request would be rejected if not all the expected Task Queues are
  /// being polled by the new Version, to protect against accidental removal of Task Queues, or
  /// worker health issues. Pass `true` here to bypass this protection.
  /// The set of expected Task Queues equals to all the Task Queues ever polled from the existing
  /// Current Version of the Deployment, with the following exclusions:
  ///   - Task Queues that are not used anymore (inferred by having empty backlog and a task
  ///     add_rate of 0.)
  ///   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
  ///     having a different Current Version than the Current Version of this deployment.)
  /// WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
  /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
  /// pollers have not reached to the server yet. Only set this if you expect those pollers to
  /// never arrive.
  /// Note: this check only happens when the ramping version is about to change, not every time
  /// that the percentage changes. Also note that the check is against the deployment's Current
  /// Version, not the previous Ramping Version.
  package var ignoreMissingTaskQueues: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This value is returned so that it can be optionally passed to APIs
  /// that write to the Worker Deployment state to ensure that the state
  /// did not change between this API call and a future write.
  package var conflictToken: Data = Data()

  /// Deprecated. Use `previous_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var previousVersion: String = String()

  /// The version that was ramping before executing this operation.
  package var previousDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _previousDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_previousDeploymentVersion = newValue}
  }
  /// Returns true if `previousDeploymentVersion` has been explicitly set.
  package var hasPreviousDeploymentVersion: Bool {return self._previousDeploymentVersion != nil}
  /// Clears the value of `previousDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearPreviousDeploymentVersion() {self._previousDeploymentVersion = nil}

  /// The ramping version percentage before executing this operation.
  package var previousPercentage: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _previousDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

package struct Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var nextPageToken: Data = Data()

  /// The list of worker deployments.
  package var workerDeployments: [Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse.WorkerDeploymentSummary] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// (-- api-linter: core::0123::resource-annotation=disabled --)
  /// A subset of WorkerDeploymentInfo
  package struct WorkerDeploymentSummary: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var name: String {
      get {return _storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createTime = newValue}
    }
    /// Returns true if `createTime` has been explicitly set.
    package var hasCreateTime: Bool {return _storage._createTime != nil}
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

    package var routingConfig: Temporal_Api_Deployment_V1_RoutingConfig {
      get {return _storage._routingConfig ?? Temporal_Api_Deployment_V1_RoutingConfig()}
      set {_uniqueStorage()._routingConfig = newValue}
    }
    /// Returns true if `routingConfig` has been explicitly set.
    package var hasRoutingConfig: Bool {return _storage._routingConfig != nil}
    /// Clears the value of `routingConfig`. Subsequent reads from it will return its default value.
    package mutating func clearRoutingConfig() {_uniqueStorage()._routingConfig = nil}

    /// Summary of the version that was added most recently in the Worker Deployment.
    package var latestVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
      get {return _storage._latestVersionSummary ?? Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
      set {_uniqueStorage()._latestVersionSummary = newValue}
    }
    /// Returns true if `latestVersionSummary` has been explicitly set.
    package var hasLatestVersionSummary: Bool {return _storage._latestVersionSummary != nil}
    /// Clears the value of `latestVersionSummary`. Subsequent reads from it will return its default value.
    package mutating func clearLatestVersionSummary() {_uniqueStorage()._latestVersionSummary = nil}

    /// Summary of the current version of the Worker Deployment. 
    package var currentVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
      get {return _storage._currentVersionSummary ?? Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
      set {_uniqueStorage()._currentVersionSummary = newValue}
    }
    /// Returns true if `currentVersionSummary` has been explicitly set.
    package var hasCurrentVersionSummary: Bool {return _storage._currentVersionSummary != nil}
    /// Clears the value of `currentVersionSummary`. Subsequent reads from it will return its default value.
    package mutating func clearCurrentVersionSummary() {_uniqueStorage()._currentVersionSummary = nil}

    /// Summary of the ramping version of the Worker Deployment.
    package var rampingVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
      get {return _storage._rampingVersionSummary ?? Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
      set {_uniqueStorage()._rampingVersionSummary = newValue}
    }
    /// Returns true if `rampingVersionSummary` has been explicitly set.
    package var hasRampingVersionSummary: Bool {return _storage._rampingVersionSummary != nil}
    /// Clears the value of `rampingVersionSummary`. Subsequent reads from it will return its default value.
    package mutating func clearRampingVersionSummary() {_uniqueStorage()._rampingVersionSummary = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  package init() {}
}

/// Used for manual deletion of Versions. User can delete a Version only when all the
/// following conditions are met:
///  - It is not the Current or Ramping Version of its Deployment.
///  - It has no active pollers (none of the task queues in the Version have pollers)
///  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
///    can be skipped by passing `skip-drainage=true`.
package struct Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// Required.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return self._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

  /// Pass to force deletion even if the Version is draining. In this case the open pinned
  /// workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
  package var skipDrainage: Bool = false

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Deletes records of (an old) Deployment. A deployment can only be deleted if
/// it has no Version in it.
package struct Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deploymentName: String = String()

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Used to update the user-defined metadata of a Worker Deployment Version.
package struct Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// Required.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return self._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

  package var upsertEntries: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  /// List of keys to remove from the metadata.
  package var removeEntries: [String] = []

  /// Optional. The identity of the client who initiated this request.
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Full metadata after performing the update.
  package var metadata: Temporal_Api_Deployment_V1_VersionMetadata {
    get {return _metadata ?? Temporal_Api_Deployment_V1_VersionMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  package var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  package mutating func clearMetadata() {self._metadata = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _metadata: Temporal_Api_Deployment_V1_VersionMetadata? = nil
}

/// Returns the Current Deployment of a deployment series.
/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_GetCurrentDeploymentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var seriesName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_GetCurrentDeploymentResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var currentDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo {
    get {return _currentDeploymentInfo ?? Temporal_Api_Deployment_V1_DeploymentInfo()}
    set {_currentDeploymentInfo = newValue}
  }
  /// Returns true if `currentDeploymentInfo` has been explicitly set.
  package var hasCurrentDeploymentInfo: Bool {return self._currentDeploymentInfo != nil}
  /// Clears the value of `currentDeploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentDeploymentInfo() {self._currentDeploymentInfo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _currentDeploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
}

/// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
package struct Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var deploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo {
    get {return _deploymentInfo ?? Temporal_Api_Deployment_V1_DeploymentInfo()}
    set {_deploymentInfo = newValue}
  }
  /// Returns true if `deploymentInfo` has been explicitly set.
  package var hasDeploymentInfo: Bool {return self._deploymentInfo != nil}
  /// Clears the value of `deploymentInfo`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentInfo() {self._deploymentInfo = nil}

  package var reachability: Temporal_Api_Enums_V1_DeploymentReachability = .unspecified

  /// Reachability level might come from server cache. This timestamp specifies when the value
  /// was actually calculated.
  package var lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastUpdateTime = newValue}
  }
  /// Returns true if `lastUpdateTime` has been explicitly set.
  package var hasLastUpdateTime: Bool {return self._lastUpdateTime != nil}
  /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastUpdateTime() {self._lastUpdateTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentInfo: Temporal_Api_Deployment_V1_DeploymentInfo? = nil
  fileprivate var _lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Workflowservice_V1_CreateWorkflowRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// The rule specification .
  package var spec: Temporal_Api_Rules_V1_WorkflowRuleSpec {
    get {return _spec ?? Temporal_Api_Rules_V1_WorkflowRuleSpec()}
    set {_spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return self._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {self._spec = nil}

  /// If true, the rule will be applied to the currently running workflows via batch job.
  /// If not set , the rule will only be applied when triggering condition is satisfied.
  /// visibility_query in the rule will be used to select the workflows to apply the rule to.
  package var forceScan: Bool = false

  /// Used to de-dupe requests. Typically should be UUID.
  package var requestID: String = String()

  /// Identity of the actor who created the rule. Will be stored with the rule.
  package var identity: String = String()

  /// Rule description.Will be stored with the rule.
  package var description_p: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _spec: Temporal_Api_Rules_V1_WorkflowRuleSpec? = nil
}

package struct Temporal_Api_Workflowservice_V1_CreateWorkflowRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Created rule.
  package var rule: Temporal_Api_Rules_V1_WorkflowRule {
    get {return _rule ?? Temporal_Api_Rules_V1_WorkflowRule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  package var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  package mutating func clearRule() {self._rule = nil}

  /// Batch Job ID if force-scan flag was provided. Otherwise empty.
  package var jobID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rule: Temporal_Api_Rules_V1_WorkflowRule? = nil
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// User-specified ID of the rule to read. Unique within the namespace.
  package var ruleID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The rule that was read.
  package var rule: Temporal_Api_Rules_V1_WorkflowRule {
    get {return _rule ?? Temporal_Api_Rules_V1_WorkflowRule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  package var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  package mutating func clearRule() {self._rule = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rule: Temporal_Api_Rules_V1_WorkflowRule? = nil
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// ID of the rule to delete. Unique within the namespace.
  package var ruleID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkflowRulesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkflowRulesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var rules: [Temporal_Api_Rules_V1_WorkflowRule] = []

  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  /// Execution info of the workflow which scheduled this activity
  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// Either provide id of existing rule, or rule specification
  package var rule: Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleRequest.OneOf_Rule? = nil

  package var id: String {
    get {
      if case .id(let v)? = rule {return v}
      return String()
    }
    set {rule = .id(newValue)}
  }

  /// Note: Rule ID and expiration date are not used in the trigger request.
  package var spec: Temporal_Api_Rules_V1_WorkflowRuleSpec {
    get {
      if case .spec(let v)? = rule {return v}
      return Temporal_Api_Rules_V1_WorkflowRuleSpec()
    }
    set {rule = .spec(newValue)}
  }

  /// The identity of the client who initiated this request
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Either provide id of existing rule, or rule specification
  package enum OneOf_Rule: Equatable, Sendable {
    case id(String)
    /// Note: Rule ID and expiration date are not used in the trigger request.
    case spec(Temporal_Api_Rules_V1_WorkflowRuleSpec)

  }

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// True is the rule was applied, based on the rule conditions (predicate/visibility_query).
  package var applied: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace this worker belongs to.
  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  package var workerHeartbeat: [Temporal_Api_Worker_V1_WorkerHeartbeat] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkersRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var pageSize: Int32 = 0

  package var nextPageToken: Data = Data()

  /// `query` in ListWorkers is used to filter workers based on worker status info.
  /// The following worker status attributes are expected are supported as part of the query:
  ///* WorkerInstanceKey
  ///* WorkerIdentity
  ///* HostName
  ///* TaskQueue
  ///* DeploymentName
  ///* BuildId
  ///* SdkName
  ///* SdkVersion
  ///* StartTime
  ///* LastHeartbeatTime
  ///* Status
  /// Currently metrics are not supported as a part of ListWorkers query.
  package var query: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_ListWorkersResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workersInfo: [Temporal_Api_Worker_V1_WorkerInfo] = []

  /// Next page token
  package var nextPageToken: Data = Data()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var identity: String = String()

  /// Selects the task queue to update.
  package var taskQueue: String = String()

  package var taskQueueType: Temporal_Api_Enums_V1_TaskQueueType = .unspecified

  /// Update to queue-wide rate limit.
  /// If not set, this configuration is unchanged.
  /// NOTE: A limit set by the worker is overriden; and restored again when reset.
  /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
  package var updateQueueRateLimit: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate {
    get {return _updateQueueRateLimit ?? Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate()}
    set {_updateQueueRateLimit = newValue}
  }
  /// Returns true if `updateQueueRateLimit` has been explicitly set.
  package var hasUpdateQueueRateLimit: Bool {return self._updateQueueRateLimit != nil}
  /// Clears the value of `updateQueueRateLimit`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateQueueRateLimit() {self._updateQueueRateLimit = nil}

  /// Update to the default fairness key rate limit.
  /// If not set, this configuration is unchanged.
  /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
  package var updateFairnessKeyRateLimitDefault: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate {
    get {return _updateFairnessKeyRateLimitDefault ?? Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate()}
    set {_updateFairnessKeyRateLimitDefault = newValue}
  }
  /// Returns true if `updateFairnessKeyRateLimitDefault` has been explicitly set.
  package var hasUpdateFairnessKeyRateLimitDefault: Bool {return self._updateFairnessKeyRateLimitDefault != nil}
  /// Clears the value of `updateFairnessKeyRateLimitDefault`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateFairnessKeyRateLimitDefault() {self._updateFairnessKeyRateLimitDefault = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct RateLimitUpdate: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Rate Limit to be updated
    package var rateLimit: Temporal_Api_Taskqueue_V1_RateLimit {
      get {return _rateLimit ?? Temporal_Api_Taskqueue_V1_RateLimit()}
      set {_rateLimit = newValue}
    }
    /// Returns true if `rateLimit` has been explicitly set.
    package var hasRateLimit: Bool {return self._rateLimit != nil}
    /// Clears the value of `rateLimit`. Subsequent reads from it will return its default value.
    package mutating func clearRateLimit() {self._rateLimit = nil}

    /// Reason for why the rate limit was set.
    package var reason: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rateLimit: Temporal_Api_Taskqueue_V1_RateLimit? = nil
  }

  package init() {}

  fileprivate var _updateQueueRateLimit: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate? = nil
  fileprivate var _updateFairnessKeyRateLimitDefault: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var config: Temporal_Api_Taskqueue_V1_TaskQueueConfig {
    get {return _config ?? Temporal_Api_Taskqueue_V1_TaskQueueConfig()}
    set {_config = newValue}
  }
  /// Returns true if `config` has been explicitly set.
  package var hasConfig: Bool {return self._config != nil}
  /// Clears the value of `config`. Subsequent reads from it will return its default value.
  package mutating func clearConfig() {self._config = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _config: Temporal_Api_Taskqueue_V1_TaskQueueConfig? = nil
}

package struct Temporal_Api_Workflowservice_V1_FetchWorkerConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace this worker belongs to.
  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// Reason for sending worker command, can be used for audit purpose.
  package var reason: String = String()

  /// Defines which workers should receive this command.
  /// only single worker is supported at this time.
  package var selector: Temporal_Api_Common_V1_WorkerSelector {
    get {return _selector ?? Temporal_Api_Common_V1_WorkerSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  package var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  package mutating func clearSelector() {self._selector = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _selector: Temporal_Api_Common_V1_WorkerSelector? = nil
}

package struct Temporal_Api_Workflowservice_V1_FetchWorkerConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The worker configuration.
  package var workerConfig: Temporal_Api_Sdk_V1_WorkerConfig {
    get {return _workerConfig ?? Temporal_Api_Sdk_V1_WorkerConfig()}
    set {_workerConfig = newValue}
  }
  /// Returns true if `workerConfig` has been explicitly set.
  package var hasWorkerConfig: Bool {return self._workerConfig != nil}
  /// Clears the value of `workerConfig`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerConfig() {self._workerConfig = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerConfig: Temporal_Api_Sdk_V1_WorkerConfig? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateWorkerConfigRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace this worker belongs to.
  package var namespace: String = String()

  /// The identity of the client who initiated this request.
  package var identity: String = String()

  /// Reason for sending worker command, can be used for audit purpose.
  package var reason: String = String()

  /// Partial updates are accepted and controlled by update_mask.
  /// The worker configuration to set.
  package var workerConfig: Temporal_Api_Sdk_V1_WorkerConfig {
    get {return _workerConfig ?? Temporal_Api_Sdk_V1_WorkerConfig()}
    set {_workerConfig = newValue}
  }
  /// Returns true if `workerConfig` has been explicitly set.
  package var hasWorkerConfig: Bool {return self._workerConfig != nil}
  /// Clears the value of `workerConfig`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerConfig() {self._workerConfig = nil}

  /// Controls which fields from `worker_config` will be applied
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  /// Defines which workers should receive this command.
  package var selector: Temporal_Api_Common_V1_WorkerSelector {
    get {return _selector ?? Temporal_Api_Common_V1_WorkerSelector()}
    set {_selector = newValue}
  }
  /// Returns true if `selector` has been explicitly set.
  package var hasSelector: Bool {return self._selector != nil}
  /// Clears the value of `selector`. Subsequent reads from it will return its default value.
  package mutating func clearSelector() {self._selector = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerConfig: Temporal_Api_Sdk_V1_WorkerConfig? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  fileprivate var _selector: Temporal_Api_Common_V1_WorkerSelector? = nil
}

package struct Temporal_Api_Workflowservice_V1_UpdateWorkerConfigResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var response: Temporal_Api_Workflowservice_V1_UpdateWorkerConfigResponse.OneOf_Response? = nil

  /// The worker configuration. Will be returned if the command was sent to a single worker.
  package var workerConfig: Temporal_Api_Sdk_V1_WorkerConfig {
    get {
      if case .workerConfig(let v)? = response {return v}
      return Temporal_Api_Sdk_V1_WorkerConfig()
    }
    set {response = .workerConfig(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Response: Equatable, Sendable {
    /// The worker configuration. Will be returned if the command was sent to a single worker.
    case workerConfig(Temporal_Api_Sdk_V1_WorkerConfig)

  }

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.workflowservice.v1"

extension Temporal_Api_Workflowservice_V1_RegisterNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RegisterNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}description\0\u{3}owner_email\0\u{3}workflow_execution_retention_period\0\u{1}clusters\0\u{3}active_cluster_name\0\u{1}data\0\u{3}security_token\0\u{3}is_global_namespace\0\u{3}history_archival_state\0\u{3}history_archival_uri\0\u{3}visibility_archival_state\0\u{3}visibility_archival_uri\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerEmail) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionRetentionPeriod) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.activeClusterName) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.securityToken) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isGlobalNamespace) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.historyArchivalState) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.historyArchivalUri) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.visibilityArchivalState) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.visibilityArchivalUri) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ownerEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerEmail, fieldNumber: 3)
    }
    try { if let v = self._workflowExecutionRetentionPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 5)
    }
    if !self.activeClusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.activeClusterName, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 7)
    }
    if !self.securityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.securityToken, fieldNumber: 8)
    }
    if self.isGlobalNamespace != false {
      try visitor.visitSingularBoolField(value: self.isGlobalNamespace, fieldNumber: 9)
    }
    if self.historyArchivalState != .unspecified {
      try visitor.visitSingularEnumField(value: self.historyArchivalState, fieldNumber: 10)
    }
    if !self.historyArchivalUri.isEmpty {
      try visitor.visitSingularStringField(value: self.historyArchivalUri, fieldNumber: 11)
    }
    if self.visibilityArchivalState != .unspecified {
      try visitor.visitSingularEnumField(value: self.visibilityArchivalState, fieldNumber: 12)
    }
    if !self.visibilityArchivalUri.isEmpty {
      try visitor.visitSingularStringField(value: self.visibilityArchivalUri, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RegisterNamespaceRequest, rhs: Temporal_Api_Workflowservice_V1_RegisterNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ownerEmail != rhs.ownerEmail {return false}
    if lhs._workflowExecutionRetentionPeriod != rhs._workflowExecutionRetentionPeriod {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.activeClusterName != rhs.activeClusterName {return false}
    if lhs.data != rhs.data {return false}
    if lhs.securityToken != rhs.securityToken {return false}
    if lhs.isGlobalNamespace != rhs.isGlobalNamespace {return false}
    if lhs.historyArchivalState != rhs.historyArchivalState {return false}
    if lhs.historyArchivalUri != rhs.historyArchivalUri {return false}
    if lhs.visibilityArchivalState != rhs.visibilityArchivalState {return false}
    if lhs.visibilityArchivalUri != rhs.visibilityArchivalUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RegisterNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RegisterNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RegisterNamespaceResponse, rhs: Temporal_Api_Workflowservice_V1_RegisterNamespaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListNamespacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListNamespacesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0\u{3}namespace_filter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._namespaceFilter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try { if let v = self._namespaceFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListNamespacesRequest, rhs: Temporal_Api_Workflowservice_V1_ListNamespacesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._namespaceFilter != rhs._namespaceFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListNamespacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListNamespacesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespaces\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.namespaces) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaces, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListNamespacesResponse, rhs: Temporal_Api_Workflowservice_V1_ListNamespacesResponse) -> Bool {
    if lhs.namespaces != rhs.namespaces {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeNamespaceRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}namespace_info\0\u{1}config\0\u{3}replication_config\0\u{3}failover_version\0\u{3}is_global_namespace\0\u{3}failover_history\0")

  fileprivate class _StorageClass {
    var _namespaceInfo: Temporal_Api_Namespace_V1_NamespaceInfo? = nil
    var _config: Temporal_Api_Namespace_V1_NamespaceConfig? = nil
    var _replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig? = nil
    var _failoverVersion: Int64 = 0
    var _isGlobalNamespace: Bool = false
    var _failoverHistory: [Temporal_Api_Replication_V1_FailoverStatus] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespaceInfo = source._namespaceInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _failoverVersion = source._failoverVersion
      _isGlobalNamespace = source._isGlobalNamespace
      _failoverHistory = source._failoverHistory
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._failoverVersion) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isGlobalNamespace) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._failoverHistory) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._namespaceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._failoverVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failoverVersion, fieldNumber: 4)
      }
      if _storage._isGlobalNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._isGlobalNamespace, fieldNumber: 5)
      }
      if !_storage._failoverHistory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._failoverHistory, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeNamespaceResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeNamespaceResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespaceInfo != rhs_storage._namespaceInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._failoverVersion != rhs_storage._failoverVersion {return false}
        if _storage._isGlobalNamespace != rhs_storage._isGlobalNamespace {return false}
        if _storage._failoverHistory != rhs_storage._failoverHistory {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}update_info\0\u{1}config\0\u{3}replication_config\0\u{3}security_token\0\u{3}delete_bad_binary\0\u{3}promote_namespace\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _updateInfo: Temporal_Api_Namespace_V1_UpdateNamespaceInfo? = nil
    var _config: Temporal_Api_Namespace_V1_NamespaceConfig? = nil
    var _replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig? = nil
    var _securityToken: String = String()
    var _deleteBadBinary: String = String()
    var _promoteNamespace: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _updateInfo = source._updateInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _securityToken = source._securityToken
      _deleteBadBinary = source._deleteBadBinary
      _promoteNamespace = source._promoteNamespace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._updateInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._securityToken) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._deleteBadBinary) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._promoteNamespace) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      try { if let v = _storage._updateInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._securityToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityToken, fieldNumber: 5)
      }
      if !_storage._deleteBadBinary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deleteBadBinary, fieldNumber: 6)
      }
      if _storage._promoteNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._promoteNamespace, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateNamespaceRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateNamespaceRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._updateInfo != rhs_storage._updateInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._securityToken != rhs_storage._securityToken {return false}
        if _storage._deleteBadBinary != rhs_storage._deleteBadBinary {return false}
        if _storage._promoteNamespace != rhs_storage._promoteNamespace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}namespace_info\0\u{1}config\0\u{3}replication_config\0\u{3}failover_version\0\u{3}is_global_namespace\0")

  fileprivate class _StorageClass {
    var _namespaceInfo: Temporal_Api_Namespace_V1_NamespaceInfo? = nil
    var _config: Temporal_Api_Namespace_V1_NamespaceConfig? = nil
    var _replicationConfig: Temporal_Api_Replication_V1_NamespaceReplicationConfig? = nil
    var _failoverVersion: Int64 = 0
    var _isGlobalNamespace: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespaceInfo = source._namespaceInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _failoverVersion = source._failoverVersion
      _isGlobalNamespace = source._isGlobalNamespace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._failoverVersion) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isGlobalNamespace) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._namespaceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._failoverVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failoverVersion, fieldNumber: 4)
      }
      if _storage._isGlobalNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._isGlobalNamespace, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateNamespaceResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateNamespaceResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespaceInfo != rhs_storage._namespaceInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._failoverVersion != rhs_storage._failoverVersion {return false}
        if _storage._isGlobalNamespace != rhs_storage._isGlobalNamespace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeprecateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeprecateNamespaceRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}security_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.securityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.securityToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeprecateNamespaceRequest, rhs: Temporal_Api_Workflowservice_V1_DeprecateNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.securityToken != rhs.securityToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeprecateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeprecateNamespaceResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeprecateNamespaceResponse, rhs: Temporal_Api_Workflowservice_V1_DeprecateNamespaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}identity\0\u{3}request_id\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}request_eager_execution\0\u{3}continued_failure\0\u{3}last_completion_result\0\u{3}workflow_start_delay\0\u{3}completion_callbacks\0\u{3}workflow_id_conflict_policy\0\u{3}user_metadata\0\u{1}links\0\u{3}versioning_override\0\u{3}on_conflict_options\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _identity: String = String()
    var _requestID: String = String()
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _workflowIDConflictPolicy: Temporal_Api_Enums_V1_WorkflowIdConflictPolicy = .unspecified
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _requestEagerExecution: Bool = false
    var _continuedFailure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastCompletionResult: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _completionCallbacks: [Temporal_Api_Common_V1_Callback] = []
    var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
    var _links: [Temporal_Api_Common_V1_Link] = []
    var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
    var _onConflictOptions: Temporal_Api_Workflow_V1_OnConflictOptions? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _identity = source._identity
      _requestID = source._requestID
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _workflowIDConflictPolicy = source._workflowIDConflictPolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _requestEagerExecution = source._requestEagerExecution
      _continuedFailure = source._continuedFailure
      _lastCompletionResult = source._lastCompletionResult
      _workflowStartDelay = source._workflowStartDelay
      _completionCallbacks = source._completionCallbacks
      _userMetadata = source._userMetadata
      _links = source._links
      _versioningOverride = source._versioningOverride
      _onConflictOptions = source._onConflictOptions
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._requestEagerExecution) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._continuedFailure) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._workflowStartDelay) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._completionCallbacks) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDConflictPolicy) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._onConflictOptions) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 9)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 13)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._requestEagerExecution != false {
        try visitor.visitSingularBoolField(value: _storage._requestEagerExecution, fieldNumber: 17)
      }
      try { if let v = _storage._continuedFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._workflowStartDelay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._completionCallbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._completionCallbacks, fieldNumber: 21)
      }
      if _storage._workflowIDConflictPolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDConflictPolicy, fieldNumber: 22)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 24)
      }
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._onConflictOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._workflowIDConflictPolicy != rhs_storage._workflowIDConflictPolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._requestEagerExecution != rhs_storage._requestEagerExecution {return false}
        if _storage._continuedFailure != rhs_storage._continuedFailure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._workflowStartDelay != rhs_storage._workflowStartDelay {return false}
        if _storage._completionCallbacks != rhs_storage._completionCallbacks {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._onConflictOptions != rhs_storage._onConflictOptions {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{3}eager_workflow_task\0\u{1}started\0\u{1}link\0\u{1}status\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._eagerWorkflowTask) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._link) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try { if let v = self._eagerWorkflowTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 3)
    }
    try { if let v = self._link {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.started != rhs.started {return false}
    if lhs.status != rhs.status {return false}
    if lhs._eagerWorkflowTask != rhs._eagerWorkflowTask {return false}
    if lhs._link != rhs._link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}wait_new_event\0\u{3}history_event_filter_type\0\u{3}skip_archival\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.waitNewEvent) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.historyEventFilterType) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.skipArchival) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 3)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    if self.waitNewEvent != false {
      try visitor.visitSingularBoolField(value: self.waitNewEvent, fieldNumber: 5)
    }
    if self.historyEventFilterType != .unspecified {
      try visitor.visitSingularEnumField(value: self.historyEventFilterType, fieldNumber: 6)
    }
    if self.skipArchival != false {
      try visitor.visitSingularBoolField(value: self.skipArchival, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryRequest, rhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.waitNewEvent != rhs.waitNewEvent {return false}
    if lhs.historyEventFilterType != rhs.historyEventFilterType {return false}
    if lhs.skipArchival != rhs.skipArchival {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}history\0\u{3}raw_history\0\u{3}next_page_token\0\u{1}archived\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rawHistory) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rawHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawHistory, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryResponse, rhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryResponse) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.rawHistory != rhs.rawHistory {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryReverseRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}maximum_page_size\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 3)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseRequest, rhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryReverseResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}history\0\u{4}\u{2}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseResponse, rhs: Temporal_Api_Workflowservice_V1_GetWorkflowExecutionHistoryReverseResponse) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollWorkflowTaskQueueRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{1}identity\0\u{3}binary_checksum\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 4)
    }
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._workerHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueRequest, rhs: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs._workerHeartbeat != rhs._workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollWorkflowTaskQueueResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}previous_started_event_id\0\u{3}started_event_id\0\u{1}attempt\0\u{3}backlog_count_hint\0\u{1}history\0\u{3}next_page_token\0\u{1}query\0\u{3}workflow_execution_task_queue\0\u{3}scheduled_time\0\u{3}started_time\0\u{1}queries\0\u{1}messages\0\u{3}poller_scaling_decision\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _previousStartedEventID: Int64 = 0
    var _startedEventID: Int64 = 0
    var _attempt: Int32 = 0
    var _backlogCountHint: Int64 = 0
    var _history: Temporal_Api_History_V1_History? = nil
    var _nextPageToken: Data = Data()
    var _query: Temporal_Api_Query_V1_WorkflowQuery? = nil
    var _workflowExecutionTaskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _queries: Dictionary<String,Temporal_Api_Query_V1_WorkflowQuery> = [:]
    var _messages: [Temporal_Api_Protocol_V1_Message] = []
    var _pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _workflowExecution = source._workflowExecution
      _workflowType = source._workflowType
      _previousStartedEventID = source._previousStartedEventID
      _startedEventID = source._startedEventID
      _attempt = source._attempt
      _backlogCountHint = source._backlogCountHint
      _history = source._history
      _nextPageToken = source._nextPageToken
      _query = source._query
      _workflowExecutionTaskQueue = source._workflowExecutionTaskQueue
      _scheduledTime = source._scheduledTime
      _startedTime = source._startedTime
      _queries = source._queries
      _messages = source._messages
      _pollerScalingDecision = source._pollerScalingDecision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._previousStartedEventID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._startedEventID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._backlogCountHint) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._history) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._nextPageToken) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTaskQueue) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 14: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Query_V1_WorkflowQuery>.self, value: &_storage._queries) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._messages) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._pollerScalingDecision) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._previousStartedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._previousStartedEventID, fieldNumber: 4)
      }
      if _storage._startedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startedEventID, fieldNumber: 5)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 6)
      }
      if _storage._backlogCountHint != 0 {
        try visitor.visitSingularInt64Field(value: _storage._backlogCountHint, fieldNumber: 7)
      }
      try { if let v = _storage._history {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._nextPageToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextPageToken, fieldNumber: 9)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._workflowExecutionTaskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._queries.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Query_V1_WorkflowQuery>.self, value: _storage._queries, fieldNumber: 14)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 15)
      }
      try { if let v = _storage._pollerScalingDecision {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse, rhs: Temporal_Api_Workflowservice_V1_PollWorkflowTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._previousStartedEventID != rhs_storage._previousStartedEventID {return false}
        if _storage._startedEventID != rhs_storage._startedEventID {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._backlogCountHint != rhs_storage._backlogCountHint {return false}
        if _storage._history != rhs_storage._history {return false}
        if _storage._nextPageToken != rhs_storage._nextPageToken {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._workflowExecutionTaskQueue != rhs_storage._workflowExecutionTaskQueue {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._queries != rhs_storage._queries {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._pollerScalingDecision != rhs_storage._pollerScalingDecision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskCompletedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}commands\0\u{1}identity\0\u{3}sticky_attributes\0\u{3}return_new_workflow_task\0\u{3}force_create_new_workflow_task\0\u{3}binary_checksum\0\u{3}query_results\0\u{1}namespace\0\u{3}worker_version_stamp\0\u{1}messages\0\u{3}sdk_metadata\0\u{3}metering_metadata\0\u{1}capabilities\0\u{1}deployment\0\u{3}versioning_behavior\0\u{3}deployment_options\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _commands: [Temporal_Api_Command_V1_Command] = []
    var _identity: String = String()
    var _stickyAttributes: Temporal_Api_Taskqueue_V1_StickyExecutionAttributes? = nil
    var _returnNewWorkflowTask: Bool = false
    var _forceCreateNewWorkflowTask: Bool = false
    var _binaryChecksum: String = String()
    var _queryResults: Dictionary<String,Temporal_Api_Query_V1_WorkflowQueryResult> = [:]
    var _namespace: String = String()
    var _workerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
    var _messages: [Temporal_Api_Protocol_V1_Message] = []
    var _sdkMetadata: Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata? = nil
    var _meteringMetadata: Temporal_Api_Common_V1_MeteringMetadata? = nil
    var _capabilities: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities? = nil
    var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
    var _versioningBehavior: Temporal_Api_Enums_V1_VersioningBehavior = .unspecified
    var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _commands = source._commands
      _identity = source._identity
      _stickyAttributes = source._stickyAttributes
      _returnNewWorkflowTask = source._returnNewWorkflowTask
      _forceCreateNewWorkflowTask = source._forceCreateNewWorkflowTask
      _binaryChecksum = source._binaryChecksum
      _queryResults = source._queryResults
      _namespace = source._namespace
      _workerVersionStamp = source._workerVersionStamp
      _messages = source._messages
      _sdkMetadata = source._sdkMetadata
      _meteringMetadata = source._meteringMetadata
      _capabilities = source._capabilities
      _deployment = source._deployment
      _versioningBehavior = source._versioningBehavior
      _deploymentOptions = source._deploymentOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._commands) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stickyAttributes) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._returnNewWorkflowTask) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._forceCreateNewWorkflowTask) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._binaryChecksum) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Query_V1_WorkflowQueryResult>.self, value: &_storage._queryResults) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._workerVersionStamp) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._messages) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sdkMetadata) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._meteringMetadata) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._capabilities) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._versioningBehavior) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentOptions) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      if !_storage._commands.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._commands, fieldNumber: 2)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 3)
      }
      try { if let v = _storage._stickyAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._returnNewWorkflowTask != false {
        try visitor.visitSingularBoolField(value: _storage._returnNewWorkflowTask, fieldNumber: 5)
      }
      if _storage._forceCreateNewWorkflowTask != false {
        try visitor.visitSingularBoolField(value: _storage._forceCreateNewWorkflowTask, fieldNumber: 6)
      }
      if !_storage._binaryChecksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._binaryChecksum, fieldNumber: 7)
      }
      if !_storage._queryResults.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Query_V1_WorkflowQueryResult>.self, value: _storage._queryResults, fieldNumber: 8)
      }
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 9)
      }
      try { if let v = _storage._workerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 11)
      }
      try { if let v = _storage._sdkMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._meteringMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._versioningBehavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningBehavior, fieldNumber: 16)
      }
      try { if let v = _storage._deploymentOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._commands != rhs_storage._commands {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._stickyAttributes != rhs_storage._stickyAttributes {return false}
        if _storage._returnNewWorkflowTask != rhs_storage._returnNewWorkflowTask {return false}
        if _storage._forceCreateNewWorkflowTask != rhs_storage._forceCreateNewWorkflowTask {return false}
        if _storage._binaryChecksum != rhs_storage._binaryChecksum {return false}
        if _storage._queryResults != rhs_storage._queryResults {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workerVersionStamp != rhs_storage._workerVersionStamp {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._sdkMetadata != rhs_storage._sdkMetadata {return false}
        if _storage._meteringMetadata != rhs_storage._meteringMetadata {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._versioningBehavior != rhs_storage._versioningBehavior {return false}
        if _storage._deploymentOptions != rhs_storage._deploymentOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.protoMessageName + ".Capabilities"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}discard_speculative_workflow_task_with_events\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.discardSpeculativeWorkflowTaskWithEvents) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.discardSpeculativeWorkflowTaskWithEvents != false {
      try visitor.visitSingularBoolField(value: self.discardSpeculativeWorkflowTaskWithEvents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities, rhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedRequest.Capabilities) -> Bool {
    if lhs.discardSpeculativeWorkflowTaskWithEvents != rhs.discardSpeculativeWorkflowTaskWithEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskCompletedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task\0\u{3}activity_tasks\0\u{3}reset_history_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowTask) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.activityTasks) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.resetHistoryEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.activityTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityTasks, fieldNumber: 2)
    }
    if self.resetHistoryEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.resetHistoryEventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskCompletedResponse) -> Bool {
    if lhs._workflowTask != rhs._workflowTask {return false}
    if lhs.activityTasks != rhs.activityTasks {return false}
    if lhs.resetHistoryEventID != rhs.resetHistoryEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskFailedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}cause\0\u{1}failure\0\u{1}identity\0\u{3}binary_checksum\0\u{1}namespace\0\u{1}messages\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 5)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 6)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 7)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskFailedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondWorkflowTaskFailedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollActivityTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollActivityTaskQueueRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{1}identity\0\u{3}task_queue_metadata\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._taskQueueMetadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._taskQueueMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._workerHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollActivityTaskQueueRequest, rhs: Temporal_Api_Workflowservice_V1_PollActivityTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._taskQueueMetadata != rhs._taskQueueMetadata {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs._workerHeartbeat != rhs._workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollActivityTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollActivityTaskQueueResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}workflow_namespace\0\u{3}workflow_type\0\u{3}workflow_execution\0\u{3}activity_type\0\u{3}activity_id\0\u{1}header\0\u{1}input\0\u{3}heartbeat_details\0\u{3}scheduled_time\0\u{3}current_attempt_scheduled_time\0\u{3}started_time\0\u{1}attempt\0\u{3}schedule_to_close_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}poller_scaling_decision\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _workflowNamespace: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _activityType: Temporal_Api_Common_V1_ActivityType? = nil
    var _activityID: String = String()
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _heartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: Int32 = 0
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _pollerScalingDecision: Temporal_Api_Taskqueue_V1_PollerScalingDecision? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _workflowNamespace = source._workflowNamespace
      _workflowType = source._workflowType
      _workflowExecution = source._workflowExecution
      _activityType = source._activityType
      _activityID = source._activityID
      _header = source._header
      _input = source._input
      _heartbeatDetails = source._heartbeatDetails
      _scheduledTime = source._scheduledTime
      _currentAttemptScheduledTime = source._currentAttemptScheduledTime
      _startedTime = source._startedTime
      _attempt = source._attempt
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _pollerScalingDecision = source._pollerScalingDecision
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowNamespace) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatDetails) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._currentAttemptScheduledTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._pollerScalingDecision) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      if !_storage._workflowNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowNamespace, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 6)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._heartbeatDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._currentAttemptScheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 13)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._pollerScalingDecision {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollActivityTaskQueueResponse, rhs: Temporal_Api_Workflowservice_V1_PollActivityTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._workflowNamespace != rhs_storage._workflowNamespace {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._currentAttemptScheduledTime != rhs_storage._currentAttemptScheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._pollerScalingDecision != rhs_storage._pollerScalingDecision {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}details\0\u{1}identity\0\u{1}namespace\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatRequest, rhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cancel_requested\0\u{3}activity_paused\0\u{3}activity_reset\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.activityPaused) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityReset) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 1)
    }
    if self.activityPaused != false {
      try visitor.visitSingularBoolField(value: self.activityPaused, fieldNumber: 2)
    }
    if self.activityReset != false {
      try visitor.visitSingularBoolField(value: self.activityReset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatResponse, rhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatResponse) -> Bool {
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs.activityPaused != rhs.activityPaused {return false}
    if lhs.activityReset != rhs.activityReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatByIdRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}details\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdRequest, rhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatByIdResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cancel_requested\0\u{3}activity_paused\0\u{3}activity_reset\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.activityPaused) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityReset) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 1)
    }
    if self.activityPaused != false {
      try visitor.visitSingularBoolField(value: self.activityPaused, fieldNumber: 2)
    }
    if self.activityReset != false {
      try visitor.visitSingularBoolField(value: self.activityReset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdResponse, rhs: Temporal_Api_Workflowservice_V1_RecordActivityTaskHeartbeatByIdResponse) -> Bool {
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs.activityPaused != rhs.activityPaused {return false}
    if lhs.activityReset != rhs.activityReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}result\0\u{1}identity\0\u{1}namespace\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._result != rhs._result {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedByIdRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}result\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedByIdResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCompletedByIdResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}failure\0\u{1}identity\0\u{1}namespace\0\u{3}last_heartbeat_details\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failures\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedResponse) -> Bool {
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedByIdRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}failure\0\u{1}identity\0\u{3}last_heartbeat_details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedByIdResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failures\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskFailedByIdResponse) -> Bool {
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}details\0\u{1}identity\0\u{1}namespace\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledByIdRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}details\0\u{1}identity\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdRequest, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledByIdResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdResponse, rhs: Temporal_Api_Workflowservice_V1_RespondActivityTaskCanceledByIdResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}identity\0\u{3}request_id\0\u{3}first_execution_run_id\0\u{1}reason\0\u{1}links\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_RequestCancelWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}signal_name\0\u{1}input\0\u{1}identity\0\u{3}request_id\0\u{1}control\0\u{1}header\0\u{2}\u{2}links\0\u{c}\u{9}\u{1}")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 7)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.control != rhs.control {return false}
    if lhs._header != rhs._header {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_SignalWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalWithStartWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}identity\0\u{3}request_id\0\u{3}workflow_id_reuse_policy\0\u{3}signal_name\0\u{3}signal_input\0\u{1}control\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}workflow_start_delay\0\u{4}\u{2}workflow_id_conflict_policy\0\u{3}user_metadata\0\u{1}links\0\u{3}versioning_override\0\u{1}priority\0\u{c}\u{15}\u{1}")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _identity: String = String()
    var _requestID: String = String()
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _workflowIDConflictPolicy: Temporal_Api_Enums_V1_WorkflowIdConflictPolicy = .unspecified
    var _signalName: String = String()
    var _signalInput: Temporal_Api_Common_V1_Payloads? = nil
    var _control: String = String()
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
    var _links: [Temporal_Api_Common_V1_Link] = []
    var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _identity = source._identity
      _requestID = source._requestID
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _workflowIDConflictPolicy = source._workflowIDConflictPolicy
      _signalName = source._signalName
      _signalInput = source._signalInput
      _control = source._control
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _workflowStartDelay = source._workflowStartDelay
      _userMetadata = source._userMetadata
      _links = source._links
      _versioningOverride = source._versioningOverride
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._signalName) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._signalInput) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._control) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._workflowStartDelay) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDConflictPolicy) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 9)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      if !_storage._signalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signalName, fieldNumber: 12)
      }
      try { if let v = _storage._signalInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._control.isEmpty {
        try visitor.visitSingularStringField(value: _storage._control, fieldNumber: 14)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 16)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._workflowStartDelay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._workflowIDConflictPolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDConflictPolicy, fieldNumber: 22)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 24)
      }
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._workflowIDConflictPolicy != rhs_storage._workflowIDConflictPolicy {return false}
        if _storage._signalName != rhs_storage._signalName {return false}
        if _storage._signalInput != rhs_storage._signalInput {return false}
        if _storage._control != rhs_storage._control {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._workflowStartDelay != rhs_storage._workflowStartDelay {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalWithStartWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}started\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_SignalWithStartWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.started != rhs.started {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}reason\0\u{3}workflow_task_finish_event_id\0\u{3}request_id\0\u{3}reset_reapply_type\0\u{3}reset_reapply_exclude_types\0\u{3}post_reset_operations\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskFinishEventID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.resetReapplyType) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.resetReapplyExcludeTypes) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.postResetOperations) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if self.workflowTaskFinishEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskFinishEventID, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    if self.resetReapplyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetReapplyType, fieldNumber: 6)
    }
    if !self.resetReapplyExcludeTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.resetReapplyExcludeTypes, fieldNumber: 7)
    }
    if !self.postResetOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postResetOperations, fieldNumber: 8)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.workflowTaskFinishEventID != rhs.workflowTaskFinishEventID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resetReapplyType != rhs.resetReapplyType {return false}
    if lhs.resetReapplyExcludeTypes != rhs.resetReapplyExcludeTypes {return false}
    if lhs.postResetOperations != rhs.postResetOperations {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_ResetWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TerminateWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}reason\0\u{1}details\0\u{1}identity\0\u{3}first_execution_run_id\0\u{1}links\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 6)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TerminateWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_TerminateWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListOpenWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}start_time_filter\0\u{3}execution_filter\0\u{3}type_filter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTimeFilter) }()
      case 5: try {
        var v: Temporal_Api_Filter_V1_WorkflowExecutionFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .executionFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .executionFilter(v)
        }
      }()
      case 6: try {
        var v: Temporal_Api_Filter_V1_WorkflowTypeFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .typeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .typeFilter(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try { if let v = self._startTimeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.filters {
    case .executionFilter?: try {
      guard case .executionFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .typeFilter?: try {
      guard case .typeFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._startTimeFilter != rhs._startTimeFilter {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListOpenWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_ListOpenWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListClosedWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}start_time_filter\0\u{3}execution_filter\0\u{3}type_filter\0\u{3}status_filter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTimeFilter) }()
      case 5: try {
        var v: Temporal_Api_Filter_V1_WorkflowExecutionFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .executionFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .executionFilter(v)
        }
      }()
      case 6: try {
        var v: Temporal_Api_Filter_V1_WorkflowTypeFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .typeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .typeFilter(v)
        }
      }()
      case 7: try {
        var v: Temporal_Api_Filter_V1_StatusFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .statusFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .statusFilter(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try { if let v = self._startTimeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.filters {
    case .executionFilter?: try {
      guard case .executionFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .typeFilter?: try {
      guard case .typeFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .statusFilter?: try {
      guard case .statusFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._startTimeFilter != rhs._startTimeFilter {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListClosedWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_ListClosedWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_ListWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListArchivedWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListArchivedWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_ListArchivedWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScanWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScanWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_ScanWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CountWorkflowExecutionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsRequest, rhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CountWorkflowExecutionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}groups\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse, rhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse.AggregationGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse.protoMessageName + ".AggregationGroup"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_values\0\u{1}count\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupValues, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse.AggregationGroup, rhs: Temporal_Api_Workflowservice_V1_CountWorkflowExecutionsResponse.AggregationGroup) -> Bool {
    if lhs.groupValues != rhs.groupValues {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSearchAttributesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetSearchAttributesRequest, rhs: Temporal_Api_Workflowservice_V1_GetSearchAttributesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSearchAttributesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}keys\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: &self.keys) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Enums_V1_IndexedValueType>.self, value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetSearchAttributesResponse, rhs: Temporal_Api_Workflowservice_V1_GetSearchAttributesResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondQueryTaskCompletedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}completed_type\0\u{3}query_result\0\u{3}error_message\0\u{2}\u{2}namespace\0\u{1}failure\0\u{1}cause\0\u{c}\u{5}\u{1}")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.completedType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.completedType != .unspecified {
      try visitor.visitSingularEnumField(value: self.completedType, fieldNumber: 2)
    }
    try { if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 6)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.completedType != rhs.completedType {return false}
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondQueryTaskCompletedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondQueryTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetStickyTaskQueueRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueRequest, rhs: Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetStickyTaskQueueResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueResponse, rhs: Temporal_Api_Workflowservice_V1_ResetStickyTaskQueueResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ShutdownWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ShutdownWorkerRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}sticky_task_queue\0\u{1}identity\0\u{1}reason\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stickyTaskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.stickyTaskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.stickyTaskQueue, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._workerHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ShutdownWorkerRequest, rhs: Temporal_Api_Workflowservice_V1_ShutdownWorkerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.stickyTaskQueue != rhs.stickyTaskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._workerHeartbeat != rhs._workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ShutdownWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ShutdownWorkerResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ShutdownWorkerResponse, rhs: Temporal_Api_Workflowservice_V1_ShutdownWorkerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_QueryWorkflowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QueryWorkflowRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}query\0\u{3}query_reject_condition\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.queryRejectCondition) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.queryRejectCondition != .unspecified {
      try visitor.visitSingularEnumField(value: self.queryRejectCondition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_QueryWorkflowRequest, rhs: Temporal_Api_Workflowservice_V1_QueryWorkflowRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs._query != rhs._query {return false}
    if lhs.queryRejectCondition != rhs.queryRejectCondition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_QueryWorkflowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QueryWorkflowResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}query_result\0\u{3}query_rejected\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._queryRejected) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._queryRejected {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_QueryWorkflowResponse, rhs: Temporal_Api_Workflowservice_V1_QueryWorkflowResponse) -> Bool {
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs._queryRejected != rhs._queryRejected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_config\0\u{3}workflow_execution_info\0\u{3}pending_activities\0\u{3}pending_children\0\u{3}pending_workflow_task\0\u{1}callbacks\0\u{3}pending_nexus_operations\0\u{3}workflow_extended_info\0")

  fileprivate class _StorageClass {
    var _executionConfig: Temporal_Api_Workflow_V1_WorkflowExecutionConfig? = nil
    var _workflowExecutionInfo: Temporal_Api_Workflow_V1_WorkflowExecutionInfo? = nil
    var _pendingActivities: [Temporal_Api_Workflow_V1_PendingActivityInfo] = []
    var _pendingChildren: [Temporal_Api_Workflow_V1_PendingChildExecutionInfo] = []
    var _pendingWorkflowTask: Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo? = nil
    var _callbacks: [Temporal_Api_Workflow_V1_CallbackInfo] = []
    var _pendingNexusOperations: [Temporal_Api_Workflow_V1_PendingNexusOperationInfo] = []
    var _workflowExtendedInfo: Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _executionConfig = source._executionConfig
      _workflowExecutionInfo = source._workflowExecutionInfo
      _pendingActivities = source._pendingActivities
      _pendingChildren = source._pendingChildren
      _pendingWorkflowTask = source._pendingWorkflowTask
      _callbacks = source._callbacks
      _pendingNexusOperations = source._pendingNexusOperations
      _workflowExtendedInfo = source._workflowExtendedInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._executionConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionInfo) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingActivities) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingChildren) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pendingWorkflowTask) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._callbacks) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingNexusOperations) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExtendedInfo) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._executionConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._workflowExecutionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._pendingActivities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingActivities, fieldNumber: 3)
      }
      if !_storage._pendingChildren.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingChildren, fieldNumber: 4)
      }
      try { if let v = _storage._pendingWorkflowTask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._callbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._callbacks, fieldNumber: 6)
      }
      if !_storage._pendingNexusOperations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingNexusOperations, fieldNumber: 7)
      }
      try { if let v = _storage._workflowExtendedInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowExecutionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._executionConfig != rhs_storage._executionConfig {return false}
        if _storage._workflowExecutionInfo != rhs_storage._workflowExecutionInfo {return false}
        if _storage._pendingActivities != rhs_storage._pendingActivities {return false}
        if _storage._pendingChildren != rhs_storage._pendingChildren {return false}
        if _storage._pendingWorkflowTask != rhs_storage._pendingWorkflowTask {return false}
        if _storage._callbacks != rhs_storage._callbacks {return false}
        if _storage._pendingNexusOperations != rhs_storage._pendingNexusOperations {return false}
        if _storage._workflowExtendedInfo != rhs_storage._workflowExtendedInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeTaskQueueRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}task_queue_type\0\u{3}include_task_queue_status\0\u{3}api_mode\0\u{1}versions\0\u{3}task_queue_types\0\u{3}report_stats\0\u{3}report_pollers\0\u{3}report_task_reachability\0\u{3}report_config\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.taskQueueType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeTaskQueueStatus) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.apiMode) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._versions) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.taskQueueTypes) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.reportStats) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reportPollers) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.reportTaskReachability) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.reportConfig) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.taskQueueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskQueueType, fieldNumber: 3)
    }
    if self.includeTaskQueueStatus != false {
      try visitor.visitSingularBoolField(value: self.includeTaskQueueStatus, fieldNumber: 4)
    }
    if self.apiMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.apiMode, fieldNumber: 5)
    }
    try { if let v = self._versions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.taskQueueTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.taskQueueTypes, fieldNumber: 7)
    }
    if self.reportStats != false {
      try visitor.visitSingularBoolField(value: self.reportStats, fieldNumber: 8)
    }
    if self.reportPollers != false {
      try visitor.visitSingularBoolField(value: self.reportPollers, fieldNumber: 9)
    }
    if self.reportTaskReachability != false {
      try visitor.visitSingularBoolField(value: self.reportTaskReachability, fieldNumber: 10)
    }
    if self.reportConfig != false {
      try visitor.visitSingularBoolField(value: self.reportConfig, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.taskQueueType != rhs.taskQueueType {return false}
    if lhs.reportStats != rhs.reportStats {return false}
    if lhs.reportConfig != rhs.reportConfig {return false}
    if lhs.includeTaskQueueStatus != rhs.includeTaskQueueStatus {return false}
    if lhs.apiMode != rhs.apiMode {return false}
    if lhs._versions != rhs._versions {return false}
    if lhs.taskQueueTypes != rhs.taskQueueTypes {return false}
    if lhs.reportPollers != rhs.reportPollers {return false}
    if lhs.reportTaskReachability != rhs.reportTaskReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeTaskQueueResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pollers\0\u{3}task_queue_status\0\u{3}versions_info\0\u{3}versioning_info\0\u{1}stats\0\u{1}config\0\u{3}effective_rate_limit\0\u{3}stats_by_priority_key\0")

  fileprivate class _StorageClass {
    var _pollers: [Temporal_Api_Taskqueue_V1_PollerInfo] = []
    var _stats: Temporal_Api_Taskqueue_V1_TaskQueueStats? = nil
    var _statsByPriorityKey: Dictionary<Int32,Temporal_Api_Taskqueue_V1_TaskQueueStats> = [:]
    var _versioningInfo: Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo? = nil
    var _config: Temporal_Api_Taskqueue_V1_TaskQueueConfig? = nil
    var _effectiveRateLimit: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit? = nil
    var _taskQueueStatus: Temporal_Api_Taskqueue_V1_TaskQueueStatus? = nil
    var _versionsInfo: Dictionary<String,Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pollers = source._pollers
      _stats = source._stats
      _statsByPriorityKey = source._statsByPriorityKey
      _versioningInfo = source._versioningInfo
      _config = source._config
      _effectiveRateLimit = source._effectiveRateLimit
      _taskQueueStatus = source._taskQueueStatus
      _versionsInfo = source._versionsInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._pollers) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueueStatus) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo>.self, value: &_storage._versionsInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._versioningInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stats) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._effectiveRateLimit) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueStats>.self, value: &_storage._statsByPriorityKey) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._pollers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pollers, fieldNumber: 1)
      }
      try { if let v = _storage._taskQueueStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._versionsInfo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo>.self, value: _storage._versionsInfo, fieldNumber: 3)
      }
      try { if let v = _storage._versioningInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._stats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._effectiveRateLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._statsByPriorityKey.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueStats>.self, value: _storage._statsByPriorityKey, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pollers != rhs_storage._pollers {return false}
        if _storage._stats != rhs_storage._stats {return false}
        if _storage._statsByPriorityKey != rhs_storage._statsByPriorityKey {return false}
        if _storage._versioningInfo != rhs_storage._versioningInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._effectiveRateLimit != rhs_storage._effectiveRateLimit {return false}
        if _storage._taskQueueStatus != rhs_storage._taskQueueStatus {return false}
        if _storage._versionsInfo != rhs_storage._versionsInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.protoMessageName + ".EffectiveRateLimit"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requests_per_second\0\u{3}rate_limit_source\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.requestsPerSecond) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rateLimitSource) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestsPerSecond.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.requestsPerSecond, fieldNumber: 1)
    }
    if self.rateLimitSource != .unspecified {
      try visitor.visitSingularEnumField(value: self.rateLimitSource, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit, rhs: Temporal_Api_Workflowservice_V1_DescribeTaskQueueResponse.EffectiveRateLimit) -> Bool {
    if lhs.requestsPerSecond != rhs.requestsPerSecond {return false}
    if lhs.rateLimitSource != rhs.rateLimitSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetClusterInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetClusterInfoRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetClusterInfoRequest, rhs: Temporal_Api_Workflowservice_V1_GetClusterInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetClusterInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetClusterInfoResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}supported_clients\0\u{3}server_version\0\u{3}cluster_id\0\u{3}version_info\0\u{3}cluster_name\0\u{3}history_shard_count\0\u{3}persistence_store\0\u{3}visibility_store\0")

  fileprivate class _StorageClass {
    var _supportedClients: Dictionary<String,String> = [:]
    var _serverVersion: String = String()
    var _clusterID: String = String()
    var _versionInfo: Temporal_Api_Version_V1_VersionInfo? = nil
    var _clusterName: String = String()
    var _historyShardCount: Int32 = 0
    var _persistenceStore: String = String()
    var _visibilityStore: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _supportedClients = source._supportedClients
      _serverVersion = source._serverVersion
      _clusterID = source._clusterID
      _versionInfo = source._versionInfo
      _clusterName = source._clusterName
      _historyShardCount = source._historyShardCount
      _persistenceStore = source._persistenceStore
      _visibilityStore = source._visibilityStore
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._supportedClients) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._serverVersion) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._clusterID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._versionInfo) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._historyShardCount) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._persistenceStore) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._visibilityStore) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._supportedClients.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._supportedClients, fieldNumber: 1)
      }
      if !_storage._serverVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverVersion, fieldNumber: 2)
      }
      if !_storage._clusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterID, fieldNumber: 3)
      }
      try { if let v = _storage._versionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 5)
      }
      if _storage._historyShardCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._historyShardCount, fieldNumber: 6)
      }
      if !_storage._persistenceStore.isEmpty {
        try visitor.visitSingularStringField(value: _storage._persistenceStore, fieldNumber: 7)
      }
      if !_storage._visibilityStore.isEmpty {
        try visitor.visitSingularStringField(value: _storage._visibilityStore, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetClusterInfoResponse, rhs: Temporal_Api_Workflowservice_V1_GetClusterInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._supportedClients != rhs_storage._supportedClients {return false}
        if _storage._serverVersion != rhs_storage._serverVersion {return false}
        if _storage._clusterID != rhs_storage._clusterID {return false}
        if _storage._versionInfo != rhs_storage._versionInfo {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._historyShardCount != rhs_storage._historyShardCount {return false}
        if _storage._persistenceStore != rhs_storage._persistenceStore {return false}
        if _storage._visibilityStore != rhs_storage._visibilityStore {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetSystemInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSystemInfoRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetSystemInfoRequest, rhs: Temporal_Api_Workflowservice_V1_GetSystemInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetSystemInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetSystemInfoResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_version\0\u{1}capabilities\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._capabilities) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 1)
    }
    try { if let v = self._capabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse, rhs: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse) -> Bool {
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs._capabilities != rhs._capabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.protoMessageName + ".Capabilities"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_and_query_header\0\u{3}internal_error_differentiation\0\u{3}activity_failure_include_heartbeat\0\u{3}supports_schedules\0\u{3}encoded_failure_attributes\0\u{3}build_id_based_versioning\0\u{3}upsert_memo\0\u{3}eager_workflow_start\0\u{3}sdk_metadata\0\u{3}count_group_by_execution_status\0\u{1}nexus\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.signalAndQueryHeader) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.internalErrorDifferentiation) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityFailureIncludeHeartbeat) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.supportsSchedules) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.encodedFailureAttributes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.buildIDBasedVersioning) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.upsertMemo) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.eagerWorkflowStart) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.sdkMetadata) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.countGroupByExecutionStatus) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.nexus) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.signalAndQueryHeader != false {
      try visitor.visitSingularBoolField(value: self.signalAndQueryHeader, fieldNumber: 1)
    }
    if self.internalErrorDifferentiation != false {
      try visitor.visitSingularBoolField(value: self.internalErrorDifferentiation, fieldNumber: 2)
    }
    if self.activityFailureIncludeHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.activityFailureIncludeHeartbeat, fieldNumber: 3)
    }
    if self.supportsSchedules != false {
      try visitor.visitSingularBoolField(value: self.supportsSchedules, fieldNumber: 4)
    }
    if self.encodedFailureAttributes != false {
      try visitor.visitSingularBoolField(value: self.encodedFailureAttributes, fieldNumber: 5)
    }
    if self.buildIDBasedVersioning != false {
      try visitor.visitSingularBoolField(value: self.buildIDBasedVersioning, fieldNumber: 6)
    }
    if self.upsertMemo != false {
      try visitor.visitSingularBoolField(value: self.upsertMemo, fieldNumber: 7)
    }
    if self.eagerWorkflowStart != false {
      try visitor.visitSingularBoolField(value: self.eagerWorkflowStart, fieldNumber: 8)
    }
    if self.sdkMetadata != false {
      try visitor.visitSingularBoolField(value: self.sdkMetadata, fieldNumber: 9)
    }
    if self.countGroupByExecutionStatus != false {
      try visitor.visitSingularBoolField(value: self.countGroupByExecutionStatus, fieldNumber: 10)
    }
    if self.nexus != false {
      try visitor.visitSingularBoolField(value: self.nexus, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities, rhs: Temporal_Api_Workflowservice_V1_GetSystemInfoResponse.Capabilities) -> Bool {
    if lhs.signalAndQueryHeader != rhs.signalAndQueryHeader {return false}
    if lhs.internalErrorDifferentiation != rhs.internalErrorDifferentiation {return false}
    if lhs.activityFailureIncludeHeartbeat != rhs.activityFailureIncludeHeartbeat {return false}
    if lhs.supportsSchedules != rhs.supportsSchedules {return false}
    if lhs.encodedFailureAttributes != rhs.encodedFailureAttributes {return false}
    if lhs.buildIDBasedVersioning != rhs.buildIDBasedVersioning {return false}
    if lhs.upsertMemo != rhs.upsertMemo {return false}
    if lhs.eagerWorkflowStart != rhs.eagerWorkflowStart {return false}
    if lhs.sdkMetadata != rhs.sdkMetadata {return false}
    if lhs.countGroupByExecutionStatus != rhs.countGroupByExecutionStatus {return false}
    if lhs.nexus != rhs.nexus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListTaskQueuePartitionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsRequest, rhs: Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListTaskQueuePartitionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_task_queue_partitions\0\u{3}workflow_task_queue_partitions\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activityTaskQueuePartitions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowTaskQueuePartitions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activityTaskQueuePartitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityTaskQueuePartitions, fieldNumber: 1)
    }
    if !self.workflowTaskQueuePartitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowTaskQueuePartitions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsResponse, rhs: Temporal_Api_Workflowservice_V1_ListTaskQueuePartitionsResponse) -> Bool {
    if lhs.activityTaskQueuePartitions != rhs.activityTaskQueuePartitions {return false}
    if lhs.workflowTaskQueuePartitions != rhs.workflowTaskQueuePartitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CreateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateScheduleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}schedule\0\u{3}initial_patch\0\u{1}identity\0\u{3}request_id\0\u{1}memo\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._initialPatch) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._initialPatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CreateScheduleRequest, rhs: Temporal_Api_Workflowservice_V1_CreateScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._initialPatch != rhs._initialPatch {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CreateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateScheduleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CreateScheduleResponse, rhs: Temporal_Api_Workflowservice_V1_CreateScheduleResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeScheduleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeScheduleRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeScheduleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schedule\0\u{1}info\0\u{1}memo\0\u{3}search_attributes\0\u{3}conflict_token\0")

  fileprivate class _StorageClass {
    var _schedule: Temporal_Api_Schedule_V1_Schedule? = nil
    var _info: Temporal_Api_Schedule_V1_ScheduleInfo? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _conflictToken: Data = Data()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _schedule = source._schedule
      _info = source._info
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _conflictToken = source._conflictToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._schedule) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._conflictToken) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._conflictToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._conflictToken, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeScheduleResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeScheduleResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._conflictToken != rhs_storage._conflictToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateScheduleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}schedule\0\u{3}conflict_token\0\u{1}identity\0\u{3}request_id\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateScheduleRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateScheduleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateScheduleResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PatchScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PatchScheduleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}patch\0\u{1}identity\0\u{3}request_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._patch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PatchScheduleRequest, rhs: Temporal_Api_Workflowservice_V1_PatchScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._patch != rhs._patch {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PatchScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PatchScheduleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PatchScheduleResponse, rhs: Temporal_Api_Workflowservice_V1_PatchScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListScheduleMatchingTimesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{3}start_time\0\u{3}end_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesRequest, rhs: Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListScheduleMatchingTimesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.startTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startTime.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.startTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesResponse, rhs: Temporal_Api_Workflowservice_V1_ListScheduleMatchingTimesResponse) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteScheduleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteScheduleRequest, rhs: Temporal_Api_Workflowservice_V1_DeleteScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteScheduleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteScheduleResponse, rhs: Temporal_Api_Workflowservice_V1_DeleteScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListSchedulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchedulesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListSchedulesRequest, rhs: Temporal_Api_Workflowservice_V1_ListSchedulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListSchedulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListSchedulesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schedules\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schedules) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schedules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListSchedulesResponse, rhs: Temporal_Api_Workflowservice_V1_ListSchedulesResponse) -> Bool {
    if lhs.schedules != rhs.schedules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerBuildIdCompatibilityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}add_new_build_id_in_new_default_set\0\u{3}add_new_compatible_build_id\0\u{3}promote_set_by_build_id\0\u{3}promote_build_id_within_set\0\u{3}merge_sets\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .addNewBuildIDInNewDefaultSet(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addNewCompatibleBuildID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addNewCompatibleBuildID(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .promoteSetByBuildID(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .promoteBuildIDWithinSet(v)
        }
      }()
      case 7: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .mergeSets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .mergeSets(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    switch self.operation {
    case .addNewBuildIDInNewDefaultSet?: try {
      guard case .addNewBuildIDInNewDefaultSet(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .addNewCompatibleBuildID?: try {
      guard case .addNewCompatibleBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .promoteSetByBuildID?: try {
      guard case .promoteSetByBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .promoteBuildIDWithinSet?: try {
      guard case .promoteBuildIDWithinSet(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .mergeSets?: try {
      guard case .mergeSets(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.protoMessageName + ".AddNewCompatibleVersion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_build_id\0\u{3}existing_compatible_build_id\0\u{3}make_set_default\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.existingCompatibleBuildID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.makeSetDefault) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.newBuildID, fieldNumber: 1)
    }
    if !self.existingCompatibleBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.existingCompatibleBuildID, fieldNumber: 2)
    }
    if self.makeSetDefault != false {
      try visitor.visitSingularBoolField(value: self.makeSetDefault, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion) -> Bool {
    if lhs.newBuildID != rhs.newBuildID {return false}
    if lhs.existingCompatibleBuildID != rhs.existingCompatibleBuildID {return false}
    if lhs.makeSetDefault != rhs.makeSetDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.protoMessageName + ".MergeSets"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}primary_set_build_id\0\u{3}secondary_set_build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.primarySetBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondarySetBuildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.primarySetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.primarySetBuildID, fieldNumber: 1)
    }
    if !self.secondarySetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.secondarySetBuildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityRequest.MergeSets) -> Bool {
    if lhs.primarySetBuildID != rhs.primarySetBuildID {return false}
    if lhs.secondarySetBuildID != rhs.secondarySetBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerBuildIdCompatibilityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{b}version_set_id\0\u{c}\u{1}\u{1}")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerBuildIdCompatibilityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerBuildIdCompatibilityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}max_sets\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxSets) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    if self.maxSets != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityRequest, rhs: Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.maxSets != rhs.maxSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerBuildIdCompatibilityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}major_version_sets\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.majorVersionSets) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.majorVersionSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.majorVersionSets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityResponse, rhs: Temporal_Api_Workflowservice_V1_GetWorkerBuildIdCompatibilityResponse) -> Bool {
    if lhs.majorVersionSets != rhs.majorVersionSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerVersioningRulesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}conflict_token\0\u{3}insert_assignment_rule\0\u{3}replace_assignment_rule\0\u{3}delete_assignment_rule\0\u{3}add_compatible_redirect_rule\0\u{3}replace_compatible_redirect_rule\0\u{3}delete_compatible_redirect_rule\0\u{3}commit_build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 4: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .insertAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .insertAssignmentRule(v)
        }
      }()
      case 5: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replaceAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replaceAssignmentRule(v)
        }
      }()
      case 6: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteAssignmentRule(v)
        }
      }()
      case 7: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addCompatibleRedirectRule(v)
        }
      }()
      case 8: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replaceCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replaceCompatibleRedirectRule(v)
        }
      }()
      case 9: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteCompatibleRedirectRule(v)
        }
      }()
      case 10: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .commitBuildID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .commitBuildID(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    switch self.operation {
    case .insertAssignmentRule?: try {
      guard case .insertAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .replaceAssignmentRule?: try {
      guard case .replaceAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deleteAssignmentRule?: try {
      guard case .deleteAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .addCompatibleRedirectRule?: try {
      guard case .addCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .replaceCompatibleRedirectRule?: try {
      guard case .replaceCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .deleteCompatibleRedirectRule?: try {
      guard case .deleteCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .commitBuildID?: try {
      guard case .commitBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".InsertBuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".ReplaceBuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}rule\0\u{1}force\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".DeleteBuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}force\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".AddCompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".ReplaceCompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".DeleteCompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceBuildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceBuildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule) -> Bool {
    if lhs.sourceBuildID != rhs.sourceBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.protoMessageName + ".CommitBuildId"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_build_id\0\u{1}force\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesRequest.CommitBuildId) -> Bool {
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerVersioningRulesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}assignment_rules\0\u{3}compatible_redirect_rules\0\u{3}conflict_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignmentRules) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.compatibleRedirectRules) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignmentRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignmentRules, fieldNumber: 1)
    }
    if !self.compatibleRedirectRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compatibleRedirectRules, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerVersioningRulesResponse) -> Bool {
    if lhs.assignmentRules != rhs.assignmentRules {return false}
    if lhs.compatibleRedirectRules != rhs.compatibleRedirectRules {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerVersioningRulesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesRequest, rhs: Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerVersioningRulesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}assignment_rules\0\u{3}compatible_redirect_rules\0\u{3}conflict_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignmentRules) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.compatibleRedirectRules) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignmentRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignmentRules, fieldNumber: 1)
    }
    if !self.compatibleRedirectRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compatibleRedirectRules, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesResponse, rhs: Temporal_Api_Workflowservice_V1_GetWorkerVersioningRulesResponse) -> Bool {
    if lhs.assignmentRules != rhs.assignmentRules {return false}
    if lhs.compatibleRedirectRules != rhs.compatibleRedirectRules {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerTaskReachabilityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}build_ids\0\u{3}task_queues\0\u{1}reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.taskQueues) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 2)
    }
    if !self.taskQueues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.taskQueues, fieldNumber: 3)
    }
    if self.reachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.reachability, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityRequest, rhs: Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.taskQueues != rhs.taskQueues {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetWorkerTaskReachabilityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id_reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buildIDReachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIDReachability.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buildIDReachability, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityResponse, rhs: Temporal_Api_Workflowservice_V1_GetWorkerTaskReachabilityResponse) -> Bool {
    if lhs.buildIDReachability != rhs.buildIDReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}first_execution_run_id\0\u{3}wait_policy\0\u{1}request\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waitPolicy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 3)
    }
    try { if let v = self._waitPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs._waitPolicy != rhs._waitPolicy {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}update_ref\0\u{1}outcome\0\u{1}stage\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse) -> Bool {
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StartBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartBatchOperationRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}visibility_query\0\u{3}job_id\0\u{1}reason\0\u{1}executions\0\u{3}max_operations_per_second\0\u{4}\u{4}termination_operation\0\u{3}signal_operation\0\u{3}cancellation_operation\0\u{3}deletion_operation\0\u{3}reset_operation\0\u{3}update_workflow_options_operation\0\u{3}unpause_activities_operation\0\u{3}reset_activities_operation\0\u{3}update_activity_options_operation\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.visibilityQuery) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.maxOperationsPerSecond) }()
      case 10: try {
        var v: Temporal_Api_Batch_V1_BatchOperationTermination?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .terminationOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .terminationOperation(v)
        }
      }()
      case 11: try {
        var v: Temporal_Api_Batch_V1_BatchOperationSignal?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .signalOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .signalOperation(v)
        }
      }()
      case 12: try {
        var v: Temporal_Api_Batch_V1_BatchOperationCancellation?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .cancellationOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .cancellationOperation(v)
        }
      }()
      case 13: try {
        var v: Temporal_Api_Batch_V1_BatchOperationDeletion?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deletionOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deletionOperation(v)
        }
      }()
      case 14: try {
        var v: Temporal_Api_Batch_V1_BatchOperationReset?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .resetOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .resetOperation(v)
        }
      }()
      case 15: try {
        var v: Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .updateWorkflowOptionsOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .updateWorkflowOptionsOperation(v)
        }
      }()
      case 16: try {
        var v: Temporal_Api_Batch_V1_BatchOperationUnpauseActivities?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .unpauseActivitiesOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .unpauseActivitiesOperation(v)
        }
      }()
      case 17: try {
        var v: Temporal_Api_Batch_V1_BatchOperationResetActivities?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .resetActivitiesOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .resetActivitiesOperation(v)
        }
      }()
      case 18: try {
        var v: Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .updateActivityOptionsOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .updateActivityOptionsOperation(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.visibilityQuery.isEmpty {
      try visitor.visitSingularStringField(value: self.visibilityQuery, fieldNumber: 2)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 5)
    }
    if self.maxOperationsPerSecond.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.maxOperationsPerSecond, fieldNumber: 6)
    }
    switch self.operation {
    case .terminationOperation?: try {
      guard case .terminationOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .signalOperation?: try {
      guard case .signalOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .cancellationOperation?: try {
      guard case .cancellationOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .deletionOperation?: try {
      guard case .deletionOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .resetOperation?: try {
      guard case .resetOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .updateWorkflowOptionsOperation?: try {
      guard case .updateWorkflowOptionsOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .unpauseActivitiesOperation?: try {
      guard case .unpauseActivitiesOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .resetActivitiesOperation?: try {
      guard case .resetActivitiesOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .updateActivityOptionsOperation?: try {
      guard case .updateActivityOptionsOperation(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StartBatchOperationRequest, rhs: Temporal_Api_Workflowservice_V1_StartBatchOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.visibilityQuery != rhs.visibilityQuery {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.executions != rhs.executions {return false}
    if lhs.maxOperationsPerSecond != rhs.maxOperationsPerSecond {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StartBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartBatchOperationResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StartBatchOperationResponse, rhs: Temporal_Api_Workflowservice_V1_StartBatchOperationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StopBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StopBatchOperationRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}job_id\0\u{1}reason\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StopBatchOperationRequest, rhs: Temporal_Api_Workflowservice_V1_StopBatchOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_StopBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StopBatchOperationResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_StopBatchOperationResponse, rhs: Temporal_Api_Workflowservice_V1_StopBatchOperationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeBatchOperationRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}job_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeBatchOperationRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeBatchOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeBatchOperationResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_type\0\u{3}job_id\0\u{1}state\0\u{3}start_time\0\u{3}close_time\0\u{3}total_operation_count\0\u{3}complete_operation_count\0\u{3}failure_operation_count\0\u{1}identity\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalOperationCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.completeOperationCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.failureOperationCount) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.totalOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalOperationCount, fieldNumber: 6)
    }
    if self.completeOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.completeOperationCount, fieldNumber: 7)
    }
    if self.failureOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.failureOperationCount, fieldNumber: 8)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 9)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeBatchOperationResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeBatchOperationResponse) -> Bool {
    if lhs.operationType != rhs.operationType {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs.totalOperationCount != rhs.totalOperationCount {return false}
    if lhs.completeOperationCount != rhs.completeOperationCount {return false}
    if lhs.failureOperationCount != rhs.failureOperationCount {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListBatchOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListBatchOperationsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListBatchOperationsRequest, rhs: Temporal_Api_Workflowservice_V1_ListBatchOperationsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListBatchOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListBatchOperationsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_info\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operationInfo) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operationInfo, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListBatchOperationsResponse, rhs: Temporal_Api_Workflowservice_V1_ListBatchOperationsResponse) -> Bool {
    if lhs.operationInfo != rhs.operationInfo {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollWorkflowExecutionUpdateRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}update_ref\0\u{1}identity\0\u{3}wait_policy\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waitPolicy) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._waitPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateRequest, rhs: Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._waitPolicy != rhs._waitPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollWorkflowExecutionUpdateResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}outcome\0\u{1}stage\0\u{3}update_ref\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 2)
    }
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateResponse, rhs: Temporal_Api_Workflowservice_V1_PollWorkflowExecutionUpdateResponse) -> Bool {
    if lhs._outcome != rhs._outcome {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollNexusTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollNexusTaskQueueRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_queue\0\u{3}worker_version_capabilities\0\u{4}\u{2}deployment_options\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.workerHeartbeat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerHeartbeat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueRequest, rhs: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.workerHeartbeat != rhs.workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollNexusTaskQueueResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}request\0\u{3}poller_scaling_decision\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pollerScalingDecision) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pollerScalingDecision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse, rhs: Temporal_Api_Workflowservice_V1_PollNexusTaskQueueResponse) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pollerScalingDecision != rhs._pollerScalingDecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskCompletedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_token\0\u{1}response\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 3)
    }
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskCompletedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskFailedRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_token\0\u{1}error\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 3)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedRequest, rhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskFailedResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedResponse, rhs: Temporal_Api_Workflowservice_V1_RespondNexusTaskFailedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExecuteMultiOperationRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}operations\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest, rhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.protoMessageName + ".Operation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_workflow\0\u{3}update_workflow\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionRequest?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .startWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .startWorkflow(v)
        }
      }()
      case 2: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionRequest?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .updateWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .updateWorkflow(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .startWorkflow?: try {
      guard case .startWorkflow(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflow?: try {
      guard case .updateWorkflow(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.Operation, rhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationRequest.Operation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExecuteMultiOperationResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse, rhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.protoMessageName + ".Response"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_workflow\0\u{3}update_workflow\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflowservice_V1_StartWorkflowExecutionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .startWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .startWorkflow(v)
        }
      }()
      case 2: try {
        var v: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .updateWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .updateWorkflow(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .startWorkflow?: try {
      guard case .startWorkflow(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflow?: try {
      guard case .updateWorkflow(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.Response, rhs: Temporal_Api_Workflowservice_V1_ExecuteMultiOperationResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateActivityOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateActivityOptionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{3}activity_options\0\u{3}update_mask\0\u{1}id\0\u{1}type\0\u{3}restore_original\0\u{3}match_all\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginal) }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if self.restoreOriginal != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginal, fieldNumber: 8)
    }
    try { if case .matchAll(let v)? = self.activity {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateActivityOptionsRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateActivityOptionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.restoreOriginal != rhs.restoreOriginal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateActivityOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateActivityOptionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateActivityOptionsResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateActivityOptionsResponse) -> Bool {
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PauseActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PauseActivityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PauseActivityRequest, rhs: Temporal_Api_Workflowservice_V1_PauseActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_PauseActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PauseActivityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_PauseActivityResponse, rhs: Temporal_Api_Workflowservice_V1_PauseActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UnpauseActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UnpauseActivityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{3}unpause_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{1}jitter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .unpauseAll(v)
        }
      }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .unpauseAll?: try {
      guard case .unpauseAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 7)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 8)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UnpauseActivityRequest, rhs: Temporal_Api_Workflowservice_V1_UnpauseActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UnpauseActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UnpauseActivityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UnpauseActivityResponse, rhs: Temporal_Api_Workflowservice_V1_UnpauseActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetActivityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{3}reset_heartbeat\0\u{3}keep_paused\0\u{1}jitter\0\u{3}restore_original_options\0\u{3}match_all\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.keepPaused) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginalOptions) }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 6)
    }
    if self.keepPaused != false {
      try visitor.visitSingularBoolField(value: self.keepPaused, fieldNumber: 7)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.restoreOriginalOptions != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginalOptions, fieldNumber: 9)
    }
    try { if case .matchAll(let v)? = self.activity {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetActivityRequest, rhs: Temporal_Api_Workflowservice_V1_ResetActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs.keepPaused != rhs.keepPaused {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.restoreOriginalOptions != rhs.restoreOriginalOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ResetActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetActivityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ResetActivityResponse, rhs: Temporal_Api_Workflowservice_V1_ResetActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionOptionsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_execution_options\0\u{3}update_mask\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionOptionsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_execution_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkflowExecutionOptionsResponse) -> Bool {
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeDeploymentRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeDeploymentRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeDeploymentResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deployment_info\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deploymentInfo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeDeploymentResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeDeploymentResponse) -> Bool {
    if lhs._deploymentInfo != rhs._deploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}deployment_version\0\u{3}report_task_queue_stats\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reportTaskQueueStats) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.reportTaskQueueStats != false {
      try visitor.visitSingularBoolField(value: self.reportTaskQueueStats, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.reportTaskQueueStats != rhs.reportTaskQueueStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_deployment_version_info\0\u{3}version_task_queues\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerDeploymentVersionInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.versionTaskQueues) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerDeploymentVersionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.versionTaskQueues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versionTaskQueues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse) -> Bool {
    if lhs._workerDeploymentVersionInfo != rhs._workerDeploymentVersionInfo {return false}
    if lhs.versionTaskQueues != rhs.versionTaskQueues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse.VersionTaskQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse.protoMessageName + ".VersionTaskQueue"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0\u{1}stats\0\u{3}stats_by_priority_key\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueStats>.self, value: &self.statsByPriorityKey) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.statsByPriorityKey.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueStats>.self, value: self.statsByPriorityKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse.VersionTaskQueue, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentVersionResponse.VersionTaskQueue) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.statsByPriorityKey != rhs.statsByPriorityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}worker_deployment_info\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workerDeploymentInfo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    try { if let v = self._workerDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkerDeploymentResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs._workerDeploymentInfo != rhs._workerDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListDeploymentsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{3}series_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.seriesName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.seriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListDeploymentsRequest, rhs: Temporal_Api_Workflowservice_V1_ListDeploymentsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.seriesName != rhs.seriesName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListDeploymentsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{1}deployments\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListDeploymentsResponse, rhs: Temporal_Api_Workflowservice_V1_ListDeploymentsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetCurrentDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetCurrentDeploymentRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0\u{1}identity\0\u{3}update_metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMetadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._updateMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetCurrentDeploymentRequest, rhs: Temporal_Api_Workflowservice_V1_SetCurrentDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._updateMetadata != rhs._updateMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetCurrentDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetCurrentDeploymentResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_deployment_info\0\u{3}previous_deployment_info\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentInfo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previousDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetCurrentDeploymentResponse, rhs: Temporal_Api_Workflowservice_V1_SetCurrentDeploymentResponse) -> Bool {
    if lhs._currentDeploymentInfo != rhs._currentDeploymentInfo {return false}
    if lhs._previousDeploymentInfo != rhs._previousDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentCurrentVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}version\0\u{3}conflict_token\0\u{1}identity\0\u{3}ignore_missing_task_queues\0\u{3}build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ignoreMissingTaskQueues) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if self.ignoreMissingTaskQueues != false {
      try visitor.visitSingularBoolField(value: self.ignoreMissingTaskQueues, fieldNumber: 6)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionRequest, rhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ignoreMissingTaskQueues != rhs.ignoreMissingTaskQueues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentCurrentVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}previous_version\0\u{3}previous_deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.previousVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    if !self.previousVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.previousVersion, fieldNumber: 2)
    }
    try { if let v = self._previousDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionResponse, rhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentCurrentVersionResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.previousVersion != rhs.previousVersion {return false}
    if lhs._previousDeploymentVersion != rhs._previousDeploymentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentRampingVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}version\0\u{1}percentage\0\u{3}conflict_token\0\u{1}identity\0\u{3}ignore_missing_task_queues\0\u{3}build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.percentage) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.ignoreMissingTaskQueues) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if self.percentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.percentage, fieldNumber: 4)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 5)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    if self.ignoreMissingTaskQueues != false {
      try visitor.visitSingularBoolField(value: self.ignoreMissingTaskQueues, fieldNumber: 7)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionRequest, rhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.percentage != rhs.percentage {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ignoreMissingTaskQueues != rhs.ignoreMissingTaskQueues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentRampingVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}previous_version\0\u{3}previous_percentage\0\u{3}previous_deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.previousVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.previousPercentage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    if !self.previousVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.previousVersion, fieldNumber: 2)
    }
    if self.previousPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.previousPercentage, fieldNumber: 3)
    }
    try { if let v = self._previousDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionResponse, rhs: Temporal_Api_Workflowservice_V1_SetWorkerDeploymentRampingVersionResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.previousVersion != rhs.previousVersion {return false}
    if lhs._previousDeploymentVersion != rhs._previousDeploymentVersion {return false}
    if lhs.previousPercentage != rhs.previousPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkerDeploymentsRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsRequest, rhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkerDeploymentsResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{3}worker_deployments\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workerDeployments) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.workerDeployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerDeployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse, rhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.workerDeployments != rhs.workerDeployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse.WorkerDeploymentSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse.protoMessageName + ".WorkerDeploymentSummary"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}create_time\0\u{3}routing_config\0\u{3}latest_version_summary\0\u{3}current_version_summary\0\u{3}ramping_version_summary\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routingConfig: Temporal_Api_Deployment_V1_RoutingConfig? = nil
    var _latestVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil
    var _currentVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil
    var _rampingVersionSummary: Temporal_Api_Deployment_V1_WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _createTime = source._createTime
      _routingConfig = source._routingConfig
      _latestVersionSummary = source._latestVersionSummary
      _currentVersionSummary = source._currentVersionSummary
      _rampingVersionSummary = source._rampingVersionSummary
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._routingConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._latestVersionSummary) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._currentVersionSummary) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rampingVersionSummary) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._routingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._latestVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._currentVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._rampingVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse.WorkerDeploymentSummary, rhs: Temporal_Api_Workflowservice_V1_ListWorkerDeploymentsResponse.WorkerDeploymentSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._routingConfig != rhs_storage._routingConfig {return false}
        if _storage._latestVersionSummary != rhs_storage._latestVersionSummary {return false}
        if _storage._currentVersionSummary != rhs_storage._currentVersionSummary {return false}
        if _storage._rampingVersionSummary != rhs_storage._rampingVersionSummary {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentVersionRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}skip_drainage\0\u{1}identity\0\u{3}deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipDrainage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.skipDrainage != false {
      try visitor.visitSingularBoolField(value: self.skipDrainage, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionRequest, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.skipDrainage != rhs.skipDrainage {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentVersionResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionResponse, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentVersionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentRequest, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentResponse, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkerDeploymentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerDeploymentVersionMetadataRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}upsert_entries\0\u{3}remove_entries\0\u{3}deployment_version\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.upsertEntries) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.removeEntries) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.upsertEntries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.upsertEntries, fieldNumber: 3)
    }
    if !self.removeEntries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removeEntries, fieldNumber: 4)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.upsertEntries != rhs.upsertEntries {return false}
    if lhs.removeEntries != rhs.removeEntries {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerDeploymentVersionMetadataResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerDeploymentVersionMetadataResponse) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetCurrentDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetCurrentDeploymentRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}series_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.seriesName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.seriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetCurrentDeploymentRequest, rhs: Temporal_Api_Workflowservice_V1_GetCurrentDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.seriesName != rhs.seriesName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetCurrentDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetCurrentDeploymentResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_deployment_info\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentInfo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetCurrentDeploymentResponse, rhs: Temporal_Api_Workflowservice_V1_GetCurrentDeploymentResponse) -> Bool {
    if lhs._currentDeploymentInfo != rhs._currentDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetDeploymentReachabilityRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityRequest, rhs: Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GetDeploymentReachabilityResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deployment_info\0\u{1}reachability\0\u{3}last_update_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deploymentInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reachability) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastUpdateTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.reachability, fieldNumber: 2)
    }
    try { if let v = self._lastUpdateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityResponse, rhs: Temporal_Api_Workflowservice_V1_GetDeploymentReachabilityResponse) -> Bool {
    if lhs._deploymentInfo != rhs._deploymentInfo {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs._lastUpdateTime != rhs._lastUpdateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CreateWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateWorkflowRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}force_scan\0\u{3}request_id\0\u{1}identity\0\u{1}description\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.forceScan) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.forceScan != false {
      try visitor.visitSingularBoolField(value: self.forceScan, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CreateWorkflowRuleRequest, rhs: Temporal_Api_Workflowservice_V1_CreateWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.forceScan != rhs.forceScan {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_CreateWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CreateWorkflowRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}job_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_CreateWorkflowRuleResponse, rhs: Temporal_Api_Workflowservice_V1_CreateWorkflowRuleResponse) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}rule_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleRequest, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleResponse, rhs: Temporal_Api_Workflowservice_V1_DescribeWorkflowRuleResponse) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}rule_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleRequest, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleResponse, rhs: Temporal_Api_Workflowservice_V1_DeleteWorkflowRuleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkflowRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkflowRulesRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkflowRulesRequest, rhs: Temporal_Api_Workflowservice_V1_ListWorkflowRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkflowRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkflowRulesResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rules\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkflowRulesResponse, rhs: Temporal_Api_Workflowservice_V1_ListWorkflowRulesResponse) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TriggerWorkflowRuleRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}spec\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.rule != nil {try decoder.handleConflictingOneOf()}
          self.rule = .id(v)
        }
      }()
      case 5: try {
        var v: Temporal_Api_Rules_V1_WorkflowRuleSpec?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .spec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .spec(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.rule {
    case .id?: try {
      guard case .id(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .spec?: try {
      guard case .spec(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleRequest, rhs: Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TriggerWorkflowRuleResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}applied\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.applied) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.applied != false {
      try visitor.visitSingularBoolField(value: self.applied, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleResponse, rhs: Temporal_Api_Workflowservice_V1_TriggerWorkflowRuleResponse) -> Bool {
    if lhs.applied != rhs.applied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordWorkerHeartbeatRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.workerHeartbeat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerHeartbeat, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatRequest, rhs: Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.workerHeartbeat != rhs.workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordWorkerHeartbeatResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatResponse, rhs: Temporal_Api_Workflowservice_V1_RecordWorkerHeartbeatResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkersRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkersRequest, rhs: Temporal_Api_Workflowservice_V1_ListWorkersRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_ListWorkersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ListWorkersResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workers_info\0\u{3}next_page_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workersInfo) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workersInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workersInfo, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_ListWorkersResponse, rhs: Temporal_Api_Workflowservice_V1_ListWorkersResponse) -> Bool {
    if lhs.workersInfo != rhs.workersInfo {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateTaskQueueConfigRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_queue\0\u{3}task_queue_type\0\u{3}update_queue_rate_limit\0\u{3}update_fairness_key_rate_limit_default\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.taskQueueType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateQueueRateLimit) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateFairnessKeyRateLimitDefault) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 3)
    }
    if self.taskQueueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskQueueType, fieldNumber: 4)
    }
    try { if let v = self._updateQueueRateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updateFairnessKeyRateLimitDefault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.taskQueueType != rhs.taskQueueType {return false}
    if lhs._updateQueueRateLimit != rhs._updateQueueRateLimit {return false}
    if lhs._updateFairnessKeyRateLimitDefault != rhs._updateFairnessKeyRateLimitDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.protoMessageName + ".RateLimitUpdate"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rate_limit\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rateLimit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate, rhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigRequest.RateLimitUpdate) -> Bool {
    if lhs._rateLimit != rhs._rateLimit {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateTaskQueueConfigResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}config\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateTaskQueueConfigResponse) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_FetchWorkerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FetchWorkerConfigRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{1}reason\0\u{2}\u{3}selector\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_FetchWorkerConfigRequest, rhs: Temporal_Api_Workflowservice_V1_FetchWorkerConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_FetchWorkerConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FetchWorkerConfigResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_config\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerConfig) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_FetchWorkerConfigResponse, rhs: Temporal_Api_Workflowservice_V1_FetchWorkerConfigResponse) -> Bool {
    if lhs._workerConfig != rhs._workerConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerConfigRequest"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{1}reason\0\u{3}worker_config\0\u{3}update_mask\0\u{1}selector\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._workerConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerConfigRequest, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._workerConfig != rhs._workerConfig {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflowservice_V1_UpdateWorkerConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateWorkerConfigResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_config\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Sdk_V1_WorkerConfig?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .workerConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .workerConfig(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .workerConfig(let v)? = self.response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflowservice_V1_UpdateWorkerConfigResponse, rhs: Temporal_Api_Workflowservice_V1_UpdateWorkerConfigResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
