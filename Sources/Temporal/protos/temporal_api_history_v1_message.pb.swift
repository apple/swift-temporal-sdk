// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/history/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Always the first event in workflow history
package struct Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  /// If this workflow is a child, the namespace our parent lives in.
  /// SDKs and UI tools should use `parent_workflow_namespace` field but server must use `parent_workflow_namespace_id` only.
  package var parentWorkflowNamespace: String {
    get {return _storage._parentWorkflowNamespace}
    set {_uniqueStorage()._parentWorkflowNamespace = newValue}
  }

  package var parentWorkflowNamespaceID: String {
    get {return _storage._parentWorkflowNamespaceID}
    set {_uniqueStorage()._parentWorkflowNamespaceID = newValue}
  }

  /// Contains information about parent workflow execution that initiated the child workflow these attributes belong to.
  /// If the workflow these attributes belong to is not a child workflow of any other execution, this field will not be populated.
  package var parentWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._parentWorkflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._parentWorkflowExecution = newValue}
  }
  /// Returns true if `parentWorkflowExecution` has been explicitly set.
  package var hasParentWorkflowExecution: Bool {return _storage._parentWorkflowExecution != nil}
  /// Clears the value of `parentWorkflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearParentWorkflowExecution() {_uniqueStorage()._parentWorkflowExecution = nil}

  /// EventID of the child execution initiated event in parent workflow
  package var parentInitiatedEventID: Int64 {
    get {return _storage._parentInitiatedEventID}
    set {_uniqueStorage()._parentInitiatedEventID = newValue}
  }

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  /// SDK will deserialize this and provide it as arguments to the workflow function
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Run id of the previous workflow which continued-as-new or retried or cron executed into this
  /// workflow.
  package var continuedExecutionRunID: String {
    get {return _storage._continuedExecutionRunID}
    set {_uniqueStorage()._continuedExecutionRunID = newValue}
  }

  package var initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator {
    get {return _storage._initiator}
    set {_uniqueStorage()._initiator = newValue}
  }

  package var continuedFailure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._continuedFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._continuedFailure = newValue}
  }
  /// Returns true if `continuedFailure` has been explicitly set.
  package var hasContinuedFailure: Bool {return _storage._continuedFailure != nil}
  /// Clears the value of `continuedFailure`. Subsequent reads from it will return its default value.
  package mutating func clearContinuedFailure() {_uniqueStorage()._continuedFailure = nil}

  package var lastCompletionResult: Temporal_Api_Common_V1_Payloads {
    get {return _storage._lastCompletionResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._lastCompletionResult = newValue}
  }
  /// Returns true if `lastCompletionResult` has been explicitly set.
  package var hasLastCompletionResult: Bool {return _storage._lastCompletionResult != nil}
  /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
  package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

  /// This is the run id when the WorkflowExecutionStarted event was written.
  /// A workflow reset changes the execution run_id, but preserves this field.
  package var originalExecutionRunID: String {
    get {return _storage._originalExecutionRunID}
    set {_uniqueStorage()._originalExecutionRunID = newValue}
  }

  /// Identity of the client who requested this execution
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// This is the very first runId along the chain of ContinueAsNew, Retry, Cron and Reset.
  /// Used to identify a chain.
  package var firstExecutionRunID: String {
    get {return _storage._firstExecutionRunID}
    set {_uniqueStorage()._firstExecutionRunID = newValue}
  }

  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Starting at 1, the number of times we have tried to execute this workflow
  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// The absolute time at which the workflow will be timed out.
  /// This is passed without change to the next run/retry of a workflow.
  package var workflowExecutionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._workflowExecutionExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._workflowExecutionExpirationTime = newValue}
  }
  /// Returns true if `workflowExecutionExpirationTime` has been explicitly set.
  package var hasWorkflowExecutionExpirationTime: Bool {return _storage._workflowExecutionExpirationTime != nil}
  /// Clears the value of `workflowExecutionExpirationTime`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionExpirationTime() {_uniqueStorage()._workflowExecutionExpirationTime = nil}

  /// If this workflow runs on a cron schedule, it will appear here
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  /// For a cron workflow, this contains the amount of time between when this iteration of
  /// the cron workflow was scheduled and when it should run next per its cron_schedule.
  package var firstWorkflowTaskBackoff: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._firstWorkflowTaskBackoff ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._firstWorkflowTaskBackoff = newValue}
  }
  /// Returns true if `firstWorkflowTaskBackoff` has been explicitly set.
  package var hasFirstWorkflowTaskBackoff: Bool {return _storage._firstWorkflowTaskBackoff != nil}
  /// Clears the value of `firstWorkflowTaskBackoff`. Subsequent reads from it will return its default value.
  package mutating func clearFirstWorkflowTaskBackoff() {_uniqueStorage()._firstWorkflowTaskBackoff = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  package var prevAutoResetPoints: Temporal_Api_Workflow_V1_ResetPoints {
    get {return _storage._prevAutoResetPoints ?? Temporal_Api_Workflow_V1_ResetPoints()}
    set {_uniqueStorage()._prevAutoResetPoints = newValue}
  }
  /// Returns true if `prevAutoResetPoints` has been explicitly set.
  package var hasPrevAutoResetPoints: Bool {return _storage._prevAutoResetPoints != nil}
  /// Clears the value of `prevAutoResetPoints`. Subsequent reads from it will return its default value.
  package mutating func clearPrevAutoResetPoints() {_uniqueStorage()._prevAutoResetPoints = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Version of the child execution initiated event in parent workflow
  /// It should be used together with parent_initiated_event_id to identify
  /// a child initiated event for global namespace
  package var parentInitiatedEventVersion: Int64 {
    get {return _storage._parentInitiatedEventVersion}
    set {_uniqueStorage()._parentInitiatedEventVersion = newValue}
  }

  /// This field is new in 1.21.
  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  /// If this workflow intends to use anything other than the current overall default version for
  /// the queue, then we include it here.
  /// Deprecated. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var sourceVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _storage._sourceVersionStamp ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_uniqueStorage()._sourceVersionStamp = newValue}
  }
  /// Returns true if `sourceVersionStamp` has been explicitly set.
  package var hasSourceVersionStamp: Bool {return _storage._sourceVersionStamp != nil}
  /// Clears the value of `sourceVersionStamp`. Subsequent reads from it will return its default value.
  package mutating func clearSourceVersionStamp() {_uniqueStorage()._sourceVersionStamp = nil}

  /// Completion callbacks attached when this workflow was started.
  package var completionCallbacks: [Temporal_Api_Common_V1_Callback] {
    get {return _storage._completionCallbacks}
    set {_uniqueStorage()._completionCallbacks = newValue}
  }

  /// Contains information about the root workflow execution.
  /// The root workflow execution is defined as follows:
  ///   1. A workflow without parent workflow is its own root workflow.
  ///   2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
  /// When the workflow is its own root workflow, then root_workflow_execution is nil.
  /// Note: workflows continued as new or reseted may or may not have parents, check examples below.
  ///
  /// Examples:
  ///   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
  ///     - The root workflow of all three workflows is W1.
  ///     - W1 has root_workflow_execution set to nil.
  ///     - W2 and W3 have root_workflow_execution set to W1.
  ///   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
  ///     - The root workflow of all three workflows is W1.
  ///     - W1 has root_workflow_execution set to nil.
  ///     - W2 and W3 have root_workflow_execution set to W1.
  ///   Scenario 3: Workflow W1 continued as new W2.
  ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  ///     - W1 and W2 have root_workflow_execution set to nil.
  ///   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
  ///     - The root workflow of all three workflows is W1.
  ///     - W1 has root_workflow_execution set to nil.
  ///     - W2 and W3 have root_workflow_execution set to W1.
  ///   Scenario 5: Workflow W1 is reseted, creating W2.
  ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  ///     - W1 and W2 have root_workflow_execution set to nil.
  package var rootWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._rootWorkflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._rootWorkflowExecution = newValue}
  }
  /// Returns true if `rootWorkflowExecution` has been explicitly set.
  package var hasRootWorkflowExecution: Bool {return _storage._rootWorkflowExecution != nil}
  /// Clears the value of `rootWorkflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearRootWorkflowExecution() {_uniqueStorage()._rootWorkflowExecution = nil}

  /// When present, this execution is assigned to the build ID of its parent or previous execution.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritedBuildID: String {
    get {return _storage._inheritedBuildID}
    set {_uniqueStorage()._inheritedBuildID = newValue}
  }

  /// Versioning override applied to this workflow when it was started.
  /// Children, crons, retries, and continue-as-new will inherit source run's override if pinned
  /// and if the new workflow's Task Queue belongs to the override version.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _storage._versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_uniqueStorage()._versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return _storage._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

  /// When present, it means this is a child workflow of a parent that is Pinned to this Worker
  /// Deployment Version. In this case, child workflow will start as Pinned to this Version instead
  /// of starting on the Current Version of its Task Queue.
  /// This is set only if the child workflow is starting on a Task Queue belonging to the same
  /// Worker Deployment Version.
  /// Deprecated. Use `parent_versioning_info`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var parentPinnedWorkerDeploymentVersion: String {
    get {return _storage._parentPinnedWorkerDeploymentVersion}
    set {_uniqueStorage()._parentPinnedWorkerDeploymentVersion = newValue}
  }

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  /// If present, the new workflow should start on this version with pinned base behavior.
  /// Child of pinned parent will inherit the parent's version if the Child's Task Queue belongs to that version.
  ///
  /// New run initiated by workflow ContinueAsNew of pinned run, will inherit the previous run's version if the
  /// new run's Task Queue belongs to that version.
  ///
  /// New run initiated by workflow Cron will never inherit.
  ///
  /// New run initiated by workflow Retry will only inherit if the retried run is effectively pinned at the time
  /// of retry, and the retried run inherited a pinned version when it started (ie. it is a child of a pinned
  /// parent, or a CaN of a pinned run, and is running on a Task Queue in the inherited version).
  ///
  /// Pinned override is inherited if Task Queue of new run is compatible with the override version.
  /// Override is inherited separately and takes precedence over inherited base version.
  package var inheritedPinnedVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._inheritedPinnedVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._inheritedPinnedVersion = newValue}
  }
  /// Returns true if `inheritedPinnedVersion` has been explicitly set.
  package var hasInheritedPinnedVersion: Bool {return _storage._inheritedPinnedVersion != nil}
  /// Clears the value of `inheritedPinnedVersion`. Subsequent reads from it will return its default value.
  package mutating func clearInheritedPinnedVersion() {_uniqueStorage()._inheritedPinnedVersion = nil}

  /// A boolean indicating whether the SDK has asked to eagerly execute the first workflow task for this workflow and
  /// eager execution was accepted by the server.
  /// Only populated by server with version >= 1.29.0.
  package var eagerExecutionAccepted: Bool {
    get {return _storage._eagerExecutionAccepted}
    set {_uniqueStorage()._eagerExecutionAccepted = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Serialized result of workflow completion (ie: The return value of the workflow function)
  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// If another run is started by cron, this contains the new run id.
  package var newExecutionRunID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Serialized result of workflow failure (ex: An exception thrown, or error returned)
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// If another run is started by cron or retry, this contains the new run id.
  package var newExecutionRunID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  /// If another run is started by cron or retry, this contains the new run id.
  package var newExecutionRunID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The run ID of the new workflow started by this continue-as-new
  package var newExecutionRunID: String {
    get {return _storage._newExecutionRunID}
    set {_uniqueStorage()._newExecutionRunID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 {
    get {return _storage._workflowTaskCompletedEventID}
    set {_uniqueStorage()._workflowTaskCompletedEventID = newValue}
  }

  /// TODO: How and is this used?
  package var backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._backoffStartInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._backoffStartInterval = newValue}
  }
  /// Returns true if `backoffStartInterval` has been explicitly set.
  package var hasBackoffStartInterval: Bool {return _storage._backoffStartInterval != nil}
  /// Clears the value of `backoffStartInterval`. Subsequent reads from it will return its default value.
  package mutating func clearBackoffStartInterval() {_uniqueStorage()._backoffStartInterval = nil}

  package var initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator {
    get {return _storage._initiator}
    set {_uniqueStorage()._initiator = newValue}
  }

  /// TODO: David are these right?
  /// Deprecated. If a workflow's retry policy would cause a new run to start when the current one
  /// has failed, this field would be populated with that failure. Now (when supported by server
  /// and sdk) the final event will be `WORKFLOW_EXECUTION_FAILED` with `new_execution_run_id` set.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return _storage._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {_uniqueStorage()._failure = nil}

  /// TODO: Is this the result of *this* workflow as it continued-as-new?
  package var lastCompletionResult: Temporal_Api_Common_V1_Payloads {
    get {return _storage._lastCompletionResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._lastCompletionResult = newValue}
  }
  /// Returns true if `lastCompletionResult` has been explicitly set.
  package var hasLastCompletionResult: Bool {return _storage._lastCompletionResult != nil}
  /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
  package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
  /// the assignment rules will be used to independently assign a Build ID to the new execution.
  /// Deprecated. Only considered for versioning v0.2.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritBuildID: Bool {
    get {return _storage._inheritBuildID}
    set {_uniqueStorage()._inheritBuildID = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The task queue this workflow task was enqueued in, which could be a normal or sticky queue
  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  /// How long the worker has to process this task once receiving it before it times out
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return self._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {self._startToCloseTimeout = nil}

  /// Starting at 1, how many attempts there have been to complete this task
  package var attempt: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
  package var scheduledEventID: Int64 = 0

  /// Identity of the worker who picked up this task
  package var identity: String = String()

  /// TODO: ? Appears unused?
  package var requestID: String = String()

  /// True if this workflow should continue-as-new soon because its history size (in
  /// either event count or bytes) is getting large.
  package var suggestContinueAsNew: Bool = false

  /// Total history size in bytes, which the workflow might use to decide when to
  /// continue-as-new regardless of the suggestion. Note that history event count is
  /// just the event id of this event, so we don't include it explicitly here.
  package var historySizeBytes: Int64 = 0

  /// Version info of the worker to whom this task was dispatched.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Used by server internally to properly reapply build ID redirects to an execution
  /// when rebuilding it from events.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var buildIDRedirectCounter: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
  package var scheduledEventID: Int64 {
    get {return _storage._scheduledEventID}
    set {_uniqueStorage()._scheduledEventID = newValue}
  }

  /// The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
  package var startedEventID: Int64 {
    get {return _storage._startedEventID}
    set {_uniqueStorage()._startedEventID = newValue}
  }

  /// Identity of the worker who completed this task
  package var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// Binary ID of the worker who completed this task
  /// Deprecated. Replaced with `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String {
    get {return _storage._binaryChecksum}
    set {_uniqueStorage()._binaryChecksum = newValue}
  }

  /// Version info of the worker who processed this workflow task. If present, the `build_id` field
  /// within is also used as `binary_checksum`, which may be omitted in that case (it may also be
  /// populated to preserve compatibility).
  /// Deprecated. Use `deployment_version` and `versioning_behavior` instead.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _storage._workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_uniqueStorage()._workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return _storage._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {_uniqueStorage()._workerVersion = nil}

  /// Data the SDK wishes to record for itself, but server need not interpret, and does not
  /// directly impact workflow state.
  package var sdkMetadata: Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata {
    get {return _storage._sdkMetadata ?? Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata()}
    set {_uniqueStorage()._sdkMetadata = newValue}
  }
  /// Returns true if `sdkMetadata` has been explicitly set.
  package var hasSdkMetadata: Bool {return _storage._sdkMetadata != nil}
  /// Clears the value of `sdkMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearSdkMetadata() {_uniqueStorage()._sdkMetadata = nil}

  /// Local usage data sent during workflow task completion and recorded here for posterity
  package var meteringMetadata: Temporal_Api_Common_V1_MeteringMetadata {
    get {return _storage._meteringMetadata ?? Temporal_Api_Common_V1_MeteringMetadata()}
    set {_uniqueStorage()._meteringMetadata = newValue}
  }
  /// Returns true if `meteringMetadata` has been explicitly set.
  package var hasMeteringMetadata: Bool {return _storage._meteringMetadata != nil}
  /// Clears the value of `meteringMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearMeteringMetadata() {_uniqueStorage()._meteringMetadata = nil}

  /// The deployment that completed this task. May or may not be set for unversioned workers,
  /// depending on whether a value is sent by the SDK. This value updates workflow execution's
  /// `versioning_info.deployment`.
  /// Deprecated. Replaced with `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _storage._deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_uniqueStorage()._deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return _storage._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

  /// Versioning behavior sent by the worker that completed this task for this particular workflow
  /// execution. UNSPECIFIED means the task was completed by an unversioned worker. This value
  /// updates workflow execution's `versioning_info.behavior`.
  package var versioningBehavior: Temporal_Api_Enums_V1_VersioningBehavior {
    get {return _storage._versioningBehavior}
    set {_uniqueStorage()._versioningBehavior = newValue}
  }

  /// The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
  /// is set. This value updates workflow execution's `versioning_info.version`.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  /// Deprecated. Replaced with `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerDeploymentVersion: String {
    get {return _storage._workerDeploymentVersion}
    set {_uniqueStorage()._workerDeploymentVersion = newValue}
  }

  /// The name of Worker Deployment that completed this task. Must be set if `versioning_behavior`
  /// is set. This value updates workflow execution's `worker_deployment_name`.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  package var workerDeploymentName: String {
    get {return _storage._workerDeploymentName}
    set {_uniqueStorage()._workerDeploymentName = newValue}
  }

  /// The Worker Deployment Version that completed this task. Must be set if `versioning_behavior`
  /// is set. This value updates workflow execution's `versioning_info.deployment_version`.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return _storage._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
  package var startedEventID: Int64 = 0

  package var timeoutType: Temporal_Api_Enums_V1_TimeoutType = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `WORKFLOW_TASK_SCHEDULED` event this task corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `WORKFLOW_TASK_STARTED` event this task corresponds to
  package var startedEventID: Int64 = 0

  package var cause: Temporal_Api_Enums_V1_WorkflowTaskFailedCause = .unspecified

  /// The failure details
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// If a worker explicitly failed this task, it's identity. TODO: What is this set to if server fails the task?
  package var identity: String = String()

  /// The original run id of the workflow. For reset workflow.
  package var baseRunID: String = String()

  /// If the workflow is being reset, the new run id.
  package var newRunID: String = String()

  /// TODO: ?
  package var forkEventVersion: Int64 = 0

  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  /// If a worker explicitly failed this task, its binary id
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String = String()

  /// Version info of the worker who processed this workflow task. If present, the `build_id` field
  /// within is also used as `binary_checksum`, which may be omitted in that case (it may also be
  /// populated to preserve compatibility).
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The worker/user assigned identifier for the activity
  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  package var activityType: Temporal_Api_Common_V1_ActivityType {
    get {return _storage._activityType ?? Temporal_Api_Common_V1_ActivityType()}
    set {_uniqueStorage()._activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  package var hasActivityType: Bool {return _storage._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  package mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
  /// retries will be attempted. Either this or `start_to_close_timeout` must be specified.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Limits time an activity task can stay in a task queue before a worker picks it up. This
  /// timeout is always non retryable, as all a retry would achieve is to put it back into the same
  /// queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
  /// specified.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToStartTimeout = newValue}
  }
  /// Returns true if `scheduleToStartTimeout` has been explicitly set.
  package var hasScheduleToStartTimeout: Bool {return _storage._scheduleToStartTimeout != nil}
  /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

  /// Maximum time an activity is allowed to execute after being picked up by a worker. This
  /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be
  /// specified.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// Maximum permitted time between successful worker heartbeats.
  package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._heartbeatTimeout = newValue}
  }
  /// Returns true if `heartbeatTimeout` has been explicitly set.
  package var hasHeartbeatTimeout: Bool {return _storage._heartbeatTimeout != nil}
  /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 {
    get {return _storage._workflowTaskCompletedEventID}
    set {_uniqueStorage()._workflowTaskCompletedEventID = newValue}
  }

  /// Activities are assigned a default retry policy controlled by the service's dynamic
  /// configuration. Retries will happen up to `schedule_to_close_timeout`. To disable retries set
  /// retry_policy.maximum_attempts to 1.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
  /// Assignment rules of the activity's Task Queue will be used to determine the Build ID.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var useWorkflowBuildID: Bool {
    get {return _storage._useWorkflowBuildID}
    set {_uniqueStorage()._useWorkflowBuildID = newValue}
  }

  /// Priority metadata. If this message is not present, or any fields are not
  /// present, they inherit the values from the workflow.
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_ActivityTaskStartedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this task corresponds to
  package var scheduledEventID: Int64 = 0

  /// id of the worker that picked up this task
  package var identity: String = String()

  /// TODO ??
  package var requestID: String = String()

  /// Starting at 1, the number of times this task has been attempted
  package var attempt: Int32 = 0

  /// Will be set to the most recent failure details, if this task has previously failed and then
  /// been retried.
  package var lastFailure: Temporal_Api_Failure_V1_Failure {
    get {return _lastFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_lastFailure = newValue}
  }
  /// Returns true if `lastFailure` has been explicitly set.
  package var hasLastFailure: Bool {return self._lastFailure != nil}
  /// Clears the value of `lastFailure`. Subsequent reads from it will return its default value.
  package mutating func clearLastFailure() {self._lastFailure = nil}

  /// Version info of the worker to whom this task was dispatched.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  /// Used by server internally to properly reapply build ID redirects to an execution
  /// when rebuilding it from events.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var buildIDRedirectCounter: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastFailure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Serialized results of the activity. IE: The return value of the activity function
  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this completion corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `ACTIVITY_TASK_STARTED` event this completion corresponds to
  package var startedEventID: Int64 = 0

  /// id of the worker that completed this task
  package var identity: String = String()

  /// Version info of the worker who processed this workflow task.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_ActivityTaskFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Failure details
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this failure corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `ACTIVITY_TASK_STARTED` event this failure corresponds to
  package var startedEventID: Int64 = 0

  /// id of the worker that failed this task
  package var identity: String = String()

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  /// Version info of the worker who processed this workflow task.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If this activity had failed, was retried, and then timed out, that failure is stored as the
  /// `cause` in here.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this timeout corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `ACTIVITY_TASK_STARTED` event this timeout corresponds to
  package var startedEventID: Int64 = 0

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel request corresponds to
  package var scheduledEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Additional information that the activity reported upon confirming cancellation
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// id of the most recent `ACTIVITY_TASK_CANCEL_REQUESTED` event which refers to the same
  /// activity
  package var latestCancelRequestedEventID: Int64 = 0

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this cancel confirmation corresponds to
  package var scheduledEventID: Int64 = 0

  /// The id of the `ACTIVITY_TASK_STARTED` event this cancel confirmation corresponds to
  package var startedEventID: Int64 = 0

  /// id of the worker who canceled this activity
  package var identity: String = String()

  /// Version info of the worker who processed this workflow task.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _workerVersion ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_workerVersion = newValue}
  }
  /// Returns true if `workerVersion` has been explicitly set.
  package var hasWorkerVersion: Bool {return self._workerVersion != nil}
  /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersion() {self._workerVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
}

package struct Temporal_Api_History_V1_TimerStartedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The worker/user assigned id for this timer
  package var timerID: String = String()

  /// How long until this timer fires
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startToFireTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startToFireTimeout = newValue}
  }
  /// Returns true if `startToFireTimeout` has been explicitly set.
  package var hasStartToFireTimeout: Bool {return self._startToFireTimeout != nil}
  /// Clears the value of `startToFireTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToFireTimeout() {self._startToFireTimeout = nil}

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_History_V1_TimerFiredEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will match the `timer_id` from `TIMER_STARTED` event for this timer
  package var timerID: String = String()

  /// The id of the `TIMER_STARTED` event itself
  package var startedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_TimerCanceledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Will match the `timer_id` from `TIMER_STARTED` event for this timer
  package var timerID: String = String()

  /// The id of the `TIMER_STARTED` event itself
  package var startedEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// The id of the worker who requested this cancel
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User provided reason for requesting cancellation
  /// TODO: shall we create a new field with name "reason" and deprecate this one?
  package var cause: String = String()

  /// TODO: Is this the ID of the event in the workflow which initiated this cancel, if there was one?
  package var externalInitiatedEventID: Int64 = 0

  package var externalWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _externalWorkflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_externalWorkflowExecution = newValue}
  }
  /// Returns true if `externalWorkflowExecution` has been explicitly set.
  package var hasExternalWorkflowExecution: Bool {return self._externalWorkflowExecution != nil}
  /// Clears the value of `externalWorkflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearExternalWorkflowExecution() {self._externalWorkflowExecution = nil}

  /// id of the worker or client who requested this cancel
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _externalWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_History_V1_MarkerRecordedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Workers use this to identify the "types" of various markers. Ex: Local activity, side effect.
  package var markerName: String = String()

  /// Serialized information recorded in the marker
  package var details: Dictionary<String,Temporal_Api_Common_V1_Payloads> = [:]

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  /// Some uses of markers, like a local activity, could "fail". If they did that is recorded here.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name/type of the signal to fire
  package var signalName: String = String()

  /// Will be deserialized and provided as argument(s) to the signal handler
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _input ?? Temporal_Api_Common_V1_Payloads()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// id of the worker/client who sent this signal
  package var identity: String = String()

  /// Headers that were passed by the sender of the signal and copied by temporal
  /// server into the workflow task.
  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  /// Deprecated. This field is never respected and should always be set to false.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var skipGenerateWorkflowTask: Bool = false

  /// When signal origin is a workflow execution, this field is set.
  package var externalWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _externalWorkflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_externalWorkflowExecution = newValue}
  }
  /// Returns true if `externalWorkflowExecution` has been explicitly set.
  package var hasExternalWorkflowExecution: Bool {return self._externalWorkflowExecution != nil}
  /// Clears the value of `externalWorkflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearExternalWorkflowExecution() {self._externalWorkflowExecution = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
  fileprivate var _externalWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User/client provided reason for termination
  package var reason: String = String()

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// id of the client who requested termination
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// The namespace the workflow to be cancelled lives in.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Workers are expected to set this to true if the workflow they are requesting to cancel is
  /// a child of the workflow which issued the request
  package var childWorkflowOnly: Bool = false

  /// Reason for requesting the cancellation
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var cause: Temporal_Api_Enums_V1_CancelExternalWorkflowExecutionFailedCause = .unspecified

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// Namespace of the workflow which failed to cancel.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this failure
  /// corresponds to
  package var initiatedEventID: Int64 = 0

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the `REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds
  /// to
  package var initiatedEventID: Int64 = 0

  /// Namespace of the to-be-cancelled workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// Namespace of the to-be-signalled workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// name/type of the signal to fire in the external workflow
  package var signalName: String = String()

  /// Serialized arguments to provide to the signal handler
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _input ?? Temporal_Api_Common_V1_Payloads()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Workers are expected to set this to true if the workflow they are requesting to cancel is
  /// a child of the workflow which issued the request
  package var childWorkflowOnly: Bool = false

  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
}

package struct Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var cause: Temporal_Api_Enums_V1_SignalExternalWorkflowExecutionFailedCause = .unspecified

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// Namespace of the workflow which failed the signal.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var initiatedEventID: Int64 = 0

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// id of the `SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED` event this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Namespace of the workflow which was signaled.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
}

package struct Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return self._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {self._searchAttributes = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
}

package struct Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  /// If set, update the workflow memo with the provided values. The values will be merged with
  /// the existing memo. If the user wants to delete values, a default/empty Payload should be
  /// used as the value for the key being deleted.
  package var upsertedMemo: Temporal_Api_Common_V1_Memo {
    get {return _upsertedMemo ?? Temporal_Api_Common_V1_Memo()}
    set {_upsertedMemo = newValue}
  }
  /// Returns true if `upsertedMemo` has been explicitly set.
  package var hasUpsertedMemo: Bool {return self._upsertedMemo != nil}
  /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
  package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _upsertedMemo: Temporal_Api_Common_V1_Memo? = nil
}

package struct Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var namespaceID: String {
    get {return _storage._namespaceID}
    set {_uniqueStorage()._namespaceID = newValue}
  }

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Default: PARENT_CLOSE_POLICY_TERMINATE.
  package var parentClosePolicy: Temporal_Api_Enums_V1_ParentClosePolicy {
    get {return _storage._parentClosePolicy}
    set {_uniqueStorage()._parentClosePolicy = newValue}
  }

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String {
    get {return _storage._control}
    set {_uniqueStorage()._control = newValue}
  }

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 {
    get {return _storage._workflowTaskCompletedEventID}
    set {_uniqueStorage()._workflowTaskCompletedEventID = newValue}
  }

  /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// If this child runs on a cron schedule, it will appear here
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
  /// rules of the child's Task Queue will be used to independently assign a Build ID to it.
  /// Deprecated. Only considered for versioning v0.2.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritBuildID: Bool {
    get {return _storage._inheritBuildID}
    set {_uniqueStorage()._inheritBuildID = newValue}
  }

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowID: String = String()

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  package var cause: Temporal_Api_Enums_V1_StartChildWorkflowExecutionFailedCause = .unspecified

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event which this command was reported with
  package var workflowTaskCompletedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
  package var startedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
  package var startedEventID: Int64 = 0

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
  package var startedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
  package var startedEventID: Int64 = 0

  package var retryState: Temporal_Api_Enums_V1_RetryState = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Namespace of the child workflow.
  /// SDKs and UI tools should use `namespace` field but server must use `namespace_id` only.
  package var namespace: String = String()

  package var namespaceID: String = String()

  package var workflowExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _workflowExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return self._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {self._workflowType = nil}

  /// Id of the `START_CHILD_WORKFLOW_EXECUTION_INITIATED` event which this event corresponds to
  package var initiatedEventID: Int64 = 0

  /// Id of the `CHILD_WORKFLOW_EXECUTION_STARTED` event which this event corresponds to
  package var startedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Versioning override upserted in this event.
  /// Ignored if nil or if unset_versioning_override is true.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return self._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {self._versioningOverride = nil}

  /// Versioning override removed in this event.
  package var unsetVersioningOverride: Bool = false

  /// Request ID attachedto the running workflow execution so that subsequent requests with same
  /// request ID will be deduped.
  package var attachedRequestID: String = String()

  /// Completion callbacks attached to the running workflow execution.
  package var attachedCompletionCallbacks: [Temporal_Api_Common_V1_Callback] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
}

/// Not used anywhere. Use case is replaced by WorkflowExecutionOptionsUpdatedEventAttributes
package struct Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Not used.
  package var newTaskQueue: String = String()

  /// Not used.
  package var newWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _newWorkflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_newWorkflowTaskTimeout = newValue}
  }
  /// Returns true if `newWorkflowTaskTimeout` has been explicitly set.
  package var hasNewWorkflowTaskTimeout: Bool {return self._newWorkflowTaskTimeout != nil}
  /// Clears the value of `newWorkflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearNewWorkflowTaskTimeout() {self._newWorkflowTaskTimeout = nil}

  /// Not used.
  package var newWorkflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _newWorkflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_newWorkflowRunTimeout = newValue}
  }
  /// Returns true if `newWorkflowRunTimeout` has been explicitly set.
  package var hasNewWorkflowRunTimeout: Bool {return self._newWorkflowRunTimeout != nil}
  /// Clears the value of `newWorkflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearNewWorkflowRunTimeout() {self._newWorkflowRunTimeout = nil}

  /// Not used.
  package var newWorkflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _newWorkflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_newWorkflowExecutionTimeout = newValue}
  }
  /// Returns true if `newWorkflowExecutionTimeout` has been explicitly set.
  package var hasNewWorkflowExecutionTimeout: Bool {return self._newWorkflowExecutionTimeout != nil}
  /// Clears the value of `newWorkflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearNewWorkflowExecutionTimeout() {self._newWorkflowExecutionTimeout = nil}

  /// Not used.
  package var upsertedMemo: Temporal_Api_Common_V1_Memo {
    get {return _upsertedMemo ?? Temporal_Api_Common_V1_Memo()}
    set {_upsertedMemo = newValue}
  }
  /// Returns true if `upsertedMemo` has been explicitly set.
  package var hasUpsertedMemo: Bool {return self._upsertedMemo != nil}
  /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
  package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _newWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _newWorkflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _newWorkflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _upsertedMemo: Temporal_Api_Common_V1_Memo? = nil
}

package struct Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `ACTIVITY_TASK_SCHEDULED` event this modification corresponds to.
  package var scheduledEventID: Int64 = 0

  /// If set, update the retry policy of the activity, replacing it with the specified one.
  /// The number of attempts at the activity is preserved.
  package var newRetryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _newRetryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_newRetryPolicy = newValue}
  }
  /// Returns true if `newRetryPolicy` has been explicitly set.
  package var hasNewRetryPolicy: Bool {return self._newRetryPolicy != nil}
  /// Clears the value of `newRetryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearNewRetryPolicy() {self._newRetryPolicy = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _newRetryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance ID of the update protocol that generated this event.
  package var protocolInstanceID: String = String()

  /// The message ID of the original request message that initiated this
  /// update. Needed so that the worker can recreate and deliver that same
  /// message as part of replay.
  package var acceptedRequestMessageID: String = String()

  /// The event ID used to sequence the original request message.
  package var acceptedRequestSequencingEventID: Int64 = 0

  /// The message payload of the original request message that initiated this
  /// update.
  package var acceptedRequest: Temporal_Api_Update_V1_Request {
    get {return _acceptedRequest ?? Temporal_Api_Update_V1_Request()}
    set {_acceptedRequest = newValue}
  }
  /// Returns true if `acceptedRequest` has been explicitly set.
  package var hasAcceptedRequest: Bool {return self._acceptedRequest != nil}
  /// Clears the value of `acceptedRequest`. Subsequent reads from it will return its default value.
  package mutating func clearAcceptedRequest() {self._acceptedRequest = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _acceptedRequest: Temporal_Api_Update_V1_Request? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The metadata about this update.
  package var meta: Temporal_Api_Update_V1_Meta {
    get {return _meta ?? Temporal_Api_Update_V1_Meta()}
    set {_meta = newValue}
  }
  /// Returns true if `meta` has been explicitly set.
  package var hasMeta: Bool {return self._meta != nil}
  /// Clears the value of `meta`. Subsequent reads from it will return its default value.
  package mutating func clearMeta() {self._meta = nil}

  /// The event ID indicating the acceptance of this update.
  package var acceptedEventID: Int64 = 0

  /// The outcome of executing the workflow update function.
  package var outcome: Temporal_Api_Update_V1_Outcome {
    get {return _outcome ?? Temporal_Api_Update_V1_Outcome()}
    set {_outcome = newValue}
  }
  /// Returns true if `outcome` has been explicitly set.
  package var hasOutcome: Bool {return self._outcome != nil}
  /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
  package mutating func clearOutcome() {self._outcome = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _meta: Temporal_Api_Update_V1_Meta? = nil
  fileprivate var _outcome: Temporal_Api_Update_V1_Outcome? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The instance ID of the update protocol that generated this event.
  package var protocolInstanceID: String = String()

  /// The message ID of the original request message that initiated this
  /// update. Needed so that the worker can recreate and deliver that same
  /// message as part of replay.
  package var rejectedRequestMessageID: String = String()

  /// The event ID used to sequence the original request message.
  package var rejectedRequestSequencingEventID: Int64 = 0

  /// The message payload of the original request message that initiated this
  /// update.
  package var rejectedRequest: Temporal_Api_Update_V1_Request {
    get {return _rejectedRequest ?? Temporal_Api_Update_V1_Request()}
    set {_rejectedRequest = newValue}
  }
  /// Returns true if `rejectedRequest` has been explicitly set.
  package var hasRejectedRequest: Bool {return self._rejectedRequest != nil}
  /// Clears the value of `rejectedRequest`. Subsequent reads from it will return its default value.
  package mutating func clearRejectedRequest() {self._rejectedRequest = nil}

  /// The cause of rejection.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rejectedRequest: Temporal_Api_Update_V1_Request? = nil
  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The update request associated with this event.
  package var request: Temporal_Api_Update_V1_Request {
    get {return _request ?? Temporal_Api_Update_V1_Request()}
    set {_request = newValue}
  }
  /// Returns true if `request` has been explicitly set.
  package var hasRequest: Bool {return self._request != nil}
  /// Clears the value of `request`. Subsequent reads from it will return its default value.
  package mutating func clearRequest() {self._request = nil}

  /// An explanation of why this event was written to history.
  package var origin: Temporal_Api_Enums_V1_UpdateAdmittedEventOrigin = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _request: Temporal_Api_Update_V1_Request? = nil
}

/// Event marking that an operation was scheduled by a workflow via the ScheduleNexusOperation command.
package struct Temporal_Api_History_V1_NexusOperationScheduledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint name, must exist in the endpoint registry.
  package var endpoint: String = String()

  /// Service name.
  package var service: String = String()

  /// Operation name.
  package var operation: String = String()

  /// Input for the operation. The server converts this into Nexus request content and the appropriate content headers
  /// internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
  /// content is transformed back to the original Payload stored in this event.
  package var input: Temporal_Api_Common_V1_Payload {
    get {return _input ?? Temporal_Api_Common_V1_Payload()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Schedule-to-close timeout for this operation.
  /// Indicates how long the caller is willing to wait for operation completion.
  /// Calls are retried internally by the server.
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return self._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {self._scheduleToCloseTimeout = nil}

  /// Header to attach to the Nexus request. Note these headers are not the same as Temporal headers on internal
  /// activities and child workflows, these are transmitted to Nexus operations that may be external and are not
  /// traditional payloads.
  package var nexusHeader: Dictionary<String,String> = [:]

  /// The `WORKFLOW_TASK_COMPLETED` event that the corresponding ScheduleNexusOperation command was reported with.
  package var workflowTaskCompletedEventID: Int64 = 0

  /// A unique ID generated by the history service upon creation of this event.
  /// The ID will be transmitted with all nexus StartOperation requests and is used as an idempotentency key.
  package var requestID: String = String()

  /// Endpoint ID as resolved in the endpoint registry at the time this event was generated.
  /// This is stored on the event and used internally by the server in case the endpoint is renamed from the time the
  /// event was originally scheduled.
  package var endpointID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _input: Temporal_Api_Common_V1_Payload? = nil
  fileprivate var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Event marking an asynchronous operation was started by the responding Nexus handler.
/// If the operation completes synchronously, this event is not generated.
/// In rare situations, such as request timeouts, the service may fail to record the actual start time and will fabricate
/// this event upon receiving the operation completion via callback.
package struct Temporal_Api_History_V1_NexusOperationStartedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_SCHEDULED` event this task corresponds to.
  package var scheduledEventID: Int64 = 0

  /// The operation ID returned by the Nexus handler in the response to the StartOperation request.
  /// This ID is used when canceling the operation.
  ///
  /// Deprecated: Renamed to operation_token.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var operationID: String = String()

  /// The request ID allocated at schedule time.
  package var requestID: String = String()

  /// The operation token returned by the Nexus handler in the response to the StartOperation request.
  /// This token is used when canceling the operation.
  package var operationToken: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Nexus operation completed successfully.
package struct Temporal_Api_History_V1_NexusOperationCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
  package var scheduledEventID: Int64 = 0

  /// Serialized result of the Nexus operation. The response of the Nexus handler.
  /// Delivered either via a completion callback or as a response to a synchronous operation.
  package var result: Temporal_Api_Common_V1_Payload {
    get {return _result ?? Temporal_Api_Common_V1_Payload()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  /// The request ID allocated at schedule time.
  package var requestID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payload? = nil
}

/// Nexus operation failed.
package struct Temporal_Api_History_V1_NexusOperationFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
  package var scheduledEventID: Int64 = 0

  /// Failure details. A NexusOperationFailureInfo wrapping an ApplicationFailureInfo.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The request ID allocated at schedule time.
  package var requestID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Nexus operation timed out.
package struct Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
  package var scheduledEventID: Int64 = 0

  /// Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The request ID allocated at schedule time.
  package var requestID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Nexus operation completed as canceled. May or may not have been due to a cancellation request by the workflow.
package struct Temporal_Api_History_V1_NexusOperationCanceledEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_SCHEDULED` event. Uniquely identifies this operation.
  package var scheduledEventID: Int64 = 0

  /// Cancellation details.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The request ID allocated at schedule time.
  package var requestID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
  package var scheduledEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
  /// with.
  package var workflowTaskCompletedEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
  package var requestedEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
  /// with.
  package var workflowTaskCompletedEventID: Int64 = 0

  /// The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
  package var scheduledEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the `NEXUS_OPERATION_CANCEL_REQUESTED` event.
  package var requestedEventID: Int64 = 0

  /// The `WORKFLOW_TASK_COMPLETED` event that the corresponding RequestCancelNexusOperation command was reported
  /// with.
  package var workflowTaskCompletedEventID: Int64 = 0

  /// Failure details. A NexusOperationFailureInfo wrapping a CanceledFailureInfo.
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  /// The id of the `NEXUS_OPERATION_SCHEDULED` event this cancel request corresponds to.
  package var scheduledEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// History events are the method by which Temporal SDKs advance (or recreate) workflow state.
/// See the `EventType` enum for more info about what each event is for.
package struct Temporal_Api_History_V1_HistoryEvent: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Monotonically increasing event number, starts at 1.
  package var eventID: Int64 {
    get {return _storage._eventID}
    set {_uniqueStorage()._eventID = newValue}
  }

  package var eventTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._eventTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._eventTime = newValue}
  }
  /// Returns true if `eventTime` has been explicitly set.
  package var hasEventTime: Bool {return _storage._eventTime != nil}
  /// Clears the value of `eventTime`. Subsequent reads from it will return its default value.
  package mutating func clearEventTime() {_uniqueStorage()._eventTime = nil}

  package var eventType: Temporal_Api_Enums_V1_EventType {
    get {return _storage._eventType}
    set {_uniqueStorage()._eventType = newValue}
  }

  /// TODO: What is this? Appears unused by SDKs
  package var version: Int64 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// TODO: What is this? Appears unused by SDKs
  package var taskID: Int64 {
    get {return _storage._taskID}
    set {_uniqueStorage()._taskID = newValue}
  }

  /// Set to true when the SDK may ignore the event as it does not impact workflow state or
  /// information in any way that the SDK need be concerned with. If an SDK encounters an event
  /// type which it does not understand, it must error unless this is true. If it is true, it's
  /// acceptable for the event type and/or attributes to be uninterpretable.
  package var workerMayIgnore: Bool {
    get {return _storage._workerMayIgnore}
    set {_uniqueStorage()._workerMayIgnore = newValue}
  }

  /// Metadata on the event. This is often carried over from commands and client calls. Most events
  /// won't have this information, and how this information is used is dependent upon the interface
  /// that reads it.
  ///
  /// Current well-known uses:
  ///  * workflow_execution_started_event_attributes - summary and details from start workflow.
  ///  * timer_started_event_attributes - summary represents an identifier for the timer for use by
  ///    user interfaces.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _storage._userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  /// Links associated with the event.
  package var links: [Temporal_Api_Common_V1_Link] {
    get {return _storage._links}
    set {_uniqueStorage()._links = newValue}
  }

  /// The event details. The type must match that in `event_type`.
  package var attributes: OneOf_Attributes? {
    get {return _storage._attributes}
    set {_uniqueStorage()._attributes = newValue}
  }

  package var workflowExecutionStartedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes {
    get {
      if case .workflowExecutionStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionStartedEventAttributes(newValue)}
  }

  package var workflowExecutionCompletedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes {
    get {
      if case .workflowExecutionCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionCompletedEventAttributes(newValue)}
  }

  package var workflowExecutionFailedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes {
    get {
      if case .workflowExecutionFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionFailedEventAttributes(newValue)}
  }

  package var workflowExecutionTimedOutEventAttributes: Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes {
    get {
      if case .workflowExecutionTimedOutEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionTimedOutEventAttributes(newValue)}
  }

  package var workflowTaskScheduledEventAttributes: Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes {
    get {
      if case .workflowTaskScheduledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowTaskScheduledEventAttributes(newValue)}
  }

  package var workflowTaskStartedEventAttributes: Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes {
    get {
      if case .workflowTaskStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowTaskStartedEventAttributes(newValue)}
  }

  package var workflowTaskCompletedEventAttributes: Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes {
    get {
      if case .workflowTaskCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowTaskCompletedEventAttributes(newValue)}
  }

  package var workflowTaskTimedOutEventAttributes: Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes {
    get {
      if case .workflowTaskTimedOutEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowTaskTimedOutEventAttributes(newValue)}
  }

  package var workflowTaskFailedEventAttributes: Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes {
    get {
      if case .workflowTaskFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowTaskFailedEventAttributes(newValue)}
  }

  package var activityTaskScheduledEventAttributes: Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes {
    get {
      if case .activityTaskScheduledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskScheduledEventAttributes(newValue)}
  }

  package var activityTaskStartedEventAttributes: Temporal_Api_History_V1_ActivityTaskStartedEventAttributes {
    get {
      if case .activityTaskStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskStartedEventAttributes(newValue)}
  }

  package var activityTaskCompletedEventAttributes: Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes {
    get {
      if case .activityTaskCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskCompletedEventAttributes(newValue)}
  }

  package var activityTaskFailedEventAttributes: Temporal_Api_History_V1_ActivityTaskFailedEventAttributes {
    get {
      if case .activityTaskFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskFailedEventAttributes(newValue)}
  }

  package var activityTaskTimedOutEventAttributes: Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes {
    get {
      if case .activityTaskTimedOutEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskTimedOutEventAttributes(newValue)}
  }

  package var timerStartedEventAttributes: Temporal_Api_History_V1_TimerStartedEventAttributes {
    get {
      if case .timerStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_TimerStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .timerStartedEventAttributes(newValue)}
  }

  package var timerFiredEventAttributes: Temporal_Api_History_V1_TimerFiredEventAttributes {
    get {
      if case .timerFiredEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_TimerFiredEventAttributes()
    }
    set {_uniqueStorage()._attributes = .timerFiredEventAttributes(newValue)}
  }

  package var activityTaskCancelRequestedEventAttributes: Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes {
    get {
      if case .activityTaskCancelRequestedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskCancelRequestedEventAttributes(newValue)}
  }

  package var activityTaskCanceledEventAttributes: Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes {
    get {
      if case .activityTaskCanceledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityTaskCanceledEventAttributes(newValue)}
  }

  package var timerCanceledEventAttributes: Temporal_Api_History_V1_TimerCanceledEventAttributes {
    get {
      if case .timerCanceledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_TimerCanceledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .timerCanceledEventAttributes(newValue)}
  }

  package var markerRecordedEventAttributes: Temporal_Api_History_V1_MarkerRecordedEventAttributes {
    get {
      if case .markerRecordedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_MarkerRecordedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .markerRecordedEventAttributes(newValue)}
  }

  package var workflowExecutionSignaledEventAttributes: Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes {
    get {
      if case .workflowExecutionSignaledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionSignaledEventAttributes(newValue)}
  }

  package var workflowExecutionTerminatedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes {
    get {
      if case .workflowExecutionTerminatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionTerminatedEventAttributes(newValue)}
  }

  package var workflowExecutionCancelRequestedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes {
    get {
      if case .workflowExecutionCancelRequestedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionCancelRequestedEventAttributes(newValue)}
  }

  package var workflowExecutionCanceledEventAttributes: Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes {
    get {
      if case .workflowExecutionCanceledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionCanceledEventAttributes(newValue)}
  }

  package var requestCancelExternalWorkflowExecutionInitiatedEventAttributes: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes {
    get {
      if case .requestCancelExternalWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .requestCancelExternalWorkflowExecutionInitiatedEventAttributes(newValue)}
  }

  package var requestCancelExternalWorkflowExecutionFailedEventAttributes: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes {
    get {
      if case .requestCancelExternalWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .requestCancelExternalWorkflowExecutionFailedEventAttributes(newValue)}
  }

  package var externalWorkflowExecutionCancelRequestedEventAttributes: Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes {
    get {
      if case .externalWorkflowExecutionCancelRequestedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .externalWorkflowExecutionCancelRequestedEventAttributes(newValue)}
  }

  package var workflowExecutionContinuedAsNewEventAttributes: Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes {
    get {
      if case .workflowExecutionContinuedAsNewEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionContinuedAsNewEventAttributes(newValue)}
  }

  package var startChildWorkflowExecutionInitiatedEventAttributes: Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes {
    get {
      if case .startChildWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .startChildWorkflowExecutionInitiatedEventAttributes(newValue)}
  }

  package var startChildWorkflowExecutionFailedEventAttributes: Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes {
    get {
      if case .startChildWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .startChildWorkflowExecutionFailedEventAttributes(newValue)}
  }

  package var childWorkflowExecutionStartedEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes {
    get {
      if case .childWorkflowExecutionStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionStartedEventAttributes(newValue)}
  }

  package var childWorkflowExecutionCompletedEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes {
    get {
      if case .childWorkflowExecutionCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionCompletedEventAttributes(newValue)}
  }

  package var childWorkflowExecutionFailedEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes {
    get {
      if case .childWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionFailedEventAttributes(newValue)}
  }

  package var childWorkflowExecutionCanceledEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes {
    get {
      if case .childWorkflowExecutionCanceledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionCanceledEventAttributes(newValue)}
  }

  package var childWorkflowExecutionTimedOutEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes {
    get {
      if case .childWorkflowExecutionTimedOutEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionTimedOutEventAttributes(newValue)}
  }

  package var childWorkflowExecutionTerminatedEventAttributes: Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes {
    get {
      if case .childWorkflowExecutionTerminatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .childWorkflowExecutionTerminatedEventAttributes(newValue)}
  }

  package var signalExternalWorkflowExecutionInitiatedEventAttributes: Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes {
    get {
      if case .signalExternalWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .signalExternalWorkflowExecutionInitiatedEventAttributes(newValue)}
  }

  package var signalExternalWorkflowExecutionFailedEventAttributes: Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes {
    get {
      if case .signalExternalWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .signalExternalWorkflowExecutionFailedEventAttributes(newValue)}
  }

  package var externalWorkflowExecutionSignaledEventAttributes: Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes {
    get {
      if case .externalWorkflowExecutionSignaledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .externalWorkflowExecutionSignaledEventAttributes(newValue)}
  }

  package var upsertWorkflowSearchAttributesEventAttributes: Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes {
    get {
      if case .upsertWorkflowSearchAttributesEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes()
    }
    set {_uniqueStorage()._attributes = .upsertWorkflowSearchAttributesEventAttributes(newValue)}
  }

  package var workflowExecutionUpdateAcceptedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes {
    get {
      if case .workflowExecutionUpdateAcceptedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionUpdateAcceptedEventAttributes(newValue)}
  }

  package var workflowExecutionUpdateRejectedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes {
    get {
      if case .workflowExecutionUpdateRejectedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionUpdateRejectedEventAttributes(newValue)}
  }

  package var workflowExecutionUpdateCompletedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes {
    get {
      if case .workflowExecutionUpdateCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionUpdateCompletedEventAttributes(newValue)}
  }

  package var workflowPropertiesModifiedExternallyEventAttributes: Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes {
    get {
      if case .workflowPropertiesModifiedExternallyEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowPropertiesModifiedExternallyEventAttributes(newValue)}
  }

  package var activityPropertiesModifiedExternallyEventAttributes: Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes {
    get {
      if case .activityPropertiesModifiedExternallyEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes()
    }
    set {_uniqueStorage()._attributes = .activityPropertiesModifiedExternallyEventAttributes(newValue)}
  }

  package var workflowPropertiesModifiedEventAttributes: Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes {
    get {
      if case .workflowPropertiesModifiedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowPropertiesModifiedEventAttributes(newValue)}
  }

  package var workflowExecutionUpdateAdmittedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes {
    get {
      if case .workflowExecutionUpdateAdmittedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionUpdateAdmittedEventAttributes(newValue)}
  }

  package var nexusOperationScheduledEventAttributes: Temporal_Api_History_V1_NexusOperationScheduledEventAttributes {
    get {
      if case .nexusOperationScheduledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationScheduledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationScheduledEventAttributes(newValue)}
  }

  package var nexusOperationStartedEventAttributes: Temporal_Api_History_V1_NexusOperationStartedEventAttributes {
    get {
      if case .nexusOperationStartedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationStartedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationStartedEventAttributes(newValue)}
  }

  package var nexusOperationCompletedEventAttributes: Temporal_Api_History_V1_NexusOperationCompletedEventAttributes {
    get {
      if case .nexusOperationCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationCompletedEventAttributes(newValue)}
  }

  package var nexusOperationFailedEventAttributes: Temporal_Api_History_V1_NexusOperationFailedEventAttributes {
    get {
      if case .nexusOperationFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationFailedEventAttributes(newValue)}
  }

  package var nexusOperationCanceledEventAttributes: Temporal_Api_History_V1_NexusOperationCanceledEventAttributes {
    get {
      if case .nexusOperationCanceledEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationCanceledEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationCanceledEventAttributes(newValue)}
  }

  package var nexusOperationTimedOutEventAttributes: Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes {
    get {
      if case .nexusOperationTimedOutEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationTimedOutEventAttributes(newValue)}
  }

  package var nexusOperationCancelRequestedEventAttributes: Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes {
    get {
      if case .nexusOperationCancelRequestedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationCancelRequestedEventAttributes(newValue)}
  }

  package var workflowExecutionOptionsUpdatedEventAttributes: Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes {
    get {
      if case .workflowExecutionOptionsUpdatedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .workflowExecutionOptionsUpdatedEventAttributes(newValue)}
  }

  package var nexusOperationCancelRequestCompletedEventAttributes: Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes {
    get {
      if case .nexusOperationCancelRequestCompletedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationCancelRequestCompletedEventAttributes(newValue)}
  }

  package var nexusOperationCancelRequestFailedEventAttributes: Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes {
    get {
      if case .nexusOperationCancelRequestFailedEventAttributes(let v)? = _storage._attributes {return v}
      return Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes()
    }
    set {_uniqueStorage()._attributes = .nexusOperationCancelRequestFailedEventAttributes(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The event details. The type must match that in `event_type`.
  package enum OneOf_Attributes: Equatable, Sendable {
    case workflowExecutionStartedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes)
    case workflowExecutionCompletedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes)
    case workflowExecutionFailedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes)
    case workflowExecutionTimedOutEventAttributes(Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes)
    case workflowTaskScheduledEventAttributes(Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes)
    case workflowTaskStartedEventAttributes(Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes)
    case workflowTaskCompletedEventAttributes(Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes)
    case workflowTaskTimedOutEventAttributes(Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes)
    case workflowTaskFailedEventAttributes(Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes)
    case activityTaskScheduledEventAttributes(Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes)
    case activityTaskStartedEventAttributes(Temporal_Api_History_V1_ActivityTaskStartedEventAttributes)
    case activityTaskCompletedEventAttributes(Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes)
    case activityTaskFailedEventAttributes(Temporal_Api_History_V1_ActivityTaskFailedEventAttributes)
    case activityTaskTimedOutEventAttributes(Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes)
    case timerStartedEventAttributes(Temporal_Api_History_V1_TimerStartedEventAttributes)
    case timerFiredEventAttributes(Temporal_Api_History_V1_TimerFiredEventAttributes)
    case activityTaskCancelRequestedEventAttributes(Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes)
    case activityTaskCanceledEventAttributes(Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes)
    case timerCanceledEventAttributes(Temporal_Api_History_V1_TimerCanceledEventAttributes)
    case markerRecordedEventAttributes(Temporal_Api_History_V1_MarkerRecordedEventAttributes)
    case workflowExecutionSignaledEventAttributes(Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes)
    case workflowExecutionTerminatedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes)
    case workflowExecutionCancelRequestedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes)
    case workflowExecutionCanceledEventAttributes(Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes)
    case requestCancelExternalWorkflowExecutionInitiatedEventAttributes(Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes)
    case requestCancelExternalWorkflowExecutionFailedEventAttributes(Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes)
    case externalWorkflowExecutionCancelRequestedEventAttributes(Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes)
    case workflowExecutionContinuedAsNewEventAttributes(Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes)
    case startChildWorkflowExecutionInitiatedEventAttributes(Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes)
    case startChildWorkflowExecutionFailedEventAttributes(Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes)
    case childWorkflowExecutionStartedEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes)
    case childWorkflowExecutionCompletedEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes)
    case childWorkflowExecutionFailedEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes)
    case childWorkflowExecutionCanceledEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes)
    case childWorkflowExecutionTimedOutEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes)
    case childWorkflowExecutionTerminatedEventAttributes(Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes)
    case signalExternalWorkflowExecutionInitiatedEventAttributes(Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes)
    case signalExternalWorkflowExecutionFailedEventAttributes(Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes)
    case externalWorkflowExecutionSignaledEventAttributes(Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes)
    case upsertWorkflowSearchAttributesEventAttributes(Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes)
    case workflowExecutionUpdateAcceptedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes)
    case workflowExecutionUpdateRejectedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes)
    case workflowExecutionUpdateCompletedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes)
    case workflowPropertiesModifiedExternallyEventAttributes(Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes)
    case activityPropertiesModifiedExternallyEventAttributes(Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes)
    case workflowPropertiesModifiedEventAttributes(Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes)
    case workflowExecutionUpdateAdmittedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes)
    case nexusOperationScheduledEventAttributes(Temporal_Api_History_V1_NexusOperationScheduledEventAttributes)
    case nexusOperationStartedEventAttributes(Temporal_Api_History_V1_NexusOperationStartedEventAttributes)
    case nexusOperationCompletedEventAttributes(Temporal_Api_History_V1_NexusOperationCompletedEventAttributes)
    case nexusOperationFailedEventAttributes(Temporal_Api_History_V1_NexusOperationFailedEventAttributes)
    case nexusOperationCanceledEventAttributes(Temporal_Api_History_V1_NexusOperationCanceledEventAttributes)
    case nexusOperationTimedOutEventAttributes(Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes)
    case nexusOperationCancelRequestedEventAttributes(Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes)
    case workflowExecutionOptionsUpdatedEventAttributes(Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes)
    case nexusOperationCancelRequestCompletedEventAttributes(Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes)
    case nexusOperationCancelRequestFailedEventAttributes(Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes)

  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_History_V1_History: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var events: [Temporal_Api_History_V1_HistoryEvent] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.history.v1"

extension Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}parent_workflow_namespace\0\u{3}parent_workflow_execution\0\u{3}parent_initiated_event_id\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}continued_execution_run_id\0\u{1}initiator\0\u{3}continued_failure\0\u{3}last_completion_result\0\u{3}original_execution_run_id\0\u{1}identity\0\u{3}first_execution_run_id\0\u{3}retry_policy\0\u{1}attempt\0\u{3}workflow_execution_expiration_time\0\u{3}cron_schedule\0\u{3}first_workflow_task_backoff\0\u{1}memo\0\u{3}search_attributes\0\u{3}prev_auto_reset_points\0\u{1}header\0\u{3}parent_initiated_event_version\0\u{3}parent_workflow_namespace_id\0\u{3}workflow_id\0\u{3}source_version_stamp\0\u{3}completion_callbacks\0\u{3}root_workflow_execution\0\u{3}inherited_build_id\0\u{3}versioning_override\0\u{3}parent_pinned_worker_deployment_version\0\u{1}priority\0\u{4}\u{2}inherited_pinned_version\0\u{3}eager_execution_accepted\0\u{b}parent_pinned_deployment_version\0\u{c}$\u{1}")

  fileprivate class _StorageClass {
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _parentWorkflowNamespace: String = String()
    var _parentWorkflowNamespaceID: String = String()
    var _parentWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _parentInitiatedEventID: Int64 = 0
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _continuedExecutionRunID: String = String()
    var _initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator = .unspecified
    var _continuedFailure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastCompletionResult: Temporal_Api_Common_V1_Payloads? = nil
    var _originalExecutionRunID: String = String()
    var _identity: String = String()
    var _firstExecutionRunID: String = String()
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _attempt: Int32 = 0
    var _workflowExecutionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cronSchedule: String = String()
    var _firstWorkflowTaskBackoff: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _prevAutoResetPoints: Temporal_Api_Workflow_V1_ResetPoints? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _parentInitiatedEventVersion: Int64 = 0
    var _workflowID: String = String()
    var _sourceVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
    var _completionCallbacks: [Temporal_Api_Common_V1_Callback] = []
    var _rootWorkflowExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _inheritedBuildID: String = String()
    var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
    var _parentPinnedWorkerDeploymentVersion: String = String()
    var _priority: Temporal_Api_Common_V1_Priority? = nil
    var _inheritedPinnedVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _eagerExecutionAccepted: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _parentWorkflowNamespace = source._parentWorkflowNamespace
      _parentWorkflowNamespaceID = source._parentWorkflowNamespaceID
      _parentWorkflowExecution = source._parentWorkflowExecution
      _parentInitiatedEventID = source._parentInitiatedEventID
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _continuedExecutionRunID = source._continuedExecutionRunID
      _initiator = source._initiator
      _continuedFailure = source._continuedFailure
      _lastCompletionResult = source._lastCompletionResult
      _originalExecutionRunID = source._originalExecutionRunID
      _identity = source._identity
      _firstExecutionRunID = source._firstExecutionRunID
      _retryPolicy = source._retryPolicy
      _attempt = source._attempt
      _workflowExecutionExpirationTime = source._workflowExecutionExpirationTime
      _cronSchedule = source._cronSchedule
      _firstWorkflowTaskBackoff = source._firstWorkflowTaskBackoff
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _prevAutoResetPoints = source._prevAutoResetPoints
      _header = source._header
      _parentInitiatedEventVersion = source._parentInitiatedEventVersion
      _workflowID = source._workflowID
      _sourceVersionStamp = source._sourceVersionStamp
      _completionCallbacks = source._completionCallbacks
      _rootWorkflowExecution = source._rootWorkflowExecution
      _inheritedBuildID = source._inheritedBuildID
      _versioningOverride = source._versioningOverride
      _parentPinnedWorkerDeploymentVersion = source._parentPinnedWorkerDeploymentVersion
      _priority = source._priority
      _inheritedPinnedVersion = source._inheritedPinnedVersion
      _eagerExecutionAccepted = source._eagerExecutionAccepted
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._parentWorkflowNamespace) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._parentWorkflowExecution) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._parentInitiatedEventID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._continuedExecutionRunID) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._initiator) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._continuedFailure) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._originalExecutionRunID) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._firstExecutionRunID) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 18: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionExpirationTime) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._firstWorkflowTaskBackoff) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._prevAutoResetPoints) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 26: try { try decoder.decodeSingularInt64Field(value: &_storage._parentInitiatedEventVersion) }()
        case 27: try { try decoder.decodeSingularStringField(value: &_storage._parentWorkflowNamespaceID) }()
        case 28: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._sourceVersionStamp) }()
        case 30: try { try decoder.decodeRepeatedMessageField(value: &_storage._completionCallbacks) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._rootWorkflowExecution) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._inheritedBuildID) }()
        case 33: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 34: try { try decoder.decodeSingularStringField(value: &_storage._parentPinnedWorkerDeploymentVersion) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 37: try { try decoder.decodeSingularMessageField(value: &_storage._inheritedPinnedVersion) }()
        case 38: try { try decoder.decodeSingularBoolField(value: &_storage._eagerExecutionAccepted) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._parentWorkflowNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentWorkflowNamespace, fieldNumber: 2)
      }
      try { if let v = _storage._parentWorkflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._parentInitiatedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parentInitiatedEventID, fieldNumber: 4)
      }
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._continuedExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._continuedExecutionRunID, fieldNumber: 10)
      }
      if _storage._initiator != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initiator, fieldNumber: 11)
      }
      try { if let v = _storage._continuedFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._originalExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalExecutionRunID, fieldNumber: 14)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 15)
      }
      if !_storage._firstExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstExecutionRunID, fieldNumber: 16)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 18)
      }
      try { if let v = _storage._workflowExecutionExpirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 20)
      }
      try { if let v = _storage._firstWorkflowTaskBackoff {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._prevAutoResetPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      if _storage._parentInitiatedEventVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._parentInitiatedEventVersion, fieldNumber: 26)
      }
      if !_storage._parentWorkflowNamespaceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentWorkflowNamespaceID, fieldNumber: 27)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 28)
      }
      try { if let v = _storage._sourceVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      if !_storage._completionCallbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._completionCallbacks, fieldNumber: 30)
      }
      try { if let v = _storage._rootWorkflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      if !_storage._inheritedBuildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inheritedBuildID, fieldNumber: 32)
      }
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      } }()
      if !_storage._parentPinnedWorkerDeploymentVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentPinnedWorkerDeploymentVersion, fieldNumber: 34)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
      try { if let v = _storage._inheritedPinnedVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      } }()
      if _storage._eagerExecutionAccepted != false {
        try visitor.visitSingularBoolField(value: _storage._eagerExecutionAccepted, fieldNumber: 38)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._parentWorkflowNamespace != rhs_storage._parentWorkflowNamespace {return false}
        if _storage._parentWorkflowNamespaceID != rhs_storage._parentWorkflowNamespaceID {return false}
        if _storage._parentWorkflowExecution != rhs_storage._parentWorkflowExecution {return false}
        if _storage._parentInitiatedEventID != rhs_storage._parentInitiatedEventID {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._continuedExecutionRunID != rhs_storage._continuedExecutionRunID {return false}
        if _storage._initiator != rhs_storage._initiator {return false}
        if _storage._continuedFailure != rhs_storage._continuedFailure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._originalExecutionRunID != rhs_storage._originalExecutionRunID {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._firstExecutionRunID != rhs_storage._firstExecutionRunID {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._workflowExecutionExpirationTime != rhs_storage._workflowExecutionExpirationTime {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._firstWorkflowTaskBackoff != rhs_storage._firstWorkflowTaskBackoff {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._prevAutoResetPoints != rhs_storage._prevAutoResetPoints {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._parentInitiatedEventVersion != rhs_storage._parentInitiatedEventVersion {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._sourceVersionStamp != rhs_storage._sourceVersionStamp {return false}
        if _storage._completionCallbacks != rhs_storage._completionCallbacks {return false}
        if _storage._rootWorkflowExecution != rhs_storage._rootWorkflowExecution {return false}
        if _storage._inheritedBuildID != rhs_storage._inheritedBuildID {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._parentPinnedWorkerDeploymentVersion != rhs_storage._parentPinnedWorkerDeploymentVersion {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._inheritedPinnedVersion != rhs_storage._inheritedPinnedVersion {return false}
        if _storage._eagerExecutionAccepted != rhs_storage._eagerExecutionAccepted {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}workflow_task_completed_event_id\0\u{3}new_execution_run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newExecutionRunID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    if !self.newExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.newExecutionRunID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.newExecutionRunID != rhs.newExecutionRunID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0\u{3}retry_state\0\u{3}workflow_task_completed_event_id\0\u{3}new_execution_run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.newExecutionRunID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 2)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 3)
    }
    if !self.newExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.newExecutionRunID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.newExecutionRunID != rhs.newExecutionRunID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionTimedOutEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}retry_state\0\u{3}new_execution_run_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.newExecutionRunID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 1)
    }
    if !self.newExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.newExecutionRunID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes) -> Bool {
    if lhs.retryState != rhs.retryState {return false}
    if lhs.newExecutionRunID != rhs.newExecutionRunID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionContinuedAsNewEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_execution_run_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}workflow_task_completed_event_id\0\u{3}backoff_start_interval\0\u{1}initiator\0\u{1}failure\0\u{3}last_completion_result\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}inherit_build_id\0")

  fileprivate class _StorageClass {
    var _newExecutionRunID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskCompletedEventID: Int64 = 0
    var _backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator = .unspecified
    var _failure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastCompletionResult: Temporal_Api_Common_V1_Payloads? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _inheritBuildID: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _newExecutionRunID = source._newExecutionRunID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _workflowTaskCompletedEventID = source._workflowTaskCompletedEventID
      _backoffStartInterval = source._backoffStartInterval
      _initiator = source._initiator
      _failure = source._failure
      _lastCompletionResult = source._lastCompletionResult
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._newExecutionRunID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._workflowTaskCompletedEventID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._backoffStartInterval) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._initiator) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._failure) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._newExecutionRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._newExecutionRunID, fieldNumber: 1)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._workflowTaskCompletedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workflowTaskCompletedEventID, fieldNumber: 7)
      }
      try { if let v = _storage._backoffStartInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._initiator != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initiator, fieldNumber: 9)
      }
      try { if let v = _storage._failure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._newExecutionRunID != rhs_storage._newExecutionRunID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._workflowTaskCompletedEventID != rhs_storage._workflowTaskCompletedEventID {return false}
        if _storage._backoffStartInterval != rhs_storage._backoffStartInterval {return false}
        if _storage._initiator != rhs_storage._initiator {return false}
        if _storage._failure != rhs_storage._failure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowTaskScheduledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{3}start_to_close_timeout\0\u{1}attempt\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToCloseTimeout) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes, rhs: Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes) -> Bool {
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs._startToCloseTimeout != rhs._startToCloseTimeout {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowTaskStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}identity\0\u{3}request_id\0\u{3}suggest_continue_as_new\0\u{3}history_size_bytes\0\u{3}worker_version\0\u{3}build_id_redirect_counter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.suggestContinueAsNew) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.historySizeBytes) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.buildIDRedirectCounter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    if self.suggestContinueAsNew != false {
      try visitor.visitSingularBoolField(value: self.suggestContinueAsNew, fieldNumber: 4)
    }
    if self.historySizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.historySizeBytes, fieldNumber: 5)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.buildIDRedirectCounter != 0 {
      try visitor.visitSingularInt64Field(value: self.buildIDRedirectCounter, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.suggestContinueAsNew != rhs.suggestContinueAsNew {return false}
    if lhs.historySizeBytes != rhs.historySizeBytes {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.buildIDRedirectCounter != rhs.buildIDRedirectCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowTaskCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}binary_checksum\0\u{3}worker_version\0\u{3}sdk_metadata\0\u{1}deployment\0\u{3}versioning_behavior\0\u{3}worker_deployment_version\0\u{3}worker_deployment_name\0\u{3}deployment_version\0\u{4}\u{2}metering_metadata\0")

  fileprivate class _StorageClass {
    var _scheduledEventID: Int64 = 0
    var _startedEventID: Int64 = 0
    var _identity: String = String()
    var _binaryChecksum: String = String()
    var _workerVersion: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
    var _sdkMetadata: Temporal_Api_Sdk_V1_WorkflowTaskCompletedMetadata? = nil
    var _meteringMetadata: Temporal_Api_Common_V1_MeteringMetadata? = nil
    var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
    var _versioningBehavior: Temporal_Api_Enums_V1_VersioningBehavior = .unspecified
    var _workerDeploymentVersion: String = String()
    var _workerDeploymentName: String = String()
    var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _scheduledEventID = source._scheduledEventID
      _startedEventID = source._startedEventID
      _identity = source._identity
      _binaryChecksum = source._binaryChecksum
      _workerVersion = source._workerVersion
      _sdkMetadata = source._sdkMetadata
      _meteringMetadata = source._meteringMetadata
      _deployment = source._deployment
      _versioningBehavior = source._versioningBehavior
      _workerDeploymentVersion = source._workerDeploymentVersion
      _workerDeploymentName = source._workerDeploymentName
      _deploymentVersion = source._deploymentVersion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._scheduledEventID) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._startedEventID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._binaryChecksum) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workerVersion) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._sdkMetadata) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._versioningBehavior) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._workerDeploymentVersion) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._workerDeploymentName) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._meteringMetadata) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._scheduledEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._scheduledEventID, fieldNumber: 1)
      }
      if _storage._startedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startedEventID, fieldNumber: 2)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 3)
      }
      if !_storage._binaryChecksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._binaryChecksum, fieldNumber: 4)
      }
      try { if let v = _storage._workerVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._sdkMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._versioningBehavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningBehavior, fieldNumber: 8)
      }
      if !_storage._workerDeploymentVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerDeploymentVersion, fieldNumber: 9)
      }
      if !_storage._workerDeploymentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerDeploymentName, fieldNumber: 10)
      }
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._meteringMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._scheduledEventID != rhs_storage._scheduledEventID {return false}
        if _storage._startedEventID != rhs_storage._startedEventID {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._binaryChecksum != rhs_storage._binaryChecksum {return false}
        if _storage._workerVersion != rhs_storage._workerVersion {return false}
        if _storage._sdkMetadata != rhs_storage._sdkMetadata {return false}
        if _storage._meteringMetadata != rhs_storage._meteringMetadata {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._versioningBehavior != rhs_storage._versioningBehavior {return false}
        if _storage._workerDeploymentVersion != rhs_storage._workerDeploymentVersion {return false}
        if _storage._workerDeploymentName != rhs_storage._workerDeploymentName {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowTaskTimedOutEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{3}timeout_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.timeoutType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    if self.timeoutType != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeoutType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes, rhs: Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.timeoutType != rhs.timeoutType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowTaskFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}cause\0\u{1}failure\0\u{1}identity\0\u{3}base_run_id\0\u{3}new_run_id\0\u{3}fork_event_version\0\u{3}binary_checksum\0\u{3}worker_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.baseRunID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.newRunID) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.forkEventVersion) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 3)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.baseRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.baseRunID, fieldNumber: 6)
    }
    if !self.newRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.newRunID, fieldNumber: 7)
    }
    if self.forkEventVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.forkEventVersion, fieldNumber: 8)
    }
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 9)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.baseRunID != rhs.baseRunID {return false}
    if lhs.newRunID != rhs.newRunID {return false}
    if lhs.forkEventVersion != rhs.forkEventVersion {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskScheduledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}activity_type\0\u{4}\u{2}task_queue\0\u{1}header\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}workflow_task_completed_event_id\0\u{3}retry_policy\0\u{3}use_workflow_build_id\0\u{1}priority\0\u{c}\u{3}\u{1}")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _activityType: Temporal_Api_Common_V1_ActivityType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskCompletedEventID: Int64 = 0
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _useWorkflowBuildID: Bool = false
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _header = source._header
      _input = source._input
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _workflowTaskCompletedEventID = source._workflowTaskCompletedEventID
      _retryPolicy = source._retryPolicy
      _useWorkflowBuildID = source._useWorkflowBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._workflowTaskCompletedEventID) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._useWorkflowBuildID) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if _storage._workflowTaskCompletedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workflowTaskCompletedEventID, fieldNumber: 11)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._useWorkflowBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._useWorkflowBuildID, fieldNumber: 13)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._workflowTaskCompletedEventID != rhs_storage._workflowTaskCompletedEventID {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._useWorkflowBuildID != rhs_storage._useWorkflowBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}identity\0\u{3}request_id\0\u{1}attempt\0\u{3}last_failure\0\u{3}worker_version\0\u{3}build_id_redirect_counter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastFailure) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.buildIDRedirectCounter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 4)
    }
    try { if let v = self._lastFailure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if self.buildIDRedirectCounter != 0 {
      try visitor.visitSingularInt64Field(value: self.buildIDRedirectCounter, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskStartedEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskStartedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs._lastFailure != rhs._lastFailure {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.buildIDRedirectCounter != rhs.buildIDRedirectCounter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}worker_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 2)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}retry_state\0\u{3}worker_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 2)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 5)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskFailedEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskFailedEventAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskTimedOutEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{3}retry_state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 2)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 3)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskCancelRequestedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}workflow_task_completed_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTaskCanceledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0\u{3}latest_cancel_requested_event_id\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}worker_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.latestCancelRequestedEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.latestCancelRequestedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.latestCancelRequestedEventID, fieldNumber: 2)
    }
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 3)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes, rhs: Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.latestCancelRequestedEventID != rhs.latestCancelRequestedEventID {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_TimerStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimerStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0\u{3}start_to_fire_timeout\0\u{3}workflow_task_completed_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToFireTimeout) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    try { if let v = self._startToFireTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_TimerStartedEventAttributes, rhs: Temporal_Api_History_V1_TimerStartedEventAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs._startToFireTimeout != rhs._startToFireTimeout {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_TimerFiredEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimerFiredEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0\u{3}started_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_TimerFiredEventAttributes, rhs: Temporal_Api_History_V1_TimerFiredEventAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_TimerCanceledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimerCanceledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0\u{3}started_event_id\0\u{3}workflow_task_completed_event_id\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_TimerCanceledEventAttributes, rhs: Temporal_Api_History_V1_TimerCanceledEventAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionCancelRequestedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cause\0\u{3}external_initiated_event_id\0\u{3}external_workflow_execution\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cause) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.externalInitiatedEventID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._externalWorkflowExecution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cause.isEmpty {
      try visitor.visitSingularStringField(value: self.cause, fieldNumber: 1)
    }
    if self.externalInitiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.externalInitiatedEventID, fieldNumber: 2)
    }
    try { if let v = self._externalWorkflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes) -> Bool {
    if lhs.cause != rhs.cause {return false}
    if lhs.externalInitiatedEventID != rhs.externalInitiatedEventID {return false}
    if lhs._externalWorkflowExecution != rhs._externalWorkflowExecution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionCanceledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task_completed_event_id\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes) -> Bool {
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_MarkerRecordedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".MarkerRecordedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}marker_name\0\u{1}details\0\u{3}workflow_task_completed_event_id\0\u{1}header\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.markerName) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payloads>.self, value: &self.details) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.markerName.isEmpty {
      try visitor.visitSingularStringField(value: self.markerName, fieldNumber: 1)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payloads>.self, value: self.details, fieldNumber: 2)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 3)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_MarkerRecordedEventAttributes, rhs: Temporal_Api_History_V1_MarkerRecordedEventAttributes) -> Bool {
    if lhs.markerName != rhs.markerName {return false}
    if lhs.details != rhs.details {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs._header != rhs._header {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionSignaledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_name\0\u{1}input\0\u{1}identity\0\u{1}header\0\u{3}skip_generate_workflow_task\0\u{3}external_workflow_execution\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.skipGenerateWorkflowTask) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._externalWorkflowExecution) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.skipGenerateWorkflowTask != false {
      try visitor.visitSingularBoolField(value: self.skipGenerateWorkflowTask, fieldNumber: 5)
    }
    try { if let v = self._externalWorkflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes) -> Bool {
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._header != rhs._header {return false}
    if lhs.skipGenerateWorkflowTask != rhs.skipGenerateWorkflowTask {return false}
    if lhs._externalWorkflowExecution != rhs._externalWorkflowExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionTerminatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{1}details\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecutionInitiatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task_completed_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}control\0\u{3}child_workflow_only\0\u{1}reason\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 4)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes, rhs: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes) -> Bool {
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecutionFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cause\0\u{3}workflow_task_completed_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}initiated_event_id\0\u{1}control\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 5)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes, rhs: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes) -> Bool {
    if lhs.cause != rhs.cause {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExternalWorkflowExecutionCancelRequestedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}initiated_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes, rhs: Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes) -> Bool {
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecutionInitiatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task_completed_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}signal_name\0\u{1}input\0\u{1}control\0\u{3}child_workflow_only\0\u{1}header\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 4)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 6)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 7)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes, rhs: Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes) -> Bool {
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecutionFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}cause\0\u{3}workflow_task_completed_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}initiated_event_id\0\u{1}control\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 5)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes, rhs: Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes) -> Bool {
    if lhs.cause != rhs.cause {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExternalWorkflowExecutionSignaledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}initiated_event_id\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}control\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 4)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes, rhs: Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes) -> Bool {
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.control != rhs.control {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpsertWorkflowSearchAttributesEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task_completed_event_id\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 1)
    }
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes, rhs: Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes) -> Bool {
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowPropertiesModifiedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task_completed_event_id\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 1)
    }
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes) -> Bool {
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecutionInitiatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}parent_close_policy\0\u{1}control\0\u{3}workflow_task_completed_event_id\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}namespace_id\0\u{3}inherit_build_id\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _namespaceID: String = String()
    var _workflowID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parentClosePolicy: Temporal_Api_Enums_V1_ParentClosePolicy = .unspecified
    var _control: String = String()
    var _workflowTaskCompletedEventID: Int64 = 0
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _inheritBuildID: Bool = false
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _namespaceID = source._namespaceID
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _parentClosePolicy = source._parentClosePolicy
      _control = source._control
      _workflowTaskCompletedEventID = source._workflowTaskCompletedEventID
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._parentClosePolicy) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._control) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._workflowTaskCompletedEventID) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._namespaceID) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._parentClosePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._parentClosePolicy, fieldNumber: 9)
      }
      if !_storage._control.isEmpty {
        try visitor.visitSingularStringField(value: _storage._control, fieldNumber: 10)
      }
      if _storage._workflowTaskCompletedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._workflowTaskCompletedEventID, fieldNumber: 11)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 12)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 14)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      if !_storage._namespaceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespaceID, fieldNumber: 18)
      }
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 19)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes, rhs: Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._namespaceID != rhs_storage._namespaceID {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._parentClosePolicy != rhs_storage._parentClosePolicy {return false}
        if _storage._control != rhs_storage._control {return false}
        if _storage._workflowTaskCompletedEventID != rhs_storage._workflowTaskCompletedEventID {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecutionFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{1}cause\0\u{1}control\0\u{3}initiated_event_id\0\u{3}workflow_task_completed_event_id\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 4)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 5)
    }
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 6)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 7)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes, rhs: Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.control != rhs.control {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}initiated_event_id\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{1}header\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 5)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}retry_state\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 5)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 6)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 7)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionCanceledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 5)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionTimedOutEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}retry_state\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 4)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 5)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 6)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionTerminatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}namespace_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 4)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 5)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes, rhs: Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionOptionsUpdatedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}versioning_override\0\u{3}unset_versioning_override\0\u{3}attached_request_id\0\u{3}attached_completion_callbacks\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._versioningOverride) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.unsetVersioningOverride) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.attachedRequestID) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachedCompletionCallbacks) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._versioningOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.unsetVersioningOverride != false {
      try visitor.visitSingularBoolField(value: self.unsetVersioningOverride, fieldNumber: 2)
    }
    if !self.attachedRequestID.isEmpty {
      try visitor.visitSingularStringField(value: self.attachedRequestID, fieldNumber: 3)
    }
    if !self.attachedCompletionCallbacks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachedCompletionCallbacks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes) -> Bool {
    if lhs._versioningOverride != rhs._versioningOverride {return false}
    if lhs.unsetVersioningOverride != rhs.unsetVersioningOverride {return false}
    if lhs.attachedRequestID != rhs.attachedRequestID {return false}
    if lhs.attachedCompletionCallbacks != rhs.attachedCompletionCallbacks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowPropertiesModifiedExternallyEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_task_queue\0\u{3}new_workflow_task_timeout\0\u{3}new_workflow_run_timeout\0\u{3}new_workflow_execution_timeout\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newTaskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newWorkflowTaskTimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._newWorkflowRunTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newWorkflowExecutionTimeout) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.newTaskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.newTaskQueue, fieldNumber: 1)
    }
    try { if let v = self._newWorkflowTaskTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._newWorkflowRunTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newWorkflowExecutionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes, rhs: Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes) -> Bool {
    if lhs.newTaskQueue != rhs.newTaskQueue {return false}
    if lhs._newWorkflowTaskTimeout != rhs._newWorkflowTaskTimeout {return false}
    if lhs._newWorkflowRunTimeout != rhs._newWorkflowRunTimeout {return false}
    if lhs._newWorkflowExecutionTimeout != rhs._newWorkflowExecutionTimeout {return false}
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityPropertiesModifiedExternallyEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}new_retry_policy\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._newRetryPolicy) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try { if let v = self._newRetryPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes, rhs: Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs._newRetryPolicy != rhs._newRetryPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionUpdateAcceptedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_instance_id\0\u{3}accepted_request_message_id\0\u{3}accepted_request_sequencing_event_id\0\u{3}accepted_request\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolInstanceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.acceptedRequestMessageID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.acceptedRequestSequencingEventID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._acceptedRequest) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.protocolInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolInstanceID, fieldNumber: 1)
    }
    if !self.acceptedRequestMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.acceptedRequestMessageID, fieldNumber: 2)
    }
    if self.acceptedRequestSequencingEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.acceptedRequestSequencingEventID, fieldNumber: 3)
    }
    try { if let v = self._acceptedRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes) -> Bool {
    if lhs.protocolInstanceID != rhs.protocolInstanceID {return false}
    if lhs.acceptedRequestMessageID != rhs.acceptedRequestMessageID {return false}
    if lhs.acceptedRequestSequencingEventID != rhs.acceptedRequestSequencingEventID {return false}
    if lhs._acceptedRequest != rhs._acceptedRequest {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionUpdateCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}meta\0\u{1}outcome\0\u{3}accepted_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._meta) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.acceptedEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._meta {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.acceptedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.acceptedEventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes) -> Bool {
    if lhs._meta != rhs._meta {return false}
    if lhs.acceptedEventID != rhs.acceptedEventID {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionUpdateRejectedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_instance_id\0\u{3}rejected_request_message_id\0\u{3}rejected_request_sequencing_event_id\0\u{3}rejected_request\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolInstanceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rejectedRequestMessageID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.rejectedRequestSequencingEventID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._rejectedRequest) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.protocolInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolInstanceID, fieldNumber: 1)
    }
    if !self.rejectedRequestMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.rejectedRequestMessageID, fieldNumber: 2)
    }
    if self.rejectedRequestSequencingEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.rejectedRequestSequencingEventID, fieldNumber: 3)
    }
    try { if let v = self._rejectedRequest {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes) -> Bool {
    if lhs.protocolInstanceID != rhs.protocolInstanceID {return false}
    if lhs.rejectedRequestMessageID != rhs.rejectedRequestMessageID {return false}
    if lhs.rejectedRequestSequencingEventID != rhs.rejectedRequestSequencingEventID {return false}
    if lhs._rejectedRequest != rhs._rejectedRequest {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionUpdateAdmittedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}request\0\u{1}origin\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.origin) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.origin != .unspecified {
      try visitor.visitSingularEnumField(value: self.origin, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes, rhs: Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes) -> Bool {
    if lhs._request != rhs._request {return false}
    if lhs.origin != rhs.origin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationScheduledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationScheduledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}nexus_header\0\u{3}workflow_task_completed_event_id\0\u{3}request_id\0\u{3}endpoint_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._scheduleToCloseTimeout) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.nexusHeader) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scheduleToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.nexusHeader.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.nexusHeader, fieldNumber: 6)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 7)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 8)
    }
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationScheduledEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationScheduledEventAttributes) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._scheduleToCloseTimeout != rhs._scheduleToCloseTimeout {return false}
    if lhs.nexusHeader != rhs.nexusHeader {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationStartedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationStartedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{4}\u{2}operation_id\0\u{3}request_id\0\u{3}operation_token\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.operationToken) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    if !self.operationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.operationToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationStartedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationStartedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.operationToken != rhs.operationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}result\0\u{3}request_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationCompletedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationCompletedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}failure\0\u{3}request_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationFailedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationFailedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationTimedOutEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}failure\0\u{3}request_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationCanceledEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCanceledEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}failure\0\u{3}request_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationCanceledEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationCanceledEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCancelRequestedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}workflow_task_completed_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCancelRequestCompletedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requested_event_id\0\u{3}workflow_task_completed_event_id\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.requestedEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestedEventID, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes) -> Bool {
    if lhs.requestedEventID != rhs.requestedEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCancelRequestFailedEventAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requested_event_id\0\u{3}workflow_task_completed_event_id\0\u{1}failure\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.requestedEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskCompletedEventID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.requestedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestedEventID, fieldNumber: 1)
    }
    if self.workflowTaskCompletedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskCompletedEventID, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes, rhs: Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes) -> Bool {
    if lhs.requestedEventID != rhs.requestedEventID {return false}
    if lhs.workflowTaskCompletedEventID != rhs.workflowTaskCompletedEventID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_HistoryEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".HistoryEvent"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_id\0\u{3}event_time\0\u{3}event_type\0\u{1}version\0\u{3}task_id\0\u{3}workflow_execution_started_event_attributes\0\u{3}workflow_execution_completed_event_attributes\0\u{3}workflow_execution_failed_event_attributes\0\u{3}workflow_execution_timed_out_event_attributes\0\u{3}workflow_task_scheduled_event_attributes\0\u{3}workflow_task_started_event_attributes\0\u{3}workflow_task_completed_event_attributes\0\u{3}workflow_task_timed_out_event_attributes\0\u{3}workflow_task_failed_event_attributes\0\u{3}activity_task_scheduled_event_attributes\0\u{3}activity_task_started_event_attributes\0\u{3}activity_task_completed_event_attributes\0\u{3}activity_task_failed_event_attributes\0\u{3}activity_task_timed_out_event_attributes\0\u{3}timer_started_event_attributes\0\u{3}timer_fired_event_attributes\0\u{3}activity_task_cancel_requested_event_attributes\0\u{3}activity_task_canceled_event_attributes\0\u{3}timer_canceled_event_attributes\0\u{3}marker_recorded_event_attributes\0\u{3}workflow_execution_signaled_event_attributes\0\u{3}workflow_execution_terminated_event_attributes\0\u{3}workflow_execution_cancel_requested_event_attributes\0\u{3}workflow_execution_canceled_event_attributes\0\u{3}request_cancel_external_workflow_execution_initiated_event_attributes\0\u{3}request_cancel_external_workflow_execution_failed_event_attributes\0\u{3}external_workflow_execution_cancel_requested_event_attributes\0\u{3}workflow_execution_continued_as_new_event_attributes\0\u{3}start_child_workflow_execution_initiated_event_attributes\0\u{3}start_child_workflow_execution_failed_event_attributes\0\u{3}child_workflow_execution_started_event_attributes\0\u{3}child_workflow_execution_completed_event_attributes\0\u{3}child_workflow_execution_failed_event_attributes\0\u{3}child_workflow_execution_canceled_event_attributes\0\u{3}child_workflow_execution_timed_out_event_attributes\0\u{3}child_workflow_execution_terminated_event_attributes\0\u{3}signal_external_workflow_execution_initiated_event_attributes\0\u{3}signal_external_workflow_execution_failed_event_attributes\0\u{3}external_workflow_execution_signaled_event_attributes\0\u{3}upsert_workflow_search_attributes_event_attributes\0\u{3}workflow_execution_update_accepted_event_attributes\0\u{3}workflow_execution_update_rejected_event_attributes\0\u{3}workflow_execution_update_completed_event_attributes\0\u{3}workflow_properties_modified_externally_event_attributes\0\u{3}activity_properties_modified_externally_event_attributes\0\u{3}workflow_properties_modified_event_attributes\0\u{3}workflow_execution_update_admitted_event_attributes\0\u{3}nexus_operation_scheduled_event_attributes\0\u{3}nexus_operation_started_event_attributes\0\u{3}nexus_operation_completed_event_attributes\0\u{3}nexus_operation_failed_event_attributes\0\u{3}nexus_operation_canceled_event_attributes\0\u{3}nexus_operation_timed_out_event_attributes\0\u{3}nexus_operation_cancel_requested_event_attributes\0\u{3}workflow_execution_options_updated_event_attributes\0\u{3}nexus_operation_cancel_request_completed_event_attributes\0\u{3}nexus_operation_cancel_request_failed_event_attributes\0\u{4}n\u{3}worker_may_ignore\0\u{3}user_metadata\0\u{1}links\0")

  fileprivate class _StorageClass {
    var _eventID: Int64 = 0
    var _eventTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _eventType: Temporal_Api_Enums_V1_EventType = .unspecified
    var _version: Int64 = 0
    var _taskID: Int64 = 0
    var _workerMayIgnore: Bool = false
    var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
    var _links: [Temporal_Api_Common_V1_Link] = []
    var _attributes: Temporal_Api_History_V1_HistoryEvent.OneOf_Attributes?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _eventID = source._eventID
      _eventTime = source._eventTime
      _eventType = source._eventType
      _version = source._version
      _taskID = source._taskID
      _workerMayIgnore = source._workerMayIgnore
      _userMetadata = source._userMetadata
      _links = source._links
      _attributes = source._attributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt64Field(value: &_storage._eventID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._eventTime) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._eventType) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._version) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._taskID) }()
        case 6: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionStartedEventAttributes(v)
          }
        }()
        case 7: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionCompletedEventAttributes(v)
          }
        }()
        case 8: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionFailedEventAttributes(v)
          }
        }()
        case 9: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionTimedOutEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionTimedOutEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionTimedOutEventAttributes(v)
          }
        }()
        case 10: try {
          var v: Temporal_Api_History_V1_WorkflowTaskScheduledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowTaskScheduledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowTaskScheduledEventAttributes(v)
          }
        }()
        case 11: try {
          var v: Temporal_Api_History_V1_WorkflowTaskStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowTaskStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowTaskStartedEventAttributes(v)
          }
        }()
        case 12: try {
          var v: Temporal_Api_History_V1_WorkflowTaskCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowTaskCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowTaskCompletedEventAttributes(v)
          }
        }()
        case 13: try {
          var v: Temporal_Api_History_V1_WorkflowTaskTimedOutEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowTaskTimedOutEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowTaskTimedOutEventAttributes(v)
          }
        }()
        case 14: try {
          var v: Temporal_Api_History_V1_WorkflowTaskFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowTaskFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowTaskFailedEventAttributes(v)
          }
        }()
        case 15: try {
          var v: Temporal_Api_History_V1_ActivityTaskScheduledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskScheduledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskScheduledEventAttributes(v)
          }
        }()
        case 16: try {
          var v: Temporal_Api_History_V1_ActivityTaskStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskStartedEventAttributes(v)
          }
        }()
        case 17: try {
          var v: Temporal_Api_History_V1_ActivityTaskCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskCompletedEventAttributes(v)
          }
        }()
        case 18: try {
          var v: Temporal_Api_History_V1_ActivityTaskFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskFailedEventAttributes(v)
          }
        }()
        case 19: try {
          var v: Temporal_Api_History_V1_ActivityTaskTimedOutEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskTimedOutEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskTimedOutEventAttributes(v)
          }
        }()
        case 20: try {
          var v: Temporal_Api_History_V1_TimerStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .timerStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .timerStartedEventAttributes(v)
          }
        }()
        case 21: try {
          var v: Temporal_Api_History_V1_TimerFiredEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .timerFiredEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .timerFiredEventAttributes(v)
          }
        }()
        case 22: try {
          var v: Temporal_Api_History_V1_ActivityTaskCancelRequestedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskCancelRequestedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskCancelRequestedEventAttributes(v)
          }
        }()
        case 23: try {
          var v: Temporal_Api_History_V1_ActivityTaskCanceledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityTaskCanceledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityTaskCanceledEventAttributes(v)
          }
        }()
        case 24: try {
          var v: Temporal_Api_History_V1_TimerCanceledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .timerCanceledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .timerCanceledEventAttributes(v)
          }
        }()
        case 25: try {
          var v: Temporal_Api_History_V1_MarkerRecordedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .markerRecordedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .markerRecordedEventAttributes(v)
          }
        }()
        case 26: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionSignaledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionSignaledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionSignaledEventAttributes(v)
          }
        }()
        case 27: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionTerminatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionTerminatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionTerminatedEventAttributes(v)
          }
        }()
        case 28: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionCancelRequestedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionCancelRequestedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionCancelRequestedEventAttributes(v)
          }
        }()
        case 29: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionCanceledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionCanceledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionCanceledEventAttributes(v)
          }
        }()
        case 30: try {
          var v: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionInitiatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .requestCancelExternalWorkflowExecutionInitiatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .requestCancelExternalWorkflowExecutionInitiatedEventAttributes(v)
          }
        }()
        case 31: try {
          var v: Temporal_Api_History_V1_RequestCancelExternalWorkflowExecutionFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .requestCancelExternalWorkflowExecutionFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .requestCancelExternalWorkflowExecutionFailedEventAttributes(v)
          }
        }()
        case 32: try {
          var v: Temporal_Api_History_V1_ExternalWorkflowExecutionCancelRequestedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .externalWorkflowExecutionCancelRequestedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .externalWorkflowExecutionCancelRequestedEventAttributes(v)
          }
        }()
        case 33: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionContinuedAsNewEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionContinuedAsNewEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionContinuedAsNewEventAttributes(v)
          }
        }()
        case 34: try {
          var v: Temporal_Api_History_V1_StartChildWorkflowExecutionInitiatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .startChildWorkflowExecutionInitiatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .startChildWorkflowExecutionInitiatedEventAttributes(v)
          }
        }()
        case 35: try {
          var v: Temporal_Api_History_V1_StartChildWorkflowExecutionFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .startChildWorkflowExecutionFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .startChildWorkflowExecutionFailedEventAttributes(v)
          }
        }()
        case 36: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionStartedEventAttributes(v)
          }
        }()
        case 37: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionCompletedEventAttributes(v)
          }
        }()
        case 38: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionFailedEventAttributes(v)
          }
        }()
        case 39: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionCanceledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionCanceledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionCanceledEventAttributes(v)
          }
        }()
        case 40: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionTimedOutEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionTimedOutEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionTimedOutEventAttributes(v)
          }
        }()
        case 41: try {
          var v: Temporal_Api_History_V1_ChildWorkflowExecutionTerminatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .childWorkflowExecutionTerminatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .childWorkflowExecutionTerminatedEventAttributes(v)
          }
        }()
        case 42: try {
          var v: Temporal_Api_History_V1_SignalExternalWorkflowExecutionInitiatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .signalExternalWorkflowExecutionInitiatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .signalExternalWorkflowExecutionInitiatedEventAttributes(v)
          }
        }()
        case 43: try {
          var v: Temporal_Api_History_V1_SignalExternalWorkflowExecutionFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .signalExternalWorkflowExecutionFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .signalExternalWorkflowExecutionFailedEventAttributes(v)
          }
        }()
        case 44: try {
          var v: Temporal_Api_History_V1_ExternalWorkflowExecutionSignaledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .externalWorkflowExecutionSignaledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .externalWorkflowExecutionSignaledEventAttributes(v)
          }
        }()
        case 45: try {
          var v: Temporal_Api_History_V1_UpsertWorkflowSearchAttributesEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .upsertWorkflowSearchAttributesEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .upsertWorkflowSearchAttributesEventAttributes(v)
          }
        }()
        case 46: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionUpdateAcceptedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionUpdateAcceptedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionUpdateAcceptedEventAttributes(v)
          }
        }()
        case 47: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionUpdateRejectedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionUpdateRejectedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionUpdateRejectedEventAttributes(v)
          }
        }()
        case 48: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionUpdateCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionUpdateCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionUpdateCompletedEventAttributes(v)
          }
        }()
        case 49: try {
          var v: Temporal_Api_History_V1_WorkflowPropertiesModifiedExternallyEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowPropertiesModifiedExternallyEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowPropertiesModifiedExternallyEventAttributes(v)
          }
        }()
        case 50: try {
          var v: Temporal_Api_History_V1_ActivityPropertiesModifiedExternallyEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .activityPropertiesModifiedExternallyEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .activityPropertiesModifiedExternallyEventAttributes(v)
          }
        }()
        case 51: try {
          var v: Temporal_Api_History_V1_WorkflowPropertiesModifiedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowPropertiesModifiedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowPropertiesModifiedEventAttributes(v)
          }
        }()
        case 52: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionUpdateAdmittedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionUpdateAdmittedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionUpdateAdmittedEventAttributes(v)
          }
        }()
        case 53: try {
          var v: Temporal_Api_History_V1_NexusOperationScheduledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationScheduledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationScheduledEventAttributes(v)
          }
        }()
        case 54: try {
          var v: Temporal_Api_History_V1_NexusOperationStartedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationStartedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationStartedEventAttributes(v)
          }
        }()
        case 55: try {
          var v: Temporal_Api_History_V1_NexusOperationCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationCompletedEventAttributes(v)
          }
        }()
        case 56: try {
          var v: Temporal_Api_History_V1_NexusOperationFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationFailedEventAttributes(v)
          }
        }()
        case 57: try {
          var v: Temporal_Api_History_V1_NexusOperationCanceledEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationCanceledEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationCanceledEventAttributes(v)
          }
        }()
        case 58: try {
          var v: Temporal_Api_History_V1_NexusOperationTimedOutEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationTimedOutEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationTimedOutEventAttributes(v)
          }
        }()
        case 59: try {
          var v: Temporal_Api_History_V1_NexusOperationCancelRequestedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationCancelRequestedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationCancelRequestedEventAttributes(v)
          }
        }()
        case 60: try {
          var v: Temporal_Api_History_V1_WorkflowExecutionOptionsUpdatedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .workflowExecutionOptionsUpdatedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .workflowExecutionOptionsUpdatedEventAttributes(v)
          }
        }()
        case 61: try {
          var v: Temporal_Api_History_V1_NexusOperationCancelRequestCompletedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationCancelRequestCompletedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationCancelRequestCompletedEventAttributes(v)
          }
        }()
        case 62: try {
          var v: Temporal_Api_History_V1_NexusOperationCancelRequestFailedEventAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .nexusOperationCancelRequestFailedEventAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .nexusOperationCancelRequestFailedEventAttributes(v)
          }
        }()
        case 300: try { try decoder.decodeSingularBoolField(value: &_storage._workerMayIgnore) }()
        case 301: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 302: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._eventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._eventID, fieldNumber: 1)
      }
      try { if let v = _storage._eventTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._eventType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._eventType, fieldNumber: 3)
      }
      if _storage._version != 0 {
        try visitor.visitSingularInt64Field(value: _storage._version, fieldNumber: 4)
      }
      if _storage._taskID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._taskID, fieldNumber: 5)
      }
      switch _storage._attributes {
      case .workflowExecutionStartedEventAttributes?: try {
        guard case .workflowExecutionStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .workflowExecutionCompletedEventAttributes?: try {
        guard case .workflowExecutionCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .workflowExecutionFailedEventAttributes?: try {
        guard case .workflowExecutionFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .workflowExecutionTimedOutEventAttributes?: try {
        guard case .workflowExecutionTimedOutEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .workflowTaskScheduledEventAttributes?: try {
        guard case .workflowTaskScheduledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .workflowTaskStartedEventAttributes?: try {
        guard case .workflowTaskStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .workflowTaskCompletedEventAttributes?: try {
        guard case .workflowTaskCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .workflowTaskTimedOutEventAttributes?: try {
        guard case .workflowTaskTimedOutEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .workflowTaskFailedEventAttributes?: try {
        guard case .workflowTaskFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .activityTaskScheduledEventAttributes?: try {
        guard case .activityTaskScheduledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .activityTaskStartedEventAttributes?: try {
        guard case .activityTaskStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .activityTaskCompletedEventAttributes?: try {
        guard case .activityTaskCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .activityTaskFailedEventAttributes?: try {
        guard case .activityTaskFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .activityTaskTimedOutEventAttributes?: try {
        guard case .activityTaskTimedOutEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .timerStartedEventAttributes?: try {
        guard case .timerStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .timerFiredEventAttributes?: try {
        guard case .timerFiredEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .activityTaskCancelRequestedEventAttributes?: try {
        guard case .activityTaskCancelRequestedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .activityTaskCanceledEventAttributes?: try {
        guard case .activityTaskCanceledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .timerCanceledEventAttributes?: try {
        guard case .timerCanceledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .markerRecordedEventAttributes?: try {
        guard case .markerRecordedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .workflowExecutionSignaledEventAttributes?: try {
        guard case .workflowExecutionSignaledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .workflowExecutionTerminatedEventAttributes?: try {
        guard case .workflowExecutionTerminatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .workflowExecutionCancelRequestedEventAttributes?: try {
        guard case .workflowExecutionCancelRequestedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .workflowExecutionCanceledEventAttributes?: try {
        guard case .workflowExecutionCanceledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .requestCancelExternalWorkflowExecutionInitiatedEventAttributes?: try {
        guard case .requestCancelExternalWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .requestCancelExternalWorkflowExecutionFailedEventAttributes?: try {
        guard case .requestCancelExternalWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .externalWorkflowExecutionCancelRequestedEventAttributes?: try {
        guard case .externalWorkflowExecutionCancelRequestedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .workflowExecutionContinuedAsNewEventAttributes?: try {
        guard case .workflowExecutionContinuedAsNewEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case .startChildWorkflowExecutionInitiatedEventAttributes?: try {
        guard case .startChildWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 34)
      }()
      case .startChildWorkflowExecutionFailedEventAttributes?: try {
        guard case .startChildWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      }()
      case .childWorkflowExecutionStartedEventAttributes?: try {
        guard case .childWorkflowExecutionStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
      }()
      case .childWorkflowExecutionCompletedEventAttributes?: try {
        guard case .childWorkflowExecutionCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 37)
      }()
      case .childWorkflowExecutionFailedEventAttributes?: try {
        guard case .childWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 38)
      }()
      case .childWorkflowExecutionCanceledEventAttributes?: try {
        guard case .childWorkflowExecutionCanceledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 39)
      }()
      case .childWorkflowExecutionTimedOutEventAttributes?: try {
        guard case .childWorkflowExecutionTimedOutEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 40)
      }()
      case .childWorkflowExecutionTerminatedEventAttributes?: try {
        guard case .childWorkflowExecutionTerminatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 41)
      }()
      case .signalExternalWorkflowExecutionInitiatedEventAttributes?: try {
        guard case .signalExternalWorkflowExecutionInitiatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 42)
      }()
      case .signalExternalWorkflowExecutionFailedEventAttributes?: try {
        guard case .signalExternalWorkflowExecutionFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 43)
      }()
      case .externalWorkflowExecutionSignaledEventAttributes?: try {
        guard case .externalWorkflowExecutionSignaledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 44)
      }()
      case .upsertWorkflowSearchAttributesEventAttributes?: try {
        guard case .upsertWorkflowSearchAttributesEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 45)
      }()
      case .workflowExecutionUpdateAcceptedEventAttributes?: try {
        guard case .workflowExecutionUpdateAcceptedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 46)
      }()
      case .workflowExecutionUpdateRejectedEventAttributes?: try {
        guard case .workflowExecutionUpdateRejectedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 47)
      }()
      case .workflowExecutionUpdateCompletedEventAttributes?: try {
        guard case .workflowExecutionUpdateCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 48)
      }()
      case .workflowPropertiesModifiedExternallyEventAttributes?: try {
        guard case .workflowPropertiesModifiedExternallyEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 49)
      }()
      case .activityPropertiesModifiedExternallyEventAttributes?: try {
        guard case .activityPropertiesModifiedExternallyEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 50)
      }()
      case .workflowPropertiesModifiedEventAttributes?: try {
        guard case .workflowPropertiesModifiedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 51)
      }()
      case .workflowExecutionUpdateAdmittedEventAttributes?: try {
        guard case .workflowExecutionUpdateAdmittedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 52)
      }()
      case .nexusOperationScheduledEventAttributes?: try {
        guard case .nexusOperationScheduledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 53)
      }()
      case .nexusOperationStartedEventAttributes?: try {
        guard case .nexusOperationStartedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 54)
      }()
      case .nexusOperationCompletedEventAttributes?: try {
        guard case .nexusOperationCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 55)
      }()
      case .nexusOperationFailedEventAttributes?: try {
        guard case .nexusOperationFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 56)
      }()
      case .nexusOperationCanceledEventAttributes?: try {
        guard case .nexusOperationCanceledEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 57)
      }()
      case .nexusOperationTimedOutEventAttributes?: try {
        guard case .nexusOperationTimedOutEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 58)
      }()
      case .nexusOperationCancelRequestedEventAttributes?: try {
        guard case .nexusOperationCancelRequestedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 59)
      }()
      case .workflowExecutionOptionsUpdatedEventAttributes?: try {
        guard case .workflowExecutionOptionsUpdatedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 60)
      }()
      case .nexusOperationCancelRequestCompletedEventAttributes?: try {
        guard case .nexusOperationCancelRequestCompletedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 61)
      }()
      case .nexusOperationCancelRequestFailedEventAttributes?: try {
        guard case .nexusOperationCancelRequestFailedEventAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 62)
      }()
      case nil: break
      }
      if _storage._workerMayIgnore != false {
        try visitor.visitSingularBoolField(value: _storage._workerMayIgnore, fieldNumber: 300)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 302)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_HistoryEvent, rhs: Temporal_Api_History_V1_HistoryEvent) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._eventID != rhs_storage._eventID {return false}
        if _storage._eventTime != rhs_storage._eventTime {return false}
        if _storage._eventType != rhs_storage._eventType {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._taskID != rhs_storage._taskID {return false}
        if _storage._workerMayIgnore != rhs_storage._workerMayIgnore {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_History_V1_History: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".History"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}events\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.events) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.events.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.events, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_History_V1_History, rhs: Temporal_Api_History_V1_History) -> Bool {
    if lhs.events != rhs.events {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
