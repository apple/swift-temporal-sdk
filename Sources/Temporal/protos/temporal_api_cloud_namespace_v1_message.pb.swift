// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/namespace/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Cloud_Namespace_V1_CertificateFilterSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The common_name in the certificate.
  /// Optional, default is empty.
  package var commonName: String = String()

  /// The organization in the certificate.
  /// Optional, default is empty.
  package var organization: String = String()

  /// The organizational_unit in the certificate.
  /// Optional, default is empty.
  package var organizationalUnit: String = String()

  /// The subject_alternative_name in the certificate.
  /// Optional, default is empty.
  package var subjectAlternativeName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The base64 encoded ca cert(s) in PEM format that the clients can use for authentication and authorization.
  /// This must only be one value, but the CA can have a chain.
  ///
  /// (-- api-linter: core::0140::base64=disabled --)
  /// Deprecated: Not supported after v0.2.0 api version. Use accepted_client_ca instead.
  /// temporal:versioning:max_version=v0.2.0
  package var acceptedClientCaDeprecated: String = String()

  /// The ca cert(s) in PEM format that the clients can use for authentication and authorization.
  /// This must only be one value, but the CA can have a chain.
  /// temporal:versioning:min_version=v0.2.0
  package var acceptedClientCa: Data = Data()

  /// Certificate filters which, if specified, only allow connections from client certificates whose distinguished name properties match at least one of the filters.
  /// This allows limiting access to specific end-entity certificates.
  /// Optional, default is empty.
  package var certificateFilters: [Temporal_Api_Cloud_Namespace_V1_CertificateFilterSpec] = []

  /// Flag to enable mTLS auth (default: disabled).
  /// Note: disabling mTLS auth will cause existing mTLS connections to fail.
  /// temporal:versioning:min_version=v0.2.0
  package var enabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag to enable API key auth (default: disabled).
  /// Note: disabling API key auth will cause existing API key connections to fail.
  package var enabled: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_CodecServerSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The codec server endpoint.
  package var endpoint: String = String()

  /// Whether to pass the user access token with your endpoint.
  package var passAccessToken: Bool = false

  /// Whether to include cross-origin credentials.
  package var includeCrossOriginCredentials: Bool = false

  /// A custom error message to display for remote codec server errors.
  /// temporal:versioning:min_version=v0.5.1
  package var customErrorMessage: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage {
    get {return _customErrorMessage ?? Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage()}
    set {_customErrorMessage = newValue}
  }
  /// Returns true if `customErrorMessage` has been explicitly set.
  package var hasCustomErrorMessage: Bool {return self._customErrorMessage != nil}
  /// Clears the value of `customErrorMessage`. Subsequent reads from it will return its default value.
  package mutating func clearCustomErrorMessage() {self._customErrorMessage = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package struct CustomErrorMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The error message to display by default for any remote codec server errors.
    package var `default`: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage {
      get {return _default ?? Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage()}
      set {_default = newValue}
    }
    /// Returns true if ``default`` has been explicitly set.
    package var hasDefault: Bool {return self._default != nil}
    /// Clears the value of ``default``. Subsequent reads from it will return its default value.
    package mutating func clearDefault() {self._default = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package struct ErrorMessage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A message to display.
      package var message: String = String()

      /// A link that is displayed along side the configured message.
      package var link: String = String()

      package var unknownFields = SwiftProtobuf.UnknownStorage()

      package init() {}
    }

    package init() {}

    fileprivate var _default: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage? = nil
  }

  package init() {}

  fileprivate var _customErrorMessage: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage? = nil
}

package struct Temporal_Api_Cloud_Namespace_V1_LifecycleSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag to enable delete protection for the namespace.
  package var enableDeleteProtection: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Flag to disable managed failover for the namespace.
  package var disableManagedFailover: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_NamespaceSpec: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name to use for the namespace.
  /// This will create a namespace that's available at '<name>.<account>.tmprl.cloud:7233'.
  /// The name is immutable. Once set, it cannot be changed.
  package var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The ids of the regions where the namespace should be available.
  /// The GetRegions API can be used to get the list of valid region ids.
  /// Specifying more than one region makes the namespace "global", which is currently a preview only feature with restricted access.
  /// Please reach out to Temporal support for more information on global namespaces.
  /// When provisioned the global namespace will be active on the first region in the list and passive on the rest.
  /// Number of supported regions is 2.
  /// The regions is immutable. Once set, it cannot be changed.
  /// Example: ["aws-us-west-2"].
  package var regions: [String] {
    get {return _storage._regions}
    set {_uniqueStorage()._regions = newValue}
  }

  /// The number of days the workflows data will be retained for.
  /// Changes to the retention period may impact your storage costs.
  /// Any changes to the retention period will be applied to all new running workflows.
  package var retentionDays: Int32 {
    get {return _storage._retentionDays}
    set {_uniqueStorage()._retentionDays = newValue}
  }

  /// The mTLS auth configuration for the namespace.
  /// If unspecified, mTLS will be disabled.
  package var mtlsAuth: Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec {
    get {return _storage._mtlsAuth ?? Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec()}
    set {_uniqueStorage()._mtlsAuth = newValue}
  }
  /// Returns true if `mtlsAuth` has been explicitly set.
  package var hasMtlsAuth: Bool {return _storage._mtlsAuth != nil}
  /// Clears the value of `mtlsAuth`. Subsequent reads from it will return its default value.
  package mutating func clearMtlsAuth() {_uniqueStorage()._mtlsAuth = nil}

  /// The API key auth configuration for the namespace.
  /// If unspecified, API keys will be disabled.
  /// temporal:versioning:min_version=v0.2.0
  package var apiKeyAuth: Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec {
    get {return _storage._apiKeyAuth ?? Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec()}
    set {_uniqueStorage()._apiKeyAuth = newValue}
  }
  /// Returns true if `apiKeyAuth` has been explicitly set.
  package var hasApiKeyAuth: Bool {return _storage._apiKeyAuth != nil}
  /// Clears the value of `apiKeyAuth`. Subsequent reads from it will return its default value.
  package mutating func clearApiKeyAuth() {_uniqueStorage()._apiKeyAuth = nil}

  /// The custom search attributes to use for the namespace.
  /// The name of the attribute is the key and the type is the value.
  /// Supported attribute types: text, keyword, int, double, bool, datetime, keyword_list.
  /// NOTE: currently deleting a search attribute is not supported.
  /// Optional, default is empty.
  /// Deprecated: Not supported after v0.3.0 api version. Use search_attributes instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var customSearchAttributes: Dictionary<String,String> {
    get {return _storage._customSearchAttributes}
    set {_uniqueStorage()._customSearchAttributes = newValue}
  }

  /// The custom search attributes to use for the namespace.
  /// The name of the attribute is the key and the type is the value.
  /// Note: currently deleting a search attribute is not supported.
  /// Optional, default is empty.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=custom_search_attributes
  package var searchAttributes: Dictionary<String,Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType> {
    get {return _storage._searchAttributes}
    set {_uniqueStorage()._searchAttributes = newValue}
  }

  /// Codec server spec used by UI to decode payloads for all users interacting with this namespace.
  /// Optional, default is unset.
  package var codecServer: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec {
    get {return _storage._codecServer ?? Temporal_Api_Cloud_Namespace_V1_CodecServerSpec()}
    set {_uniqueStorage()._codecServer = newValue}
  }
  /// Returns true if `codecServer` has been explicitly set.
  package var hasCodecServer: Bool {return _storage._codecServer != nil}
  /// Clears the value of `codecServer`. Subsequent reads from it will return its default value.
  package mutating func clearCodecServer() {_uniqueStorage()._codecServer = nil}

  /// The lifecycle configuration for the namespace.
  /// temporal:versioning:min_version=v0.4.0
  package var lifecycle: Temporal_Api_Cloud_Namespace_V1_LifecycleSpec {
    get {return _storage._lifecycle ?? Temporal_Api_Cloud_Namespace_V1_LifecycleSpec()}
    set {_uniqueStorage()._lifecycle = newValue}
  }
  /// Returns true if `lifecycle` has been explicitly set.
  package var hasLifecycle: Bool {return _storage._lifecycle != nil}
  /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
  package mutating func clearLifecycle() {_uniqueStorage()._lifecycle = nil}

  /// The high availability configuration for the namespace.
  /// temporal:versioning:min_version=v0.4.0
  package var highAvailability: Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec {
    get {return _storage._highAvailability ?? Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec()}
    set {_uniqueStorage()._highAvailability = newValue}
  }
  /// Returns true if `highAvailability` has been explicitly set.
  package var hasHighAvailability: Bool {return _storage._highAvailability != nil}
  /// Clears the value of `highAvailability`. Subsequent reads from it will return its default value.
  package mutating func clearHighAvailability() {_uniqueStorage()._highAvailability = nil}

  /// The private connectivity configuration for the namespace.
  /// This will apply the connectivity rules specified to the namespace.
  /// temporal:versioning:min_version=v0.6.0
  package var connectivityRuleIds: [String] {
    get {return _storage._connectivityRuleIds}
    set {_uniqueStorage()._connectivityRuleIds = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum SearchAttributeType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case text // = 1
    case keyword // = 2
    case int // = 3
    case double // = 4
    case bool // = 5
    case datetime // = 6
    case keywordList // = 7
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .text
      case 2: self = .keyword
      case 3: self = .int
      case 4: self = .double
      case 5: self = .bool
      case 6: self = .datetime
      case 7: self = .keywordList
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .text: return 1
      case .keyword: return 2
      case .int: return 3
      case .double: return 4
      case .bool: return 5
      case .datetime: return 6
      case .keywordList: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType] = [
      .unspecified,
      .text,
      .keyword,
      .int,
      .double,
      .bool,
      .datetime,
      .keywordList,
    ]

  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Cloud_Namespace_V1_Endpoints: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The web UI address.
  package var webAddress: String = String()

  /// The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
  package var mtlsGrpcAddress: String = String()

  /// The gRPC address for API key client connections (may be empty if API keys are disabled).
  package var grpcAddress: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_Limits: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The number of actions per second (APS) that is currently allowed for the namespace.
  /// The namespace may be throttled if its APS exceeds the limit.
  package var actionsPerSecondLimit: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of principal arns that are allowed to access the namespace on the private link.
  package var allowedPrincipalArns: [String] = []

  /// The list of vpc endpoint service names that are associated with the namespace.
  package var vpcEndpointServiceNames: [String] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The id of the region where the private connectivity applies.
  package var region: String = String()

  /// The AWS PrivateLink info.
  /// This will only be set for an aws region.
  package var awsPrivateLink: Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo {
    get {return _awsPrivateLink ?? Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo()}
    set {_awsPrivateLink = newValue}
  }
  /// Returns true if `awsPrivateLink` has been explicitly set.
  package var hasAwsPrivateLink: Bool {return self._awsPrivateLink != nil}
  /// Clears the value of `awsPrivateLink`. Subsequent reads from it will return its default value.
  package mutating func clearAwsPrivateLink() {self._awsPrivateLink = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _awsPrivateLink: Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo? = nil
}

package struct Temporal_Api_Cloud_Namespace_V1_Namespace: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The namespace identifier.
  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  /// The current version of the namespace specification.
  /// The next update operation will have to include this version.
  package var resourceVersion: String {
    get {return _storage._resourceVersion}
    set {_uniqueStorage()._resourceVersion = newValue}
  }

  /// The namespace specification.
  package var spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec {
    get {return _storage._spec ?? Temporal_Api_Cloud_Namespace_V1_NamespaceSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The current state of the namespace.
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String {
    get {return _storage._stateDeprecated}
    set {_uniqueStorage()._stateDeprecated = newValue}
  }

  /// The current state of the namespace.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The id of the async operation that is creating/updating/deleting the namespace, if any.
  package var asyncOperationID: String {
    get {return _storage._asyncOperationID}
    set {_uniqueStorage()._asyncOperationID = newValue}
  }

  /// The endpoints for the namespace.
  package var endpoints: Temporal_Api_Cloud_Namespace_V1_Endpoints {
    get {return _storage._endpoints ?? Temporal_Api_Cloud_Namespace_V1_Endpoints()}
    set {_uniqueStorage()._endpoints = newValue}
  }
  /// Returns true if `endpoints` has been explicitly set.
  package var hasEndpoints: Bool {return _storage._endpoints != nil}
  /// Clears the value of `endpoints`. Subsequent reads from it will return its default value.
  package mutating func clearEndpoints() {_uniqueStorage()._endpoints = nil}

  /// The currently active region for the namespace.
  package var activeRegion: String {
    get {return _storage._activeRegion}
    set {_uniqueStorage()._activeRegion = newValue}
  }

  /// The limits set on the namespace currently.
  package var limits: Temporal_Api_Cloud_Namespace_V1_Limits {
    get {return _storage._limits ?? Temporal_Api_Cloud_Namespace_V1_Limits()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  package var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  package mutating func clearLimits() {_uniqueStorage()._limits = nil}

  /// The private connectivities for the namespace, if any.
  package var privateConnectivities: [Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity] {
    get {return _storage._privateConnectivities}
    set {_uniqueStorage()._privateConnectivities = newValue}
  }

  /// The date and time when the namespace was created.
  package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdTime = newValue}
  }
  /// Returns true if `createdTime` has been explicitly set.
  package var hasCreatedTime: Bool {return _storage._createdTime != nil}
  /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

  /// The date and time when the namespace was last modified.
  /// Will not be set if the namespace has never been modified.
  package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastModifiedTime = newValue}
  }
  /// Returns true if `lastModifiedTime` has been explicitly set.
  package var hasLastModifiedTime: Bool {return _storage._lastModifiedTime != nil}
  /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

  /// The status of each region where the namespace is available.
  /// The id of the region is the key and the status is the value of the map.
  package var regionStatus: Dictionary<String,Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus> {
    get {return _storage._regionStatus}
    set {_uniqueStorage()._regionStatus = newValue}
  }

  /// The connectivity rules that are set on this namespace.
  package var connectivityRules: [Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule] {
    get {return _storage._connectivityRules}
    set {_uniqueStorage()._connectivityRules = newValue}
  }

  /// The tags for the namespace.
  package var tags: Dictionary<String,String> {
    get {return _storage._tags}
    set {_uniqueStorage()._tags = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The current state of the namespace region.
  /// Possible values: adding, active, passive, removing, failed.
  /// For any failed state, reach out to Temporal Cloud support for remediation.
  /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
  /// temporal:versioning:max_version=v0.3.0
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var stateDeprecated: String = String()

  /// The current state of the namespace region.
  /// temporal:versioning:min_version=v0.3.0
  /// temporal:enums:replaces=state_deprecated
  package var state: Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus.State = .unspecified

  /// The id of the async operation that is making changes to where the namespace is available, if any.
  package var asyncOperationID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// The region is being added to the namespace.
    case adding // = 1

    /// The namespace is active in this region.
    case active // = 2

    /// The namespace is passive in this region.
    case passive // = 3

    /// The region is being removed from the namespace.
    case removing // = 4

    /// The region failed to be added/removed, check failure_reason in the last async_operation status for more details.
    case failed // = 5
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .adding
      case 2: self = .active
      case 3: self = .passive
      case 4: self = .removing
      case 5: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .adding: return 1
      case .active: return 2
      case .passive: return 3
      case .removing: return 4
      case .failed: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus.State] = [
      .unspecified,
      .adding,
      .active,
      .passive,
      .removing,
      .failed,
    ]

  }

  package init() {}
}

package struct Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the export sink, it can't be changed once set. 
  package var name: String = String()

  /// A flag indicating whether the export sink is enabled or not.
  package var enabled: Bool = false

  /// The S3 configuration details when destination_type is S3.
  package var s3: Temporal_Api_Cloud_Sink_V1_S3Spec {
    get {return _s3 ?? Temporal_Api_Cloud_Sink_V1_S3Spec()}
    set {_s3 = newValue}
  }
  /// Returns true if `s3` has been explicitly set.
  package var hasS3: Bool {return self._s3 != nil}
  /// Clears the value of `s3`. Subsequent reads from it will return its default value.
  package mutating func clearS3() {self._s3 = nil}

  /// The GCS configuration details when destination_type is GCS. 
  package var gcs: Temporal_Api_Cloud_Sink_V1_GCSSpec {
    get {return _gcs ?? Temporal_Api_Cloud_Sink_V1_GCSSpec()}
    set {_gcs = newValue}
  }
  /// Returns true if `gcs` has been explicitly set.
  package var hasGcs: Bool {return self._gcs != nil}
  /// Clears the value of `gcs`. Subsequent reads from it will return its default value.
  package mutating func clearGcs() {self._gcs = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _s3: Temporal_Api_Cloud_Sink_V1_S3Spec? = nil
  fileprivate var _gcs: Temporal_Api_Cloud_Sink_V1_GCSSpec? = nil
}

package struct Temporal_Api_Cloud_Namespace_V1_ExportSink: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique name of the export sink.
  package var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  /// The version of the export sink resource.
  package var resourceVersion: String {
    get {return _storage._resourceVersion}
    set {_uniqueStorage()._resourceVersion = newValue}
  }

  /// The current state of the export sink.
  package var state: Temporal_Api_Cloud_Resource_V1_ResourceState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The specification details of the export sink.
  package var spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec {
    get {return _storage._spec ?? Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec()}
    set {_uniqueStorage()._spec = newValue}
  }
  /// Returns true if `spec` has been explicitly set.
  package var hasSpec: Bool {return _storage._spec != nil}
  /// Clears the value of `spec`. Subsequent reads from it will return its default value.
  package mutating func clearSpec() {_uniqueStorage()._spec = nil}

  /// The health status of the export sink.
  package var health: Temporal_Api_Cloud_Namespace_V1_ExportSink.Health {
    get {return _storage._health}
    set {_uniqueStorage()._health = newValue}
  }

  /// An error message describing any issues with the export sink, if applicable.
  package var errorMessage: String {
    get {return _storage._errorMessage}
    set {_uniqueStorage()._errorMessage = newValue}
  }

  /// The timestamp of the latest successful data export.
  package var latestDataExportTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._latestDataExportTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._latestDataExportTime = newValue}
  }
  /// Returns true if `latestDataExportTime` has been explicitly set.
  package var hasLatestDataExportTime: Bool {return _storage._latestDataExportTime != nil}
  /// Clears the value of `latestDataExportTime`. Subsequent reads from it will return its default value.
  package mutating func clearLatestDataExportTime() {_uniqueStorage()._latestDataExportTime = nil}

  /// The timestamp of the last health check performed on the export sink.
  package var lastHealthCheckTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastHealthCheckTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastHealthCheckTime = newValue}
  }
  /// Returns true if `lastHealthCheckTime` has been explicitly set.
  package var hasLastHealthCheckTime: Bool {return _storage._lastHealthCheckTime != nil}
  /// Clears the value of `lastHealthCheckTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastHealthCheckTime() {_uniqueStorage()._lastHealthCheckTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum Health: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case ok // = 1
    case errorInternal // = 2
    case errorUserConfiguration // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .ok
      case 2: self = .errorInternal
      case 3: self = .errorUserConfiguration
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .ok: return 1
      case .errorInternal: return 2
      case .errorUserConfiguration: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Cloud_Namespace_V1_ExportSink.Health] = [
      .unspecified,
      .ok,
      .errorInternal,
      .errorUserConfiguration,
    ]

  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.namespace.v1"

extension Temporal_Api_Cloud_Namespace_V1_CertificateFilterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CertificateFilterSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}common_name\0\u{1}organization\0\u{3}organizational_unit\0\u{3}subject_alternative_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commonName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.organizationalUnit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subjectAlternativeName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commonName.isEmpty {
      try visitor.visitSingularStringField(value: self.commonName, fieldNumber: 1)
    }
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 2)
    }
    if !self.organizationalUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationalUnit, fieldNumber: 3)
    }
    if !self.subjectAlternativeName.isEmpty {
      try visitor.visitSingularStringField(value: self.subjectAlternativeName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_CertificateFilterSpec, rhs: Temporal_Api_Cloud_Namespace_V1_CertificateFilterSpec) -> Bool {
    if lhs.commonName != rhs.commonName {return false}
    if lhs.organization != rhs.organization {return false}
    if lhs.organizationalUnit != rhs.organizationalUnit {return false}
    if lhs.subjectAlternativeName != rhs.subjectAlternativeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".MtlsAuthSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}accepted_client_ca_deprecated\0\u{3}certificate_filters\0\u{1}enabled\0\u{3}accepted_client_ca\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.acceptedClientCaDeprecated) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.certificateFilters) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.acceptedClientCa) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acceptedClientCaDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.acceptedClientCaDeprecated, fieldNumber: 1)
    }
    if !self.certificateFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.certificateFilters, fieldNumber: 2)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    if !self.acceptedClientCa.isEmpty {
      try visitor.visitSingularBytesField(value: self.acceptedClientCa, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec, rhs: Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec) -> Bool {
    if lhs.acceptedClientCaDeprecated != rhs.acceptedClientCaDeprecated {return false}
    if lhs.acceptedClientCa != rhs.acceptedClientCa {return false}
    if lhs.certificateFilters != rhs.certificateFilters {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApiKeyAuthSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec, rhs: Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_CodecServerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CodecServerSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{3}pass_access_token\0\u{3}include_cross_origin_credentials\0\u{3}custom_error_message\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.passAccessToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeCrossOriginCredentials) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._customErrorMessage) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if self.passAccessToken != false {
      try visitor.visitSingularBoolField(value: self.passAccessToken, fieldNumber: 2)
    }
    if self.includeCrossOriginCredentials != false {
      try visitor.visitSingularBoolField(value: self.includeCrossOriginCredentials, fieldNumber: 3)
    }
    try { if let v = self._customErrorMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec, rhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.passAccessToken != rhs.passAccessToken {return false}
    if lhs.includeCrossOriginCredentials != rhs.includeCrossOriginCredentials {return false}
    if lhs._customErrorMessage != rhs._customErrorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.protoMessageName + ".CustomErrorMessage"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}default\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._default) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._default {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage, rhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage) -> Bool {
    if lhs._default != rhs._default {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.protoMessageName + ".ErrorMessage"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}link\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.link) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage, rhs: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec.CustomErrorMessage.ErrorMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.link != rhs.link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_LifecycleSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".LifecycleSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enable_delete_protection\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableDeleteProtection) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableDeleteProtection != false {
      try visitor.visitSingularBoolField(value: self.enableDeleteProtection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_LifecycleSpec, rhs: Temporal_Api_Cloud_Namespace_V1_LifecycleSpec) -> Bool {
    if lhs.enableDeleteProtection != rhs.enableDeleteProtection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".HighAvailabilitySpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}disable_managed_failover\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disableManagedFailover) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disableManagedFailover != false {
      try visitor.visitSingularBoolField(value: self.disableManagedFailover, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec, rhs: Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec) -> Bool {
    if lhs.disableManagedFailover != rhs.disableManagedFailover {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_NamespaceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}regions\0\u{3}retention_days\0\u{3}mtls_auth\0\u{3}custom_search_attributes\0\u{3}codec_server\0\u{3}api_key_auth\0\u{3}search_attributes\0\u{1}lifecycle\0\u{3}high_availability\0\u{3}connectivity_rule_ids\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _regions: [String] = []
    var _retentionDays: Int32 = 0
    var _mtlsAuth: Temporal_Api_Cloud_Namespace_V1_MtlsAuthSpec? = nil
    var _apiKeyAuth: Temporal_Api_Cloud_Namespace_V1_ApiKeyAuthSpec? = nil
    var _customSearchAttributes: Dictionary<String,String> = [:]
    var _searchAttributes: Dictionary<String,Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType> = [:]
    var _codecServer: Temporal_Api_Cloud_Namespace_V1_CodecServerSpec? = nil
    var _lifecycle: Temporal_Api_Cloud_Namespace_V1_LifecycleSpec? = nil
    var _highAvailability: Temporal_Api_Cloud_Namespace_V1_HighAvailabilitySpec? = nil
    var _connectivityRuleIds: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _regions = source._regions
      _retentionDays = source._retentionDays
      _mtlsAuth = source._mtlsAuth
      _apiKeyAuth = source._apiKeyAuth
      _customSearchAttributes = source._customSearchAttributes
      _searchAttributes = source._searchAttributes
      _codecServer = source._codecServer
      _lifecycle = source._lifecycle
      _highAvailability = source._highAvailability
      _connectivityRuleIds = source._connectivityRuleIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._regions) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._retentionDays) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mtlsAuth) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._customSearchAttributes) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._codecServer) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._apiKeyAuth) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType>.self, value: &_storage._searchAttributes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lifecycle) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._highAvailability) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._connectivityRuleIds) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._regions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._regions, fieldNumber: 2)
      }
      if _storage._retentionDays != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retentionDays, fieldNumber: 3)
      }
      try { if let v = _storage._mtlsAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._customSearchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._customSearchAttributes, fieldNumber: 5)
      }
      try { if let v = _storage._codecServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._apiKeyAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType>.self, value: _storage._searchAttributes, fieldNumber: 8)
      }
      try { if let v = _storage._lifecycle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._highAvailability {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._connectivityRuleIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._connectivityRuleIds, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec, rhs: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._regions != rhs_storage._regions {return false}
        if _storage._retentionDays != rhs_storage._retentionDays {return false}
        if _storage._mtlsAuth != rhs_storage._mtlsAuth {return false}
        if _storage._apiKeyAuth != rhs_storage._apiKeyAuth {return false}
        if _storage._customSearchAttributes != rhs_storage._customSearchAttributes {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._codecServer != rhs_storage._codecServer {return false}
        if _storage._lifecycle != rhs_storage._lifecycle {return false}
        if _storage._highAvailability != rhs_storage._highAvailability {return false}
        if _storage._connectivityRuleIds != rhs_storage._connectivityRuleIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_NamespaceSpec.SearchAttributeType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SEARCH_ATTRIBUTE_TYPE_UNSPECIFIED\0\u{1}SEARCH_ATTRIBUTE_TYPE_TEXT\0\u{1}SEARCH_ATTRIBUTE_TYPE_KEYWORD\0\u{1}SEARCH_ATTRIBUTE_TYPE_INT\0\u{1}SEARCH_ATTRIBUTE_TYPE_DOUBLE\0\u{1}SEARCH_ATTRIBUTE_TYPE_BOOL\0\u{1}SEARCH_ATTRIBUTE_TYPE_DATETIME\0\u{1}SEARCH_ATTRIBUTE_TYPE_KEYWORD_LIST\0")
}

extension Temporal_Api_Cloud_Namespace_V1_Endpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Endpoints"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}web_address\0\u{3}mtls_grpc_address\0\u{3}grpc_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.webAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mtlsGrpcAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.grpcAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.webAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.webAddress, fieldNumber: 1)
    }
    if !self.mtlsGrpcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.mtlsGrpcAddress, fieldNumber: 2)
    }
    if !self.grpcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.grpcAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_Endpoints, rhs: Temporal_Api_Cloud_Namespace_V1_Endpoints) -> Bool {
    if lhs.webAddress != rhs.webAddress {return false}
    if lhs.mtlsGrpcAddress != rhs.mtlsGrpcAddress {return false}
    if lhs.grpcAddress != rhs.grpcAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_Limits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Limits"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}actions_per_second_limit\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.actionsPerSecondLimit) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsPerSecondLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.actionsPerSecondLimit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_Limits, rhs: Temporal_Api_Cloud_Namespace_V1_Limits) -> Bool {
    if lhs.actionsPerSecondLimit != rhs.actionsPerSecondLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AWSPrivateLinkInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}allowed_principal_arns\0\u{3}vpc_endpoint_service_names\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedPrincipalArns) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.vpcEndpointServiceNames) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedPrincipalArns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPrincipalArns, fieldNumber: 1)
    }
    if !self.vpcEndpointServiceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.vpcEndpointServiceNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo, rhs: Temporal_Api_Cloud_Namespace_V1_AWSPrivateLinkInfo) -> Bool {
    if lhs.allowedPrincipalArns != rhs.allowedPrincipalArns {return false}
    if lhs.vpcEndpointServiceNames != rhs.vpcEndpointServiceNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PrivateConnectivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0\u{3}aws_private_link\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._awsPrivateLink) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    try { if let v = self._awsPrivateLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity, rhs: Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs._awsPrivateLink != rhs._awsPrivateLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Namespace"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}endpoints\0\u{3}active_region\0\u{1}limits\0\u{3}private_connectivities\0\u{3}created_time\0\u{3}last_modified_time\0\u{3}region_status\0\u{1}state\0\u{3}connectivity_rules\0\u{1}tags\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _resourceVersion: String = String()
    var _spec: Temporal_Api_Cloud_Namespace_V1_NamespaceSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _endpoints: Temporal_Api_Cloud_Namespace_V1_Endpoints? = nil
    var _activeRegion: String = String()
    var _limits: Temporal_Api_Cloud_Namespace_V1_Limits? = nil
    var _privateConnectivities: [Temporal_Api_Cloud_Namespace_V1_PrivateConnectivity] = []
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _regionStatus: Dictionary<String,Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus> = [:]
    var _connectivityRules: [Temporal_Api_Cloud_Connectivityrule_V1_ConnectivityRule] = []
    var _tags: Dictionary<String,String> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _endpoints = source._endpoints
      _activeRegion = source._activeRegion
      _limits = source._limits
      _privateConnectivities = source._privateConnectivities
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
      _regionStatus = source._regionStatus
      _connectivityRules = source._connectivityRules
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endpoints) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._activeRegion) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._limits) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._privateConnectivities) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus>.self, value: &_storage._regionStatus) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._connectivityRules) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._endpoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._activeRegion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activeRegion, fieldNumber: 7)
      }
      try { if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._privateConnectivities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._privateConnectivities, fieldNumber: 9)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._regionStatus.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus>.self, value: _storage._regionStatus, fieldNumber: 12)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 13)
      }
      if !_storage._connectivityRules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._connectivityRules, fieldNumber: 14)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_Namespace, rhs: Temporal_Api_Cloud_Namespace_V1_Namespace) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._endpoints != rhs_storage._endpoints {return false}
        if _storage._activeRegion != rhs_storage._activeRegion {return false}
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._privateConnectivities != rhs_storage._privateConnectivities {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        if _storage._regionStatus != rhs_storage._regionStatus {return false}
        if _storage._connectivityRules != rhs_storage._connectivityRules {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceRegionStatus"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateDeprecated) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stateDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDeprecated, fieldNumber: 1)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus, rhs: Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus) -> Bool {
    if lhs.stateDeprecated != rhs.stateDeprecated {return false}
    if lhs.state != rhs.state {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_NamespaceRegionStatus.State: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STATE_UNSPECIFIED\0\u{1}STATE_ADDING\0\u{1}STATE_ACTIVE\0\u{1}STATE_PASSIVE\0\u{1}STATE_REMOVING\0\u{1}STATE_FAILED\0")
}

extension Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExportSinkSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}enabled\0\u{1}s3\0\u{1}gcs\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._s3) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gcs) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try { if let v = self._s3 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gcs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec, rhs: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs._s3 != rhs._s3 {return false}
    if lhs._gcs != rhs._gcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_ExportSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ExportSink"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}resource_version\0\u{1}state\0\u{1}spec\0\u{1}health\0\u{3}error_message\0\u{3}latest_data_export_time\0\u{3}last_health_check_time\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _resourceVersion: String = String()
    var _state: Temporal_Api_Cloud_Resource_V1_ResourceState = .unspecified
    var _spec: Temporal_Api_Cloud_Namespace_V1_ExportSinkSpec? = nil
    var _health: Temporal_Api_Cloud_Namespace_V1_ExportSink.Health = .unspecified
    var _errorMessage: String = String()
    var _latestDataExportTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastHealthCheckTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _resourceVersion = source._resourceVersion
      _state = source._state
      _spec = source._spec
      _health = source._health
      _errorMessage = source._errorMessage
      _latestDataExportTime = source._latestDataExportTime
      _lastHealthCheckTime = source._lastHealthCheckTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._health) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._latestDataExportTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastHealthCheckTime) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._health != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._health, fieldNumber: 5)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 6)
      }
      try { if let v = _storage._latestDataExportTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastHealthCheckTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Cloud_Namespace_V1_ExportSink, rhs: Temporal_Api_Cloud_Namespace_V1_ExportSink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._latestDataExportTime != rhs_storage._latestDataExportTime {return false}
        if _storage._lastHealthCheckTime != rhs_storage._lastHealthCheckTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Cloud_Namespace_V1_ExportSink.Health: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HEALTH_UNSPECIFIED\0\u{1}HEALTH_OK\0\u{1}HEALTH_ERROR_INTERNAL\0\u{1}HEALTH_ERROR_USER_CONFIGURATION\0")
}
