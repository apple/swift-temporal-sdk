// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/worker/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Worker_V1_WorkerPollerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of polling RPCs that are currently in flight.
  package var currentPollers: Int32 = 0

  package var lastSuccessfulPollTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastSuccessfulPollTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastSuccessfulPollTime = newValue}
  }
  /// Returns true if `lastSuccessfulPollTime` has been explicitly set.
  package var hasLastSuccessfulPollTime: Bool {return self._lastSuccessfulPollTime != nil}
  /// Clears the value of `lastSuccessfulPollTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastSuccessfulPollTime() {self._lastSuccessfulPollTime = nil}

  /// Set true if the number of concurrent pollers is auto-scaled
  package var isAutoscaling: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastSuccessfulPollTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Worker_V1_WorkerSlotsInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Number of slots available for the worker to specific tasks.
  /// May be -1 if the upper bound is not known.
  package var currentAvailableSlots: Int32 = 0

  /// Number of slots used by the worker for specific tasks.
  package var currentUsedSlots: Int32 = 0

  /// Kind of the slot supplier, which is used to determine how the slots are allocated.
  /// Possible values: "Fixed | ResourceBased | Custom String"
  package var slotSupplierKind: String = String()

  /// Total number of tasks processed (completed both successfully and unsuccesfully, or any other way)
  /// by the worker since the worker started. This is a cumulative counter.
  package var totalProcessedTasks: Int32 = 0

  /// Total number of failed tasks processed by the worker so far.
  package var totalFailedTasks: Int32 = 0

  /// Number of tasks processed in since the last heartbeat from the worker.
  /// This is a cumulative counter, and it is reset to 0 each time the worker sends a heartbeat.
  /// Contains both successful and failed tasks.
  package var lastIntervalProcessedTasks: Int32 = 0

  /// Number of failed tasks processed since the last heartbeat from the worker.
  package var lastIntervalFailureTasks: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Holds everything needed to identify the worker host/process context
package struct Temporal_Api_Worker_V1_WorkerHostInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Worker host identifier.
  package var hostName: String = String()

  /// Worker process identifier. This id should be unique for all _processes_
  /// running workers in the namespace, and should be shared by all workers
  /// in the same process.
  /// This will be used to build the worker command nexus task queue name:
  /// "temporal-sys/worker-commands/{process_key}"
  package var processKey: String = String()

  /// Worker process identifier. Unlike process_key, this id only needs to be unique
  /// within one host (so using e.g. a unix pid would be appropriate).
  package var processID: String = String()

  /// System used CPU as a float in the range [0.0, 1.0] where 1.0 is defined as all
  /// cores on the host pegged.
  package var currentHostCpuUsage: Float = 0

  /// System used memory as a float in the range [0.0, 1.0] where 1.0 is defined as
  /// all available memory on the host is used.
  package var currentHostMemUsage: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Worker info message, contains information about the worker and its current state.
/// All information is provided by the worker itself.
/// (-- api-linter: core::0140::prepositions=disabled
///     aip.dev/not-precedent: Removing those words make names less clear. --)
package struct Temporal_Api_Worker_V1_WorkerHeartbeat: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Worker identifier, should be unique for the namespace.
  /// It is distinct from worker identity, which is not necessarily namespace-unique.
  package var workerInstanceKey: String {
    get {return _storage._workerInstanceKey}
    set {_uniqueStorage()._workerInstanceKey = newValue}
  }

  /// Worker identity, set by the client, may not be unique.
  /// Usually host_name+(user group name)+process_id, but can be overwritten by the user.
  package var workerIdentity: String {
    get {return _storage._workerIdentity}
    set {_uniqueStorage()._workerIdentity = newValue}
  }

  /// Worker host information.
  package var hostInfo: Temporal_Api_Worker_V1_WorkerHostInfo {
    get {return _storage._hostInfo ?? Temporal_Api_Worker_V1_WorkerHostInfo()}
    set {_uniqueStorage()._hostInfo = newValue}
  }
  /// Returns true if `hostInfo` has been explicitly set.
  package var hasHostInfo: Bool {return _storage._hostInfo != nil}
  /// Clears the value of `hostInfo`. Subsequent reads from it will return its default value.
  package mutating func clearHostInfo() {_uniqueStorage()._hostInfo = nil}

  /// Task queue this worker is polling for tasks.
  package var taskQueue: String {
    get {return _storage._taskQueue}
    set {_uniqueStorage()._taskQueue = newValue}
  }

  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return _storage._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

  package var sdkName: String {
    get {return _storage._sdkName}
    set {_uniqueStorage()._sdkName = newValue}
  }

  package var sdkVersion: String {
    get {return _storage._sdkVersion}
    set {_uniqueStorage()._sdkVersion = newValue}
  }

  /// Worker status. Defined by SDK.
  package var status: Temporal_Api_Enums_V1_WorkerStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  /// Worker start time.
  /// It can be used to determine worker uptime. (current time - start time)
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  /// Timestamp of this heartbeat, coming from the worker. Worker should set it to "now".
  /// Note that this timestamp comes directly from the worker and is subject to workers' clock skew.
  package var heartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._heartbeatTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._heartbeatTime = newValue}
  }
  /// Returns true if `heartbeatTime` has been explicitly set.
  package var hasHeartbeatTime: Bool {return _storage._heartbeatTime != nil}
  /// Clears the value of `heartbeatTime`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTime() {_uniqueStorage()._heartbeatTime = nil}

  /// Elapsed time since the last heartbeat from the worker.
  package var elapsedSinceLastHeartbeat: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._elapsedSinceLastHeartbeat ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._elapsedSinceLastHeartbeat = newValue}
  }
  /// Returns true if `elapsedSinceLastHeartbeat` has been explicitly set.
  package var hasElapsedSinceLastHeartbeat: Bool {return _storage._elapsedSinceLastHeartbeat != nil}
  /// Clears the value of `elapsedSinceLastHeartbeat`. Subsequent reads from it will return its default value.
  package mutating func clearElapsedSinceLastHeartbeat() {_uniqueStorage()._elapsedSinceLastHeartbeat = nil}

  package var workflowTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo {
    get {return _storage._workflowTaskSlotsInfo ?? Temporal_Api_Worker_V1_WorkerSlotsInfo()}
    set {_uniqueStorage()._workflowTaskSlotsInfo = newValue}
  }
  /// Returns true if `workflowTaskSlotsInfo` has been explicitly set.
  package var hasWorkflowTaskSlotsInfo: Bool {return _storage._workflowTaskSlotsInfo != nil}
  /// Clears the value of `workflowTaskSlotsInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskSlotsInfo() {_uniqueStorage()._workflowTaskSlotsInfo = nil}

  package var activityTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo {
    get {return _storage._activityTaskSlotsInfo ?? Temporal_Api_Worker_V1_WorkerSlotsInfo()}
    set {_uniqueStorage()._activityTaskSlotsInfo = newValue}
  }
  /// Returns true if `activityTaskSlotsInfo` has been explicitly set.
  package var hasActivityTaskSlotsInfo: Bool {return _storage._activityTaskSlotsInfo != nil}
  /// Clears the value of `activityTaskSlotsInfo`. Subsequent reads from it will return its default value.
  package mutating func clearActivityTaskSlotsInfo() {_uniqueStorage()._activityTaskSlotsInfo = nil}

  package var nexusTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo {
    get {return _storage._nexusTaskSlotsInfo ?? Temporal_Api_Worker_V1_WorkerSlotsInfo()}
    set {_uniqueStorage()._nexusTaskSlotsInfo = newValue}
  }
  /// Returns true if `nexusTaskSlotsInfo` has been explicitly set.
  package var hasNexusTaskSlotsInfo: Bool {return _storage._nexusTaskSlotsInfo != nil}
  /// Clears the value of `nexusTaskSlotsInfo`. Subsequent reads from it will return its default value.
  package mutating func clearNexusTaskSlotsInfo() {_uniqueStorage()._nexusTaskSlotsInfo = nil}

  package var localActivitySlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo {
    get {return _storage._localActivitySlotsInfo ?? Temporal_Api_Worker_V1_WorkerSlotsInfo()}
    set {_uniqueStorage()._localActivitySlotsInfo = newValue}
  }
  /// Returns true if `localActivitySlotsInfo` has been explicitly set.
  package var hasLocalActivitySlotsInfo: Bool {return _storage._localActivitySlotsInfo != nil}
  /// Clears the value of `localActivitySlotsInfo`. Subsequent reads from it will return its default value.
  package mutating func clearLocalActivitySlotsInfo() {_uniqueStorage()._localActivitySlotsInfo = nil}

  package var workflowPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo {
    get {return _storage._workflowPollerInfo ?? Temporal_Api_Worker_V1_WorkerPollerInfo()}
    set {_uniqueStorage()._workflowPollerInfo = newValue}
  }
  /// Returns true if `workflowPollerInfo` has been explicitly set.
  package var hasWorkflowPollerInfo: Bool {return _storage._workflowPollerInfo != nil}
  /// Clears the value of `workflowPollerInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowPollerInfo() {_uniqueStorage()._workflowPollerInfo = nil}

  package var workflowStickyPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo {
    get {return _storage._workflowStickyPollerInfo ?? Temporal_Api_Worker_V1_WorkerPollerInfo()}
    set {_uniqueStorage()._workflowStickyPollerInfo = newValue}
  }
  /// Returns true if `workflowStickyPollerInfo` has been explicitly set.
  package var hasWorkflowStickyPollerInfo: Bool {return _storage._workflowStickyPollerInfo != nil}
  /// Clears the value of `workflowStickyPollerInfo`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowStickyPollerInfo() {_uniqueStorage()._workflowStickyPollerInfo = nil}

  package var activityPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo {
    get {return _storage._activityPollerInfo ?? Temporal_Api_Worker_V1_WorkerPollerInfo()}
    set {_uniqueStorage()._activityPollerInfo = newValue}
  }
  /// Returns true if `activityPollerInfo` has been explicitly set.
  package var hasActivityPollerInfo: Bool {return _storage._activityPollerInfo != nil}
  /// Clears the value of `activityPollerInfo`. Subsequent reads from it will return its default value.
  package mutating func clearActivityPollerInfo() {_uniqueStorage()._activityPollerInfo = nil}

  package var nexusPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo {
    get {return _storage._nexusPollerInfo ?? Temporal_Api_Worker_V1_WorkerPollerInfo()}
    set {_uniqueStorage()._nexusPollerInfo = newValue}
  }
  /// Returns true if `nexusPollerInfo` has been explicitly set.
  package var hasNexusPollerInfo: Bool {return _storage._nexusPollerInfo != nil}
  /// Clears the value of `nexusPollerInfo`. Subsequent reads from it will return its default value.
  package mutating func clearNexusPollerInfo() {_uniqueStorage()._nexusPollerInfo = nil}

  /// A Workflow Task found a cached Workflow Execution to run against.
  package var totalStickyCacheHit: Int32 {
    get {return _storage._totalStickyCacheHit}
    set {_uniqueStorage()._totalStickyCacheHit = newValue}
  }

  /// A Workflow Task did not find a cached Workflow execution to run against.
  package var totalStickyCacheMiss: Int32 {
    get {return _storage._totalStickyCacheMiss}
    set {_uniqueStorage()._totalStickyCacheMiss = newValue}
  }

  /// Current cache size, expressed in number of Workflow Executions.
  package var currentStickyCacheSize: Int32 {
    get {return _storage._currentStickyCacheSize}
    set {_uniqueStorage()._currentStickyCacheSize = newValue}
  }

  /// Plugins currently in use by this SDK.
  package var plugins: [Temporal_Api_Worker_V1_PluginInfo] {
    get {return _storage._plugins}
    set {_uniqueStorage()._plugins = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Worker_V1_WorkerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat {
    get {return _workerHeartbeat ?? Temporal_Api_Worker_V1_WorkerHeartbeat()}
    set {_workerHeartbeat = newValue}
  }
  /// Returns true if `workerHeartbeat` has been explicitly set.
  package var hasWorkerHeartbeat: Bool {return self._workerHeartbeat != nil}
  /// Clears the value of `workerHeartbeat`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerHeartbeat() {self._workerHeartbeat = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerHeartbeat: Temporal_Api_Worker_V1_WorkerHeartbeat? = nil
}

package struct Temporal_Api_Worker_V1_PluginInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the plugin, required.
  package var name: String = String()

  /// The version of the plugin, may be empty.
  package var version: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.worker.v1"

extension Temporal_Api_Worker_V1_WorkerPollerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerPollerInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_pollers\0\u{3}last_successful_poll_time\0\u{3}is_autoscaling\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.currentPollers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastSuccessfulPollTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAutoscaling) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.currentPollers != 0 {
      try visitor.visitSingularInt32Field(value: self.currentPollers, fieldNumber: 1)
    }
    try { if let v = self._lastSuccessfulPollTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.isAutoscaling != false {
      try visitor.visitSingularBoolField(value: self.isAutoscaling, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_WorkerPollerInfo, rhs: Temporal_Api_Worker_V1_WorkerPollerInfo) -> Bool {
    if lhs.currentPollers != rhs.currentPollers {return false}
    if lhs._lastSuccessfulPollTime != rhs._lastSuccessfulPollTime {return false}
    if lhs.isAutoscaling != rhs.isAutoscaling {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Worker_V1_WorkerSlotsInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerSlotsInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_available_slots\0\u{3}current_used_slots\0\u{3}slot_supplier_kind\0\u{3}total_processed_tasks\0\u{3}total_failed_tasks\0\u{3}last_interval_processed_tasks\0\u{3}last_interval_failure_tasks\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.currentAvailableSlots) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.currentUsedSlots) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.slotSupplierKind) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.totalProcessedTasks) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.totalFailedTasks) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.lastIntervalProcessedTasks) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.lastIntervalFailureTasks) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.currentAvailableSlots != 0 {
      try visitor.visitSingularInt32Field(value: self.currentAvailableSlots, fieldNumber: 1)
    }
    if self.currentUsedSlots != 0 {
      try visitor.visitSingularInt32Field(value: self.currentUsedSlots, fieldNumber: 2)
    }
    if !self.slotSupplierKind.isEmpty {
      try visitor.visitSingularStringField(value: self.slotSupplierKind, fieldNumber: 3)
    }
    if self.totalProcessedTasks != 0 {
      try visitor.visitSingularInt32Field(value: self.totalProcessedTasks, fieldNumber: 4)
    }
    if self.totalFailedTasks != 0 {
      try visitor.visitSingularInt32Field(value: self.totalFailedTasks, fieldNumber: 5)
    }
    if self.lastIntervalProcessedTasks != 0 {
      try visitor.visitSingularInt32Field(value: self.lastIntervalProcessedTasks, fieldNumber: 6)
    }
    if self.lastIntervalFailureTasks != 0 {
      try visitor.visitSingularInt32Field(value: self.lastIntervalFailureTasks, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_WorkerSlotsInfo, rhs: Temporal_Api_Worker_V1_WorkerSlotsInfo) -> Bool {
    if lhs.currentAvailableSlots != rhs.currentAvailableSlots {return false}
    if lhs.currentUsedSlots != rhs.currentUsedSlots {return false}
    if lhs.slotSupplierKind != rhs.slotSupplierKind {return false}
    if lhs.totalProcessedTasks != rhs.totalProcessedTasks {return false}
    if lhs.totalFailedTasks != rhs.totalFailedTasks {return false}
    if lhs.lastIntervalProcessedTasks != rhs.lastIntervalProcessedTasks {return false}
    if lhs.lastIntervalFailureTasks != rhs.lastIntervalFailureTasks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Worker_V1_WorkerHostInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerHostInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}host_name\0\u{3}process_id\0\u{3}current_host_cpu_usage\0\u{3}current_host_mem_usage\0\u{3}process_key\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.hostName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.processID) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.currentHostCpuUsage) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.currentHostMemUsage) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.processKey) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hostName.isEmpty {
      try visitor.visitSingularStringField(value: self.hostName, fieldNumber: 1)
    }
    if !self.processID.isEmpty {
      try visitor.visitSingularStringField(value: self.processID, fieldNumber: 2)
    }
    if self.currentHostCpuUsage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentHostCpuUsage, fieldNumber: 3)
    }
    if self.currentHostMemUsage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.currentHostMemUsage, fieldNumber: 4)
    }
    if !self.processKey.isEmpty {
      try visitor.visitSingularStringField(value: self.processKey, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_WorkerHostInfo, rhs: Temporal_Api_Worker_V1_WorkerHostInfo) -> Bool {
    if lhs.hostName != rhs.hostName {return false}
    if lhs.processKey != rhs.processKey {return false}
    if lhs.processID != rhs.processID {return false}
    if lhs.currentHostCpuUsage != rhs.currentHostCpuUsage {return false}
    if lhs.currentHostMemUsage != rhs.currentHostMemUsage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Worker_V1_WorkerHeartbeat: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerHeartbeat"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_instance_key\0\u{3}worker_identity\0\u{3}host_info\0\u{3}task_queue\0\u{3}deployment_version\0\u{3}sdk_name\0\u{3}sdk_version\0\u{1}status\0\u{3}start_time\0\u{3}heartbeat_time\0\u{3}elapsed_since_last_heartbeat\0\u{3}workflow_task_slots_info\0\u{3}activity_task_slots_info\0\u{3}nexus_task_slots_info\0\u{3}local_activity_slots_info\0\u{3}workflow_poller_info\0\u{3}workflow_sticky_poller_info\0\u{3}activity_poller_info\0\u{3}nexus_poller_info\0\u{3}total_sticky_cache_hit\0\u{3}total_sticky_cache_miss\0\u{3}current_sticky_cache_size\0\u{1}plugins\0")

  fileprivate class _StorageClass {
    var _workerInstanceKey: String = String()
    var _workerIdentity: String = String()
    var _hostInfo: Temporal_Api_Worker_V1_WorkerHostInfo? = nil
    var _taskQueue: String = String()
    var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _sdkName: String = String()
    var _sdkVersion: String = String()
    var _status: Temporal_Api_Enums_V1_WorkerStatus = .unspecified
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _heartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _elapsedSinceLastHeartbeat: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo? = nil
    var _activityTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo? = nil
    var _nexusTaskSlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo? = nil
    var _localActivitySlotsInfo: Temporal_Api_Worker_V1_WorkerSlotsInfo? = nil
    var _workflowPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo? = nil
    var _workflowStickyPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo? = nil
    var _activityPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo? = nil
    var _nexusPollerInfo: Temporal_Api_Worker_V1_WorkerPollerInfo? = nil
    var _totalStickyCacheHit: Int32 = 0
    var _totalStickyCacheMiss: Int32 = 0
    var _currentStickyCacheSize: Int32 = 0
    var _plugins: [Temporal_Api_Worker_V1_PluginInfo] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workerInstanceKey = source._workerInstanceKey
      _workerIdentity = source._workerIdentity
      _hostInfo = source._hostInfo
      _taskQueue = source._taskQueue
      _deploymentVersion = source._deploymentVersion
      _sdkName = source._sdkName
      _sdkVersion = source._sdkVersion
      _status = source._status
      _startTime = source._startTime
      _heartbeatTime = source._heartbeatTime
      _elapsedSinceLastHeartbeat = source._elapsedSinceLastHeartbeat
      _workflowTaskSlotsInfo = source._workflowTaskSlotsInfo
      _activityTaskSlotsInfo = source._activityTaskSlotsInfo
      _nexusTaskSlotsInfo = source._nexusTaskSlotsInfo
      _localActivitySlotsInfo = source._localActivitySlotsInfo
      _workflowPollerInfo = source._workflowPollerInfo
      _workflowStickyPollerInfo = source._workflowStickyPollerInfo
      _activityPollerInfo = source._activityPollerInfo
      _nexusPollerInfo = source._nexusPollerInfo
      _totalStickyCacheHit = source._totalStickyCacheHit
      _totalStickyCacheMiss = source._totalStickyCacheMiss
      _currentStickyCacheSize = source._currentStickyCacheSize
      _plugins = source._plugins
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workerInstanceKey) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workerIdentity) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._hostInfo) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._sdkName) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._sdkVersion) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._elapsedSinceLastHeartbeat) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskSlotsInfo) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._activityTaskSlotsInfo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._nexusTaskSlotsInfo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._localActivitySlotsInfo) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._workflowPollerInfo) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._workflowStickyPollerInfo) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._activityPollerInfo) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._nexusPollerInfo) }()
        case 20: try { try decoder.decodeSingularInt32Field(value: &_storage._totalStickyCacheHit) }()
        case 21: try { try decoder.decodeSingularInt32Field(value: &_storage._totalStickyCacheMiss) }()
        case 22: try { try decoder.decodeSingularInt32Field(value: &_storage._currentStickyCacheSize) }()
        case 23: try { try decoder.decodeRepeatedMessageField(value: &_storage._plugins) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workerInstanceKey.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerInstanceKey, fieldNumber: 1)
      }
      if !_storage._workerIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerIdentity, fieldNumber: 2)
      }
      try { if let v = _storage._hostInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 4)
      }
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._sdkName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sdkName, fieldNumber: 6)
      }
      if !_storage._sdkVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sdkVersion, fieldNumber: 7)
      }
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 8)
      }
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._elapsedSinceLastHeartbeat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._workflowTaskSlotsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._activityTaskSlotsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._nexusTaskSlotsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._localActivitySlotsInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._workflowPollerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._workflowStickyPollerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._activityPollerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._nexusPollerInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if _storage._totalStickyCacheHit != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalStickyCacheHit, fieldNumber: 20)
      }
      if _storage._totalStickyCacheMiss != 0 {
        try visitor.visitSingularInt32Field(value: _storage._totalStickyCacheMiss, fieldNumber: 21)
      }
      if _storage._currentStickyCacheSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._currentStickyCacheSize, fieldNumber: 22)
      }
      if !_storage._plugins.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._plugins, fieldNumber: 23)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_WorkerHeartbeat, rhs: Temporal_Api_Worker_V1_WorkerHeartbeat) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workerInstanceKey != rhs_storage._workerInstanceKey {return false}
        if _storage._workerIdentity != rhs_storage._workerIdentity {return false}
        if _storage._hostInfo != rhs_storage._hostInfo {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        if _storage._sdkName != rhs_storage._sdkName {return false}
        if _storage._sdkVersion != rhs_storage._sdkVersion {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._heartbeatTime != rhs_storage._heartbeatTime {return false}
        if _storage._elapsedSinceLastHeartbeat != rhs_storage._elapsedSinceLastHeartbeat {return false}
        if _storage._workflowTaskSlotsInfo != rhs_storage._workflowTaskSlotsInfo {return false}
        if _storage._activityTaskSlotsInfo != rhs_storage._activityTaskSlotsInfo {return false}
        if _storage._nexusTaskSlotsInfo != rhs_storage._nexusTaskSlotsInfo {return false}
        if _storage._localActivitySlotsInfo != rhs_storage._localActivitySlotsInfo {return false}
        if _storage._workflowPollerInfo != rhs_storage._workflowPollerInfo {return false}
        if _storage._workflowStickyPollerInfo != rhs_storage._workflowStickyPollerInfo {return false}
        if _storage._activityPollerInfo != rhs_storage._activityPollerInfo {return false}
        if _storage._nexusPollerInfo != rhs_storage._nexusPollerInfo {return false}
        if _storage._totalStickyCacheHit != rhs_storage._totalStickyCacheHit {return false}
        if _storage._totalStickyCacheMiss != rhs_storage._totalStickyCacheMiss {return false}
        if _storage._currentStickyCacheSize != rhs_storage._currentStickyCacheSize {return false}
        if _storage._plugins != rhs_storage._plugins {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Worker_V1_WorkerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkerInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_heartbeat\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerHeartbeat) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_WorkerInfo, rhs: Temporal_Api_Worker_V1_WorkerInfo) -> Bool {
    if lhs._workerHeartbeat != rhs._workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Worker_V1_PluginInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PluginInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Worker_V1_PluginInfo, rhs: Temporal_Api_Worker_V1_PluginInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
