// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/batch/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Batch_V1_BatchOperationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Batch job ID
  package var jobID: String = String()

  /// Batch operation state
  package var state: Temporal_Api_Enums_V1_BatchOperationState = .unspecified

  /// Batch operation start time
  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return self._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {self._startTime = nil}

  /// Batch operation close time
  package var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_closeTime = newValue}
  }
  /// Returns true if `closeTime` has been explicitly set.
  package var hasCloseTime: Bool {return self._closeTime != nil}
  /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
  package mutating func clearCloseTime() {self._closeTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// BatchOperationTermination sends terminate requests to batch workflows.
/// Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
/// Ignore first_execution_run_id because this is used for single workflow operation.
package struct Temporal_Api_Batch_V1_BatchOperationTermination: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Serialized value(s) to provide to the termination event
  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

/// BatchOperationSignal sends signals to batch workflows.
/// Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
package struct Temporal_Api_Batch_V1_BatchOperationSignal: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The workflow author-defined name of the signal to send to the workflow
  package var signal: String = String()

  /// Serialized value(s) to provide with the signal
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _input ?? Temporal_Api_Common_V1_Payloads()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Headers that are passed with the signal to the processing workflow.
  /// These can include things like auth or tracing tokens.
  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
}

/// BatchOperationCancellation sends cancel requests to batch workflows.
/// Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
/// Ignore first_execution_run_id because this is used for single workflow operation.
package struct Temporal_Api_Batch_V1_BatchOperationCancellation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// BatchOperationDeletion sends deletion requests to batch workflows.
/// Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
package struct Temporal_Api_Batch_V1_BatchOperationDeletion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client
  package var identity: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// BatchOperationReset sends reset requests to batch workflows.
/// Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
package struct Temporal_Api_Batch_V1_BatchOperationReset: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  /// Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored.
  package var options: Temporal_Api_Common_V1_ResetOptions {
    get {return _options ?? Temporal_Api_Common_V1_ResetOptions()}
    set {_options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  package var hasOptions: Bool {return self._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  package mutating func clearOptions() {self._options = nil}

  /// Deprecated. Use `options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var resetType: Temporal_Api_Enums_V1_ResetType = .unspecified

  /// Deprecated. Use `options`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var resetReapplyType: Temporal_Api_Enums_V1_ResetReapplyType = .unspecified

  /// Operations to perform after the workflow has been reset. These operations will be applied
  /// to the *new* run of the workflow execution in the order they are provided.
  /// All operations are applied to the workflow before the first new workflow task is generated
  package var postResetOperations: [Temporal_Api_Workflow_V1_PostResetOperation] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _options: Temporal_Api_Common_V1_ResetOptions? = nil
}

/// BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
/// Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
package struct Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  /// Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
  package var workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions {
    get {return _workflowExecutionOptions ?? Temporal_Api_Workflow_V1_WorkflowExecutionOptions()}
    set {_workflowExecutionOptions = newValue}
  }
  /// Returns true if `workflowExecutionOptions` has been explicitly set.
  package var hasWorkflowExecutionOptions: Bool {return self._workflowExecutionOptions != nil}
  /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

  /// Controls which fields from `workflow_execution_options` will be applied.
  /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

/// BatchOperationUnpauseActivities sends unpause requests to batch workflows.
package struct Temporal_Api_Batch_V1_BatchOperationUnpauseActivities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  /// The activity to unpause. If match_all is set to true, all activities will be unpaused.
  package var activity: Temporal_Api_Batch_V1_BatchOperationUnpauseActivities.OneOf_Activity? = nil

  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  package var matchAll: Bool {
    get {
      if case .matchAll(let v)? = activity {return v}
      return false
    }
    set {activity = .matchAll(newValue)}
  }

  /// Setting this flag will also reset the number of attempts.
  package var resetAttempts: Bool = false

  /// Setting this flag will also reset the heartbeat details.
  package var resetHeartbeat: Bool = false

  /// If set, the activity will start at a random time within the specified jitter
  /// duration, introducing variability to the start time.
  package var jitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_jitter = newValue}
  }
  /// Returns true if `jitter` has been explicitly set.
  package var hasJitter: Bool {return self._jitter != nil}
  /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
  package mutating func clearJitter() {self._jitter = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The activity to unpause. If match_all is set to true, all activities will be unpaused.
  package enum OneOf_Activity: Equatable, Sendable {
    case type(String)
    case matchAll(Bool)

  }

  package init() {}

  fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// BatchOperationTriggerWorkflowRule sends TriggerWorkflowRule requests to batch workflows.
package struct Temporal_Api_Batch_V1_BatchOperationTriggerWorkflowRule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  package var rule: Temporal_Api_Batch_V1_BatchOperationTriggerWorkflowRule.OneOf_Rule? = nil

  /// ID of existing rule.
  package var id: String {
    get {
      if case .id(let v)? = rule {return v}
      return String()
    }
    set {rule = .id(newValue)}
  }

  /// Rule specification to be applied to the workflow without creating a new rule.
  package var spec: Temporal_Api_Rules_V1_WorkflowRuleSpec {
    get {
      if case .spec(let v)? = rule {return v}
      return Temporal_Api_Rules_V1_WorkflowRuleSpec()
    }
    set {rule = .spec(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Rule: Equatable, Sendable {
    /// ID of existing rule.
    case id(String)
    /// Rule specification to be applied to the workflow without creating a new rule.
    case spec(Temporal_Api_Rules_V1_WorkflowRuleSpec)

  }

  package init() {}
}

/// BatchOperationResetActivities sends activity reset requests in a batch.
/// NOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest
package struct Temporal_Api_Batch_V1_BatchOperationResetActivities: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  /// The activities to reset. If match_all is set to true, all activities will be reset.
  package var activity: Temporal_Api_Batch_V1_BatchOperationResetActivities.OneOf_Activity? = nil

  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  package var matchAll: Bool {
    get {
      if case .matchAll(let v)? = activity {return v}
      return false
    }
    set {activity = .matchAll(newValue)}
  }

  /// Setting this flag will also reset the number of attempts.
  package var resetAttempts: Bool = false

  /// Setting this flag will also reset the heartbeat details.
  package var resetHeartbeat: Bool = false

  /// If activity is paused, it will remain paused after reset
  package var keepPaused: Bool = false

  /// If set, the activity will start at a random time within the specified jitter
  /// duration, introducing variability to the start time.
  package var jitter: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_jitter = newValue}
  }
  /// Returns true if `jitter` has been explicitly set.
  package var hasJitter: Bool {return self._jitter != nil}
  /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
  package mutating func clearJitter() {self._jitter = nil}

  /// If set, the activity options will be restored to the defaults.
  /// Default options are then options activity was created with.
  /// They are part of the first ActivityTaskScheduled event.
  package var restoreOriginalOptions: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The activities to reset. If match_all is set to true, all activities will be reset.
  package enum OneOf_Activity: Equatable, Sendable {
    case type(String)
    case matchAll(Bool)

  }

  package init() {}

  fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.
/// NOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest
package struct Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity of the worker/client.
  package var identity: String = String()

  /// The activity to update. If match_all is set to true, all activities will be updated.
  package var activity: Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions.OneOf_Activity? = nil

  package var type: String {
    get {
      if case .type(let v)? = activity {return v}
      return String()
    }
    set {activity = .type(newValue)}
  }

  package var matchAll: Bool {
    get {
      if case .matchAll(let v)? = activity {return v}
      return false
    }
    set {activity = .matchAll(newValue)}
  }

  /// Update Activity options. Partial updates are accepted and controlled by update_mask.
  package var activityOptions: Temporal_Api_Activity_V1_ActivityOptions {
    get {return _activityOptions ?? Temporal_Api_Activity_V1_ActivityOptions()}
    set {_activityOptions = newValue}
  }
  /// Returns true if `activityOptions` has been explicitly set.
  package var hasActivityOptions: Bool {return self._activityOptions != nil}
  /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
  package mutating func clearActivityOptions() {self._activityOptions = nil}

  /// Controls which fields from `activity_options` will be applied
  package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
    get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  package var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateMask() {self._updateMask = nil}

  /// If set, the activity options will be restored to the default.
  /// Default options are then options activity was created with.
  /// They are part of the first ActivityTaskScheduled event.
  /// This flag cannot be combined with any other option; if you supply
  /// restore_original together with other options, the request will be rejected.
  package var restoreOriginal: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The activity to update. If match_all is set to true, all activities will be updated.
  package enum OneOf_Activity: Equatable, Sendable {
    case type(String)
    case matchAll(Bool)

  }

  package init() {}

  fileprivate var _activityOptions: Temporal_Api_Activity_V1_ActivityOptions? = nil
  fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.batch.v1"

extension Temporal_Api_Batch_V1_BatchOperationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}state\0\u{3}start_time\0\u{3}close_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationInfo, rhs: Temporal_Api_Batch_V1_BatchOperationInfo) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationTermination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationTermination"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationTermination, rhs: Temporal_Api_Batch_V1_BatchOperationTermination) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationSignal"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}signal\0\u{1}input\0\u{1}header\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signal.isEmpty {
      try visitor.visitSingularStringField(value: self.signal, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationSignal, rhs: Temporal_Api_Batch_V1_BatchOperationSignal) -> Bool {
    if lhs.signal != rhs.signal {return false}
    if lhs._input != rhs._input {return false}
    if lhs._header != rhs._header {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationCancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationCancellation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationCancellation, rhs: Temporal_Api_Batch_V1_BatchOperationCancellation) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationDeletion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationDeletion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationDeletion, rhs: Temporal_Api_Batch_V1_BatchOperationDeletion) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationReset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationReset"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reset_type\0\u{3}reset_reapply_type\0\u{1}identity\0\u{1}options\0\u{3}post_reset_operations\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.resetType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resetReapplyType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.postResetOperations) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.resetType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetType, fieldNumber: 1)
    }
    if self.resetReapplyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetReapplyType, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.postResetOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postResetOperations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationReset, rhs: Temporal_Api_Batch_V1_BatchOperationReset) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs._options != rhs._options {return false}
    if lhs.resetType != rhs.resetType {return false}
    if lhs.resetReapplyType != rhs.resetReapplyType {return false}
    if lhs.postResetOperations != rhs.postResetOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationUpdateWorkflowExecutionOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{3}workflow_execution_options\0\u{3}update_mask\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions, rhs: Temporal_Api_Batch_V1_BatchOperationUpdateWorkflowExecutionOptions) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationUnpauseActivities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationUnpauseActivities"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{1}jitter\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 4)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 5)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationUnpauseActivities, rhs: Temporal_Api_Batch_V1_BatchOperationUnpauseActivities) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationTriggerWorkflowRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationTriggerWorkflowRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}id\0\u{1}spec\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.rule != nil {try decoder.handleConflictingOneOf()}
          self.rule = .id(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Rules_V1_WorkflowRuleSpec?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .spec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .spec(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.rule {
    case .id?: try {
      guard case .id(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .spec?: try {
      guard case .spec(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationTriggerWorkflowRule, rhs: Temporal_Api_Batch_V1_BatchOperationTriggerWorkflowRule) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationResetActivities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationResetActivities"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{3}keep_paused\0\u{1}jitter\0\u{3}restore_original_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.keepPaused) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginalOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 4)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 5)
    }
    if self.keepPaused != false {
      try visitor.visitSingularBoolField(value: self.keepPaused, fieldNumber: 6)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.restoreOriginalOptions != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginalOptions, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationResetActivities, rhs: Temporal_Api_Batch_V1_BatchOperationResetActivities) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs.keepPaused != rhs.keepPaused {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.restoreOriginalOptions != rhs.restoreOriginalOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BatchOperationUpdateActivityOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}activity_options\0\u{3}update_mask\0\u{3}restore_original\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginal) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.restoreOriginal != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginal, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions, rhs: Temporal_Api_Batch_V1_BatchOperationUpdateActivityOptions) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.restoreOriginal != rhs.restoreOriginal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
