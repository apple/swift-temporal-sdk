// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/workflow_commands/workflow_commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package enum Coresdk_WorkflowCommands_ActivityCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Initiate a cancellation request and immediately report cancellation to the workflow.
  case tryCancel // = 0

  /// Wait for activity cancellation completion. Note that activity must heartbeat to receive a
  /// cancellation notification. This can block the cancellation for a long time if activity
  /// doesn't heartbeat or chooses to ignore the cancellation request.
  case waitCancellationCompleted // = 1

  /// Do not request cancellation of the activity and immediately report cancellation to the
  /// workflow
  case abandon // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .tryCancel
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .tryCancel
    case 1: self = .waitCancellationCompleted
    case 2: self = .abandon
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .tryCancel: return 0
    case .waitCancellationCompleted: return 1
    case .abandon: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Coresdk_WorkflowCommands_ActivityCancellationType] = [
    .tryCancel,
    .waitCancellationCompleted,
    .abandon,
  ]

}

package struct Coresdk_WorkflowCommands_WorkflowCommand: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// User metadata that may or may not be persisted into history depending on the command type.
  /// Lang layers are expected to expose the setting of the internals of this metadata on a
  /// per-command basis where applicable.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return self._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {self._userMetadata = nil}

  package var variant: Coresdk_WorkflowCommands_WorkflowCommand.OneOf_Variant? = nil

  package var startTimer: Coresdk_WorkflowCommands_StartTimer {
    get {
      if case .startTimer(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_StartTimer()
    }
    set {variant = .startTimer(newValue)}
  }

  package var scheduleActivity: Coresdk_WorkflowCommands_ScheduleActivity {
    get {
      if case .scheduleActivity(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_ScheduleActivity()
    }
    set {variant = .scheduleActivity(newValue)}
  }

  package var respondToQuery: Coresdk_WorkflowCommands_QueryResult {
    get {
      if case .respondToQuery(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_QueryResult()
    }
    set {variant = .respondToQuery(newValue)}
  }

  package var requestCancelActivity: Coresdk_WorkflowCommands_RequestCancelActivity {
    get {
      if case .requestCancelActivity(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_RequestCancelActivity()
    }
    set {variant = .requestCancelActivity(newValue)}
  }

  package var cancelTimer: Coresdk_WorkflowCommands_CancelTimer {
    get {
      if case .cancelTimer(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_CancelTimer()
    }
    set {variant = .cancelTimer(newValue)}
  }

  package var completeWorkflowExecution: Coresdk_WorkflowCommands_CompleteWorkflowExecution {
    get {
      if case .completeWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_CompleteWorkflowExecution()
    }
    set {variant = .completeWorkflowExecution(newValue)}
  }

  package var failWorkflowExecution: Coresdk_WorkflowCommands_FailWorkflowExecution {
    get {
      if case .failWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_FailWorkflowExecution()
    }
    set {variant = .failWorkflowExecution(newValue)}
  }

  package var continueAsNewWorkflowExecution: Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution {
    get {
      if case .continueAsNewWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution()
    }
    set {variant = .continueAsNewWorkflowExecution(newValue)}
  }

  package var cancelWorkflowExecution: Coresdk_WorkflowCommands_CancelWorkflowExecution {
    get {
      if case .cancelWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_CancelWorkflowExecution()
    }
    set {variant = .cancelWorkflowExecution(newValue)}
  }

  package var setPatchMarker: Coresdk_WorkflowCommands_SetPatchMarker {
    get {
      if case .setPatchMarker(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_SetPatchMarker()
    }
    set {variant = .setPatchMarker(newValue)}
  }

  package var startChildWorkflowExecution: Coresdk_WorkflowCommands_StartChildWorkflowExecution {
    get {
      if case .startChildWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_StartChildWorkflowExecution()
    }
    set {variant = .startChildWorkflowExecution(newValue)}
  }

  package var cancelChildWorkflowExecution: Coresdk_WorkflowCommands_CancelChildWorkflowExecution {
    get {
      if case .cancelChildWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_CancelChildWorkflowExecution()
    }
    set {variant = .cancelChildWorkflowExecution(newValue)}
  }

  package var requestCancelExternalWorkflowExecution: Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution {
    get {
      if case .requestCancelExternalWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution()
    }
    set {variant = .requestCancelExternalWorkflowExecution(newValue)}
  }

  package var signalExternalWorkflowExecution: Coresdk_WorkflowCommands_SignalExternalWorkflowExecution {
    get {
      if case .signalExternalWorkflowExecution(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_SignalExternalWorkflowExecution()
    }
    set {variant = .signalExternalWorkflowExecution(newValue)}
  }

  package var cancelSignalWorkflow: Coresdk_WorkflowCommands_CancelSignalWorkflow {
    get {
      if case .cancelSignalWorkflow(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_CancelSignalWorkflow()
    }
    set {variant = .cancelSignalWorkflow(newValue)}
  }

  package var scheduleLocalActivity: Coresdk_WorkflowCommands_ScheduleLocalActivity {
    get {
      if case .scheduleLocalActivity(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_ScheduleLocalActivity()
    }
    set {variant = .scheduleLocalActivity(newValue)}
  }

  package var requestCancelLocalActivity: Coresdk_WorkflowCommands_RequestCancelLocalActivity {
    get {
      if case .requestCancelLocalActivity(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_RequestCancelLocalActivity()
    }
    set {variant = .requestCancelLocalActivity(newValue)}
  }

  package var upsertWorkflowSearchAttributes: Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes {
    get {
      if case .upsertWorkflowSearchAttributes(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes()
    }
    set {variant = .upsertWorkflowSearchAttributes(newValue)}
  }

  package var modifyWorkflowProperties: Coresdk_WorkflowCommands_ModifyWorkflowProperties {
    get {
      if case .modifyWorkflowProperties(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_ModifyWorkflowProperties()
    }
    set {variant = .modifyWorkflowProperties(newValue)}
  }

  package var updateResponse: Coresdk_WorkflowCommands_UpdateResponse {
    get {
      if case .updateResponse(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_UpdateResponse()
    }
    set {variant = .updateResponse(newValue)}
  }

  package var scheduleNexusOperation: Coresdk_WorkflowCommands_ScheduleNexusOperation {
    get {
      if case .scheduleNexusOperation(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_ScheduleNexusOperation()
    }
    set {variant = .scheduleNexusOperation(newValue)}
  }

  package var requestCancelNexusOperation: Coresdk_WorkflowCommands_RequestCancelNexusOperation {
    get {
      if case .requestCancelNexusOperation(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_RequestCancelNexusOperation()
    }
    set {variant = .requestCancelNexusOperation(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    case startTimer(Coresdk_WorkflowCommands_StartTimer)
    case scheduleActivity(Coresdk_WorkflowCommands_ScheduleActivity)
    case respondToQuery(Coresdk_WorkflowCommands_QueryResult)
    case requestCancelActivity(Coresdk_WorkflowCommands_RequestCancelActivity)
    case cancelTimer(Coresdk_WorkflowCommands_CancelTimer)
    case completeWorkflowExecution(Coresdk_WorkflowCommands_CompleteWorkflowExecution)
    case failWorkflowExecution(Coresdk_WorkflowCommands_FailWorkflowExecution)
    case continueAsNewWorkflowExecution(Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution)
    case cancelWorkflowExecution(Coresdk_WorkflowCommands_CancelWorkflowExecution)
    case setPatchMarker(Coresdk_WorkflowCommands_SetPatchMarker)
    case startChildWorkflowExecution(Coresdk_WorkflowCommands_StartChildWorkflowExecution)
    case cancelChildWorkflowExecution(Coresdk_WorkflowCommands_CancelChildWorkflowExecution)
    case requestCancelExternalWorkflowExecution(Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution)
    case signalExternalWorkflowExecution(Coresdk_WorkflowCommands_SignalExternalWorkflowExecution)
    case cancelSignalWorkflow(Coresdk_WorkflowCommands_CancelSignalWorkflow)
    case scheduleLocalActivity(Coresdk_WorkflowCommands_ScheduleLocalActivity)
    case requestCancelLocalActivity(Coresdk_WorkflowCommands_RequestCancelLocalActivity)
    case upsertWorkflowSearchAttributes(Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes)
    case modifyWorkflowProperties(Coresdk_WorkflowCommands_ModifyWorkflowProperties)
    case updateResponse(Coresdk_WorkflowCommands_UpdateResponse)
    case scheduleNexusOperation(Coresdk_WorkflowCommands_ScheduleNexusOperation)
    case requestCancelNexusOperation(Coresdk_WorkflowCommands_RequestCancelNexusOperation)

  }

  package init() {}

  fileprivate var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
}

package struct Coresdk_WorkflowCommands_StartTimer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 = 0

  package var startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startToFireTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startToFireTimeout = newValue}
  }
  /// Returns true if `startToFireTimeout` has been explicitly set.
  package var hasStartToFireTimeout: Bool {return self._startToFireTimeout != nil}
  /// Clears the value of `startToFireTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToFireTimeout() {self._startToFireTimeout = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Coresdk_WorkflowCommands_CancelTimer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number as passed to `StartTimer`
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowCommands_ScheduleActivity: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  package var activityType: String {
    get {return _storage._activityType}
    set {_uniqueStorage()._activityType = newValue}
  }

  /// The name of the task queue to place this activity request in
  package var taskQueue: String {
    get {return _storage._taskQueue}
    set {_uniqueStorage()._taskQueue = newValue}
  }

  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  /// Arguments/input to the activity. Called "input" upstream.
  package var arguments: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
  /// retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
  /// When not specified defaults to the workflow execution timeout.
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Limits time an activity task can stay in a task queue before a worker picks it up. This
  /// timeout is always non retryable as all a retry would achieve is to put it back into the same
  /// queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
  package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToStartTimeout = newValue}
  }
  /// Returns true if `scheduleToStartTimeout` has been explicitly set.
  package var hasScheduleToStartTimeout: Bool {return _storage._scheduleToStartTimeout != nil}
  /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

  /// Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
  /// always retryable. Either this or schedule_to_close_timeout must be specified.
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// Maximum time allowed between successful worker heartbeats.
  package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._heartbeatTimeout = newValue}
  }
  /// Returns true if `heartbeatTimeout` has been explicitly set.
  package var hasHeartbeatTimeout: Bool {return _storage._heartbeatTimeout != nil}
  /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

  /// Activities are provided by a default retry policy controlled through the service dynamic
  /// configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
  /// retry_policy.maximum_attempts to 1.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
  package var cancellationType: Coresdk_WorkflowCommands_ActivityCancellationType {
    get {return _storage._cancellationType}
    set {_uniqueStorage()._cancellationType = newValue}
  }

  /// If set, the worker will not tell the service that it can immediately start executing this
  /// activity. When unset/default, workers will always attempt to do so if activity execution
  /// slots are available.
  package var doNotEagerlyExecute: Bool {
    get {return _storage._doNotEagerlyExecute}
    set {_uniqueStorage()._doNotEagerlyExecute = newValue}
  }

  /// Whether this activity should run on a worker with a compatible build id or not.
  package var versioningIntent: Coresdk_Common_VersioningIntent {
    get {return _storage._versioningIntent}
    set {_uniqueStorage()._versioningIntent = newValue}
  }

  /// The Priority to use for this activity
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Coresdk_WorkflowCommands_ScheduleLocalActivity: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  package var activityType: String {
    get {return _storage._activityType}
    set {_uniqueStorage()._activityType = newValue}
  }

  /// Local activities can start with a non-1 attempt, if lang has been told to backoff using
  /// a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
  /// resolution.
  package var attempt: UInt32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// If this local activity is a retry (as per the attempt field) this needs to be the original
  /// scheduling time (as provided in `DoBackoff`)
  package var originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._originalScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._originalScheduleTime = newValue}
  }
  /// Returns true if `originalScheduleTime` has been explicitly set.
  package var hasOriginalScheduleTime: Bool {return _storage._originalScheduleTime != nil}
  /// Clears the value of `originalScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearOriginalScheduleTime() {_uniqueStorage()._originalScheduleTime = nil}

  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  /// Arguments/input to the activity.
  package var arguments: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// Indicates how long the caller is willing to wait for local activity completion. Limits how
  /// long retries will be attempted. When not specified defaults to the workflow execution
  /// timeout (which may be unset).
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Limits time the local activity can idle internally before being executed. That can happen if
  /// the worker is currently at max concurrent local activity executions. This timeout is always
  /// non retryable as all a retry would achieve is to put it back into the same queue. Defaults
  /// to `schedule_to_close_timeout` if not specified and that is set. Must be <=
  /// `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
  package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToStartTimeout = newValue}
  }
  /// Returns true if `scheduleToStartTimeout` has been explicitly set.
  package var hasScheduleToStartTimeout: Bool {return _storage._scheduleToStartTimeout != nil}
  /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

  /// Maximum time the local activity is allowed to execute after the task is dispatched. This
  /// timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
  /// specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
  /// clamped down.
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// Specify a retry policy for the local activity. By default local activities will be retried
  /// indefinitely.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// If the activity is retrying and backoff would exceed this value, lang will be told to
  /// schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
  /// core. Defaults to 1 minute.
  package var localRetryThreshold: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._localRetryThreshold ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._localRetryThreshold = newValue}
  }
  /// Returns true if `localRetryThreshold` has been explicitly set.
  package var hasLocalRetryThreshold: Bool {return _storage._localRetryThreshold != nil}
  /// Clears the value of `localRetryThreshold`. Subsequent reads from it will return its default value.
  package mutating func clearLocalRetryThreshold() {_uniqueStorage()._localRetryThreshold = nil}

  /// Defines how the workflow will wait (or not) for cancellation of the activity to be
  /// confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
  /// will default to `TRY_CANCEL` automatically.
  package var cancellationType: Coresdk_WorkflowCommands_ActivityCancellationType {
    get {return _storage._cancellationType}
    set {_uniqueStorage()._cancellationType = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Coresdk_WorkflowCommands_RequestCancelActivity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number as passed to `ScheduleActivity`
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowCommands_RequestCancelLocalActivity: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number as passed to `ScheduleLocalActivity`
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowCommands_QueryResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Corresponds to the id provided in the activation job
  package var queryID: String = String()

  package var variant: Coresdk_WorkflowCommands_QueryResult.OneOf_Variant? = nil

  package var succeeded: Coresdk_WorkflowCommands_QuerySuccess {
    get {
      if case .succeeded(let v)? = variant {return v}
      return Coresdk_WorkflowCommands_QuerySuccess()
    }
    set {variant = .succeeded(newValue)}
  }

  package var failed: Temporal_Api_Failure_V1_Failure {
    get {
      if case .failed(let v)? = variant {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {variant = .failed(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    case succeeded(Coresdk_WorkflowCommands_QuerySuccess)
    case failed(Temporal_Api_Failure_V1_Failure)

  }

  package init() {}
}

package struct Coresdk_WorkflowCommands_QuerySuccess: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var response: Temporal_Api_Common_V1_Payload {
    get {return _response ?? Temporal_Api_Common_V1_Payload()}
    set {_response = newValue}
  }
  /// Returns true if `response` has been explicitly set.
  package var hasResponse: Bool {return self._response != nil}
  /// Clears the value of `response`. Subsequent reads from it will return its default value.
  package mutating func clearResponse() {self._response = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _response: Temporal_Api_Common_V1_Payload? = nil
}

/// Issued when the workflow completes successfully
package struct Coresdk_WorkflowCommands_CompleteWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var result: Temporal_Api_Common_V1_Payload {
    get {return _result ?? Temporal_Api_Common_V1_Payload()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payload? = nil
}

/// Issued when the workflow errors out
package struct Coresdk_WorkflowCommands_FailWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

/// Continue the workflow as a new execution
package struct Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifier the lang-specific sdk uses to execute workflow code
  package var workflowType: String {
    get {return _storage._workflowType}
    set {_uniqueStorage()._workflowType = newValue}
  }

  /// Task queue for the new workflow execution
  package var taskQueue: String {
    get {return _storage._taskQueue}
    set {_uniqueStorage()._taskQueue = newValue}
  }

  /// Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
  /// typically wouldn't make any sense.
  package var arguments: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._arguments}
    set {_uniqueStorage()._arguments = newValue}
  }

  /// Timeout for a single run of the new workflow. Will not re-use current workflow's value.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task. Will not re-use current workflow's value.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
  package var memo: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  /// If set, the new workflow will have these headers. Will *not* re-use current workflow's
  /// headers otherwise.
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  /// If set, the new workflow will have these search attributes. If unset, re-uses the current
  /// workflow's search attributes.
  package var searchAttributes: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._searchAttributes}
    set {_uniqueStorage()._searchAttributes = newValue}
  }

  /// If set, the new workflow will have this retry policy. If unset, re-uses the current
  /// workflow's retry policy.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Whether the continued workflow should run on a worker with a compatible build id or not.
  package var versioningIntent: Coresdk_Common_VersioningIntent {
    get {return _storage._versioningIntent}
    set {_uniqueStorage()._versioningIntent = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Indicate a workflow has completed as cancelled. Generally sent as a response to an activation
/// containing a cancellation job.
package struct Coresdk_WorkflowCommands_CancelWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// A request to set/check if a certain patch is present or not
package struct Coresdk_WorkflowCommands_SetPatchMarker: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A user-chosen identifier for this patch. If the same identifier is used in multiple places in
  /// the code, those places are considered to be versioned as one unit. IE: The check call will
  /// return the same result for all of them
  package var patchID: String = String()

  /// Can be set to true to indicate that branches using this change are being removed, and all
  /// future worker deployments will only have the "with change" code in them.
  package var deprecated: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Start a child workflow execution
package struct Coresdk_WorkflowCommands_StartChildWorkflowExecution: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 {
    get {return _storage._seq}
    set {_uniqueStorage()._seq = newValue}
  }

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: String {
    get {return _storage._workflowType}
    set {_uniqueStorage()._workflowType = newValue}
  }

  package var taskQueue: String {
    get {return _storage._taskQueue}
    set {_uniqueStorage()._taskQueue = newValue}
  }

  package var input: [Temporal_Api_Common_V1_Payload] {
    get {return _storage._input}
    set {_uniqueStorage()._input = newValue}
  }

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Default: PARENT_CLOSE_POLICY_TERMINATE.
  package var parentClosePolicy: Coresdk_ChildWorkflow_ParentClosePolicy {
    get {return _storage._parentClosePolicy}
    set {_uniqueStorage()._parentClosePolicy = newValue}
  }

  /// string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
  /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  /// Header fields
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._headers}
    set {_uniqueStorage()._headers = newValue}
  }

  /// Memo fields
  package var memo: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._memo}
    set {_uniqueStorage()._memo = newValue}
  }

  /// Search attributes
  package var searchAttributes: Dictionary<String,Temporal_Api_Common_V1_Payload> {
    get {return _storage._searchAttributes}
    set {_uniqueStorage()._searchAttributes = newValue}
  }

  /// Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
  package var cancellationType: Coresdk_ChildWorkflow_ChildWorkflowCancellationType {
    get {return _storage._cancellationType}
    set {_uniqueStorage()._cancellationType = newValue}
  }

  /// Whether this child should run on a worker with a compatible build id or not.
  package var versioningIntent: Coresdk_Common_VersioningIntent {
    get {return _storage._versioningIntent}
    set {_uniqueStorage()._versioningIntent = newValue}
  }

  /// The Priority to use for this activity
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Cancel a child workflow
package struct Coresdk_WorkflowCommands_CancelChildWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sequence number as given to the `StartChildWorkflowExecution` command
  package var childWorkflowSeq: UInt32 = 0

  /// A reason for the cancellation
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Request cancellation of an external workflow execution. For cancellation of a child workflow,
/// prefer `CancelChildWorkflowExecution` instead, as it guards against cancel-before-start issues.
package struct Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 = 0

  /// The workflow instance being targeted
  package var workflowExecution: Coresdk_Common_NamespacedWorkflowExecution {
    get {return _workflowExecution ?? Coresdk_Common_NamespacedWorkflowExecution()}
    set {_workflowExecution = newValue}
  }
  /// Returns true if `workflowExecution` has been explicitly set.
  package var hasWorkflowExecution: Bool {return self._workflowExecution != nil}
  /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

  /// A reason for the cancellation
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workflowExecution: Coresdk_Common_NamespacedWorkflowExecution? = nil
}

/// Send a signal to an external or child workflow
package struct Coresdk_WorkflowCommands_SignalExternalWorkflowExecution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 = 0

  /// What workflow is being targeted
  package var target: Coresdk_WorkflowCommands_SignalExternalWorkflowExecution.OneOf_Target? = nil

  /// A specific workflow instance
  package var workflowExecution: Coresdk_Common_NamespacedWorkflowExecution {
    get {
      if case .workflowExecution(let v)? = target {return v}
      return Coresdk_Common_NamespacedWorkflowExecution()
    }
    set {target = .workflowExecution(newValue)}
  }

  /// The desired target must be a child of the issuing workflow, and this is its workflow id
  package var childWorkflowID: String {
    get {
      if case .childWorkflowID(let v)? = target {return v}
      return String()
    }
    set {target = .childWorkflowID(newValue)}
  }

  /// Name of the signal handler
  package var signalName: String = String()

  /// Arguments for the handler
  package var args: [Temporal_Api_Common_V1_Payload] = []

  /// Headers to attach to the signal
  package var headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// What workflow is being targeted
  package enum OneOf_Target: Equatable, Sendable {
    /// A specific workflow instance
    case workflowExecution(Coresdk_Common_NamespacedWorkflowExecution)
    /// The desired target must be a child of the issuing workflow, and this is its workflow id
    case childWorkflowID(String)

  }

  package init() {}
}

/// Can be used to cancel not-already-sent `SignalExternalWorkflowExecution` commands
package struct Coresdk_WorkflowCommands_CancelSignalWorkflow: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
  /// value?
  package var searchAttributes: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Coresdk_WorkflowCommands_ModifyWorkflowProperties: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, update the workflow memo with the provided values. The values will be merged with
  /// the existing memo. If the user wants to delete values, a default/empty Payload should be
  /// used as the value for the key being deleted.
  package var upsertedMemo: Temporal_Api_Common_V1_Memo {
    get {return _upsertedMemo ?? Temporal_Api_Common_V1_Memo()}
    set {_upsertedMemo = newValue}
  }
  /// Returns true if `upsertedMemo` has been explicitly set.
  package var hasUpsertedMemo: Bool {return self._upsertedMemo != nil}
  /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
  package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _upsertedMemo: Temporal_Api_Common_V1_Memo? = nil
}

/// A reply to a `DoUpdate` job - lang must run the update's validator if told to, and then
/// immediately run the handler, if the update was accepted.
///
/// There must always be an accepted or rejected response immediately, in the same activation as
/// this job, to indicate the result of the validator. Accepted for ran and accepted or skipped, or
/// rejected for rejected.
///
/// Then, in the same or any subsequent activation, after the update handler has completed, respond
/// with completed or rejected as appropriate for the result of the handler.
package struct Coresdk_WorkflowCommands_UpdateResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The protocol message instance ID
  package var protocolInstanceID: String = String()

  package var response: Coresdk_WorkflowCommands_UpdateResponse.OneOf_Response? = nil

  /// Must be sent if the update's validator has passed (or lang was not asked to run it, and
  /// thus should be considered already-accepted, allowing lang to always send the same
  /// sequence on replay).
  package var accepted: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .accepted(let v)? = response {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {response = .accepted(newValue)}
  }

  /// Must be sent if the update's validator does not pass, or after acceptance if the update
  /// handler fails.
  package var rejected: Temporal_Api_Failure_V1_Failure {
    get {
      if case .rejected(let v)? = response {return v}
      return Temporal_Api_Failure_V1_Failure()
    }
    set {response = .rejected(newValue)}
  }

  /// Must be sent once the update handler completes successfully.
  package var completed: Temporal_Api_Common_V1_Payload {
    get {
      if case .completed(let v)? = response {return v}
      return Temporal_Api_Common_V1_Payload()
    }
    set {response = .completed(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Response: Equatable, Sendable {
    /// Must be sent if the update's validator has passed (or lang was not asked to run it, and
    /// thus should be considered already-accepted, allowing lang to always send the same
    /// sequence on replay).
    case accepted(SwiftProtobuf.Google_Protobuf_Empty)
    /// Must be sent if the update's validator does not pass, or after acceptance if the update
    /// handler fails.
    case rejected(Temporal_Api_Failure_V1_Failure)
    /// Must be sent once the update handler completes successfully.
    case completed(Temporal_Api_Common_V1_Payload)

  }

  package init() {}
}

/// A request to begin a Nexus operation
package struct Coresdk_WorkflowCommands_ScheduleNexusOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number, used as the operation identifier
  package var seq: UInt32 = 0

  /// Endpoint name, must exist in the endpoint registry or this command will fail.
  package var endpoint: String = String()

  /// Service name.
  package var service: String = String()

  /// Operation name.
  package var operation: String = String()

  /// Input for the operation. The server converts this into Nexus request content and the
  /// appropriate content headers internally when sending the StartOperation request. On the
  /// handler side, if it is also backed by Temporal, the content is transformed back to the
  /// original Payload sent in this command.
  package var input: Temporal_Api_Common_V1_Payload {
    get {return _input ?? Temporal_Api_Common_V1_Payload()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Schedule-to-close timeout for this operation.
  /// Indicates how long the caller is willing to wait for operation completion.
  /// Calls are retried internally by the server.
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return self._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {self._scheduleToCloseTimeout = nil}

  /// Header to attach to the Nexus request.
  /// Users are responsible for encrypting sensitive data in this header as it is stored in
  /// workflow history and transmitted to external services as-is. This is useful for propagating
  /// tracing information. Note these headers are not the same as Temporal headers on internal
  /// activities and child workflows, these are transmitted to Nexus operations that may be
  /// external and are not traditional payloads.
  package var nexusHeader: Dictionary<String,String> = [:]

  /// Defines behaviour of the underlying nexus operation when operation cancellation has been requested.
  package var cancellationType: Coresdk_Nexus_NexusOperationCancellationType = .waitCancellationCompleted

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _input: Temporal_Api_Common_V1_Payload? = nil
  fileprivate var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Request cancellation of a nexus operation started via `ScheduleNexusOperation`
package struct Coresdk_WorkflowCommands_RequestCancelNexusOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Lang's incremental sequence number as passed to `ScheduleNexusOperation`
  package var seq: UInt32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.workflow_commands"

extension Coresdk_WorkflowCommands_ActivityCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TRY_CANCEL\0\u{1}WAIT_CANCELLATION_COMPLETED\0\u{1}ABANDON\0")
}

extension Coresdk_WorkflowCommands_WorkflowCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowCommand"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_timer\0\u{3}schedule_activity\0\u{3}respond_to_query\0\u{3}request_cancel_activity\0\u{3}cancel_timer\0\u{3}complete_workflow_execution\0\u{3}fail_workflow_execution\0\u{3}continue_as_new_workflow_execution\0\u{3}cancel_workflow_execution\0\u{3}set_patch_marker\0\u{3}start_child_workflow_execution\0\u{3}cancel_child_workflow_execution\0\u{3}request_cancel_external_workflow_execution\0\u{3}signal_external_workflow_execution\0\u{3}cancel_signal_workflow\0\u{3}schedule_local_activity\0\u{3}request_cancel_local_activity\0\u{3}upsert_workflow_search_attributes\0\u{3}modify_workflow_properties\0\u{3}update_response\0\u{3}schedule_nexus_operation\0\u{3}request_cancel_nexus_operation\0\u{4}N\u{1}user_metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk_WorkflowCommands_StartTimer?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .startTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .startTimer(v)
        }
      }()
      case 2: try {
        var v: Coresdk_WorkflowCommands_ScheduleActivity?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .scheduleActivity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .scheduleActivity(v)
        }
      }()
      case 3: try {
        var v: Coresdk_WorkflowCommands_QueryResult?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .respondToQuery(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .respondToQuery(v)
        }
      }()
      case 4: try {
        var v: Coresdk_WorkflowCommands_RequestCancelActivity?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .requestCancelActivity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .requestCancelActivity(v)
        }
      }()
      case 5: try {
        var v: Coresdk_WorkflowCommands_CancelTimer?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelTimer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelTimer(v)
        }
      }()
      case 6: try {
        var v: Coresdk_WorkflowCommands_CompleteWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .completeWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .completeWorkflowExecution(v)
        }
      }()
      case 7: try {
        var v: Coresdk_WorkflowCommands_FailWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .failWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .failWorkflowExecution(v)
        }
      }()
      case 8: try {
        var v: Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .continueAsNewWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .continueAsNewWorkflowExecution(v)
        }
      }()
      case 9: try {
        var v: Coresdk_WorkflowCommands_CancelWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelWorkflowExecution(v)
        }
      }()
      case 10: try {
        var v: Coresdk_WorkflowCommands_SetPatchMarker?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .setPatchMarker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .setPatchMarker(v)
        }
      }()
      case 11: try {
        var v: Coresdk_WorkflowCommands_StartChildWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .startChildWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .startChildWorkflowExecution(v)
        }
      }()
      case 12: try {
        var v: Coresdk_WorkflowCommands_CancelChildWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelChildWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelChildWorkflowExecution(v)
        }
      }()
      case 13: try {
        var v: Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .requestCancelExternalWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .requestCancelExternalWorkflowExecution(v)
        }
      }()
      case 14: try {
        var v: Coresdk_WorkflowCommands_SignalExternalWorkflowExecution?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .signalExternalWorkflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .signalExternalWorkflowExecution(v)
        }
      }()
      case 15: try {
        var v: Coresdk_WorkflowCommands_CancelSignalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancelSignalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancelSignalWorkflow(v)
        }
      }()
      case 16: try {
        var v: Coresdk_WorkflowCommands_ScheduleLocalActivity?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .scheduleLocalActivity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .scheduleLocalActivity(v)
        }
      }()
      case 17: try {
        var v: Coresdk_WorkflowCommands_RequestCancelLocalActivity?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .requestCancelLocalActivity(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .requestCancelLocalActivity(v)
        }
      }()
      case 18: try {
        var v: Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .upsertWorkflowSearchAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .upsertWorkflowSearchAttributes(v)
        }
      }()
      case 19: try {
        var v: Coresdk_WorkflowCommands_ModifyWorkflowProperties?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .modifyWorkflowProperties(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .modifyWorkflowProperties(v)
        }
      }()
      case 20: try {
        var v: Coresdk_WorkflowCommands_UpdateResponse?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .updateResponse(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .updateResponse(v)
        }
      }()
      case 21: try {
        var v: Coresdk_WorkflowCommands_ScheduleNexusOperation?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .scheduleNexusOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .scheduleNexusOperation(v)
        }
      }()
      case 22: try {
        var v: Coresdk_WorkflowCommands_RequestCancelNexusOperation?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .requestCancelNexusOperation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .requestCancelNexusOperation(v)
        }
      }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._userMetadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .startTimer?: try {
      guard case .startTimer(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .scheduleActivity?: try {
      guard case .scheduleActivity(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .respondToQuery?: try {
      guard case .respondToQuery(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .requestCancelActivity?: try {
      guard case .requestCancelActivity(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .cancelTimer?: try {
      guard case .cancelTimer(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .completeWorkflowExecution?: try {
      guard case .completeWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .failWorkflowExecution?: try {
      guard case .failWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .continueAsNewWorkflowExecution?: try {
      guard case .continueAsNewWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .cancelWorkflowExecution?: try {
      guard case .cancelWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .setPatchMarker?: try {
      guard case .setPatchMarker(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .startChildWorkflowExecution?: try {
      guard case .startChildWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .cancelChildWorkflowExecution?: try {
      guard case .cancelChildWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .requestCancelExternalWorkflowExecution?: try {
      guard case .requestCancelExternalWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .signalExternalWorkflowExecution?: try {
      guard case .signalExternalWorkflowExecution(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .cancelSignalWorkflow?: try {
      guard case .cancelSignalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .scheduleLocalActivity?: try {
      guard case .scheduleLocalActivity(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .requestCancelLocalActivity?: try {
      guard case .requestCancelLocalActivity(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .upsertWorkflowSearchAttributes?: try {
      guard case .upsertWorkflowSearchAttributes(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .modifyWorkflowProperties?: try {
      guard case .modifyWorkflowProperties(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case .updateResponse?: try {
      guard case .updateResponse(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    }()
    case .scheduleNexusOperation?: try {
      guard case .scheduleNexusOperation(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    }()
    case .requestCancelNexusOperation?: try {
      guard case .requestCancelNexusOperation(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
    }()
    case nil: break
    }
    try { if let v = self._userMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_WorkflowCommand, rhs: Coresdk_WorkflowCommands_WorkflowCommand) -> Bool {
    if lhs._userMetadata != rhs._userMetadata {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_StartTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartTimer"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}start_to_fire_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToFireTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._startToFireTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_StartTimer, rhs: Coresdk_WorkflowCommands_StartTimer) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._startToFireTimeout != rhs._startToFireTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_CancelTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelTimer"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_CancelTimer, rhs: Coresdk_WorkflowCommands_CancelTimer) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_ScheduleActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}activity_id\0\u{3}activity_type\0\u{4}\u{2}task_queue\0\u{1}headers\0\u{1}arguments\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}cancellation_type\0\u{3}do_not_eagerly_execute\0\u{3}versioning_intent\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _activityID: String = String()
    var _activityType: String = String()
    var _taskQueue: String = String()
    var _headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _arguments: [Temporal_Api_Common_V1_Payload] = []
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cancellationType: Coresdk_WorkflowCommands_ActivityCancellationType = .tryCancel
    var _doNotEagerlyExecute: Bool = false
    var _versioningIntent: Coresdk_Common_VersioningIntent = .unspecified
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _headers = source._headers
      _arguments = source._arguments
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _cancellationType = source._cancellationType
      _doNotEagerlyExecute = source._doNotEagerlyExecute
      _versioningIntent = source._versioningIntent
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headers) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._doNotEagerlyExecute) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 2)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 3)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 5)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headers, fieldNumber: 6)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 7)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._cancellationType != .tryCancel {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 13)
      }
      if _storage._doNotEagerlyExecute != false {
        try visitor.visitSingularBoolField(value: _storage._doNotEagerlyExecute, fieldNumber: 14)
      }
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 15)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_ScheduleActivity, rhs: Coresdk_WorkflowCommands_ScheduleActivity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        if _storage._doNotEagerlyExecute != rhs_storage._doNotEagerlyExecute {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_ScheduleLocalActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleLocalActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}activity_id\0\u{3}activity_type\0\u{1}attempt\0\u{3}original_schedule_time\0\u{1}headers\0\u{1}arguments\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}retry_policy\0\u{3}local_retry_threshold\0\u{3}cancellation_type\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _activityID: String = String()
    var _activityType: String = String()
    var _attempt: UInt32 = 0
    var _originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _arguments: [Temporal_Api_Common_V1_Payload] = []
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _localRetryThreshold: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _cancellationType: Coresdk_WorkflowCommands_ActivityCancellationType = .tryCancel

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _activityID = source._activityID
      _activityType = source._activityType
      _attempt = source._attempt
      _originalScheduleTime = source._originalScheduleTime
      _headers = source._headers
      _arguments = source._arguments
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _retryPolicy = source._retryPolicy
      _localRetryThreshold = source._localRetryThreshold
      _cancellationType = source._cancellationType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._attempt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._originalScheduleTime) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headers) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._localRetryThreshold) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 2)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 3)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._attempt, fieldNumber: 4)
      }
      try { if let v = _storage._originalScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headers, fieldNumber: 6)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 7)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._localRetryThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._cancellationType != .tryCancel {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_ScheduleLocalActivity, rhs: Coresdk_WorkflowCommands_ScheduleLocalActivity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._originalScheduleTime != rhs_storage._originalScheduleTime {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._localRetryThreshold != rhs_storage._localRetryThreshold {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_RequestCancelActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_RequestCancelActivity, rhs: Coresdk_WorkflowCommands_RequestCancelActivity) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_RequestCancelLocalActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelLocalActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_RequestCancelLocalActivity, rhs: Coresdk_WorkflowCommands_RequestCancelLocalActivity) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QueryResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}query_id\0\u{1}succeeded\0\u{1}failed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.queryID) }()
      case 2: try {
        var v: Coresdk_WorkflowCommands_QuerySuccess?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .succeeded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .succeeded(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .failed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.queryID.isEmpty {
      try visitor.visitSingularStringField(value: self.queryID, fieldNumber: 1)
    }
    switch self.variant {
    case .succeeded?: try {
      guard case .succeeded(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_QueryResult, rhs: Coresdk_WorkflowCommands_QueryResult) -> Bool {
    if lhs.queryID != rhs.queryID {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_QuerySuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QuerySuccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}response\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_QuerySuccess, rhs: Coresdk_WorkflowCommands_QuerySuccess) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_CompleteWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompleteWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_CompleteWorkflowExecution, rhs: Coresdk_WorkflowCommands_CompleteWorkflowExecution) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_FailWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_FailWorkflowExecution, rhs: Coresdk_WorkflowCommands_FailWorkflowExecution) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ContinueAsNewWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}arguments\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}memo\0\u{1}headers\0\u{3}search_attributes\0\u{3}retry_policy\0\u{3}versioning_intent\0")

  fileprivate class _StorageClass {
    var _workflowType: String = String()
    var _taskQueue: String = String()
    var _arguments: [Temporal_Api_Common_V1_Payload] = []
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _memo: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _searchAttributes: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _versioningIntent: Coresdk_Common_VersioningIntent = .unspecified

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _arguments = source._arguments
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _memo = source._memo
      _headers = source._headers
      _searchAttributes = source._searchAttributes
      _retryPolicy = source._retryPolicy
      _versioningIntent = source._versioningIntent
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._memo) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headers) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._searchAttributes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 1)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 2)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 3)
      }
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._memo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._memo, fieldNumber: 6)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headers, fieldNumber: 7)
      }
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._searchAttributes, fieldNumber: 8)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution, rhs: Coresdk_WorkflowCommands_ContinueAsNewWorkflowExecution) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_CancelWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_CancelWorkflowExecution, rhs: Coresdk_WorkflowCommands_CancelWorkflowExecution) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_SetPatchMarker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetPatchMarker"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}patch_id\0\u{1}deprecated\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.patchID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deprecated) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchID.isEmpty {
      try visitor.visitSingularStringField(value: self.patchID, fieldNumber: 1)
    }
    if self.deprecated != false {
      try visitor.visitSingularBoolField(value: self.deprecated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_SetPatchMarker, rhs: Coresdk_WorkflowCommands_SetPatchMarker) -> Bool {
    if lhs.patchID != rhs.patchID {return false}
    if lhs.deprecated != rhs.deprecated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_StartChildWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}parent_close_policy\0\u{4}\u{2}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}headers\0\u{1}memo\0\u{3}search_attributes\0\u{3}cancellation_type\0\u{3}versioning_intent\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: String = String()
    var _taskQueue: String = String()
    var _input: [Temporal_Api_Common_V1_Payload] = []
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parentClosePolicy: Coresdk_ChildWorkflow_ParentClosePolicy = .unspecified
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _headers: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _memo: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _searchAttributes: Dictionary<String,Temporal_Api_Common_V1_Payload> = [:]
    var _cancellationType: Coresdk_ChildWorkflow_ChildWorkflowCancellationType = .abandon
    var _versioningIntent: Coresdk_Common_VersioningIntent = .unspecified
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _parentClosePolicy = source._parentClosePolicy
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _headers = source._headers
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _cancellationType = source._cancellationType
      _versioningIntent = source._versioningIntent
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._parentClosePolicy) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._headers) }()
        case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._memo) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &_storage._searchAttributes) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 2)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 3)
      }
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 4)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 5)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._input, fieldNumber: 6)
      }
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._parentClosePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._parentClosePolicy, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 12)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 14)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._headers, fieldNumber: 15)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._memo, fieldNumber: 16)
      }
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: _storage._searchAttributes, fieldNumber: 17)
      }
      if _storage._cancellationType != .abandon {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 18)
      }
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 19)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_StartChildWorkflowExecution, rhs: Coresdk_WorkflowCommands_StartChildWorkflowExecution) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._parentClosePolicy != rhs_storage._parentClosePolicy {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_CancelChildWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelChildWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}child_workflow_seq\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.childWorkflowSeq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.childWorkflowSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.childWorkflowSeq, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_CancelChildWorkflowExecution, rhs: Coresdk_WorkflowCommands_CancelChildWorkflowExecution) -> Bool {
    if lhs.childWorkflowSeq != rhs.childWorkflowSeq {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}workflow_execution\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution, rhs: Coresdk_WorkflowCommands_RequestCancelExternalWorkflowExecution) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_SignalExternalWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}workflow_execution\0\u{3}child_workflow_id\0\u{3}signal_name\0\u{1}args\0\u{1}headers\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try {
        var v: Coresdk_Common_NamespacedWorkflowExecution?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .workflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .workflowExecution(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .childWorkflowID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    switch self.target {
    case .workflowExecution?: try {
      guard case .workflowExecution(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .childWorkflowID?: try {
      guard case .childWorkflowID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 4)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 5)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.headers, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_SignalExternalWorkflowExecution, rhs: Coresdk_WorkflowCommands_SignalExternalWorkflowExecution) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.target != rhs.target {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs.args != rhs.args {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_CancelSignalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelSignalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_CancelSignalWorkflow, rhs: Coresdk_WorkflowCommands_CancelSignalWorkflow) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpsertWorkflowSearchAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: &self.searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payload>.self, value: self.searchAttributes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes, rhs: Coresdk_WorkflowCommands_UpsertWorkflowSearchAttributes) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_ModifyWorkflowProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ModifyWorkflowProperties"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_ModifyWorkflowProperties, rhs: Coresdk_WorkflowCommands_ModifyWorkflowProperties) -> Bool {
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_UpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_instance_id\0\u{1}accepted\0\u{1}rejected\0\u{1}completed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolInstanceID) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .accepted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .accepted(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Failure_V1_Failure?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .rejected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .rejected(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Common_V1_Payload?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .completed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.protocolInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolInstanceID, fieldNumber: 1)
    }
    switch self.response {
    case .accepted?: try {
      guard case .accepted(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rejected?: try {
      guard case .rejected(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .completed?: try {
      guard case .completed(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_UpdateResponse, rhs: Coresdk_WorkflowCommands_UpdateResponse) -> Bool {
    if lhs.protocolInstanceID != rhs.protocolInstanceID {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_ScheduleNexusOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleNexusOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}nexus_header\0\u{3}cancellation_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._scheduleToCloseTimeout) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.nexusHeader) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cancellationType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 3)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 4)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scheduleToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nexusHeader.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.nexusHeader, fieldNumber: 7)
    }
    if self.cancellationType != .waitCancellationCompleted {
      try visitor.visitSingularEnumField(value: self.cancellationType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_ScheduleNexusOperation, rhs: Coresdk_WorkflowCommands_ScheduleNexusOperation) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._scheduleToCloseTimeout != rhs._scheduleToCloseTimeout {return false}
    if lhs.nexusHeader != rhs.nexusHeader {return false}
    if lhs.cancellationType != rhs.cancellationType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_WorkflowCommands_RequestCancelNexusOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelNexusOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_WorkflowCommands_RequestCancelNexusOperation, rhs: Coresdk_WorkflowCommands_RequestCancelNexusOperation) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
