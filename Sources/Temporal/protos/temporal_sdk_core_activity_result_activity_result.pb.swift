// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/activity_result/activity_result.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Used to report activity completions to core
package struct Coresdk_ActivityResult_ActivityExecutionResult: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var status: Coresdk_ActivityResult_ActivityExecutionResult.OneOf_Status? = nil

  package var completed: Coresdk_ActivityResult_Success {
    get {
      if case .completed(let v)? = status {return v}
      return Coresdk_ActivityResult_Success()
    }
    set {status = .completed(newValue)}
  }

  package var failed: Coresdk_ActivityResult_Failure {
    get {
      if case .failed(let v)? = status {return v}
      return Coresdk_ActivityResult_Failure()
    }
    set {status = .failed(newValue)}
  }

  package var cancelled: Coresdk_ActivityResult_Cancellation {
    get {
      if case .cancelled(let v)? = status {return v}
      return Coresdk_ActivityResult_Cancellation()
    }
    set {status = .cancelled(newValue)}
  }

  package var willCompleteAsync: Coresdk_ActivityResult_WillCompleteAsync {
    get {
      if case .willCompleteAsync(let v)? = status {return v}
      return Coresdk_ActivityResult_WillCompleteAsync()
    }
    set {status = .willCompleteAsync(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    case completed(Coresdk_ActivityResult_Success)
    case failed(Coresdk_ActivityResult_Failure)
    case cancelled(Coresdk_ActivityResult_Cancellation)
    case willCompleteAsync(Coresdk_ActivityResult_WillCompleteAsync)

  }

  package init() {}
}

/// Used to report activity resolutions to lang. IE: This is what the activities are resolved with
/// in the workflow.
package struct Coresdk_ActivityResult_ActivityResolution: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var status: Coresdk_ActivityResult_ActivityResolution.OneOf_Status? = nil

  package var completed: Coresdk_ActivityResult_Success {
    get {
      if case .completed(let v)? = status {return v}
      return Coresdk_ActivityResult_Success()
    }
    set {status = .completed(newValue)}
  }

  package var failed: Coresdk_ActivityResult_Failure {
    get {
      if case .failed(let v)? = status {return v}
      return Coresdk_ActivityResult_Failure()
    }
    set {status = .failed(newValue)}
  }

  package var cancelled: Coresdk_ActivityResult_Cancellation {
    get {
      if case .cancelled(let v)? = status {return v}
      return Coresdk_ActivityResult_Cancellation()
    }
    set {status = .cancelled(newValue)}
  }

  package var backoff: Coresdk_ActivityResult_DoBackoff {
    get {
      if case .backoff(let v)? = status {return v}
      return Coresdk_ActivityResult_DoBackoff()
    }
    set {status = .backoff(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Status: Equatable, Sendable {
    case completed(Coresdk_ActivityResult_Success)
    case failed(Coresdk_ActivityResult_Failure)
    case cancelled(Coresdk_ActivityResult_Cancellation)
    case backoff(Coresdk_ActivityResult_DoBackoff)

  }

  package init() {}
}

/// Used to report successful completion either when executing or resolving
package struct Coresdk_ActivityResult_Success: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var result: Temporal_Api_Common_V1_Payload {
    get {return _result ?? Temporal_Api_Common_V1_Payload()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payload? = nil
}

/// Used to report activity failure either when executing or resolving
package struct Coresdk_ActivityResult_Failure: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

///
/// Used to report cancellation from both Core and Lang.
/// When Lang reports a cancelled activity, it must put a CancelledFailure in the failure field.
/// When Core reports a cancelled activity, it must put an ActivityFailure with CancelledFailure
/// as the cause in the failure field.
package struct Coresdk_ActivityResult_Cancellation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

///
/// Used in ActivityExecutionResult to notify Core that this Activity will complete asynchronously.
/// Core will forget about this Activity and free up resources used to track this Activity.
package struct Coresdk_ActivityResult_WillCompleteAsync: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

///
/// Issued when a local activity needs to retry but also wants to back off more than would be
/// reasonable to WFT heartbeat for. Lang is expected to schedule a timer for the duration
/// and then start a local activity of the same type & same inputs with the provided attempt number
/// after the timer has elapsed.
///
/// This exists because Core does not have a concept of starting commands by itself, they originate
/// from lang. So expecting lang to start the timer / next pass of the activity fits more smoothly.
package struct Coresdk_ActivityResult_DoBackoff: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The attempt number that lang should provide when scheduling the retry. If the LA failed
  /// on attempt 4 and we told lang to back off with a timer, this number will be 5.
  package var attempt: UInt32 = 0

  package var backoffDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _backoffDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_backoffDuration = newValue}
  }
  /// Returns true if `backoffDuration` has been explicitly set.
  package var hasBackoffDuration: Bool {return self._backoffDuration != nil}
  /// Clears the value of `backoffDuration`. Subsequent reads from it will return its default value.
  package mutating func clearBackoffDuration() {self._backoffDuration = nil}

  /// The time the first attempt of this local activity was scheduled. Must be passed with attempt
  /// to the retry LA.
  package var originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _originalScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_originalScheduleTime = newValue}
  }
  /// Returns true if `originalScheduleTime` has been explicitly set.
  package var hasOriginalScheduleTime: Bool {return self._originalScheduleTime != nil}
  /// Clears the value of `originalScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearOriginalScheduleTime() {self._originalScheduleTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _backoffDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.activity_result"

extension Coresdk_ActivityResult_ActivityExecutionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityExecutionResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{3}will_complete_async\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk_ActivityResult_Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk_ActivityResult_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk_ActivityResult_Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Coresdk_ActivityResult_WillCompleteAsync?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .willCompleteAsync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .willCompleteAsync(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .willCompleteAsync?: try {
      guard case .willCompleteAsync(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_ActivityExecutionResult, rhs: Coresdk_ActivityResult_ActivityExecutionResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_ActivityResolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityResolution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{1}backoff\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk_ActivityResult_Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk_ActivityResult_Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk_ActivityResult_Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Coresdk_ActivityResult_DoBackoff?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .backoff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .backoff(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .backoff?: try {
      guard case .backoff(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_ActivityResolution, rhs: Coresdk_ActivityResult_ActivityResolution) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Success"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_Success, rhs: Coresdk_ActivityResult_Success) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Failure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_Failure, rhs: Coresdk_ActivityResult_Failure) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_Cancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancellation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_Cancellation, rhs: Coresdk_ActivityResult_Cancellation) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_WillCompleteAsync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WillCompleteAsync"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_WillCompleteAsync, rhs: Coresdk_ActivityResult_WillCompleteAsync) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk_ActivityResult_DoBackoff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DoBackoff"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attempt\0\u{3}backoff_duration\0\u{3}original_schedule_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.attempt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._backoffDuration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originalScheduleTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.attempt != 0 {
      try visitor.visitSingularUInt32Field(value: self.attempt, fieldNumber: 1)
    }
    try { if let v = self._backoffDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk_ActivityResult_DoBackoff, rhs: Coresdk_ActivityResult_DoBackoff) -> Bool {
    if lhs.attempt != rhs.attempt {return false}
    if lhs._backoffDuration != rhs._backoffDuration {return false}
    if lhs._originalScheduleTime != rhs._originalScheduleTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
