// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/workflow/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Hold basic information about a workflow execution.
/// This structure is a part of visibility, and thus contain a limited subset of information.
package struct Temporal_Api_Workflow_V1_WorkflowExecutionInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return _storage._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {_uniqueStorage()._execution = nil}

  package var type: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._type ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  package var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  package mutating func clearType() {_uniqueStorage()._type = nil}

  package var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._startTime = newValue}
  }
  /// Returns true if `startTime` has been explicitly set.
  package var hasStartTime: Bool {return _storage._startTime != nil}
  /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

  package var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._closeTime = newValue}
  }
  /// Returns true if `closeTime` has been explicitly set.
  package var hasCloseTime: Bool {return _storage._closeTime != nil}
  /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
  package mutating func clearCloseTime() {_uniqueStorage()._closeTime = nil}

  package var status: Temporal_Api_Enums_V1_WorkflowExecutionStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  package var historyLength: Int64 {
    get {return _storage._historyLength}
    set {_uniqueStorage()._historyLength = newValue}
  }

  package var parentNamespaceID: String {
    get {return _storage._parentNamespaceID}
    set {_uniqueStorage()._parentNamespaceID = newValue}
  }

  package var parentExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._parentExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._parentExecution = newValue}
  }
  /// Returns true if `parentExecution` has been explicitly set.
  package var hasParentExecution: Bool {return _storage._parentExecution != nil}
  /// Clears the value of `parentExecution`. Subsequent reads from it will return its default value.
  package mutating func clearParentExecution() {_uniqueStorage()._parentExecution = nil}

  package var executionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._executionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._executionTime = newValue}
  }
  /// Returns true if `executionTime` has been explicitly set.
  package var hasExecutionTime: Bool {return _storage._executionTime != nil}
  /// Clears the value of `executionTime`. Subsequent reads from it will return its default value.
  package mutating func clearExecutionTime() {_uniqueStorage()._executionTime = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  package var autoResetPoints: Temporal_Api_Workflow_V1_ResetPoints {
    get {return _storage._autoResetPoints ?? Temporal_Api_Workflow_V1_ResetPoints()}
    set {_uniqueStorage()._autoResetPoints = newValue}
  }
  /// Returns true if `autoResetPoints` has been explicitly set.
  package var hasAutoResetPoints: Bool {return _storage._autoResetPoints != nil}
  /// Clears the value of `autoResetPoints`. Subsequent reads from it will return its default value.
  package mutating func clearAutoResetPoints() {_uniqueStorage()._autoResetPoints = nil}

  package var taskQueue: String {
    get {return _storage._taskQueue}
    set {_uniqueStorage()._taskQueue = newValue}
  }

  package var stateTransitionCount: Int64 {
    get {return _storage._stateTransitionCount}
    set {_uniqueStorage()._stateTransitionCount = newValue}
  }

  package var historySizeBytes: Int64 {
    get {return _storage._historySizeBytes}
    set {_uniqueStorage()._historySizeBytes = newValue}
  }

  /// If set, the most recent worker version stamp that appeared in a workflow task completion
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var mostRecentWorkerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _storage._mostRecentWorkerVersionStamp ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_uniqueStorage()._mostRecentWorkerVersionStamp = newValue}
  }
  /// Returns true if `mostRecentWorkerVersionStamp` has been explicitly set.
  package var hasMostRecentWorkerVersionStamp: Bool {return _storage._mostRecentWorkerVersionStamp != nil}
  /// Clears the value of `mostRecentWorkerVersionStamp`. Subsequent reads from it will return its default value.
  package mutating func clearMostRecentWorkerVersionStamp() {_uniqueStorage()._mostRecentWorkerVersionStamp = nil}

  /// Workflow execution duration is defined as difference between close time and execution time.
  /// This field is only populated if the workflow is closed.
  package var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._executionDuration = newValue}
  }
  /// Returns true if `executionDuration` has been explicitly set.
  package var hasExecutionDuration: Bool {return _storage._executionDuration != nil}
  /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
  package mutating func clearExecutionDuration() {_uniqueStorage()._executionDuration = nil}

  /// Contains information about the root workflow execution.
  /// The root workflow execution is defined as follows:
  /// 1. A workflow without parent workflow is its own root workflow.
  /// 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
  /// Note: workflows continued as new or reseted may or may not have parents, check examples below.
  ///
  /// Examples:
  ///   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
  ///     - The root workflow of all three workflows is W1.
  ///   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
  ///     - The root workflow of all three workflows is W1.
  ///   Scenario 3: Workflow W1 continued as new W2.
  ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  ///   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
  ///     - The root workflow of all three workflows is W1.
  ///   Scenario 5: Workflow W1 is reseted, creating W2.
  ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
  package var rootExecution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _storage._rootExecution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_uniqueStorage()._rootExecution = newValue}
  }
  /// Returns true if `rootExecution` has been explicitly set.
  package var hasRootExecution: Bool {return _storage._rootExecution != nil}
  /// Clears the value of `rootExecution`. Subsequent reads from it will return its default value.
  package mutating func clearRootExecution() {_uniqueStorage()._rootExecution = nil}

  /// The currently assigned build ID for this execution. Presence of this value means worker versioning is used
  /// for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
  /// when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
  /// again, the assigned build ID may change according to the latest versioning rules.
  /// Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
  /// this execution.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var assignedBuildID: String {
    get {return _storage._assignedBuildID}
    set {_uniqueStorage()._assignedBuildID = newValue}
  }

  /// Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
  /// of using the assignment rules.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritedBuildID: String {
    get {return _storage._inheritedBuildID}
    set {_uniqueStorage()._inheritedBuildID = newValue}
  }

  /// The first run ID in the execution chain.
  /// Executions created via the following operations are considered to be in the same chain
  /// - ContinueAsNew
  /// - Workflow Retry
  /// - Workflow Reset
  /// - Cron Schedule
  package var firstRunID: String {
    get {return _storage._firstRunID}
    set {_uniqueStorage()._firstRunID = newValue}
  }

  /// Absent value means the workflow execution is not versioned. When present, the execution might
  /// be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
  /// Experimental. Versioning info is experimental and might change in the future.
  package var versioningInfo: Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo {
    get {return _storage._versioningInfo ?? Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo()}
    set {_uniqueStorage()._versioningInfo = newValue}
  }
  /// Returns true if `versioningInfo` has been explicitly set.
  package var hasVersioningInfo: Bool {return _storage._versioningInfo != nil}
  /// Clears the value of `versioningInfo`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningInfo() {_uniqueStorage()._versioningInfo = nil}

  /// The name of Worker Deployment that completed the most recent workflow task.
  /// Experimental. Worker Deployments are experimental and might change in the future.
  package var workerDeploymentName: String {
    get {return _storage._workerDeploymentName}
    set {_uniqueStorage()._workerDeploymentName = newValue}
  }

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Holds all the extra information about workflow execution that is not part of Visibility.
package struct Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Workflow execution expiration time is defined as workflow start time plus expiration timeout.
  /// Workflow start time may change after workflow reset.
  package var executionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _executionExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_executionExpirationTime = newValue}
  }
  /// Returns true if `executionExpirationTime` has been explicitly set.
  package var hasExecutionExpirationTime: Bool {return self._executionExpirationTime != nil}
  /// Clears the value of `executionExpirationTime`. Subsequent reads from it will return its default value.
  package mutating func clearExecutionExpirationTime() {self._executionExpirationTime = nil}

  /// Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
  package var runExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _runExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_runExpirationTime = newValue}
  }
  /// Returns true if `runExpirationTime` has been explicitly set.
  package var hasRunExpirationTime: Bool {return self._runExpirationTime != nil}
  /// Clears the value of `runExpirationTime`. Subsequent reads from it will return its default value.
  package mutating func clearRunExpirationTime() {self._runExpirationTime = nil}

  /// indicates if the workflow received a cancel request
  package var cancelRequested: Bool = false

  /// Last workflow reset time. Nil if the workflow was never reset.
  package var lastResetTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastResetTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastResetTime = newValue}
  }
  /// Returns true if `lastResetTime` has been explicitly set.
  package var hasLastResetTime: Bool {return self._lastResetTime != nil}
  /// Clears the value of `lastResetTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastResetTime() {self._lastResetTime = nil}

  /// Original workflow start time.
  package var originalStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _originalStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_originalStartTime = newValue}
  }
  /// Returns true if `originalStartTime` has been explicitly set.
  package var hasOriginalStartTime: Bool {return self._originalStartTime != nil}
  /// Clears the value of `originalStartTime`. Subsequent reads from it will return its default value.
  package mutating func clearOriginalStartTime() {self._originalStartTime = nil}

  /// Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
  package var resetRunID: String = String()

  /// Request ID information (eg: history event information associated with the request ID).
  /// Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
  /// calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
  /// used in the StartWorkflowExecution request).
  package var requestIDInfos: Dictionary<String,Temporal_Api_Workflow_V1_RequestIdInfo> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _executionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _runExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastResetTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _originalStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Holds all the information about worker versioning for a particular workflow execution.
/// Experimental. Versioning info is experimental and might change in the future.
package struct Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Versioning behavior determines how the server should treat this execution when workers are
  /// upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
  /// unversioned. See the comments in `VersioningBehavior` enum for more info about different
  /// behaviors.
  /// This field is first set after an execution completes its first workflow task on a versioned
  /// worker, and set again on completion of every subsequent workflow task.
  /// For child workflows of Pinned parents, this will be set to Pinned (along with `deployment_version`) when
  /// the the child starts so that child's first workflow task goes to the same Version as the
  /// parent. After the first workflow task, it depends on the child workflow itself if it wants
  /// to stay pinned or become unpinned (according to Versioning Behavior set in the worker).
  /// Note that `behavior` is overridden by `versioning_override` if the latter is present.
  package var behavior: Temporal_Api_Enums_V1_VersioningBehavior {
    get {return _storage._behavior}
    set {_uniqueStorage()._behavior = newValue}
  }

  /// The worker deployment that completed the last workflow task of this workflow execution. Must
  /// be present if `behavior` is set. Absent value means no workflow task is completed, or the
  /// last workflow task was completed by an unversioned worker. Unversioned workers may still send
  /// a deployment value which will be stored here, so the right way to check if an execution is
  /// versioned if an execution is versioned or not is via the `behavior` field.
  /// Note that `deployment` is overridden by `versioning_override` if the latter is present.
  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _storage._deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_uniqueStorage()._deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return _storage._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// The Worker Deployment Version that completed the last workflow task of this workflow execution.
  /// An absent value means no workflow task is completed, or the workflow is unversioned.
  /// If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
  /// by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
  ///
  /// For child workflows of Pinned parents, this will be set to the parent's Pinned Version when
  /// the child starts, so that the child's first workflow task goes to the same Version as the parent.
  /// Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
  /// will override this value.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return _storage._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

  /// Present if user has set an execution-specific versioning override. This override takes
  /// precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
  /// override can be set when starting a new execution, as well as afterwards by calling the
  /// `UpdateWorkflowExecutionOptions` API.
  /// Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
  /// workflow retries, and cron workflows.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _storage._versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_uniqueStorage()._versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return _storage._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

  /// When present, indicates the workflow is transitioning to a different deployment. Can
  /// indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
  /// on a different deployment, or versioned -> unversioned.
  /// Not applicable to workflows with PINNED behavior.
  /// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
  /// start a transition to the task queue's current deployment if the task queue's current
  /// deployment is different from the workflow's deployment.
  /// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
  /// tasks will be redirected to the task queue's current deployment. As soon as a poller from
  /// that deployment is available to receive the task, the workflow will automatically start a
  /// transition to that deployment and continue execution there.
  /// A deployment transition can only exist while there is a pending or started workflow task.
  /// Once the pending workflow task completes on the transition's target deployment, the
  /// transition completes and the workflow's `deployment` and `behavior` fields are updated per
  /// the worker's task completion response.
  /// Pending activities will not start new attempts during a transition. Once the transition is
  /// completed, pending activities will start their next attempt on the new deployment.
  /// Deprecated. Use version_transition.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deploymentTransition: Temporal_Api_Workflow_V1_DeploymentTransition {
    get {return _storage._deploymentTransition ?? Temporal_Api_Workflow_V1_DeploymentTransition()}
    set {_uniqueStorage()._deploymentTransition = newValue}
  }
  /// Returns true if `deploymentTransition` has been explicitly set.
  package var hasDeploymentTransition: Bool {return _storage._deploymentTransition != nil}
  /// Clears the value of `deploymentTransition`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentTransition() {_uniqueStorage()._deploymentTransition = nil}

  /// When present, indicates the workflow is transitioning to a different deployment version
  /// (which may belong to the same deployment name or another). Can indicate one of the following
  /// transitions: unversioned -> versioned, versioned -> versioned
  /// on a different deployment version, or versioned -> unversioned.
  /// Not applicable to workflows with PINNED behavior.
  /// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
  /// start a transition to the task queue's current version if the task queue's current version is
  /// different from the workflow's current deployment version.
  /// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
  /// tasks will be redirected to the task queue's current version. As soon as a poller from
  /// that deployment version is available to receive the task, the workflow will automatically
  /// start a transition to that version and continue execution there.
  /// A version transition can only exist while there is a pending or started workflow task.
  /// Once the pending workflow task completes on the transition's target version, the
  /// transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
  /// worker's task completion response.
  /// Pending activities will not start new attempts during a transition. Once the transition is
  /// completed, pending activities will start their next attempt on the new version.
  package var versionTransition: Temporal_Api_Workflow_V1_DeploymentVersionTransition {
    get {return _storage._versionTransition ?? Temporal_Api_Workflow_V1_DeploymentVersionTransition()}
    set {_uniqueStorage()._versionTransition = newValue}
  }
  /// Returns true if `versionTransition` has been explicitly set.
  package var hasVersionTransition: Bool {return _storage._versionTransition != nil}
  /// Clears the value of `versionTransition`. Subsequent reads from it will return its default value.
  package mutating func clearVersionTransition() {_uniqueStorage()._versionTransition = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// Holds information about ongoing transition of a workflow execution from one deployment to another.
/// Deprecated. Use DeploymentVersionTransition.
package struct Temporal_Api_Workflow_V1_DeploymentTransition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The target deployment of the transition. Null means a so-far-versioned workflow is
  /// transitioning to unversioned workers.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
}

/// Holds information about ongoing transition of a workflow execution from one worker
/// deployment version to another.
/// Experimental. Might change in the future.
package struct Temporal_Api_Workflow_V1_DeploymentVersionTransition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Deprecated. Use `deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var version: String = String()

  /// The target Version of the transition.
  /// If nil, a so-far-versioned workflow is transitioning to unversioned workers.
  package var deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _deploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_deploymentVersion = newValue}
  }
  /// Returns true if `deploymentVersion` has been explicitly set.
  package var hasDeploymentVersion: Bool {return self._deploymentVersion != nil}
  /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
}

package struct Temporal_Api_Workflow_V1_WorkflowExecutionConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return self._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {self._taskQueue = nil}

  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return self._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {self._workflowExecutionTimeout = nil}

  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return self._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {self._workflowRunTimeout = nil}

  package var defaultWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _defaultWorkflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_defaultWorkflowTaskTimeout = newValue}
  }
  /// Returns true if `defaultWorkflowTaskTimeout` has been explicitly set.
  package var hasDefaultWorkflowTaskTimeout: Bool {return self._defaultWorkflowTaskTimeout != nil}
  /// Clears the value of `defaultWorkflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearDefaultWorkflowTaskTimeout() {self._defaultWorkflowTaskTimeout = nil}

  /// User metadata provided on start workflow.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return self._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {self._userMetadata = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _defaultWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
}

package struct Temporal_Api_Workflow_V1_PendingActivityInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  package var activityType: Temporal_Api_Common_V1_ActivityType {
    get {return _storage._activityType ?? Temporal_Api_Common_V1_ActivityType()}
    set {_uniqueStorage()._activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  package var hasActivityType: Bool {return _storage._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  package mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

  package var state: Temporal_Api_Enums_V1_PendingActivityState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  package var heartbeatDetails: Temporal_Api_Common_V1_Payloads {
    get {return _storage._heartbeatDetails ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._heartbeatDetails = newValue}
  }
  /// Returns true if `heartbeatDetails` has been explicitly set.
  package var hasHeartbeatDetails: Bool {return _storage._heartbeatDetails != nil}
  /// Clears the value of `heartbeatDetails`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatDetails() {_uniqueStorage()._heartbeatDetails = nil}

  package var lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastHeartbeatTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastHeartbeatTime = newValue}
  }
  /// Returns true if `lastHeartbeatTime` has been explicitly set.
  package var hasLastHeartbeatTime: Bool {return _storage._lastHeartbeatTime != nil}
  /// Clears the value of `lastHeartbeatTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastHeartbeatTime() {_uniqueStorage()._lastHeartbeatTime = nil}

  package var lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastStartedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastStartedTime = newValue}
  }
  /// Returns true if `lastStartedTime` has been explicitly set.
  package var hasLastStartedTime: Bool {return _storage._lastStartedTime != nil}
  /// Clears the value of `lastStartedTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastStartedTime() {_uniqueStorage()._lastStartedTime = nil}

  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  package var maximumAttempts: Int32 {
    get {return _storage._maximumAttempts}
    set {_uniqueStorage()._maximumAttempts = newValue}
  }

  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return _storage._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

  package var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expirationTime = newValue}
  }
  /// Returns true if `expirationTime` has been explicitly set.
  package var hasExpirationTime: Bool {return _storage._expirationTime != nil}
  /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
  package mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

  package var lastFailure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._lastFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._lastFailure = newValue}
  }
  /// Returns true if `lastFailure` has been explicitly set.
  package var hasLastFailure: Bool {return _storage._lastFailure != nil}
  /// Clears the value of `lastFailure`. Subsequent reads from it will return its default value.
  package mutating func clearLastFailure() {_uniqueStorage()._lastFailure = nil}

  package var lastWorkerIdentity: String {
    get {return _storage._lastWorkerIdentity}
    set {_uniqueStorage()._lastWorkerIdentity = newValue}
  }

  /// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
  /// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
  /// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  package var assignedBuildID: OneOf_AssignedBuildID? {
    get {return _storage._assignedBuildID}
    set {_uniqueStorage()._assignedBuildID = newValue}
  }

  /// Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var useWorkflowBuildID: SwiftProtobuf.Google_Protobuf_Empty {
    get {
      if case .useWorkflowBuildID(let v)? = _storage._assignedBuildID {return v}
      return SwiftProtobuf.Google_Protobuf_Empty()
    }
    set {_uniqueStorage()._assignedBuildID = .useWorkflowBuildID(newValue)}
  }

  /// Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
  /// The activity will use the build id in this field instead.
  /// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
  /// rules.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var lastIndependentlyAssignedBuildID: String {
    get {
      if case .lastIndependentlyAssignedBuildID(let v)? = _storage._assignedBuildID {return v}
      return String()
    }
    set {_uniqueStorage()._assignedBuildID = .lastIndependentlyAssignedBuildID(newValue)}
  }

  /// Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
  /// This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var lastWorkerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp {
    get {return _storage._lastWorkerVersionStamp ?? Temporal_Api_Common_V1_WorkerVersionStamp()}
    set {_uniqueStorage()._lastWorkerVersionStamp = newValue}
  }
  /// Returns true if `lastWorkerVersionStamp` has been explicitly set.
  package var hasLastWorkerVersionStamp: Bool {return _storage._lastWorkerVersionStamp != nil}
  /// Clears the value of `lastWorkerVersionStamp`. Subsequent reads from it will return its default value.
  package mutating func clearLastWorkerVersionStamp() {_uniqueStorage()._lastWorkerVersionStamp = nil}

  /// The time activity will wait until the next retry.
  /// If activity is currently running it will be next retry interval if activity failed.
  /// If activity is currently waiting it will be current retry interval.
  /// If there will be no retry it will be null.
  package var currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._currentRetryInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._currentRetryInterval = newValue}
  }
  /// Returns true if `currentRetryInterval` has been explicitly set.
  package var hasCurrentRetryInterval: Bool {return _storage._currentRetryInterval != nil}
  /// Clears the value of `currentRetryInterval`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentRetryInterval() {_uniqueStorage()._currentRetryInterval = nil}

  /// The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
  package var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastAttemptCompleteTime = newValue}
  }
  /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
  package var hasLastAttemptCompleteTime: Bool {return _storage._lastAttemptCompleteTime != nil}
  /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptCompleteTime() {_uniqueStorage()._lastAttemptCompleteTime = nil}

  /// Next time when activity will be scheduled.
  /// If activity is currently scheduled or started it will be null.
  package var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._nextAttemptScheduleTime = newValue}
  }
  /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
  package var hasNextAttemptScheduleTime: Bool {return _storage._nextAttemptScheduleTime != nil}
  /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearNextAttemptScheduleTime() {_uniqueStorage()._nextAttemptScheduleTime = nil}

  /// Indicates if activity is paused.
  package var paused: Bool {
    get {return _storage._paused}
    set {_uniqueStorage()._paused = newValue}
  }

  /// The deployment this activity was dispatched to most recently. Present only if the activity
  /// was dispatched to a versioned worker.
  /// Deprecated. Use `last_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var lastDeployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _storage._lastDeployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_uniqueStorage()._lastDeployment = newValue}
  }
  /// Returns true if `lastDeployment` has been explicitly set.
  package var hasLastDeployment: Bool {return _storage._lastDeployment != nil}
  /// Clears the value of `lastDeployment`. Subsequent reads from it will return its default value.
  package mutating func clearLastDeployment() {_uniqueStorage()._lastDeployment = nil}

  /// The Worker Deployment Version this activity was dispatched to most recently.
  /// Deprecated. Use `last_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var lastWorkerDeploymentVersion: String {
    get {return _storage._lastWorkerDeploymentVersion}
    set {_uniqueStorage()._lastWorkerDeploymentVersion = newValue}
  }

  /// The Worker Deployment Version this activity was dispatched to most recently.
  /// If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
  package var lastDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _storage._lastDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_uniqueStorage()._lastDeploymentVersion = newValue}
  }
  /// Returns true if `lastDeploymentVersion` has been explicitly set.
  package var hasLastDeploymentVersion: Bool {return _storage._lastDeploymentVersion != nil}
  /// Clears the value of `lastDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearLastDeploymentVersion() {_uniqueStorage()._lastDeploymentVersion = nil}

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var pauseInfo: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo {
    get {return _storage._pauseInfo ?? Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo()}
    set {_uniqueStorage()._pauseInfo = newValue}
  }
  /// Returns true if `pauseInfo` has been explicitly set.
  package var hasPauseInfo: Bool {return _storage._pauseInfo != nil}
  /// Clears the value of `pauseInfo`. Subsequent reads from it will return its default value.
  package mutating func clearPauseInfo() {_uniqueStorage()._pauseInfo = nil}

  /// Current activity options. May be different from the one used to start the activity.
  package var activityOptions: Temporal_Api_Activity_V1_ActivityOptions {
    get {return _storage._activityOptions ?? Temporal_Api_Activity_V1_ActivityOptions()}
    set {_uniqueStorage()._activityOptions = newValue}
  }
  /// Returns true if `activityOptions` has been explicitly set.
  package var hasActivityOptions: Bool {return _storage._activityOptions != nil}
  /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
  package mutating func clearActivityOptions() {_uniqueStorage()._activityOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
  /// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
  /// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
  /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
  package enum OneOf_AssignedBuildID: Equatable, Sendable {
    /// Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case useWorkflowBuildID(SwiftProtobuf.Google_Protobuf_Empty)
    /// Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
    /// The activity will use the build id in this field instead.
    /// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
    /// rules.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    case lastIndependentlyAssignedBuildID(String)

  }

  package struct PauseInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The time when the activity was paused.
    package var pauseTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {return _pauseTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_pauseTime = newValue}
    }
    /// Returns true if `pauseTime` has been explicitly set.
    package var hasPauseTime: Bool {return self._pauseTime != nil}
    /// Clears the value of `pauseTime`. Subsequent reads from it will return its default value.
    package mutating func clearPauseTime() {self._pauseTime = nil}

    package var pausedBy: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.OneOf_PausedBy? = nil

    /// activity was paused by the manual intervention
    package var manual: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual {
      get {
        if case .manual(let v)? = pausedBy {return v}
        return Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual()
      }
      set {pausedBy = .manual(newValue)}
    }

    /// activity was paused by the rule
    package var rule: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule {
      get {
        if case .rule(let v)? = pausedBy {return v}
        return Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule()
      }
      set {pausedBy = .rule(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_PausedBy: Equatable, Sendable {
      /// activity was paused by the manual intervention
      case manual(Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual)
      /// activity was paused by the rule
      case rule(Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule)

    }

    package struct Manual: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The identity of the actor that paused the activity.
      package var identity: String = String()

      /// Reason for pausing the activity.
      package var reason: String = String()

      package var unknownFields = SwiftProtobuf.UnknownStorage()

      package init() {}
    }

    package struct Rule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The rule that paused the activity.
      package var ruleID: String = String()

      /// The identity of the actor that created the rule.
      package var identity: String = String()

      /// Reason why rule was created. Populated from rule description.
      package var reason: String = String()

      package var unknownFields = SwiftProtobuf.UnknownStorage()

      package init() {}
    }

    package init() {}

    fileprivate var _pauseTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Workflow_V1_PendingChildExecutionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workflowID: String = String()

  package var runID: String = String()

  package var workflowTypeName: String = String()

  package var initiatedID: Int64 = 0

  /// Default: PARENT_CLOSE_POLICY_TERMINATE.
  package var parentClosePolicy: Temporal_Api_Enums_V1_ParentClosePolicy = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var state: Temporal_Api_Enums_V1_PendingWorkflowTaskState = .unspecified

  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return self._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {self._scheduledTime = nil}

  /// original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
  /// Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
  /// In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
  /// some threshold, the workflow task will be forced timeout.
  package var originalScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _originalScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_originalScheduledTime = newValue}
  }
  /// Returns true if `originalScheduledTime` has been explicitly set.
  package var hasOriginalScheduledTime: Bool {return self._originalScheduledTime != nil}
  /// Clears the value of `originalScheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearOriginalScheduledTime() {self._originalScheduledTime = nil}

  package var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_startedTime = newValue}
  }
  /// Returns true if `startedTime` has been explicitly set.
  package var hasStartedTime: Bool {return self._startedTime != nil}
  /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
  package mutating func clearStartedTime() {self._startedTime = nil}

  package var attempt: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _originalScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Workflow_V1_ResetPoints: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var points: [Temporal_Api_Workflow_V1_ResetPointInfo] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// ResetPointInfo records the workflow event id that is the first one processed by a given
/// build id or binary checksum. A new reset point will be created if either build id or binary
/// checksum changes (although in general only one or the other will be used at a time).
package struct Temporal_Api_Workflow_V1_ResetPointInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Worker build id.
  package var buildID: String = String()

  /// Deprecated. A worker binary version identifier.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var binaryChecksum: String = String()

  /// The first run ID in the execution chain that was touched by this worker build.
  package var runID: String = String()

  /// Event ID of the first WorkflowTaskCompleted event processed by this worker build.
  package var firstWorkflowTaskCompletedID: Int64 = 0

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  /// (-- api-linter: core::0214::resource-expiry=disabled
  ///     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
  /// The time that the run is deleted due to retention.
  package var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_expireTime = newValue}
  }
  /// Returns true if `expireTime` has been explicitly set.
  package var hasExpireTime: Bool {return self._expireTime != nil}
  /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
  package mutating func clearExpireTime() {self._expireTime = nil}

  /// false if the reset point has pending childWFs/reqCancels/signalExternals.
  package var resettable: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// NewWorkflowExecutionInfo is a shared message that encapsulates all the
/// required arguments to starting a workflow in different contexts.
package struct Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  /// Serialized arguments to the workflow.
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  /// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
  /// for use by user interfaces to display the fixed as-of-start summary and details of the
  /// workflow.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _storage._userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_uniqueStorage()._userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return _storage._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

  /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
  /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _storage._versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_uniqueStorage()._versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return _storage._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

  /// Priority metadata
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// CallbackInfo contains the state of an attached workflow callback.
package struct Temporal_Api_Workflow_V1_CallbackInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Information on how this callback should be invoked (e.g. its URL and type).
  package var callback: Temporal_Api_Common_V1_Callback {
    get {return _callback ?? Temporal_Api_Common_V1_Callback()}
    set {_callback = newValue}
  }
  /// Returns true if `callback` has been explicitly set.
  package var hasCallback: Bool {return self._callback != nil}
  /// Clears the value of `callback`. Subsequent reads from it will return its default value.
  package mutating func clearCallback() {self._callback = nil}

  /// Trigger for this callback.
  package var trigger: Temporal_Api_Workflow_V1_CallbackInfo.Trigger {
    get {return _trigger ?? Temporal_Api_Workflow_V1_CallbackInfo.Trigger()}
    set {_trigger = newValue}
  }
  /// Returns true if `trigger` has been explicitly set.
  package var hasTrigger: Bool {return self._trigger != nil}
  /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
  package mutating func clearTrigger() {self._trigger = nil}

  /// The time when the callback was registered.
  package var registrationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _registrationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_registrationTime = newValue}
  }
  /// Returns true if `registrationTime` has been explicitly set.
  package var hasRegistrationTime: Bool {return self._registrationTime != nil}
  /// Clears the value of `registrationTime`. Subsequent reads from it will return its default value.
  package mutating func clearRegistrationTime() {self._registrationTime = nil}

  package var state: Temporal_Api_Enums_V1_CallbackState = .unspecified

  /// The number of attempts made to deliver the callback.
  /// This number represents a minimum bound since the attempt is incremented after the callback request completes.
  package var attempt: Int32 = 0

  /// The time when the last attempt completed.
  package var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastAttemptCompleteTime = newValue}
  }
  /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
  package var hasLastAttemptCompleteTime: Bool {return self._lastAttemptCompleteTime != nil}
  /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptCompleteTime() {self._lastAttemptCompleteTime = nil}

  /// The last attempt's failure, if any.
  package var lastAttemptFailure: Temporal_Api_Failure_V1_Failure {
    get {return _lastAttemptFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_lastAttemptFailure = newValue}
  }
  /// Returns true if `lastAttemptFailure` has been explicitly set.
  package var hasLastAttemptFailure: Bool {return self._lastAttemptFailure != nil}
  /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptFailure() {self._lastAttemptFailure = nil}

  /// The time when the next attempt is scheduled.
  package var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAttemptScheduleTime = newValue}
  }
  /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
  package var hasNextAttemptScheduleTime: Bool {return self._nextAttemptScheduleTime != nil}
  /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearNextAttemptScheduleTime() {self._nextAttemptScheduleTime = nil}

  /// If the state is BLOCKED, blocked reason provides additional information.
  package var blockedReason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Trigger for when the workflow is closed.
  package struct WorkflowClosed: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }

  package struct Trigger: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var variant: Temporal_Api_Workflow_V1_CallbackInfo.Trigger.OneOf_Variant? = nil

    package var workflowClosed: Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed {
      get {
        if case .workflowClosed(let v)? = variant {return v}
        return Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed()
      }
      set {variant = .workflowClosed(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Variant: Equatable, Sendable {
      case workflowClosed(Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed)

    }

    package init() {}
  }

  package init() {}

  fileprivate var _callback: Temporal_Api_Common_V1_Callback? = nil
  fileprivate var _trigger: Temporal_Api_Workflow_V1_CallbackInfo.Trigger? = nil
  fileprivate var _registrationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastAttemptFailure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// PendingNexusOperationInfo contains the state of a pending Nexus operation.
package struct Temporal_Api_Workflow_V1_PendingNexusOperationInfo: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint name.
  /// Resolved to a URL via the cluster's endpoint registry.
  package var endpoint: String {
    get {return _storage._endpoint}
    set {_uniqueStorage()._endpoint = newValue}
  }

  /// Service name.
  package var service: String {
    get {return _storage._service}
    set {_uniqueStorage()._service = newValue}
  }

  /// Operation name.
  package var operation: String {
    get {return _storage._operation}
    set {_uniqueStorage()._operation = newValue}
  }

  /// Operation ID. Only set for asynchronous operations after a successful StartOperation call.
  ///
  /// Deprecated. Renamed to operation_token.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var operationID: String {
    get {return _storage._operationID}
    set {_uniqueStorage()._operationID = newValue}
  }

  /// Schedule-to-close timeout for this operation.
  /// This is the only timeout settable by a workflow.
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// The time when the operation was scheduled.
  package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._scheduledTime = newValue}
  }
  /// Returns true if `scheduledTime` has been explicitly set.
  package var hasScheduledTime: Bool {return _storage._scheduledTime != nil}
  /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
  package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

  package var state: Temporal_Api_Enums_V1_PendingNexusOperationState {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  /// The number of attempts made to deliver the start operation request.
  /// This number represents a minimum bound since the attempt is incremented after the request completes.
  package var attempt: Int32 {
    get {return _storage._attempt}
    set {_uniqueStorage()._attempt = newValue}
  }

  /// The time when the last attempt completed.
  package var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._lastAttemptCompleteTime = newValue}
  }
  /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
  package var hasLastAttemptCompleteTime: Bool {return _storage._lastAttemptCompleteTime != nil}
  /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptCompleteTime() {_uniqueStorage()._lastAttemptCompleteTime = nil}

  /// The last attempt's failure, if any.
  package var lastAttemptFailure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._lastAttemptFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._lastAttemptFailure = newValue}
  }
  /// Returns true if `lastAttemptFailure` has been explicitly set.
  package var hasLastAttemptFailure: Bool {return _storage._lastAttemptFailure != nil}
  /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptFailure() {_uniqueStorage()._lastAttemptFailure = nil}

  /// The time when the next attempt is scheduled.
  package var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._nextAttemptScheduleTime = newValue}
  }
  /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
  package var hasNextAttemptScheduleTime: Bool {return _storage._nextAttemptScheduleTime != nil}
  /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearNextAttemptScheduleTime() {_uniqueStorage()._nextAttemptScheduleTime = nil}

  package var cancellationInfo: Temporal_Api_Workflow_V1_NexusOperationCancellationInfo {
    get {return _storage._cancellationInfo ?? Temporal_Api_Workflow_V1_NexusOperationCancellationInfo()}
    set {_uniqueStorage()._cancellationInfo = newValue}
  }
  /// Returns true if `cancellationInfo` has been explicitly set.
  package var hasCancellationInfo: Bool {return _storage._cancellationInfo != nil}
  /// Clears the value of `cancellationInfo`. Subsequent reads from it will return its default value.
  package mutating func clearCancellationInfo() {_uniqueStorage()._cancellationInfo = nil}

  /// The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
  /// DescribeWorkflowExecution response with workflow history.
  package var scheduledEventID: Int64 {
    get {return _storage._scheduledEventID}
    set {_uniqueStorage()._scheduledEventID = newValue}
  }

  /// If the state is BLOCKED, blocked reason provides additional information.
  package var blockedReason: String {
    get {return _storage._blockedReason}
    set {_uniqueStorage()._blockedReason = newValue}
  }

  /// Operation token. Only set for asynchronous operations after a successful StartOperation call.
  package var operationToken: String {
    get {return _storage._operationToken}
    set {_uniqueStorage()._operationToken = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
package struct Temporal_Api_Workflow_V1_NexusOperationCancellationInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The time when cancellation was requested.
  package var requestedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _requestedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_requestedTime = newValue}
  }
  /// Returns true if `requestedTime` has been explicitly set.
  package var hasRequestedTime: Bool {return self._requestedTime != nil}
  /// Clears the value of `requestedTime`. Subsequent reads from it will return its default value.
  package mutating func clearRequestedTime() {self._requestedTime = nil}

  package var state: Temporal_Api_Enums_V1_NexusOperationCancellationState = .unspecified

  /// The number of attempts made to deliver the cancel operation request.
  /// This number represents a minimum bound since the attempt is incremented after the request completes.
  package var attempt: Int32 = 0

  /// The time when the last attempt completed.
  package var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastAttemptCompleteTime = newValue}
  }
  /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
  package var hasLastAttemptCompleteTime: Bool {return self._lastAttemptCompleteTime != nil}
  /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptCompleteTime() {self._lastAttemptCompleteTime = nil}

  /// The last attempt's failure, if any.
  package var lastAttemptFailure: Temporal_Api_Failure_V1_Failure {
    get {return _lastAttemptFailure ?? Temporal_Api_Failure_V1_Failure()}
    set {_lastAttemptFailure = newValue}
  }
  /// Returns true if `lastAttemptFailure` has been explicitly set.
  package var hasLastAttemptFailure: Bool {return self._lastAttemptFailure != nil}
  /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
  package mutating func clearLastAttemptFailure() {self._lastAttemptFailure = nil}

  /// The time when the next attempt is scheduled.
  package var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_nextAttemptScheduleTime = newValue}
  }
  /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
  package var hasNextAttemptScheduleTime: Bool {return self._nextAttemptScheduleTime != nil}
  /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
  package mutating func clearNextAttemptScheduleTime() {self._nextAttemptScheduleTime = nil}

  /// If the state is BLOCKED, blocked reason provides additional information.
  package var blockedReason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _requestedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastAttemptFailure: Temporal_Api_Failure_V1_Failure? = nil
  fileprivate var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Workflow_V1_WorkflowExecutionOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
  package var versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride {
    get {return _versioningOverride ?? Temporal_Api_Workflow_V1_VersioningOverride()}
    set {_versioningOverride = newValue}
  }
  /// Returns true if `versioningOverride` has been explicitly set.
  package var hasVersioningOverride: Bool {return self._versioningOverride != nil}
  /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
  package mutating func clearVersioningOverride() {self._versioningOverride = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
}

/// Used to override the versioning behavior (and pinned deployment version, if applicable) of a
/// specific workflow execution. If set, takes precedence over the worker-sent values. See
/// `WorkflowExecutionInfo.VersioningInfo` for more information. To remove the override, call
/// `UpdateWorkflowExecutionOptions` with a null `VersioningOverride`, and use the `update_mask`
/// to indicate that it should be mutated.
/// Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
/// workflow retries, and cron workflows.
package struct Temporal_Api_Workflow_V1_VersioningOverride: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether to override the workflow to be AutoUpgrade or Pinned.
  package var override: Temporal_Api_Workflow_V1_VersioningOverride.OneOf_Override? = nil

  /// Send the next workflow task to the Version specified in the override.
  package var pinned: Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride {
    get {
      if case .pinned(let v)? = override {return v}
      return Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride()
    }
    set {override = .pinned(newValue)}
  }

  /// Send the next workflow task to the Current Deployment Version
  /// of its Task Queue when the next workflow task is dispatched.
  package var autoUpgrade: Bool {
    get {
      if case .autoUpgrade(let v)? = override {return v}
      return false
    }
    set {override = .autoUpgrade(newValue)}
  }

  /// Required.
  /// Deprecated. Use `override`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var behavior: Temporal_Api_Enums_V1_VersioningBehavior = .unspecified

  /// Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
  /// Identifies the worker deployment to pin the workflow to.
  /// Deprecated. Use `override.pinned.version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var deployment: Temporal_Api_Deployment_V1_Deployment {
    get {return _deployment ?? Temporal_Api_Deployment_V1_Deployment()}
    set {_deployment = newValue}
  }
  /// Returns true if `deployment` has been explicitly set.
  package var hasDeployment: Bool {return self._deployment != nil}
  /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
  package mutating func clearDeployment() {self._deployment = nil}

  /// Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
  /// Identifies the worker deployment version to pin the workflow to, in the format
  /// "<deployment_name>.<build_id>".
  /// Deprecated. Use `override.pinned.version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var pinnedVersion: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Indicates whether to override the workflow to be AutoUpgrade or Pinned.
  package enum OneOf_Override: Equatable, Sendable {
    /// Send the next workflow task to the Version specified in the override.
    case pinned(Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride)
    /// Send the next workflow task to the Current Deployment Version
    /// of its Task Queue when the next workflow task is dispatched.
    case autoUpgrade(Bool)

  }

  /// Used to specify different sub-types of Pinned override that we plan to add in the future.
  package enum PinnedOverrideBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Unspecified.
    case unspecified // = 0

    /// Override workflow behavior to be Pinned.
    case pinned // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pinned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pinned: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverrideBehavior] = [
      .unspecified,
      .pinned,
    ]

  }

  package struct PinnedOverride: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
    /// See `PinnedOverrideBehavior` for details.
    package var behavior: Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverrideBehavior = .unspecified

    /// Required.
    package var version: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
      get {return _version ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
      set {_version = newValue}
    }
    /// Returns true if `version` has been explicitly set.
    package var hasVersion: Bool {return self._version != nil}
    /// Clears the value of `version`. Subsequent reads from it will return its default value.
    package mutating func clearVersion() {self._version = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _version: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
  }

  package init() {}

  fileprivate var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
}

/// When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
/// there is already an existing running workflow, OnConflictOptions defines actions to be taken on
/// the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
/// history event in the running workflow with the changes requested in this object.
package struct Temporal_Api_Workflow_V1_OnConflictOptions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Attaches the request ID to the running workflow.
  package var attachRequestID: Bool = false

  /// Attaches the completion callbacks to the running workflow.
  package var attachCompletionCallbacks: Bool = false

  /// Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
  package var attachLinks: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// RequestIdInfo contains details of a request ID.
package struct Temporal_Api_Workflow_V1_RequestIdInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The event type of the history event generated by the request.
  package var eventType: Temporal_Api_Enums_V1_EventType = .unspecified

  /// The event id of the history event generated by the request. It's possible the event ID is not
  /// known (unflushed buffered event). In this case, the value will be zero or a negative value,
  /// representing an invalid ID.
  package var eventID: Int64 = 0

  /// Indicate if the request is still buffered. If so, the event ID is not known and its value
  /// will be an invalid event ID.
  package var buffered: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
package struct Temporal_Api_Workflow_V1_PostResetOperation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var variant: Temporal_Api_Workflow_V1_PostResetOperation.OneOf_Variant? = nil

  package var signalWorkflow: Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow {
    get {
      if case .signalWorkflow(let v)? = variant {return v}
      return Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow()
    }
    set {variant = .signalWorkflow(newValue)}
  }

  package var updateWorkflowOptions: Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions {
    get {
      if case .updateWorkflowOptions(let v)? = variant {return v}
      return Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions()
    }
    set {variant = .updateWorkflowOptions(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package enum OneOf_Variant: Equatable, Sendable {
    case signalWorkflow(Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow)
    case updateWorkflowOptions(Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions)

  }

  /// SignalWorkflow represents sending a signal after a workflow reset.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
  package struct SignalWorkflow: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The workflow author-defined name of the signal to send to the workflow.
    package var signalName: String = String()

    /// Serialized value(s) to provide with the signal.
    package var input: Temporal_Api_Common_V1_Payloads {
      get {return _input ?? Temporal_Api_Common_V1_Payloads()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {return self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {self._input = nil}

    /// Headers that are passed with the signal to the processing workflow.
    package var header: Temporal_Api_Common_V1_Header {
      get {return _header ?? Temporal_Api_Common_V1_Header()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {return self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {self._header = nil}

    /// Links to be associated with the WorkflowExecutionSignaled event.
    package var links: [Temporal_Api_Common_V1_Link] = []

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
    fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
  }

  /// UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
  /// Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
  package struct UpdateWorkflowOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
    package var workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions {
      get {return _workflowExecutionOptions ?? Temporal_Api_Workflow_V1_WorkflowExecutionOptions()}
      set {_workflowExecutionOptions = newValue}
    }
    /// Returns true if `workflowExecutionOptions` has been explicitly set.
    package var hasWorkflowExecutionOptions: Bool {return self._workflowExecutionOptions != nil}
    /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

    /// Controls which fields from `workflow_execution_options` will be applied.
    /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
    package var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {return _updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    package var hasUpdateMask: Bool {return self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    package mutating func clearUpdateMask() {self._updateMask = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _workflowExecutionOptions: Temporal_Api_Workflow_V1_WorkflowExecutionOptions? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  }

  package init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.workflow.v1"

extension Temporal_Api_Workflow_V1_WorkflowExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}execution\0\u{1}type\0\u{3}start_time\0\u{3}close_time\0\u{1}status\0\u{3}history_length\0\u{3}parent_namespace_id\0\u{3}parent_execution\0\u{3}execution_time\0\u{1}memo\0\u{3}search_attributes\0\u{3}auto_reset_points\0\u{3}task_queue\0\u{3}state_transition_count\0\u{3}history_size_bytes\0\u{3}most_recent_worker_version_stamp\0\u{3}execution_duration\0\u{3}root_execution\0\u{3}assigned_build_id\0\u{3}inherited_build_id\0\u{3}first_run_id\0\u{3}versioning_info\0\u{3}worker_deployment_name\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _type: Temporal_Api_Common_V1_WorkflowType? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Temporal_Api_Enums_V1_WorkflowExecutionStatus = .unspecified
    var _historyLength: Int64 = 0
    var _parentNamespaceID: String = String()
    var _parentExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _executionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _autoResetPoints: Temporal_Api_Workflow_V1_ResetPoints? = nil
    var _taskQueue: String = String()
    var _stateTransitionCount: Int64 = 0
    var _historySizeBytes: Int64 = 0
    var _mostRecentWorkerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
    var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _rootExecution: Temporal_Api_Common_V1_WorkflowExecution? = nil
    var _assignedBuildID: String = String()
    var _inheritedBuildID: String = String()
    var _firstRunID: String = String()
    var _versioningInfo: Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo? = nil
    var _workerDeploymentName: String = String()
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _execution = source._execution
      _type = source._type
      _startTime = source._startTime
      _closeTime = source._closeTime
      _status = source._status
      _historyLength = source._historyLength
      _parentNamespaceID = source._parentNamespaceID
      _parentExecution = source._parentExecution
      _executionTime = source._executionTime
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _autoResetPoints = source._autoResetPoints
      _taskQueue = source._taskQueue
      _stateTransitionCount = source._stateTransitionCount
      _historySizeBytes = source._historySizeBytes
      _mostRecentWorkerVersionStamp = source._mostRecentWorkerVersionStamp
      _executionDuration = source._executionDuration
      _rootExecution = source._rootExecution
      _assignedBuildID = source._assignedBuildID
      _inheritedBuildID = source._inheritedBuildID
      _firstRunID = source._firstRunID
      _versioningInfo = source._versioningInfo
      _workerDeploymentName = source._workerDeploymentName
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._execution) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._closeTime) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._historyLength) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._parentNamespaceID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._parentExecution) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._executionTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._autoResetPoints) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._stateTransitionCount) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._historySizeBytes) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._mostRecentWorkerVersionStamp) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._executionDuration) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._rootExecution) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._assignedBuildID) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._inheritedBuildID) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._firstRunID) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._versioningInfo) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._workerDeploymentName) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._execution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._closeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._historyLength != 0 {
        try visitor.visitSingularInt64Field(value: _storage._historyLength, fieldNumber: 6)
      }
      if !_storage._parentNamespaceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentNamespaceID, fieldNumber: 7)
      }
      try { if let v = _storage._parentExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._executionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._autoResetPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 13)
      }
      if _storage._stateTransitionCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stateTransitionCount, fieldNumber: 14)
      }
      if _storage._historySizeBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._historySizeBytes, fieldNumber: 15)
      }
      try { if let v = _storage._mostRecentWorkerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._executionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._rootExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._assignedBuildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assignedBuildID, fieldNumber: 19)
      }
      if !_storage._inheritedBuildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inheritedBuildID, fieldNumber: 20)
      }
      if !_storage._firstRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstRunID, fieldNumber: 21)
      }
      try { if let v = _storage._versioningInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._workerDeploymentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerDeploymentName, fieldNumber: 23)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_WorkflowExecutionInfo, rhs: Temporal_Api_Workflow_V1_WorkflowExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._execution != rhs_storage._execution {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._closeTime != rhs_storage._closeTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._historyLength != rhs_storage._historyLength {return false}
        if _storage._parentNamespaceID != rhs_storage._parentNamespaceID {return false}
        if _storage._parentExecution != rhs_storage._parentExecution {return false}
        if _storage._executionTime != rhs_storage._executionTime {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._autoResetPoints != rhs_storage._autoResetPoints {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._stateTransitionCount != rhs_storage._stateTransitionCount {return false}
        if _storage._historySizeBytes != rhs_storage._historySizeBytes {return false}
        if _storage._mostRecentWorkerVersionStamp != rhs_storage._mostRecentWorkerVersionStamp {return false}
        if _storage._executionDuration != rhs_storage._executionDuration {return false}
        if _storage._rootExecution != rhs_storage._rootExecution {return false}
        if _storage._assignedBuildID != rhs_storage._assignedBuildID {return false}
        if _storage._inheritedBuildID != rhs_storage._inheritedBuildID {return false}
        if _storage._firstRunID != rhs_storage._firstRunID {return false}
        if _storage._versioningInfo != rhs_storage._versioningInfo {return false}
        if _storage._workerDeploymentName != rhs_storage._workerDeploymentName {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionExtendedInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_expiration_time\0\u{3}run_expiration_time\0\u{3}cancel_requested\0\u{3}last_reset_time\0\u{3}original_start_time\0\u{3}reset_run_id\0\u{3}request_id_infos\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._executionExpirationTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._runExpirationTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastResetTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._originalStartTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resetRunID) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Workflow_V1_RequestIdInfo>.self, value: &self.requestIDInfos) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._executionExpirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._runExpirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 3)
    }
    try { if let v = self._lastResetTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.resetRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.resetRunID, fieldNumber: 6)
    }
    if !self.requestIDInfos.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Workflow_V1_RequestIdInfo>.self, value: self.requestIDInfos, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo, rhs: Temporal_Api_Workflow_V1_WorkflowExecutionExtendedInfo) -> Bool {
    if lhs._executionExpirationTime != rhs._executionExpirationTime {return false}
    if lhs._runExpirationTime != rhs._runExpirationTime {return false}
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs._lastResetTime != rhs._lastResetTime {return false}
    if lhs._originalStartTime != rhs._originalStartTime {return false}
    if lhs.resetRunID != rhs.resetRunID {return false}
    if lhs.requestIDInfos != rhs.requestIDInfos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionVersioningInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}deployment\0\u{3}versioning_override\0\u{3}deployment_transition\0\u{1}version\0\u{3}version_transition\0\u{3}deployment_version\0")

  fileprivate class _StorageClass {
    var _behavior: Temporal_Api_Enums_V1_VersioningBehavior = .unspecified
    var _deployment: Temporal_Api_Deployment_V1_Deployment? = nil
    var _version: String = String()
    var _deploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
    var _deploymentTransition: Temporal_Api_Workflow_V1_DeploymentTransition? = nil
    var _versionTransition: Temporal_Api_Workflow_V1_DeploymentVersionTransition? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _behavior = source._behavior
      _deployment = source._deployment
      _version = source._version
      _deploymentVersion = source._deploymentVersion
      _versioningOverride = source._versioningOverride
      _deploymentTransition = source._deploymentTransition
      _versionTransition = source._versionTransition
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._behavior) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentTransition) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._versionTransition) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._behavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._behavior, fieldNumber: 1)
      }
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._deploymentTransition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      try { if let v = _storage._versionTransition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo, rhs: Temporal_Api_Workflow_V1_WorkflowExecutionVersioningInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._behavior != rhs_storage._behavior {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._deploymentTransition != rhs_storage._deploymentTransition {return false}
        if _storage._versionTransition != rhs_storage._versionTransition {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_DeploymentTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeploymentTransition"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deployment\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_DeploymentTransition, rhs: Temporal_Api_Workflow_V1_DeploymentTransition) -> Bool {
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_DeploymentVersionTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DeploymentVersionTransition"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_DeploymentVersionTransition, rhs: Temporal_Api_Workflow_V1_DeploymentVersionTransition) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_WorkflowExecutionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}default_workflow_task_timeout\0\u{3}user_metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionTimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowRunTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._defaultWorkflowTaskTimeout) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._userMetadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._workflowExecutionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowRunTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._defaultWorkflowTaskTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._userMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_WorkflowExecutionConfig, rhs: Temporal_Api_Workflow_V1_WorkflowExecutionConfig) -> Bool {
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs._workflowExecutionTimeout != rhs._workflowExecutionTimeout {return false}
    if lhs._workflowRunTimeout != rhs._workflowRunTimeout {return false}
    if lhs._defaultWorkflowTaskTimeout != rhs._defaultWorkflowTaskTimeout {return false}
    if lhs._userMetadata != rhs._userMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingActivityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PendingActivityInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}activity_type\0\u{1}state\0\u{3}heartbeat_details\0\u{3}last_heartbeat_time\0\u{3}last_started_time\0\u{1}attempt\0\u{3}maximum_attempts\0\u{3}scheduled_time\0\u{3}expiration_time\0\u{3}last_failure\0\u{3}last_worker_identity\0\u{3}use_workflow_build_id\0\u{3}last_independently_assigned_build_id\0\u{3}last_worker_version_stamp\0\u{3}current_retry_interval\0\u{3}last_attempt_complete_time\0\u{3}next_attempt_schedule_time\0\u{1}paused\0\u{3}last_deployment\0\u{3}last_worker_deployment_version\0\u{1}priority\0\u{3}pause_info\0\u{3}activity_options\0\u{3}last_deployment_version\0")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _activityType: Temporal_Api_Common_V1_ActivityType? = nil
    var _state: Temporal_Api_Enums_V1_PendingActivityState = .unspecified
    var _heartbeatDetails: Temporal_Api_Common_V1_Payloads? = nil
    var _lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: Int32 = 0
    var _maximumAttempts: Int32 = 0
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastFailure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastWorkerIdentity: String = String()
    var _assignedBuildID: Temporal_Api_Workflow_V1_PendingActivityInfo.OneOf_AssignedBuildID?
    var _lastWorkerVersionStamp: Temporal_Api_Common_V1_WorkerVersionStamp? = nil
    var _currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _paused: Bool = false
    var _lastDeployment: Temporal_Api_Deployment_V1_Deployment? = nil
    var _lastWorkerDeploymentVersion: String = String()
    var _lastDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil
    var _pauseInfo: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo? = nil
    var _activityOptions: Temporal_Api_Activity_V1_ActivityOptions? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _activityType = source._activityType
      _state = source._state
      _heartbeatDetails = source._heartbeatDetails
      _lastHeartbeatTime = source._lastHeartbeatTime
      _lastStartedTime = source._lastStartedTime
      _attempt = source._attempt
      _maximumAttempts = source._maximumAttempts
      _scheduledTime = source._scheduledTime
      _expirationTime = source._expirationTime
      _lastFailure = source._lastFailure
      _lastWorkerIdentity = source._lastWorkerIdentity
      _assignedBuildID = source._assignedBuildID
      _lastWorkerVersionStamp = source._lastWorkerVersionStamp
      _currentRetryInterval = source._currentRetryInterval
      _lastAttemptCompleteTime = source._lastAttemptCompleteTime
      _nextAttemptScheduleTime = source._nextAttemptScheduleTime
      _paused = source._paused
      _lastDeployment = source._lastDeployment
      _lastWorkerDeploymentVersion = source._lastWorkerDeploymentVersion
      _lastDeploymentVersion = source._lastDeploymentVersion
      _priority = source._priority
      _pauseInfo = source._pauseInfo
      _activityOptions = source._activityOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatDetails) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastHeartbeatTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._lastStartedTime) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._maximumAttempts) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastFailure) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._lastWorkerIdentity) }()
        case 13: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._assignedBuildID {
            hadOneofValue = true
            if case .useWorkflowBuildID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._assignedBuildID = .useWorkflowBuildID(v)
          }
        }()
        case 14: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._assignedBuildID != nil {try decoder.handleConflictingOneOf()}
            _storage._assignedBuildID = .lastIndependentlyAssignedBuildID(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._lastWorkerVersionStamp) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._currentRetryInterval) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptCompleteTime) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._nextAttemptScheduleTime) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeployment) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._lastWorkerDeploymentVersion) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._pauseInfo) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._activityOptions) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeploymentVersion) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._heartbeatDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lastHeartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._lastStartedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 7)
      }
      if _storage._maximumAttempts != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maximumAttempts, fieldNumber: 8)
      }
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lastFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._lastWorkerIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastWorkerIdentity, fieldNumber: 12)
      }
      switch _storage._assignedBuildID {
      case .useWorkflowBuildID?: try {
        guard case .useWorkflowBuildID(let v)? = _storage._assignedBuildID else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .lastIndependentlyAssignedBuildID?: try {
        guard case .lastIndependentlyAssignedBuildID(let v)? = _storage._assignedBuildID else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._lastWorkerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._currentRetryInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._lastAttemptCompleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._nextAttemptScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 19)
      }
      try { if let v = _storage._lastDeployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._lastWorkerDeploymentVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastWorkerDeploymentVersion, fieldNumber: 21)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._pauseInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._activityOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._lastDeploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingActivityInfo, rhs: Temporal_Api_Workflow_V1_PendingActivityInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._lastHeartbeatTime != rhs_storage._lastHeartbeatTime {return false}
        if _storage._lastStartedTime != rhs_storage._lastStartedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._maximumAttempts != rhs_storage._maximumAttempts {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._lastFailure != rhs_storage._lastFailure {return false}
        if _storage._lastWorkerIdentity != rhs_storage._lastWorkerIdentity {return false}
        if _storage._assignedBuildID != rhs_storage._assignedBuildID {return false}
        if _storage._lastWorkerVersionStamp != rhs_storage._lastWorkerVersionStamp {return false}
        if _storage._currentRetryInterval != rhs_storage._currentRetryInterval {return false}
        if _storage._lastAttemptCompleteTime != rhs_storage._lastAttemptCompleteTime {return false}
        if _storage._nextAttemptScheduleTime != rhs_storage._nextAttemptScheduleTime {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._lastDeployment != rhs_storage._lastDeployment {return false}
        if _storage._lastWorkerDeploymentVersion != rhs_storage._lastWorkerDeploymentVersion {return false}
        if _storage._lastDeploymentVersion != rhs_storage._lastDeploymentVersion {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._pauseInfo != rhs_storage._pauseInfo {return false}
        if _storage._activityOptions != rhs_storage._activityOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_PendingActivityInfo.protoMessageName + ".PauseInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pause_time\0\u{1}manual\0\u{2}\u{2}rule\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pauseTime) }()
      case 2: try {
        var v: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual?
        var hadOneofValue = false
        if let current = self.pausedBy {
          hadOneofValue = true
          if case .manual(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pausedBy = .manual(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule?
        var hadOneofValue = false
        if let current = self.pausedBy {
          hadOneofValue = true
          if case .rule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pausedBy = .rule(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pauseTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.pausedBy {
    case .manual?: try {
      guard case .manual(let v)? = self.pausedBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rule?: try {
      guard case .rule(let v)? = self.pausedBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo, rhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo) -> Bool {
    if lhs._pauseTime != rhs._pauseTime {return false}
    if lhs.pausedBy != rhs.pausedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.protoMessageName + ".Manual"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual, rhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Manual) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.protoMessageName + ".Rule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_id\0\u{1}identity\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule, rhs: Temporal_Api_Workflow_V1_PendingActivityInfo.PauseInfo.Rule) -> Bool {
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingChildExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PendingChildExecutionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}run_id\0\u{3}workflow_type_name\0\u{3}initiated_id\0\u{3}parent_close_policy\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowTypeName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.parentClosePolicy) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    if !self.workflowTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowTypeName, fieldNumber: 3)
    }
    if self.initiatedID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedID, fieldNumber: 4)
    }
    if self.parentClosePolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.parentClosePolicy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingChildExecutionInfo, rhs: Temporal_Api_Workflow_V1_PendingChildExecutionInfo) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.workflowTypeName != rhs.workflowTypeName {return false}
    if lhs.initiatedID != rhs.initiatedID {return false}
    if lhs.parentClosePolicy != rhs.parentClosePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PendingWorkflowTaskInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0\u{3}scheduled_time\0\u{3}original_scheduled_time\0\u{3}started_time\0\u{1}attempt\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduledTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originalScheduledTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startedTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._scheduledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalScheduledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo, rhs: Temporal_Api_Workflow_V1_PendingWorkflowTaskInfo) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs._originalScheduledTime != rhs._originalScheduledTime {return false}
    if lhs._startedTime != rhs._startedTime {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_ResetPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetPoints"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_ResetPoints, rhs: Temporal_Api_Workflow_V1_ResetPoints) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_ResetPointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ResetPointInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}binary_checksum\0\u{3}run_id\0\u{3}first_workflow_task_completed_id\0\u{3}create_time\0\u{3}expire_time\0\u{1}resettable\0\u{3}build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.firstWorkflowTaskCompletedID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.resettable) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    if self.firstWorkflowTaskCompletedID != 0 {
      try visitor.visitSingularInt64Field(value: self.firstWorkflowTaskCompletedID, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.resettable != false {
      try visitor.visitSingularBoolField(value: self.resettable, fieldNumber: 6)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_ResetPointInfo, rhs: Temporal_Api_Workflow_V1_ResetPointInfo) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.firstWorkflowTaskCompletedID != rhs.firstWorkflowTaskCompletedID {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.resettable != rhs.resettable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NewWorkflowExecutionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}user_metadata\0\u{3}versioning_override\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _workflowID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
    var _versioningOverride: Temporal_Api_Workflow_V1_VersioningOverride? = nil
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _userMetadata = source._userMetadata
      _versioningOverride = source._versioningOverride
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 1)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 8)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 10)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo, rhs: Temporal_Api_Workflow_V1_NewWorkflowExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_CallbackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CallbackInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}callback\0\u{1}trigger\0\u{3}registration_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}blocked_reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._callback) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._registrationTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptCompleteTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptFailure) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._nextAttemptScheduleTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.blockedReason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._registrationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 5)
    }
    try { if let v = self._lastAttemptCompleteTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastAttemptFailure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._nextAttemptScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.blockedReason.isEmpty {
      try visitor.visitSingularStringField(value: self.blockedReason, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_CallbackInfo, rhs: Temporal_Api_Workflow_V1_CallbackInfo) -> Bool {
    if lhs._callback != rhs._callback {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs._registrationTime != rhs._registrationTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs._lastAttemptCompleteTime != rhs._lastAttemptCompleteTime {return false}
    if lhs._lastAttemptFailure != rhs._lastAttemptFailure {return false}
    if lhs._nextAttemptScheduleTime != rhs._nextAttemptScheduleTime {return false}
    if lhs.blockedReason != rhs.blockedReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_CallbackInfo.protoMessageName + ".WorkflowClosed"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed, rhs: Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_CallbackInfo.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_CallbackInfo.protoMessageName + ".Trigger"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_closed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflow_V1_CallbackInfo.WorkflowClosed?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .workflowClosed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .workflowClosed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .workflowClosed(let v)? = self.variant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_CallbackInfo.Trigger, rhs: Temporal_Api_Workflow_V1_CallbackInfo.Trigger) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PendingNexusOperationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PendingNexusOperationInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{3}operation_id\0\u{3}schedule_to_close_timeout\0\u{3}scheduled_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}cancellation_info\0\u{3}scheduled_event_id\0\u{3}blocked_reason\0\u{3}operation_token\0")

  fileprivate class _StorageClass {
    var _endpoint: String = String()
    var _service: String = String()
    var _operation: String = String()
    var _operationID: String = String()
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Temporal_Api_Enums_V1_PendingNexusOperationState = .unspecified
    var _attempt: Int32 = 0
    var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastAttemptFailure: Temporal_Api_Failure_V1_Failure? = nil
    var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cancellationInfo: Temporal_Api_Workflow_V1_NexusOperationCancellationInfo? = nil
    var _scheduledEventID: Int64 = 0
    var _blockedReason: String = String()
    var _operationToken: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _endpoint = source._endpoint
      _service = source._service
      _operation = source._operation
      _operationID = source._operationID
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduledTime = source._scheduledTime
      _state = source._state
      _attempt = source._attempt
      _lastAttemptCompleteTime = source._lastAttemptCompleteTime
      _lastAttemptFailure = source._lastAttemptFailure
      _nextAttemptScheduleTime = source._nextAttemptScheduleTime
      _cancellationInfo = source._cancellationInfo
      _scheduledEventID = source._scheduledEventID
      _blockedReason = source._blockedReason
      _operationToken = source._operationToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._endpoint) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._service) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._operation) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._operationID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptCompleteTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptFailure) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._nextAttemptScheduleTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cancellationInfo) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._scheduledEventID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._blockedReason) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._operationToken) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._endpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpoint, fieldNumber: 1)
      }
      if !_storage._service.isEmpty {
        try visitor.visitSingularStringField(value: _storage._service, fieldNumber: 2)
      }
      if !_storage._operation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operation, fieldNumber: 3)
      }
      if !_storage._operationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operationID, fieldNumber: 4)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 7)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 8)
      }
      try { if let v = _storage._lastAttemptCompleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastAttemptFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._nextAttemptScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._cancellationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._scheduledEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._scheduledEventID, fieldNumber: 13)
      }
      if !_storage._blockedReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockedReason, fieldNumber: 14)
      }
      if !_storage._operationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operationToken, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PendingNexusOperationInfo, rhs: Temporal_Api_Workflow_V1_PendingNexusOperationInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._operationID != rhs_storage._operationID {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._lastAttemptCompleteTime != rhs_storage._lastAttemptCompleteTime {return false}
        if _storage._lastAttemptFailure != rhs_storage._lastAttemptFailure {return false}
        if _storage._nextAttemptScheduleTime != rhs_storage._nextAttemptScheduleTime {return false}
        if _storage._cancellationInfo != rhs_storage._cancellationInfo {return false}
        if _storage._scheduledEventID != rhs_storage._scheduledEventID {return false}
        if _storage._blockedReason != rhs_storage._blockedReason {return false}
        if _storage._operationToken != rhs_storage._operationToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_NexusOperationCancellationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationCancellationInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requested_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}blocked_reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._requestedTime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptCompleteTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptFailure) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nextAttemptScheduleTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.blockedReason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 3)
    }
    try { if let v = self._lastAttemptCompleteTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lastAttemptFailure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nextAttemptScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.blockedReason.isEmpty {
      try visitor.visitSingularStringField(value: self.blockedReason, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_NexusOperationCancellationInfo, rhs: Temporal_Api_Workflow_V1_NexusOperationCancellationInfo) -> Bool {
    if lhs._requestedTime != rhs._requestedTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs._lastAttemptCompleteTime != rhs._lastAttemptCompleteTime {return false}
    if lhs._lastAttemptFailure != rhs._lastAttemptFailure {return false}
    if lhs._nextAttemptScheduleTime != rhs._nextAttemptScheduleTime {return false}
    if lhs.blockedReason != rhs.blockedReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_WorkflowExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}versioning_override\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._versioningOverride) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._versioningOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_WorkflowExecutionOptions, rhs: Temporal_Api_Workflow_V1_WorkflowExecutionOptions) -> Bool {
    if lhs._versioningOverride != rhs._versioningOverride {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_VersioningOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".VersioningOverride"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}deployment\0\u{1}pinned\0\u{3}auto_upgrade\0\u{4}\u{5}pinned_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.behavior) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 3: try {
        var v: Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .pinned(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .pinned(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .autoUpgrade(v)
        }
      }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.pinnedVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.behavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.behavior, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.override {
    case .pinned?: try {
      guard case .pinned(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .autoUpgrade?: try {
      guard case .autoUpgrade(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.pinnedVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.pinnedVersion, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_VersioningOverride, rhs: Temporal_Api_Workflow_V1_VersioningOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.behavior != rhs.behavior {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.pinnedVersion != rhs.pinnedVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverrideBehavior: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED\0\u{1}PINNED_OVERRIDE_BEHAVIOR_PINNED\0")
}

extension Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_VersioningOverride.protoMessageName + ".PinnedOverride"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.behavior) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.behavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.behavior, fieldNumber: 1)
    }
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride, rhs: Temporal_Api_Workflow_V1_VersioningOverride.PinnedOverride) -> Bool {
    if lhs.behavior != rhs.behavior {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_OnConflictOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".OnConflictOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attach_request_id\0\u{3}attach_completion_callbacks\0\u{3}attach_links\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.attachRequestID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.attachCompletionCallbacks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.attachLinks) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attachRequestID != false {
      try visitor.visitSingularBoolField(value: self.attachRequestID, fieldNumber: 1)
    }
    if self.attachCompletionCallbacks != false {
      try visitor.visitSingularBoolField(value: self.attachCompletionCallbacks, fieldNumber: 2)
    }
    if self.attachLinks != false {
      try visitor.visitSingularBoolField(value: self.attachLinks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_OnConflictOptions, rhs: Temporal_Api_Workflow_V1_OnConflictOptions) -> Bool {
    if lhs.attachRequestID != rhs.attachRequestID {return false}
    if lhs.attachCompletionCallbacks != rhs.attachCompletionCallbacks {return false}
    if lhs.attachLinks != rhs.attachLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_RequestIdInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestIdInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_type\0\u{3}event_id\0\u{1}buffered\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.buffered) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if self.eventID != 0 {
      try visitor.visitSingularInt64Field(value: self.eventID, fieldNumber: 2)
    }
    if self.buffered != false {
      try visitor.visitSingularBoolField(value: self.buffered, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_RequestIdInfo, rhs: Temporal_Api_Workflow_V1_RequestIdInfo) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.buffered != rhs.buffered {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PostResetOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PostResetOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_workflow\0\u{3}update_workflow_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .signalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .signalWorkflow(v)
        }
      }()
      case 2: try {
        var v: Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .updateWorkflowOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .updateWorkflowOptions(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .signalWorkflow?: try {
      guard case .signalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflowOptions?: try {
      guard case .updateWorkflowOptions(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PostResetOperation, rhs: Temporal_Api_Workflow_V1_PostResetOperation) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_PostResetOperation.protoMessageName + ".SignalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_name\0\u{1}input\0\u{1}header\0\u{1}links\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow, rhs: Temporal_Api_Workflow_V1_PostResetOperation.SignalWorkflow) -> Bool {
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs._header != rhs._header {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = Temporal_Api_Workflow_V1_PostResetOperation.protoMessageName + ".UpdateWorkflowOptions"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_execution_options\0\u{3}update_mask\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions, rhs: Temporal_Api_Workflow_V1_PostResetOperation.UpdateWorkflowOptions) -> Bool {
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
