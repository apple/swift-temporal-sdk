// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/taskqueue/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// See https://docs.temporal.io/docs/concepts/task-queues/
package struct Temporal_Api_Taskqueue_V1_TaskQueue: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var name: String = String()

  /// Default: TASK_QUEUE_KIND_NORMAL.
  package var kind: Temporal_Api_Enums_V1_TaskQueueKind = .unspecified

  /// Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
  /// the normal task queue that the sticky worker is running on.
  package var normalName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Only applies to activity task queues
package struct Temporal_Api_Taskqueue_V1_TaskQueueMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Allows throttling dispatch of tasks from this queue
  package var maxTasksPerSecond: SwiftProtobuf.Google_Protobuf_DoubleValue {
    get {return _maxTasksPerSecond ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
    set {_maxTasksPerSecond = newValue}
  }
  /// Returns true if `maxTasksPerSecond` has been explicitly set.
  package var hasMaxTasksPerSecond: Bool {return self._maxTasksPerSecond != nil}
  /// Clears the value of `maxTasksPerSecond`. Subsequent reads from it will return its default value.
  package mutating func clearMaxTasksPerSecond() {self._maxTasksPerSecond = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _maxTasksPerSecond: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
}

/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package struct Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Specifies which Deployment Version should receive new workflow executions and tasks of
  /// existing unversioned or AutoUpgrade workflows.
  /// Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
  /// Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
  /// is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
  package var currentDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _currentDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_currentDeploymentVersion = newValue}
  }
  /// Returns true if `currentDeploymentVersion` has been explicitly set.
  package var hasCurrentDeploymentVersion: Bool {return self._currentDeploymentVersion != nil}
  /// Clears the value of `currentDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearCurrentDeploymentVersion() {self._currentDeploymentVersion = nil}

  /// Deprecated. Use `current_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var currentVersion: String = String()

  /// When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
  /// Must always be different from `current_deployment_version` unless both are nil.
  /// Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
  /// Note that it is possible to ramp from one Version to another Version, or from unversioned
  /// workers to a particular Version, or from a particular Version to unversioned workers.
  package var rampingDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion {
    get {return _rampingDeploymentVersion ?? Temporal_Api_Deployment_V1_WorkerDeploymentVersion()}
    set {_rampingDeploymentVersion = newValue}
  }
  /// Returns true if `rampingDeploymentVersion` has been explicitly set.
  package var hasRampingDeploymentVersion: Bool {return self._rampingDeploymentVersion != nil}
  /// Clears the value of `rampingDeploymentVersion`. Subsequent reads from it will return its default value.
  package mutating func clearRampingDeploymentVersion() {self._rampingDeploymentVersion = nil}

  /// Deprecated. Use `ramping_deployment_version`.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var rampingVersion: String = String()

  /// Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
  /// Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
  /// not yet "promoted" to be the Current Version, likely due to pending validations.
  /// A 0% value means the Ramping Version is receiving no traffic.
  package var rampingVersionPercentage: Float = 0

  /// Last time versioning information of this Task Queue changed.
  package var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  package var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateTime() {self._updateTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _currentDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
  fileprivate var _rampingDeploymentVersion: Temporal_Api_Deployment_V1_WorkerDeploymentVersion? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Used for specifying versions the caller is interested in.
package struct Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Include specific Build IDs.
  package var buildIds: [String] = []

  /// Include the unversioned queue.
  package var unversioned: Bool = false

  /// Include all active versions. A version is considered active if, in the last few minutes,
  /// it has had new tasks or polls, or it has been the subject of certain task queue API calls.
  package var allActive: Bool = false

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
  package var typesInfo: Dictionary<Int32,Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo> = [:]

  /// Task Reachability is eventually consistent; there may be a delay until it converges to the most
  /// accurate value but it is designed in a way to take the more conservative side until it converges.
  /// For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
  ///
  /// Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
  /// accounted for reachability as server cannot know if they'll happen as they do not use
  /// assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
  /// who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
  /// sure to query reachability for the parent/previous workflow's Task Queue as well.
  package var taskReachability: Temporal_Api_Enums_V1_BuildIdTaskReachability = .unspecified

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
  package var pollers: [Temporal_Api_Taskqueue_V1_PollerInfo] = []

  package var stats: Temporal_Api_Taskqueue_V1_TaskQueueStats {
    get {return _stats ?? Temporal_Api_Taskqueue_V1_TaskQueueStats()}
    set {_stats = newValue}
  }
  /// Returns true if `stats` has been explicitly set.
  package var hasStats: Bool {return self._stats != nil}
  /// Clears the value of `stats`. Subsequent reads from it will return its default value.
  package mutating func clearStats() {self._stats = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _stats: Temporal_Api_Taskqueue_V1_TaskQueueStats? = nil
}

/// TaskQueueStats contains statistics about task queue backlog and activity.
///
/// For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
/// comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
package struct Temporal_Api_Taskqueue_V1_TaskQueueStats: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
  /// converges to the right value. Can be relied upon for scaling decisions.
  ///
  /// Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
  /// those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
  /// grows.
  package var approximateBacklogCount: Int64 = 0

  /// Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
  /// the queue. Can be relied upon for scaling decisions.
  ///
  /// Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
  /// those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
  /// few seconds.
  package var approximateBacklogAge: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _approximateBacklogAge ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_approximateBacklogAge = newValue}
  }
  /// Returns true if `approximateBacklogAge` has been explicitly set.
  package var hasApproximateBacklogAge: Bool {return self._approximateBacklogAge != nil}
  /// Clears the value of `approximateBacklogAge`. Subsequent reads from it will return its default value.
  package mutating func clearApproximateBacklogAge() {self._approximateBacklogAge = nil}

  /// The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
  /// whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
  /// to the backlog (sync-matched).
  ///
  /// The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
  /// backlog grows/shrinks.
  ///
  /// Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
  /// tasks_add_rate, because:
  /// - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
  ///   enable for activities by default in the latest SDKs.
  /// - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
  ///   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
  ///   worker instance.
  package var tasksAddRate: Float = 0

  /// The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
  /// tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
  /// going to the backlog (sync-matched).
  ///
  /// The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
  /// backlog grows/shrinks.
  ///
  /// Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
  /// tasks_dispatch_rate, because:
  /// - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
  ///   enable for activities by default in the latest SDKs.
  /// - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
  ///   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
  ///   worker instance.
  package var tasksDispatchRate: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _approximateBacklogAge: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
package struct Temporal_Api_Taskqueue_V1_TaskQueueStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var backlogCountHint: Int64 = 0

  package var readLevel: Int64 = 0

  package var ackLevel: Int64 = 0

  package var ratePerSecond: Double = 0

  package var taskIDBlock: Temporal_Api_Taskqueue_V1_TaskIdBlock {
    get {return _taskIDBlock ?? Temporal_Api_Taskqueue_V1_TaskIdBlock()}
    set {_taskIDBlock = newValue}
  }
  /// Returns true if `taskIDBlock` has been explicitly set.
  package var hasTaskIDBlock: Bool {return self._taskIDBlock != nil}
  /// Clears the value of `taskIDBlock`. Subsequent reads from it will return its default value.
  package mutating func clearTaskIDBlock() {self._taskIDBlock = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _taskIDBlock: Temporal_Api_Taskqueue_V1_TaskIdBlock? = nil
}

package struct Temporal_Api_Taskqueue_V1_TaskIdBlock: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var startID: Int64 = 0

  package var endID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var key: String = String()

  package var ownerHostName: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_PollerInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var lastAccessTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastAccessTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastAccessTime = newValue}
  }
  /// Returns true if `lastAccessTime` has been explicitly set.
  package var hasLastAccessTime: Bool {return self._lastAccessTime != nil}
  /// Clears the value of `lastAccessTime`. Subsequent reads from it will return its default value.
  package mutating func clearLastAccessTime() {self._lastAccessTime = nil}

  package var identity: String = String()

  package var ratePerSecond: Double = 0

  /// If a worker has opted into the worker versioning feature while polling, its capabilities will
  /// appear here.
  /// Deprecated. Replaced by deployment_options.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities {
    get {return _workerVersionCapabilities ?? Temporal_Api_Common_V1_WorkerVersionCapabilities()}
    set {_workerVersionCapabilities = newValue}
  }
  /// Returns true if `workerVersionCapabilities` has been explicitly set.
  package var hasWorkerVersionCapabilities: Bool {return self._workerVersionCapabilities != nil}
  /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

  /// Worker deployment options that SDK sent to server.
  package var deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions {
    get {return _deploymentOptions ?? Temporal_Api_Deployment_V1_WorkerDeploymentOptions()}
    set {_deploymentOptions = newValue}
  }
  /// Returns true if `deploymentOptions` has been explicitly set.
  package var hasDeploymentOptions: Bool {return self._deploymentOptions != nil}
  /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
  package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _lastAccessTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _workerVersionCapabilities: Temporal_Api_Common_V1_WorkerVersionCapabilities? = nil
  fileprivate var _deploymentOptions: Temporal_Api_Deployment_V1_WorkerDeploymentOptions? = nil
}

package struct Temporal_Api_Taskqueue_V1_StickyExecutionAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workerTaskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _workerTaskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_workerTaskQueue = newValue}
  }
  /// Returns true if `workerTaskQueue` has been explicitly set.
  package var hasWorkerTaskQueue: Bool {return self._workerTaskQueue != nil}
  /// Clears the value of `workerTaskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearWorkerTaskQueue() {self._workerTaskQueue = nil}

  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_scheduleToStartTimeout = newValue}
  }
  /// Returns true if `scheduleToStartTimeout` has been explicitly set.
  package var hasScheduleToStartTimeout: Bool {return self._scheduleToStartTimeout != nil}
  /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToStartTimeout() {self._scheduleToStartTimeout = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _workerTaskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
  fileprivate var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

/// Used by the worker versioning APIs, represents an unordered set of one or more versions which are
/// considered to be compatible with each other. Currently the versions are always worker build IDs.
package struct Temporal_Api_Taskqueue_V1_CompatibleVersionSet: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// All the compatible versions, unordered, except for the last element, which is considered the set "default".
  package var buildIds: [String] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Reachability of tasks for a worker on a single task queue.
package struct Temporal_Api_Taskqueue_V1_TaskQueueReachability: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var taskQueue: String = String()

  /// Task reachability for a worker in a single task queue.
  /// See the TaskReachability docstring for information about each enum variant.
  /// If reachability is empty, this worker is considered unreachable in this task queue.
  package var reachability: [Temporal_Api_Enums_V1_TaskReachability] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Reachability of tasks for a worker by build id, in one or more task queues.
package struct Temporal_Api_Taskqueue_V1_BuildIdReachability: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A build id or empty if unversioned.
  package var buildID: String = String()

  /// Reachability per task queue.
  package var taskQueueReachability: [Temporal_Api_Taskqueue_V1_TaskQueueReachability] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_RampByPercentage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Acceptable range is [0,100).
  package var rampPercentage: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

/// Assignment rules are applied to *new* Workflow and Activity executions at
/// schedule time to assign them to a Build ID.
///
/// Assignment rules will not be used in the following cases:
///    - Child Workflows or Continue-As-New Executions who inherit their
///      parent/previous Workflow's assigned Build ID (by setting the
///      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
///      is used.)
///    - An Activity that inherits the assigned Build ID of its Workflow (by
///      setting the `use_workflow_build_id` flag - default behavior in SDKs
///      when the same Task Queue is used.)
///
/// In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
/// the task will be dispatched to Workers of the Build ID determined by the
/// assignment rules (or inherited). Otherwise, the final Build ID will be
/// determined by the redirect rules.
///
/// Once a Workflow completes its first Workflow Task in a particular Build ID it
/// stays in that Build ID regardless of changes to assignment rules. Redirect
/// rules can be used to move the workflow to another compatible Build ID.
///
/// When using Worker Versioning on a Task Queue, in the steady state,
/// there should typically be a single assignment rule to send all new executions
/// to the latest Build ID. Existence of at least one such "unconditional"
/// rule at all times is enforces by the system, unless the `force` flag is used
/// by the user when replacing/deleting these rules (for exceptional cases).
///
/// During a deployment, one or more additional rules can be added to assign a
/// subset of the tasks to a new Build ID based on a "ramp percentage".
///
/// When there are multiple assignment rules for a Task Queue, the rules are
/// evaluated in order, starting from index 0. The first applicable rule will be
/// applied and the rest will be ignored.
///
/// In the event that no assignment rule is applicable on a task (or the Task
/// Queue is simply not versioned), the tasks will be dispatched to an
/// unversioned Worker.
package struct Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var targetBuildID: String = String()

  /// If a ramp is provided, this rule will be applied only to a sample of
  /// tasks according to the provided percentage.
  /// This option can be used only on "terminal" Build IDs (the ones not used
  /// as source in any redirect rules).
  package var ramp: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule.OneOf_Ramp? = nil

  /// This ramp is useful for gradual Blue/Green deployments (and similar)
  /// where you want to send a certain portion of the traffic to the target
  /// Build ID.
  package var percentageRamp: Temporal_Api_Taskqueue_V1_RampByPercentage {
    get {
      if case .percentageRamp(let v)? = ramp {return v}
      return Temporal_Api_Taskqueue_V1_RampByPercentage()
    }
    set {ramp = .percentageRamp(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// If a ramp is provided, this rule will be applied only to a sample of
  /// tasks according to the provided percentage.
  /// This option can be used only on "terminal" Build IDs (the ones not used
  /// as source in any redirect rules).
  package enum OneOf_Ramp: Equatable, Sendable {
    /// This ramp is useful for gradual Blue/Green deployments (and similar)
    /// where you want to send a certain portion of the traffic to the target
    /// Build ID.
    case percentageRamp(Temporal_Api_Taskqueue_V1_RampByPercentage)

  }

  package init() {}
}

/// These rules apply to tasks assigned to a particular Build ID
/// (`source_build_id`) to redirect them to another *compatible* Build ID
/// (`target_build_id`).
///
/// It is user's responsibility to ensure that the target Build ID is compatible
/// with the source Build ID (e.g. by using the Patching API).
///
/// Most deployments are not expected to need these rules, however following
/// situations can greatly benefit from redirects:
///  - Need to move long-running Workflow Executions from an old Build ID to a
///    newer one.
///  - Need to hotfix some broken or stuck Workflow Executions.
///
/// In steady state, redirect rules are beneficial when dealing with old
/// Executions ran on now-decommissioned Build IDs:
///  - To redirecting the Workflow Queries to the current (compatible) Build ID.
///  - To be able to Reset an old Execution so it can run on the current
///    (compatible) Build ID.
///
/// Redirect rules can be chained.
package struct Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var sourceBuildID: String = String()

  /// Target Build ID must be compatible with the Source Build ID; that is it
  /// must be able to process event histories made by the Source Build ID by
  /// using [Patching](https://docs.temporal.io/workflows#patching) or other
  /// means.
  package var targetBuildID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule {
    get {return _rule ?? Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  package var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  package mutating func clearRule() {self._rule = nil}

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rule: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule {
    get {return _rule ?? Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule()}
    set {_rule = newValue}
  }
  /// Returns true if `rule` has been explicitly set.
  package var hasRule: Bool {return self._rule != nil}
  /// Clears the value of `rule`. Subsequent reads from it will return its default value.
  package mutating func clearRule() {self._rule = nil}

  package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  package var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  package mutating func clearCreateTime() {self._createTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rule: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule? = nil
  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Attached to task responses to give hints to the SDK about how it may adjust its number of
/// pollers.
package struct Temporal_Api_Taskqueue_V1_PollerScalingDecision: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// How many poll requests to suggest should be added or removed, if any. As of now, server only
  /// scales up or down by 1. However, SDKs should allow for other values (while staying within
  /// defined min/max).
  ///
  /// The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
  /// all slots are already occupied.
  package var pollRequestDeltaSuggestion: Int32 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_RateLimit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Zero is a valid rate limit.
  package var requestsPerSecond: Float = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Taskqueue_V1_ConfigMetadata: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Reason for why the config was set.
  package var reason: String = String()

  /// Identity of the last updater.
  /// Set by the request's identity field.
  package var updateIdentity: String = String()

  /// Time of the last update.
  package var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  package var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  package mutating func clearUpdateTime() {self._updateTime = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

package struct Temporal_Api_Taskqueue_V1_RateLimitConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var rateLimit: Temporal_Api_Taskqueue_V1_RateLimit {
    get {return _rateLimit ?? Temporal_Api_Taskqueue_V1_RateLimit()}
    set {_rateLimit = newValue}
  }
  /// Returns true if `rateLimit` has been explicitly set.
  package var hasRateLimit: Bool {return self._rateLimit != nil}
  /// Clears the value of `rateLimit`. Subsequent reads from it will return its default value.
  package mutating func clearRateLimit() {self._rateLimit = nil}

  package var metadata: Temporal_Api_Taskqueue_V1_ConfigMetadata {
    get {return _metadata ?? Temporal_Api_Taskqueue_V1_ConfigMetadata()}
    set {_metadata = newValue}
  }
  /// Returns true if `metadata` has been explicitly set.
  package var hasMetadata: Bool {return self._metadata != nil}
  /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
  package mutating func clearMetadata() {self._metadata = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _rateLimit: Temporal_Api_Taskqueue_V1_RateLimit? = nil
  fileprivate var _metadata: Temporal_Api_Taskqueue_V1_ConfigMetadata? = nil
}

package struct Temporal_Api_Taskqueue_V1_TaskQueueConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unless modified, this is the system-defined rate limit.
  package var queueRateLimit: Temporal_Api_Taskqueue_V1_RateLimitConfig {
    get {return _queueRateLimit ?? Temporal_Api_Taskqueue_V1_RateLimitConfig()}
    set {_queueRateLimit = newValue}
  }
  /// Returns true if `queueRateLimit` has been explicitly set.
  package var hasQueueRateLimit: Bool {return self._queueRateLimit != nil}
  /// Clears the value of `queueRateLimit`. Subsequent reads from it will return its default value.
  package mutating func clearQueueRateLimit() {self._queueRateLimit = nil}

  /// If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key.
  package var fairnessKeysRateLimitDefault: Temporal_Api_Taskqueue_V1_RateLimitConfig {
    get {return _fairnessKeysRateLimitDefault ?? Temporal_Api_Taskqueue_V1_RateLimitConfig()}
    set {_fairnessKeysRateLimitDefault = newValue}
  }
  /// Returns true if `fairnessKeysRateLimitDefault` has been explicitly set.
  package var hasFairnessKeysRateLimitDefault: Bool {return self._fairnessKeysRateLimitDefault != nil}
  /// Clears the value of `fairnessKeysRateLimitDefault`. Subsequent reads from it will return its default value.
  package mutating func clearFairnessKeysRateLimitDefault() {self._fairnessKeysRateLimitDefault = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _queueRateLimit: Temporal_Api_Taskqueue_V1_RateLimitConfig? = nil
  fileprivate var _fairnessKeysRateLimitDefault: Temporal_Api_Taskqueue_V1_RateLimitConfig? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.taskqueue.v1"

extension Temporal_Api_Taskqueue_V1_TaskQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueue"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}kind\0\u{3}normal_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.normalName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.normalName.isEmpty {
      try visitor.visitSingularStringField(value: self.normalName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueue, rhs: Temporal_Api_Taskqueue_V1_TaskQueue) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.normalName != rhs.normalName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}max_tasks_per_second\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxTasksPerSecond) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxTasksPerSecond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueMetadata, rhs: Temporal_Api_Taskqueue_V1_TaskQueueMetadata) -> Bool {
    if lhs._maxTasksPerSecond != rhs._maxTasksPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersioningInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_version\0\u{3}ramping_version\0\u{3}ramping_version_percentage\0\u{3}update_time\0\u{4}\u{3}current_deployment_version\0\u{4}\u{2}ramping_deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currentVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rampingVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.rampingVersionPercentage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._rampingDeploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.currentVersion, fieldNumber: 1)
    }
    if !self.rampingVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.rampingVersion, fieldNumber: 2)
    }
    if self.rampingVersionPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rampingVersionPercentage, fieldNumber: 3)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._currentDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._rampingDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo, rhs: Temporal_Api_Taskqueue_V1_TaskQueueVersioningInfo) -> Bool {
    if lhs._currentDeploymentVersion != rhs._currentDeploymentVersion {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs._rampingDeploymentVersion != rhs._rampingDeploymentVersion {return false}
    if lhs.rampingVersion != rhs.rampingVersion {return false}
    if lhs.rampingVersionPercentage != rhs.rampingVersionPercentage {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersionSelection"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_ids\0\u{1}unversioned\0\u{3}all_active\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.unversioned) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allActive) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 1)
    }
    if self.unversioned != false {
      try visitor.visitSingularBoolField(value: self.unversioned, fieldNumber: 2)
    }
    if self.allActive != false {
      try visitor.visitSingularBoolField(value: self.allActive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection, rhs: Temporal_Api_Taskqueue_V1_TaskQueueVersionSelection) -> Bool {
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.unversioned != rhs.unversioned {return false}
    if lhs.allActive != rhs.allActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}types_info\0\u{3}task_reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo>.self, value: &self.typesInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskReachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typesInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo>.self, value: self.typesInfo, fieldNumber: 1)
    }
    if self.taskReachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskReachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo, rhs: Temporal_Api_Taskqueue_V1_TaskQueueVersionInfo) -> Bool {
    if lhs.typesInfo != rhs.typesInfo {return false}
    if lhs.taskReachability != rhs.taskReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueTypeInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pollers\0\u{1}stats\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pollers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pollers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pollers, fieldNumber: 1)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo, rhs: Temporal_Api_Taskqueue_V1_TaskQueueTypeInfo) -> Bool {
    if lhs.pollers != rhs.pollers {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueStats"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}approximate_backlog_count\0\u{3}approximate_backlog_age\0\u{3}tasks_add_rate\0\u{3}tasks_dispatch_rate\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.approximateBacklogCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._approximateBacklogAge) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.tasksAddRate) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.tasksDispatchRate) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.approximateBacklogCount != 0 {
      try visitor.visitSingularInt64Field(value: self.approximateBacklogCount, fieldNumber: 1)
    }
    try { if let v = self._approximateBacklogAge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.tasksAddRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tasksAddRate, fieldNumber: 3)
    }
    if self.tasksDispatchRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tasksDispatchRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueStats, rhs: Temporal_Api_Taskqueue_V1_TaskQueueStats) -> Bool {
    if lhs.approximateBacklogCount != rhs.approximateBacklogCount {return false}
    if lhs._approximateBacklogAge != rhs._approximateBacklogAge {return false}
    if lhs.tasksAddRate != rhs.tasksAddRate {return false}
    if lhs.tasksDispatchRate != rhs.tasksDispatchRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueStatus"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}backlog_count_hint\0\u{3}read_level\0\u{3}ack_level\0\u{3}rate_per_second\0\u{3}task_id_block\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.backlogCountHint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.readLevel) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ackLevel) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.ratePerSecond) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._taskIDBlock) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.backlogCountHint != 0 {
      try visitor.visitSingularInt64Field(value: self.backlogCountHint, fieldNumber: 1)
    }
    if self.readLevel != 0 {
      try visitor.visitSingularInt64Field(value: self.readLevel, fieldNumber: 2)
    }
    if self.ackLevel != 0 {
      try visitor.visitSingularInt64Field(value: self.ackLevel, fieldNumber: 3)
    }
    if self.ratePerSecond.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.ratePerSecond, fieldNumber: 4)
    }
    try { if let v = self._taskIDBlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueStatus, rhs: Temporal_Api_Taskqueue_V1_TaskQueueStatus) -> Bool {
    if lhs.backlogCountHint != rhs.backlogCountHint {return false}
    if lhs.readLevel != rhs.readLevel {return false}
    if lhs.ackLevel != rhs.ackLevel {return false}
    if lhs.ratePerSecond != rhs.ratePerSecond {return false}
    if lhs._taskIDBlock != rhs._taskIDBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskIdBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskIdBlock"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_id\0\u{3}end_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startID != 0 {
      try visitor.visitSingularInt64Field(value: self.startID, fieldNumber: 1)
    }
    if self.endID != 0 {
      try visitor.visitSingularInt64Field(value: self.endID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskIdBlock, rhs: Temporal_Api_Taskqueue_V1_TaskIdBlock) -> Bool {
    if lhs.startID != rhs.startID {return false}
    if lhs.endID != rhs.endID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueuePartitionMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}owner_host_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerHostName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.ownerHostName.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerHostName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata, rhs: Temporal_Api_Taskqueue_V1_TaskQueuePartitionMetadata) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.ownerHostName != rhs.ownerHostName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_PollerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollerInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_access_time\0\u{1}identity\0\u{3}rate_per_second\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastAccessTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.ratePerSecond) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastAccessTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if self.ratePerSecond.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.ratePerSecond, fieldNumber: 3)
    }
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_PollerInfo, rhs: Temporal_Api_Taskqueue_V1_PollerInfo) -> Bool {
    if lhs._lastAccessTime != rhs._lastAccessTime {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ratePerSecond != rhs.ratePerSecond {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_StickyExecutionAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StickyExecutionAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_task_queue\0\u{3}schedule_to_start_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerTaskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduleToStartTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerTaskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scheduleToStartTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_StickyExecutionAttributes, rhs: Temporal_Api_Taskqueue_V1_StickyExecutionAttributes) -> Bool {
    if lhs._workerTaskQueue != rhs._workerTaskQueue {return false}
    if lhs._scheduleToStartTimeout != rhs._scheduleToStartTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_CompatibleVersionSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompatibleVersionSet"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_ids\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_CompatibleVersionSet, rhs: Temporal_Api_Taskqueue_V1_CompatibleVersionSet) -> Bool {
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueReachability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueReachability"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{1}reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 1)
    }
    if !self.reachability.isEmpty {
      try visitor.visitPackedEnumField(value: self.reachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueReachability, rhs: Temporal_Api_Taskqueue_V1_TaskQueueReachability) -> Bool {
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_BuildIdReachability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BuildIdReachability"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id\0\u{3}task_queue_reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.taskQueueReachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 1)
    }
    if !self.taskQueueReachability.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskQueueReachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_BuildIdReachability, rhs: Temporal_Api_Taskqueue_V1_BuildIdReachability) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.taskQueueReachability != rhs.taskQueueReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_RampByPercentage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RampByPercentage"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}ramp_percentage\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rampPercentage) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rampPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rampPercentage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_RampByPercentage, rhs: Temporal_Api_Taskqueue_V1_RampByPercentage) -> Bool {
    if lhs.rampPercentage != rhs.rampPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_build_id\0\u{4}\u{2}percentage_ramp\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      case 3: try {
        var v: Temporal_Api_Taskqueue_V1_RampByPercentage?
        var hadOneofValue = false
        if let current = self.ramp {
          hadOneofValue = true
          if case .percentageRamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ramp = .percentageRamp(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 1)
    }
    try { if case .percentageRamp(let v)? = self.ramp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule, rhs: Temporal_Api_Taskqueue_V1_BuildIdAssignmentRule) -> Bool {
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.ramp != rhs.ramp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_build_id\0\u{3}target_build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceBuildID, fieldNumber: 1)
    }
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule, rhs: Temporal_Api_Taskqueue_V1_CompatibleBuildIdRedirectRule) -> Bool {
    if lhs.sourceBuildID != rhs.sourceBuildID {return false}
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimestampedBuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}create_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule, rhs: Temporal_Api_Taskqueue_V1_TimestampedBuildIdAssignmentRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimestampedCompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}create_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule, rhs: Temporal_Api_Taskqueue_V1_TimestampedCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_PollerScalingDecision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollerScalingDecision"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}poll_request_delta_suggestion\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pollRequestDeltaSuggestion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pollRequestDeltaSuggestion != 0 {
      try visitor.visitSingularInt32Field(value: self.pollRequestDeltaSuggestion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_PollerScalingDecision, rhs: Temporal_Api_Taskqueue_V1_PollerScalingDecision) -> Bool {
    if lhs.pollRequestDeltaSuggestion != rhs.pollRequestDeltaSuggestion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RateLimit"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requests_per_second\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.requestsPerSecond) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestsPerSecond.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.requestsPerSecond, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_RateLimit, rhs: Temporal_Api_Taskqueue_V1_RateLimit) -> Bool {
    if lhs.requestsPerSecond != rhs.requestsPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_ConfigMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ConfigMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{3}update_identity\0\u{3}update_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.updateIdentity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    if !self.updateIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.updateIdentity, fieldNumber: 2)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_ConfigMetadata, rhs: Temporal_Api_Taskqueue_V1_ConfigMetadata) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.updateIdentity != rhs.updateIdentity {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_RateLimitConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RateLimitConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rate_limit\0\u{1}metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rateLimit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_RateLimitConfig, rhs: Temporal_Api_Taskqueue_V1_RateLimitConfig) -> Bool {
    if lhs._rateLimit != rhs._rateLimit {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Taskqueue_V1_TaskQueueConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}queue_rate_limit\0\u{3}fairness_keys_rate_limit_default\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queueRateLimit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fairnessKeysRateLimitDefault) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queueRateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fairnessKeysRateLimitDefault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Taskqueue_V1_TaskQueueConfig, rhs: Temporal_Api_Taskqueue_V1_TaskQueueConfig) -> Bool {
    if lhs._queueRateLimit != rhs._queueRateLimit {return false}
    if lhs._fairnessKeysRateLimitDefault != rhs._fairnessKeysRateLimitDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
