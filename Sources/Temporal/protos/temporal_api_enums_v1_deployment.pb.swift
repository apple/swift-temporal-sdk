// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/deployment.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Specify the reachability level for a deployment so users can decide if it is time to
/// decommission the deployment.
package enum Temporal_Api_Enums_V1_DeploymentReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Reachability level is not specified.
  case unspecified // = 0

  /// The deployment is reachable by new and/or open workflows. The deployment cannot be
  /// decommissioned safely.
  case reachable // = 1

  /// The deployment is not reachable by new or open workflows, but might be still needed by
  /// Queries sent to closed workflows. The deployment can be decommissioned safely if user does
  /// not query closed workflows.
  case closedWorkflowsOnly // = 2

  /// The deployment is not reachable by any workflow because all the workflows who needed this
  /// deployment went out of retention period. The deployment can be decommissioned safely.
  case unreachable // = 3
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .reachable
    case 2: self = .closedWorkflowsOnly
    case 3: self = .unreachable
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .reachable: return 1
    case .closedWorkflowsOnly: return 2
    case .unreachable: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_DeploymentReachability] = [
    .unspecified,
    .reachable,
    .closedWorkflowsOnly,
    .unreachable,
  ]

}

/// (-- api-linter: core::0216::synonyms=disabled
///     aip.dev/not-precedent: Call this status because it is . --)
/// Specify the drainage status for a Worker Deployment Version so users can decide whether they
/// can safely decommission the version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package enum Temporal_Api_Enums_V1_VersionDrainageStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int

  /// Drainage Status is not specified.
  case unspecified // = 0

  /// The Worker Deployment Version is not used by new workflows but is still used by
  /// open pinned workflows. The version cannot be decommissioned safely.
  case draining // = 1

  /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
  /// Queries sent to closed workflows. The version can be decommissioned safely if user does
  /// not query closed workflows. If the user does query closed workflows for some time x after
  /// workflows are closed, they should decommission the version after it has been drained for that duration.
  case drained // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .draining
    case 2: self = .drained
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .draining: return 1
    case .drained: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_VersionDrainageStatus] = [
    .unspecified,
    .draining,
    .drained,
  ]

}

/// Versioning Mode of a worker is set by the app developer in the worker code, and specifies the
/// behavior of the system in the following related aspects:
/// - Whether or not Temporal Server considers this worker's version (Build ID) when dispatching
///   tasks to it.
/// - Whether or not the workflows processed by this worker are versioned using the worker's version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package enum Temporal_Api_Enums_V1_WorkerVersioningMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// Workers with this mode are not distinguished from each other for task routing, even if they
  /// have different Build IDs.
  /// Workflows processed by this worker will be unversioned and user needs to use Patching to keep
  /// the new code compatible with prior versions.
  /// This mode is recommended to be used along with Rolling Upgrade deployment strategies.
  /// Workers with this mode are represented by the special string `__unversioned__` in the APIs.
  case unversioned // = 1

  /// Workers with this mode are part of a Worker Deployment Version which is identified as
  /// "<deployment_name>.<build_id>". Such workers are called "versioned" as opposed to
  /// "unversioned".
  /// Each Deployment Version is distinguished from other Versions for task routing and users can
  /// configure Temporal Server to send tasks to a particular Version (see
  /// `WorkerDeploymentInfo.routing_config`). This mode is the best option for Blue/Green and
  /// Rainbow strategies (but typically not suitable for Rolling upgrades.)
  /// Workflow Versioning Behaviors are enabled in this mode: each workflow type must choose
  /// between the Pinned and AutoUpgrade behaviors. Depending on the chosen behavior, the user may
  /// or may not need to use Patching to keep the new code compatible with prior versions. (see
  /// VersioningBehavior enum.)
  case versioned // = 2
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .unversioned
    case 2: self = .versioned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .unversioned: return 1
    case .versioned: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkerVersioningMode] = [
    .unspecified,
    .unversioned,
    .versioned,
  ]

}

/// (-- api-linter: core::0216::synonyms=disabled
///     aip.dev/not-precedent: Call this status because it is . --)
/// Specify the status of a Worker Deployment Version.
/// Experimental. Worker Deployments are experimental and might significantly change in the future.
package enum Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  package typealias RawValue = Int
  case unspecified // = 0

  /// The Worker Deployment Version has been created inside the Worker Deployment but is not used by any
  /// workflow executions. These Versions can still have workflows if they have an explicit Versioning Override targeting
  /// this Version. Such Versioning Override could be set at workflow start time, or at a later time via `UpdateWorkflowExecutionOptions`.
  case inactive // = 1

  /// The Worker Deployment Version is the current version of the Worker Deployment. All new workflow executions 
  /// and tasks of existing unversioned or AutoUpgrade workflows are routed to this version.
  case current // = 2

  /// The Worker Deployment Version is the ramping version of the Worker Deployment. A subset of new Pinned workflow executions are 
  /// routed to this version. Moreover, a portion of existing unversioned or AutoUpgrade workflow executions are also routed to this version.
  case ramping // = 3

  /// The Worker Deployment Version is not used by new workflows but is still used by
  /// open pinned workflows. The version cannot be decommissioned safely.
  case draining // = 4

  /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
  /// Queries sent to closed workflows. The version can be decommissioned safely if user does
  /// not query closed workflows. If the user does query closed workflows for some time x after
  /// workflows are closed, they should decommission the version after it has been drained for that duration.
  case drained // = 5
  case UNRECOGNIZED(Int)

  package init() {
    self = .unspecified
  }

  package init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .inactive
    case 2: self = .current
    case 3: self = .ramping
    case 4: self = .draining
    case 5: self = .drained
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  package var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .inactive: return 1
    case .current: return 2
    case .ramping: return 3
    case .draining: return 4
    case .drained: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  package static let allCases: [Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus] = [
    .unspecified,
    .inactive,
    .current,
    .ramping,
    .draining,
    .drained,
  ]

}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Temporal_Api_Enums_V1_DeploymentReachability: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEPLOYMENT_REACHABILITY_UNSPECIFIED\0\u{1}DEPLOYMENT_REACHABILITY_REACHABLE\0\u{1}DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY\0\u{1}DEPLOYMENT_REACHABILITY_UNREACHABLE\0")
}

extension Temporal_Api_Enums_V1_VersionDrainageStatus: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VERSION_DRAINAGE_STATUS_UNSPECIFIED\0\u{1}VERSION_DRAINAGE_STATUS_DRAINING\0\u{1}VERSION_DRAINAGE_STATUS_DRAINED\0")
}

extension Temporal_Api_Enums_V1_WorkerVersioningMode: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKER_VERSIONING_MODE_UNSPECIFIED\0\u{1}WORKER_VERSIONING_MODE_UNVERSIONED\0\u{1}WORKER_VERSIONING_MODE_VERSIONED\0")
}

extension Temporal_Api_Enums_V1_WorkerDeploymentVersionStatus: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED\0")
}
