// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/command/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

package struct Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var activityID: String {
    get {return _storage._activityID}
    set {_uniqueStorage()._activityID = newValue}
  }

  package var activityType: Temporal_Api_Common_V1_ActivityType {
    get {return _storage._activityType ?? Temporal_Api_Common_V1_ActivityType()}
    set {_uniqueStorage()._activityType = newValue}
  }
  /// Returns true if `activityType` has been explicitly set.
  package var hasActivityType: Bool {return _storage._activityType != nil}
  /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
  package mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Indicates how long the caller is willing to wait for activity completion. The "schedule" time
  /// is when the activity is initially scheduled, not when the most recent retry is scheduled.
  /// Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
  /// specified. When not specified, defaults to the workflow execution timeout.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return _storage._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

  /// Limits the time an activity task can stay in a task queue before a worker picks it up. The
  /// "schedule" time is when the most recent retry is scheduled. This timeout should usually not
  /// be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
  /// always non retryable, as all a retry would achieve is to put it back into the same queue.
  /// Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
  /// specified. More info:
  /// https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._scheduleToStartTimeout = newValue}
  }
  /// Returns true if `scheduleToStartTimeout` has been explicitly set.
  package var hasScheduleToStartTimeout: Bool {return _storage._scheduleToStartTimeout != nil}
  /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

  /// Maximum time an activity is allowed to execute after being picked up by a worker. This
  /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._startToCloseTimeout = newValue}
  }
  /// Returns true if `startToCloseTimeout` has been explicitly set.
  package var hasStartToCloseTimeout: Bool {return _storage._startToCloseTimeout != nil}
  /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

  /// Maximum permitted time between successful worker heartbeats.
  package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._heartbeatTimeout = newValue}
  }
  /// Returns true if `heartbeatTimeout` has been explicitly set.
  package var hasHeartbeatTimeout: Bool {return _storage._heartbeatTimeout != nil}
  /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

  /// Activities are provided by a default retry policy which is controlled through the service's
  /// dynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has
  /// elapsed. To disable retries set retry_policy.maximum_attempts to 1.
  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Request to start the activity directly bypassing matching service and worker polling
  /// The slot for executing the activity should be reserved when setting this field to true.
  package var requestEagerExecution: Bool {
    get {return _storage._requestEagerExecution}
    set {_uniqueStorage()._requestEagerExecution = newValue}
  }

  /// If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
  /// Assignment rules of the activity's Task Queue will be used to determine the Build ID.
  package var useWorkflowBuildID: Bool {
    get {return _storage._useWorkflowBuildID}
    set {_uniqueStorage()._useWorkflowBuildID = newValue}
  }

  /// Priority metadata. If this message is not present, or any fields are not
  /// present, they inherit the values from the workflow.
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
  package var scheduledEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Command_V1_StartTimerCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// An id for the timer, currently live timers must have different ids. Typically autogenerated
  /// by the SDK.
  package var timerID: String = String()

  /// How long until the timer fires, producing a `TIMER_FIRED` event.
  ///
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _startToFireTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_startToFireTimeout = newValue}
  }
  /// Returns true if `startToFireTimeout` has been explicitly set.
  package var hasStartToFireTimeout: Bool {return self._startToFireTimeout != nil}
  /// Clears the value of `startToFireTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearStartToFireTimeout() {self._startToFireTimeout = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var result: Temporal_Api_Common_V1_Payloads {
    get {return _result ?? Temporal_Api_Common_V1_Payloads()}
    set {_result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  package var hasResult: Bool {return self._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  package mutating func clearResult() {self._result = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _result: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_Command_V1_CancelTimerCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The same timer id from the start timer command
  package var timerID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var details: Temporal_Api_Common_V1_Payloads {
    get {return _details ?? Temporal_Api_Common_V1_Payloads()}
    set {_details = newValue}
  }
  /// Returns true if `details` has been explicitly set.
  package var hasDetails: Bool {return self._details != nil}
  /// Clears the value of `details`. Subsequent reads from it will return its default value.
  package mutating func clearDetails() {self._details = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _details: Temporal_Api_Common_V1_Payloads? = nil
}

package struct Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var workflowID: String = String()

  package var runID: String = String()

  /// Deprecated.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Set this to true if the workflow being cancelled is a child of the workflow originating this
  /// command. The request will be rejected if it is set to true and the target workflow is *not*
  /// a child of the requesting workflow.
  package var childWorkflowOnly: Bool = false

  /// Reason for requesting the cancellation
  package var reason: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String = String()

  package var execution: Temporal_Api_Common_V1_WorkflowExecution {
    get {return _execution ?? Temporal_Api_Common_V1_WorkflowExecution()}
    set {_execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  package var hasExecution: Bool {return self._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  package mutating func clearExecution() {self._execution = nil}

  /// The workflow author-defined name of the signal to send to the workflow.
  package var signalName: String = String()

  /// Serialized value(s) to provide with the signal.
  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _input ?? Temporal_Api_Common_V1_Payloads()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Deprecated
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var control: String = String()

  /// Set this to true if the workflow being cancelled is a child of the workflow originating this
  /// command. The request will be rejected if it is set to true and the target workflow is *not*
  /// a child of the requesting workflow.
  package var childWorkflowOnly: Bool = false

  /// Headers that are passed by the workflow that is sending a signal to the external 
  /// workflow that is receiving this signal.
  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _execution: Temporal_Api_Common_V1_WorkflowExecution? = nil
  fileprivate var _input: Temporal_Api_Common_V1_Payloads? = nil
  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
}

package struct Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return self._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {self._searchAttributes = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
}

package struct Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If set, update the workflow memo with the provided values. The values will be merged with
  /// the existing memo. If the user wants to delete values, a default/empty Payload should be
  /// used as the value for the key being deleted.
  package var upsertedMemo: Temporal_Api_Common_V1_Memo {
    get {return _upsertedMemo ?? Temporal_Api_Common_V1_Memo()}
    set {_upsertedMemo = newValue}
  }
  /// Returns true if `upsertedMemo` has been explicitly set.
  package var hasUpsertedMemo: Bool {return self._upsertedMemo != nil}
  /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
  package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _upsertedMemo: Temporal_Api_Common_V1_Memo? = nil
}

package struct Temporal_Api_Command_V1_RecordMarkerCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var markerName: String = String()

  package var details: Dictionary<String,Temporal_Api_Common_V1_Payloads> = [:]

  package var header: Temporal_Api_Common_V1_Header {
    get {return _header ?? Temporal_Api_Common_V1_Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {self._header = nil}

  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {self._failure = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _header: Temporal_Api_Common_V1_Header? = nil
  fileprivate var _failure: Temporal_Api_Failure_V1_Failure? = nil
}

package struct Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// How long the workflow start will be delayed - not really a "backoff" in the traditional sense.
  package var backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._backoffStartInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._backoffStartInterval = newValue}
  }
  /// Returns true if `backoffStartInterval` has been explicitly set.
  package var hasBackoffStartInterval: Bool {return _storage._backoffStartInterval != nil}
  /// Clears the value of `backoffStartInterval`. Subsequent reads from it will return its default value.
  package mutating func clearBackoffStartInterval() {_uniqueStorage()._backoffStartInterval = nil}

  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Should be removed
  package var initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator {
    get {return _storage._initiator}
    set {_uniqueStorage()._initiator = newValue}
  }

  /// Should be removed
  package var failure: Temporal_Api_Failure_V1_Failure {
    get {return _storage._failure ?? Temporal_Api_Failure_V1_Failure()}
    set {_uniqueStorage()._failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  package var hasFailure: Bool {return _storage._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  package mutating func clearFailure() {_uniqueStorage()._failure = nil}

  /// Should be removed
  package var lastCompletionResult: Temporal_Api_Common_V1_Payloads {
    get {return _storage._lastCompletionResult ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._lastCompletionResult = newValue}
  }
  /// Returns true if `lastCompletionResult` has been explicitly set.
  package var hasLastCompletionResult: Bool {return _storage._lastCompletionResult != nil}
  /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
  package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

  /// Should be removed. Not necessarily unused but unclear and not exposed by SDKs.
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
  /// the assignment rules will be used to independently assign a Build ID to the new execution.
  /// Deprecated. Only considered for versioning v0.2.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritBuildID: Bool {
    get {return _storage._inheritBuildID}
    set {_uniqueStorage()._inheritBuildID = newValue}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var namespace: String {
    get {return _storage._namespace}
    set {_uniqueStorage()._namespace = newValue}
  }

  package var workflowID: String {
    get {return _storage._workflowID}
    set {_uniqueStorage()._workflowID = newValue}
  }

  package var workflowType: Temporal_Api_Common_V1_WorkflowType {
    get {return _storage._workflowType ?? Temporal_Api_Common_V1_WorkflowType()}
    set {_uniqueStorage()._workflowType = newValue}
  }
  /// Returns true if `workflowType` has been explicitly set.
  package var hasWorkflowType: Bool {return _storage._workflowType != nil}
  /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

  package var taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue {
    get {return _storage._taskQueue ?? Temporal_Api_Taskqueue_V1_TaskQueue()}
    set {_uniqueStorage()._taskQueue = newValue}
  }
  /// Returns true if `taskQueue` has been explicitly set.
  package var hasTaskQueue: Bool {return _storage._taskQueue != nil}
  /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
  package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

  package var input: Temporal_Api_Common_V1_Payloads {
    get {return _storage._input ?? Temporal_Api_Common_V1_Payloads()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {_uniqueStorage()._input = nil}

  /// Total workflow execution timeout including retries and continue as new.
  package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowExecutionTimeout = newValue}
  }
  /// Returns true if `workflowExecutionTimeout` has been explicitly set.
  package var hasWorkflowExecutionTimeout: Bool {return _storage._workflowExecutionTimeout != nil}
  /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

  /// Timeout of a single workflow run.
  package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowRunTimeout = newValue}
  }
  /// Returns true if `workflowRunTimeout` has been explicitly set.
  package var hasWorkflowRunTimeout: Bool {return _storage._workflowRunTimeout != nil}
  /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

  /// Timeout of a single workflow task.
  package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_uniqueStorage()._workflowTaskTimeout = newValue}
  }
  /// Returns true if `workflowTaskTimeout` has been explicitly set.
  package var hasWorkflowTaskTimeout: Bool {return _storage._workflowTaskTimeout != nil}
  /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

  /// Default: PARENT_CLOSE_POLICY_TERMINATE.
  package var parentClosePolicy: Temporal_Api_Enums_V1_ParentClosePolicy {
    get {return _storage._parentClosePolicy}
    set {_uniqueStorage()._parentClosePolicy = newValue}
  }

  package var control: String {
    get {return _storage._control}
    set {_uniqueStorage()._control = newValue}
  }

  /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
  package var workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy {
    get {return _storage._workflowIDReusePolicy}
    set {_uniqueStorage()._workflowIDReusePolicy = newValue}
  }

  package var retryPolicy: Temporal_Api_Common_V1_RetryPolicy {
    get {return _storage._retryPolicy ?? Temporal_Api_Common_V1_RetryPolicy()}
    set {_uniqueStorage()._retryPolicy = newValue}
  }
  /// Returns true if `retryPolicy` has been explicitly set.
  package var hasRetryPolicy: Bool {return _storage._retryPolicy != nil}
  /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
  package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

  /// Establish a cron schedule for the child workflow.
  package var cronSchedule: String {
    get {return _storage._cronSchedule}
    set {_uniqueStorage()._cronSchedule = newValue}
  }

  package var header: Temporal_Api_Common_V1_Header {
    get {return _storage._header ?? Temporal_Api_Common_V1_Header()}
    set {_uniqueStorage()._header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  package var hasHeader: Bool {return _storage._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  package mutating func clearHeader() {_uniqueStorage()._header = nil}

  package var memo: Temporal_Api_Common_V1_Memo {
    get {return _storage._memo ?? Temporal_Api_Common_V1_Memo()}
    set {_uniqueStorage()._memo = newValue}
  }
  /// Returns true if `memo` has been explicitly set.
  package var hasMemo: Bool {return _storage._memo != nil}
  /// Clears the value of `memo`. Subsequent reads from it will return its default value.
  package mutating func clearMemo() {_uniqueStorage()._memo = nil}

  package var searchAttributes: Temporal_Api_Common_V1_SearchAttributes {
    get {return _storage._searchAttributes ?? Temporal_Api_Common_V1_SearchAttributes()}
    set {_uniqueStorage()._searchAttributes = newValue}
  }
  /// Returns true if `searchAttributes` has been explicitly set.
  package var hasSearchAttributes: Bool {return _storage._searchAttributes != nil}
  /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
  package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

  /// If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
  /// rules of the child's Task Queue will be used to independently assign a Build ID to it.
  /// Deprecated. Only considered for versioning v0.2.
  ///
  /// NOTE: This field was marked as deprecated in the .proto file.
  package var inheritBuildID: Bool {
    get {return _storage._inheritBuildID}
    set {_uniqueStorage()._inheritBuildID = newValue}
  }

  /// Priority metadata. If this message is not present, or any fields are not
  /// present, they inherit the values from the workflow.
  package var priority: Temporal_Api_Common_V1_Priority {
    get {return _storage._priority ?? Temporal_Api_Common_V1_Priority()}
    set {_uniqueStorage()._priority = newValue}
  }
  /// Returns true if `priority` has been explicitly set.
  package var hasPriority: Bool {return _storage._priority != nil}
  /// Clears the value of `priority`. Subsequent reads from it will return its default value.
  package mutating func clearPriority() {_uniqueStorage()._priority = nil}

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

package struct Temporal_Api_Command_V1_ProtocolMessageCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The message ID of the message to which this command is a pointer.
  package var messageID: String = String()

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Endpoint name, must exist in the endpoint registry or this command will fail.
  package var endpoint: String = String()

  /// Service name.
  package var service: String = String()

  /// Operation name.
  package var operation: String = String()

  /// Input for the operation. The server converts this into Nexus request content and the appropriate content headers
  /// internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
  /// content is transformed back to the original Payload sent in this command.
  package var input: Temporal_Api_Common_V1_Payload {
    get {return _input ?? Temporal_Api_Common_V1_Payload()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  package var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  package mutating func clearInput() {self._input = nil}

  /// Schedule-to-close timeout for this operation.
  /// Indicates how long the caller is willing to wait for operation completion.
  /// Calls are retried internally by the server.
  /// (-- api-linter: core::0140::prepositions=disabled
  ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
  package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_scheduleToCloseTimeout = newValue}
  }
  /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
  package var hasScheduleToCloseTimeout: Bool {return self._scheduleToCloseTimeout != nil}
  /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
  package mutating func clearScheduleToCloseTimeout() {self._scheduleToCloseTimeout = nil}

  /// Header to attach to the Nexus request.
  /// Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
  /// transmitted to external services as-is.
  /// This is useful for propagating tracing information.
  /// Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
  /// transmitted to Nexus operations that may be external and are not traditional payloads.
  package var nexusHeader: Dictionary<String,String> = [:]

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  fileprivate var _input: Temporal_Api_Common_V1_Payload? = nil
  fileprivate var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

package struct Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
  /// The operation may ignore cancellation and end up with any completion state.
  package var scheduledEventID: Int64 = 0

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}
}

package struct Temporal_Api_Command_V1_Command: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var commandType: Temporal_Api_Enums_V1_CommandType = .unspecified

  /// Metadata on the command. This is sometimes carried over to the history event if one is
  /// created as a result of the command. Most commands won't have this information, and how this
  /// information is used is dependent upon the interface that reads it.
  ///
  /// Current well-known uses:
  ///  * start_child_workflow_execution_command_attributes - populates
  ///    temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details
  ///    are used by user interfaces to show fixed as-of-start workflow summary and details.
  ///  * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer
  ///    started where the summary is used to identify the timer.
  package var userMetadata: Temporal_Api_Sdk_V1_UserMetadata {
    get {return _userMetadata ?? Temporal_Api_Sdk_V1_UserMetadata()}
    set {_userMetadata = newValue}
  }
  /// Returns true if `userMetadata` has been explicitly set.
  package var hasUserMetadata: Bool {return self._userMetadata != nil}
  /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
  package mutating func clearUserMetadata() {self._userMetadata = nil}

  /// The command details. The type must match that in `command_type`.
  package var attributes: Temporal_Api_Command_V1_Command.OneOf_Attributes? = nil

  package var scheduleActivityTaskCommandAttributes: Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes {
    get {
      if case .scheduleActivityTaskCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes()
    }
    set {attributes = .scheduleActivityTaskCommandAttributes(newValue)}
  }

  package var startTimerCommandAttributes: Temporal_Api_Command_V1_StartTimerCommandAttributes {
    get {
      if case .startTimerCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_StartTimerCommandAttributes()
    }
    set {attributes = .startTimerCommandAttributes(newValue)}
  }

  package var completeWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes {
    get {
      if case .completeWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes()
    }
    set {attributes = .completeWorkflowExecutionCommandAttributes(newValue)}
  }

  package var failWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes {
    get {
      if case .failWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes()
    }
    set {attributes = .failWorkflowExecutionCommandAttributes(newValue)}
  }

  package var requestCancelActivityTaskCommandAttributes: Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes {
    get {
      if case .requestCancelActivityTaskCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes()
    }
    set {attributes = .requestCancelActivityTaskCommandAttributes(newValue)}
  }

  package var cancelTimerCommandAttributes: Temporal_Api_Command_V1_CancelTimerCommandAttributes {
    get {
      if case .cancelTimerCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_CancelTimerCommandAttributes()
    }
    set {attributes = .cancelTimerCommandAttributes(newValue)}
  }

  package var cancelWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes {
    get {
      if case .cancelWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes()
    }
    set {attributes = .cancelWorkflowExecutionCommandAttributes(newValue)}
  }

  package var requestCancelExternalWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes {
    get {
      if case .requestCancelExternalWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes()
    }
    set {attributes = .requestCancelExternalWorkflowExecutionCommandAttributes(newValue)}
  }

  package var recordMarkerCommandAttributes: Temporal_Api_Command_V1_RecordMarkerCommandAttributes {
    get {
      if case .recordMarkerCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_RecordMarkerCommandAttributes()
    }
    set {attributes = .recordMarkerCommandAttributes(newValue)}
  }

  package var continueAsNewWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes {
    get {
      if case .continueAsNewWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes()
    }
    set {attributes = .continueAsNewWorkflowExecutionCommandAttributes(newValue)}
  }

  package var startChildWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes {
    get {
      if case .startChildWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes()
    }
    set {attributes = .startChildWorkflowExecutionCommandAttributes(newValue)}
  }

  package var signalExternalWorkflowExecutionCommandAttributes: Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes {
    get {
      if case .signalExternalWorkflowExecutionCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes()
    }
    set {attributes = .signalExternalWorkflowExecutionCommandAttributes(newValue)}
  }

  package var upsertWorkflowSearchAttributesCommandAttributes: Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes {
    get {
      if case .upsertWorkflowSearchAttributesCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes()
    }
    set {attributes = .upsertWorkflowSearchAttributesCommandAttributes(newValue)}
  }

  package var protocolMessageCommandAttributes: Temporal_Api_Command_V1_ProtocolMessageCommandAttributes {
    get {
      if case .protocolMessageCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_ProtocolMessageCommandAttributes()
    }
    set {attributes = .protocolMessageCommandAttributes(newValue)}
  }

  /// 16 is available for use - it was used as part of a prototype that never made it into a release
  package var modifyWorkflowPropertiesCommandAttributes: Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes {
    get {
      if case .modifyWorkflowPropertiesCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes()
    }
    set {attributes = .modifyWorkflowPropertiesCommandAttributes(newValue)}
  }

  package var scheduleNexusOperationCommandAttributes: Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes {
    get {
      if case .scheduleNexusOperationCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes()
    }
    set {attributes = .scheduleNexusOperationCommandAttributes(newValue)}
  }

  package var requestCancelNexusOperationCommandAttributes: Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes {
    get {
      if case .requestCancelNexusOperationCommandAttributes(let v)? = attributes {return v}
      return Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes()
    }
    set {attributes = .requestCancelNexusOperationCommandAttributes(newValue)}
  }

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The command details. The type must match that in `command_type`.
  package enum OneOf_Attributes: Equatable, Sendable {
    case scheduleActivityTaskCommandAttributes(Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes)
    case startTimerCommandAttributes(Temporal_Api_Command_V1_StartTimerCommandAttributes)
    case completeWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes)
    case failWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes)
    case requestCancelActivityTaskCommandAttributes(Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes)
    case cancelTimerCommandAttributes(Temporal_Api_Command_V1_CancelTimerCommandAttributes)
    case cancelWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes)
    case requestCancelExternalWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes)
    case recordMarkerCommandAttributes(Temporal_Api_Command_V1_RecordMarkerCommandAttributes)
    case continueAsNewWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes)
    case startChildWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes)
    case signalExternalWorkflowExecutionCommandAttributes(Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes)
    case upsertWorkflowSearchAttributesCommandAttributes(Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes)
    case protocolMessageCommandAttributes(Temporal_Api_Command_V1_ProtocolMessageCommandAttributes)
    /// 16 is available for use - it was used as part of a prototype that never made it into a release
    case modifyWorkflowPropertiesCommandAttributes(Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes)
    case scheduleNexusOperationCommandAttributes(Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes)
    case requestCancelNexusOperationCommandAttributes(Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes)

  }

  package init() {}

  fileprivate var _userMetadata: Temporal_Api_Sdk_V1_UserMetadata? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.command.v1"

extension Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleActivityTaskCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}activity_type\0\u{4}\u{2}task_queue\0\u{1}header\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}request_eager_execution\0\u{3}use_workflow_build_id\0\u{1}priority\0\u{c}\u{3}\u{1}")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _activityType: Temporal_Api_Common_V1_ActivityType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _requestEagerExecution: Bool = false
    var _useWorkflowBuildID: Bool = false
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _header = source._header
      _input = source._input
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _requestEagerExecution = source._requestEagerExecution
      _useWorkflowBuildID = source._useWorkflowBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._requestEagerExecution) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._useWorkflowBuildID) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._requestEagerExecution != false {
        try visitor.visitSingularBoolField(value: _storage._requestEagerExecution, fieldNumber: 12)
      }
      if _storage._useWorkflowBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._useWorkflowBuildID, fieldNumber: 13)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes, rhs: Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._requestEagerExecution != rhs_storage._requestEagerExecution {return false}
        if _storage._useWorkflowBuildID != rhs_storage._useWorkflowBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelActivityTaskCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes, rhs: Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_StartTimerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartTimerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0\u{3}start_to_fire_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToFireTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    try { if let v = self._startToFireTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_StartTimerCommandAttributes, rhs: Temporal_Api_Command_V1_StartTimerCommandAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs._startToFireTimeout != rhs._startToFireTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompleteWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_CancelTimerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelTimerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_CancelTimerCommandAttributes, rhs: Temporal_Api_Command_V1_CancelTimerCommandAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{1}control\0\u{3}child_workflow_only\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 4)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}signal_name\0\u{1}input\0\u{1}control\0\u{3}child_workflow_only\0\u{1}header\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 5)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 6)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpsertWorkflowSearchAttributesCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes, rhs: Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes) -> Bool {
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ModifyWorkflowPropertiesCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes, rhs: Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes) -> Bool {
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_RecordMarkerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordMarkerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}marker_name\0\u{1}details\0\u{1}header\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.markerName) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payloads>.self, value: &self.details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.markerName.isEmpty {
      try visitor.visitSingularStringField(value: self.markerName, fieldNumber: 1)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Temporal_Api_Common_V1_Payloads>.self, value: self.details, fieldNumber: 2)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_RecordMarkerCommandAttributes, rhs: Temporal_Api_Command_V1_RecordMarkerCommandAttributes) -> Bool {
    if lhs.markerName != rhs.markerName {return false}
    if lhs.details != rhs.details {return false}
    if lhs._header != rhs._header {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ContinueAsNewWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}backoff_start_interval\0\u{3}retry_policy\0\u{1}initiator\0\u{1}failure\0\u{3}last_completion_result\0\u{3}cron_schedule\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}inherit_build_id\0")

  fileprivate class _StorageClass {
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _initiator: Temporal_Api_Enums_V1_ContinueAsNewInitiator = .unspecified
    var _failure: Temporal_Api_Failure_V1_Failure? = nil
    var _lastCompletionResult: Temporal_Api_Common_V1_Payloads? = nil
    var _cronSchedule: String = String()
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _inheritBuildID: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _backoffStartInterval = source._backoffStartInterval
      _retryPolicy = source._retryPolicy
      _initiator = source._initiator
      _failure = source._failure
      _lastCompletionResult = source._lastCompletionResult
      _cronSchedule = source._cronSchedule
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._backoffStartInterval) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._initiator) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._failure) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._backoffStartInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._initiator != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initiator, fieldNumber: 8)
      }
      try { if let v = _storage._failure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 11)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._backoffStartInterval != rhs_storage._backoffStartInterval {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._initiator != rhs_storage._initiator {return false}
        if _storage._failure != rhs_storage._failure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}parent_close_policy\0\u{1}control\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}inherit_build_id\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Temporal_Api_Common_V1_WorkflowType? = nil
    var _taskQueue: Temporal_Api_Taskqueue_V1_TaskQueue? = nil
    var _input: Temporal_Api_Common_V1_Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parentClosePolicy: Temporal_Api_Enums_V1_ParentClosePolicy = .unspecified
    var _control: String = String()
    var _workflowIDReusePolicy: Temporal_Api_Enums_V1_WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Temporal_Api_Common_V1_RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _header: Temporal_Api_Common_V1_Header? = nil
    var _memo: Temporal_Api_Common_V1_Memo? = nil
    var _searchAttributes: Temporal_Api_Common_V1_SearchAttributes? = nil
    var _inheritBuildID: Bool = false
    var _priority: Temporal_Api_Common_V1_Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _parentClosePolicy = source._parentClosePolicy
      _control = source._control
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._parentClosePolicy) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._control) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._parentClosePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._parentClosePolicy, fieldNumber: 9)
      }
      if !_storage._control.isEmpty {
        try visitor.visitSingularStringField(value: _storage._control, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 13)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 17)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes, rhs: Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._parentClosePolicy != rhs_storage._parentClosePolicy {return false}
        if _storage._control != rhs_storage._control {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_ProtocolMessageCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ProtocolMessageCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_ProtocolMessageCommandAttributes, rhs: Temporal_Api_Command_V1_ProtocolMessageCommandAttributes) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleNexusOperationCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}nexus_header\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._scheduleToCloseTimeout) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.nexusHeader) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scheduleToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.nexusHeader.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.nexusHeader, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes, rhs: Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._scheduleToCloseTimeout != rhs._scheduleToCloseTimeout {return false}
    if lhs.nexusHeader != rhs.nexusHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelNexusOperationCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes, rhs: Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Temporal_Api_Command_V1_Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Command"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}command_type\0\u{3}schedule_activity_task_command_attributes\0\u{3}start_timer_command_attributes\0\u{3}complete_workflow_execution_command_attributes\0\u{3}fail_workflow_execution_command_attributes\0\u{3}request_cancel_activity_task_command_attributes\0\u{3}cancel_timer_command_attributes\0\u{3}cancel_workflow_execution_command_attributes\0\u{3}request_cancel_external_workflow_execution_command_attributes\0\u{3}record_marker_command_attributes\0\u{3}continue_as_new_workflow_execution_command_attributes\0\u{3}start_child_workflow_execution_command_attributes\0\u{3}signal_external_workflow_execution_command_attributes\0\u{3}upsert_workflow_search_attributes_command_attributes\0\u{3}protocol_message_command_attributes\0\u{4}\u{2}modify_workflow_properties_command_attributes\0\u{3}schedule_nexus_operation_command_attributes\0\u{3}request_cancel_nexus_operation_command_attributes\0\u{4}Z\u{4}user_metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.commandType) }()
      case 2: try {
        var v: Temporal_Api_Command_V1_ScheduleActivityTaskCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .scheduleActivityTaskCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .scheduleActivityTaskCommandAttributes(v)
        }
      }()
      case 3: try {
        var v: Temporal_Api_Command_V1_StartTimerCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .startTimerCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .startTimerCommandAttributes(v)
        }
      }()
      case 4: try {
        var v: Temporal_Api_Command_V1_CompleteWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .completeWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .completeWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 5: try {
        var v: Temporal_Api_Command_V1_FailWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .failWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .failWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 6: try {
        var v: Temporal_Api_Command_V1_RequestCancelActivityTaskCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .requestCancelActivityTaskCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .requestCancelActivityTaskCommandAttributes(v)
        }
      }()
      case 7: try {
        var v: Temporal_Api_Command_V1_CancelTimerCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .cancelTimerCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .cancelTimerCommandAttributes(v)
        }
      }()
      case 8: try {
        var v: Temporal_Api_Command_V1_CancelWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .cancelWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .cancelWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 9: try {
        var v: Temporal_Api_Command_V1_RequestCancelExternalWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .requestCancelExternalWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .requestCancelExternalWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 10: try {
        var v: Temporal_Api_Command_V1_RecordMarkerCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .recordMarkerCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .recordMarkerCommandAttributes(v)
        }
      }()
      case 11: try {
        var v: Temporal_Api_Command_V1_ContinueAsNewWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .continueAsNewWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .continueAsNewWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 12: try {
        var v: Temporal_Api_Command_V1_StartChildWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .startChildWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .startChildWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 13: try {
        var v: Temporal_Api_Command_V1_SignalExternalWorkflowExecutionCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .signalExternalWorkflowExecutionCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .signalExternalWorkflowExecutionCommandAttributes(v)
        }
      }()
      case 14: try {
        var v: Temporal_Api_Command_V1_UpsertWorkflowSearchAttributesCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .upsertWorkflowSearchAttributesCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .upsertWorkflowSearchAttributesCommandAttributes(v)
        }
      }()
      case 15: try {
        var v: Temporal_Api_Command_V1_ProtocolMessageCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .protocolMessageCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .protocolMessageCommandAttributes(v)
        }
      }()
      case 17: try {
        var v: Temporal_Api_Command_V1_ModifyWorkflowPropertiesCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .modifyWorkflowPropertiesCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .modifyWorkflowPropertiesCommandAttributes(v)
        }
      }()
      case 18: try {
        var v: Temporal_Api_Command_V1_ScheduleNexusOperationCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .scheduleNexusOperationCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .scheduleNexusOperationCommandAttributes(v)
        }
      }()
      case 19: try {
        var v: Temporal_Api_Command_V1_RequestCancelNexusOperationCommandAttributes?
        var hadOneofValue = false
        if let current = self.attributes {
          hadOneofValue = true
          if case .requestCancelNexusOperationCommandAttributes(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.attributes = .requestCancelNexusOperationCommandAttributes(v)
        }
      }()
      case 301: try { try decoder.decodeSingularMessageField(value: &self._userMetadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.commandType != .unspecified {
      try visitor.visitSingularEnumField(value: self.commandType, fieldNumber: 1)
    }
    switch self.attributes {
    case .scheduleActivityTaskCommandAttributes?: try {
      guard case .scheduleActivityTaskCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startTimerCommandAttributes?: try {
      guard case .startTimerCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .completeWorkflowExecutionCommandAttributes?: try {
      guard case .completeWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .failWorkflowExecutionCommandAttributes?: try {
      guard case .failWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .requestCancelActivityTaskCommandAttributes?: try {
      guard case .requestCancelActivityTaskCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .cancelTimerCommandAttributes?: try {
      guard case .cancelTimerCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .cancelWorkflowExecutionCommandAttributes?: try {
      guard case .cancelWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .requestCancelExternalWorkflowExecutionCommandAttributes?: try {
      guard case .requestCancelExternalWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .recordMarkerCommandAttributes?: try {
      guard case .recordMarkerCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .continueAsNewWorkflowExecutionCommandAttributes?: try {
      guard case .continueAsNewWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .startChildWorkflowExecutionCommandAttributes?: try {
      guard case .startChildWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .signalExternalWorkflowExecutionCommandAttributes?: try {
      guard case .signalExternalWorkflowExecutionCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .upsertWorkflowSearchAttributesCommandAttributes?: try {
      guard case .upsertWorkflowSearchAttributesCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .protocolMessageCommandAttributes?: try {
      guard case .protocolMessageCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .modifyWorkflowPropertiesCommandAttributes?: try {
      guard case .modifyWorkflowPropertiesCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .scheduleNexusOperationCommandAttributes?: try {
      guard case .scheduleNexusOperationCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case .requestCancelNexusOperationCommandAttributes?: try {
      guard case .requestCancelNexusOperationCommandAttributes(let v)? = self.attributes else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
    }()
    case nil: break
    }
    try { if let v = self._userMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Temporal_Api_Command_V1_Command, rhs: Temporal_Api_Command_V1_Command) -> Bool {
    if lhs.commandType != rhs.commandType {return false}
    if lhs._userMetadata != rhs._userMetadata {return false}
    if lhs.attributes != rhs.attributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
