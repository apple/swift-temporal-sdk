// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/taskqueue/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Taskqueue.V1 {


  /// See https://docs.temporal.io/docs/concepts/task-queues/
  package struct TaskQueue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var name: String = String()

    /// Default: TASK_QUEUE_KIND_NORMAL.
    package var kind: Api.Enums.V1.TaskQueueKind = .unspecified

    /// Iff kind == TASK_QUEUE_KIND_STICKY, then this field contains the name of
    /// the normal task queue that the sticky worker is running on.
    package var normalName: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  /// Only applies to activity task queues
  package struct TaskQueueMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Allows throttling dispatch of tasks from this queue
    package var maxTasksPerSecond: SwiftProtobuf.Google_Protobuf_DoubleValue {
      get {_maxTasksPerSecond ?? SwiftProtobuf.Google_Protobuf_DoubleValue()}
      set {_maxTasksPerSecond = newValue}
    }
    /// Returns true if `maxTasksPerSecond` has been explicitly set.
    package var hasMaxTasksPerSecond: Bool {self._maxTasksPerSecond != nil}
    /// Clears the value of `maxTasksPerSecond`. Subsequent reads from it will return its default value.
    package mutating func clearMaxTasksPerSecond() {self._maxTasksPerSecond = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _maxTasksPerSecond: SwiftProtobuf.Google_Protobuf_DoubleValue? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  package struct TaskQueueVersioningInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Specifies which Deployment Version should receive new workflow executions and tasks of
    /// existing unversioned or AutoUpgrade workflows.
    /// Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    /// Note: Current Version is overridden by the Ramping Version for a portion of traffic when ramp percentage
    /// is non-zero (see `ramping_deployment_version` and `ramping_version_percentage`).
    package var currentDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_currentDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_currentDeploymentVersion = newValue}
    }
    /// Returns true if `currentDeploymentVersion` has been explicitly set.
    package var hasCurrentDeploymentVersion: Bool {self._currentDeploymentVersion != nil}
    /// Clears the value of `currentDeploymentVersion`. Subsequent reads from it will return its default value.
    package mutating func clearCurrentDeploymentVersion() {self._currentDeploymentVersion = nil}

    /// Deprecated. Use `current_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var currentVersion: String = String()

    /// When ramp percentage is non-zero, that portion of traffic is shifted from the Current Version to the Ramping Version.
    /// Must always be different from `current_deployment_version` unless both are nil.
    /// Nil value represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    /// Note that it is possible to ramp from one Version to another Version, or from unversioned
    /// workers to a particular Version, or from a particular Version to unversioned workers.
    package var rampingDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_rampingDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_rampingDeploymentVersion = newValue}
    }
    /// Returns true if `rampingDeploymentVersion` has been explicitly set.
    package var hasRampingDeploymentVersion: Bool {self._rampingDeploymentVersion != nil}
    /// Clears the value of `rampingDeploymentVersion`. Subsequent reads from it will return its default value.
    package mutating func clearRampingDeploymentVersion() {self._rampingDeploymentVersion = nil}

    /// Deprecated. Use `ramping_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var rampingVersion: String = String()

    /// Percentage of tasks that are routed to the Ramping Version instead of the Current Version.
    /// Valid range: [0, 100]. A 100% value means the Ramping Version is receiving full traffic but
    /// not yet "promoted" to be the Current Version, likely due to pending validations.
    /// A 0% value means the Ramping Version is receiving no traffic.
    package var rampingVersionPercentage: Float = 0

    /// Last time versioning information of this Task Queue changed.
    package var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_updateTime = newValue}
    }
    /// Returns true if `updateTime` has been explicitly set.
    package var hasUpdateTime: Bool {self._updateTime != nil}
    /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
    package mutating func clearUpdateTime() {self._updateTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _currentDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    fileprivate var _rampingDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// Used for specifying versions the caller is interested in.
  package struct TaskQueueVersionSelection: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Include specific Build IDs.
    package var buildIds: [String] = []

    /// Include the unversioned queue.
    package var unversioned: Bool = false

    /// Include all active versions. A version is considered active if, in the last few minutes,
    /// it has had new tasks or polls, or it has been the subject of certain task queue API calls.
    package var allActive: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct TaskQueueVersionInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Task Queue info per Task Type. Key is the numerical value of the temporal.api.enums.v1.TaskQueueType enum.
    package var typesInfo: Dictionary<Int32,Api.Taskqueue.V1.TaskQueueTypeInfo> = [:]

    /// Task Reachability is eventually consistent; there may be a delay until it converges to the most
    /// accurate value but it is designed in a way to take the more conservative side until it converges.
    /// For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
    ///
    /// Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
    /// accounted for reachability as server cannot know if they'll happen as they do not use
    /// assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
    /// who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
    /// sure to query reachability for the parent/previous workflow's Task Queue as well.
    package var taskReachability: Api.Enums.V1.BuildIdTaskReachability = .unspecified

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct TaskQueueTypeInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unversioned workers (with `useVersioning=false`) are reported in unversioned result even if they set a Build ID.
    package var pollers: [Api.Taskqueue.V1.PollerInfo] = []

    package var stats: Api.Taskqueue.V1.TaskQueueStats {
      get {_stats ?? Api.Taskqueue.V1.TaskQueueStats()}
      set {_stats = newValue}
    }
    /// Returns true if `stats` has been explicitly set.
    package var hasStats: Bool {self._stats != nil}
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    package mutating func clearStats() {self._stats = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _stats: Api.Taskqueue.V1.TaskQueueStats? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// TaskQueueStats contains statistics about task queue backlog and activity.
  ///
  /// For workflow task queue type, this result is partial because tasks sent to sticky queues are not included. Read
  /// comments above each metric to understand the impact of sticky queue exclusion on that metric accuracy.
  package struct TaskQueueStats: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The approximate number of tasks backlogged in this task queue. May count expired tasks but eventually
    /// converges to the right value. Can be relied upon for scaling decisions.
    ///
    /// Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
    /// those tasks only remain valid for a few seconds, the inaccuracy becomes less significant as the backlog size
    /// grows.
    package var approximateBacklogCount: Int64 = 0

    /// Approximate age of the oldest task in the backlog based on the creation time of the task at the head of
    /// the queue. Can be relied upon for scaling decisions.
    ///
    /// Special note for workflow task queue type: this metric does not count sticky queue tasks. However, because
    /// those tasks only remain valid for a few seconds, they should not affect the result when backlog is older than
    /// few seconds.
    package var approximateBacklogAge: SwiftProtobuf.Google_Protobuf_Duration {
      get {_approximateBacklogAge ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_approximateBacklogAge = newValue}
    }
    /// Returns true if `approximateBacklogAge` has been explicitly set.
    package var hasApproximateBacklogAge: Bool {self._approximateBacklogAge != nil}
    /// Clears the value of `approximateBacklogAge`. Subsequent reads from it will return its default value.
    package mutating func clearApproximateBacklogAge() {self._approximateBacklogAge = nil}

    /// The approximate tasks per second added to the task queue, averaging the last 30 seconds. These includes tasks
    /// whether or not they were added to/dispatched from the backlog or they were dispatched immediately without going
    /// to the backlog (sync-matched).
    ///
    /// The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
    /// backlog grows/shrinks.
    ///
    /// Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
    /// tasks_add_rate, because:
    /// - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
    ///   enable for activities by default in the latest SDKs.
    /// - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
    ///   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
    ///   worker instance.
    package var tasksAddRate: Float = 0

    /// The approximate tasks per second dispatched from the task queue, averaging the last 30 seconds. These includes
    /// tasks whether or not they were added to/dispatched from the backlog or they were dispatched immediately without
    /// going to the backlog (sync-matched).
    ///
    /// The difference between `tasks_add_rate` and `tasks_dispatch_rate` is a reliable metric for the rate at which
    /// backlog grows/shrinks.
    ///
    /// Note: the actual tasks delivered to the workers may significantly be higher than the numbers reported by
    /// tasks_dispatch_rate, because:
    /// - Tasks can be sent to workers without going to the task queue. This is called Eager dispatch. Eager dispatch is
    ///   enable for activities by default in the latest SDKs.
    /// - Tasks going to Sticky queue are not accounted for. Note that, typically, only the first workflow task of each
    ///   workflow goes to a normal queue, and the rest workflow tasks go to the Sticky queue associated with a specific
    ///   worker instance.
    package var tasksDispatchRate: Float = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _approximateBacklogAge: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// Deprecated. Use `InternalTaskQueueStatus`. This is kept until `DescribeTaskQueue` supports legacy behavior.
  package struct TaskQueueStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var backlogCountHint: Int64 = 0

    package var readLevel: Int64 = 0

    package var ackLevel: Int64 = 0

    package var ratePerSecond: Double = 0

    package var taskIDBlock: Api.Taskqueue.V1.TaskIdBlock {
      get {_taskIDBlock ?? Api.Taskqueue.V1.TaskIdBlock()}
      set {_taskIDBlock = newValue}
    }
    /// Returns true if `taskIDBlock` has been explicitly set.
    package var hasTaskIDBlock: Bool {self._taskIDBlock != nil}
    /// Clears the value of `taskIDBlock`. Subsequent reads from it will return its default value.
    package mutating func clearTaskIDBlock() {self._taskIDBlock = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _taskIDBlock: Api.Taskqueue.V1.TaskIdBlock? = nil
  }
}
extension Api.Taskqueue.V1 {


  package struct TaskIdBlock: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var startID: Int64 = 0

    package var endID: Int64 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct TaskQueuePartitionMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var key: String = String()

    package var ownerHostName: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct PollerInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var lastAccessTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastAccessTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastAccessTime = newValue}
    }
    /// Returns true if `lastAccessTime` has been explicitly set.
    package var hasLastAccessTime: Bool {self._lastAccessTime != nil}
    /// Clears the value of `lastAccessTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastAccessTime() {self._lastAccessTime = nil}

    package var identity: String = String()

    package var ratePerSecond: Double = 0

    /// If a worker has opted into the worker versioning feature while polling, its capabilities will
    /// appear here.
    /// Deprecated. Replaced by deployment_options.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities {
      get {_workerVersionCapabilities ?? Api.Common.V1.WorkerVersionCapabilities()}
      set {_workerVersionCapabilities = newValue}
    }
    /// Returns true if `workerVersionCapabilities` has been explicitly set.
    package var hasWorkerVersionCapabilities: Bool {self._workerVersionCapabilities != nil}
    /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
    package mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

    /// Worker deployment options that SDK sent to server.
    package var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    package var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    package mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _lastAccessTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Taskqueue.V1 {


  package struct StickyExecutionAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var workerTaskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_workerTaskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_workerTaskQueue = newValue}
    }
    /// Returns true if `workerTaskQueue` has been explicitly set.
    package var hasWorkerTaskQueue: Bool {self._workerTaskQueue != nil}
    /// Clears the value of `workerTaskQueue`. Subsequent reads from it will return its default value.
    package mutating func clearWorkerTaskQueue() {self._workerTaskQueue = nil}

    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {self._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {self._scheduleToStartTimeout = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _workerTaskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// Used by the worker versioning APIs, represents an unordered set of one or more versions which are
  /// considered to be compatible with each other. Currently the versions are always worker build IDs.
  package struct CompatibleVersionSet: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// All the compatible versions, unordered, except for the last element, which is considered the set "default".
    package var buildIds: [String] = []

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  /// Reachability of tasks for a worker on a single task queue.
  package struct TaskQueueReachability: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var taskQueue: String = String()

    /// Task reachability for a worker in a single task queue.
    /// See the TaskReachability docstring for information about each enum variant.
    /// If reachability is empty, this worker is considered unreachable in this task queue.
    package var reachability: [Api.Enums.V1.TaskReachability] = []

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  /// Reachability of tasks for a worker by build id, in one or more task queues.
  package struct BuildIdReachability: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A build id or empty if unversioned.
    package var buildID: String = String()

    /// Reachability per task queue.
    package var taskQueueReachability: [Api.Taskqueue.V1.TaskQueueReachability] = []

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct RampByPercentage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Acceptable range is [0,100).
    package var rampPercentage: Float = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  /// Assignment rules are applied to *new* Workflow and Activity executions at
  /// schedule time to assign them to a Build ID.
  ///
  /// Assignment rules will not be used in the following cases:
  ///    - Child Workflows or Continue-As-New Executions who inherit their
  ///      parent/previous Workflow's assigned Build ID (by setting the
  ///      `inherit_build_id` flag - default behavior in SDKs when the same Task Queue
  ///      is used.)
  ///    - An Activity that inherits the assigned Build ID of its Workflow (by
  ///      setting the `use_workflow_build_id` flag - default behavior in SDKs
  ///      when the same Task Queue is used.)
  ///
  /// In absence of (applicable) redirect rules (`CompatibleBuildIdRedirectRule`s)
  /// the task will be dispatched to Workers of the Build ID determined by the
  /// assignment rules (or inherited). Otherwise, the final Build ID will be
  /// determined by the redirect rules.
  ///
  /// Once a Workflow completes its first Workflow Task in a particular Build ID it
  /// stays in that Build ID regardless of changes to assignment rules. Redirect
  /// rules can be used to move the workflow to another compatible Build ID.
  ///
  /// When using Worker Versioning on a Task Queue, in the steady state,
  /// there should typically be a single assignment rule to send all new executions
  /// to the latest Build ID. Existence of at least one such "unconditional"
  /// rule at all times is enforces by the system, unless the `force` flag is used
  /// by the user when replacing/deleting these rules (for exceptional cases).
  ///
  /// During a deployment, one or more additional rules can be added to assign a
  /// subset of the tasks to a new Build ID based on a "ramp percentage".
  ///
  /// When there are multiple assignment rules for a Task Queue, the rules are
  /// evaluated in order, starting from index 0. The first applicable rule will be
  /// applied and the rest will be ignored.
  ///
  /// In the event that no assignment rule is applicable on a task (or the Task
  /// Queue is simply not versioned), the tasks will be dispatched to an
  /// unversioned Worker.
  package struct BuildIdAssignmentRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var targetBuildID: String = String()

    /// If a ramp is provided, this rule will be applied only to a sample of
    /// tasks according to the provided percentage.
    /// This option can be used only on "terminal" Build IDs (the ones not used
    /// as source in any redirect rules).
    package var ramp: Api.Taskqueue.V1.BuildIdAssignmentRule.OneOf_Ramp? = nil

    /// This ramp is useful for gradual Blue/Green deployments (and similar)
    /// where you want to send a certain portion of the traffic to the target
    /// Build ID.
    package var percentageRamp: Api.Taskqueue.V1.RampByPercentage {
      get {
        if case .percentageRamp(let v)? = ramp {return v}
        return Api.Taskqueue.V1.RampByPercentage()
      }
      set {ramp = .percentageRamp(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    /// If a ramp is provided, this rule will be applied only to a sample of
    /// tasks according to the provided percentage.
    /// This option can be used only on "terminal" Build IDs (the ones not used
    /// as source in any redirect rules).
    package enum OneOf_Ramp: Equatable, Sendable {
      /// This ramp is useful for gradual Blue/Green deployments (and similar)
      /// where you want to send a certain portion of the traffic to the target
      /// Build ID.
      case percentageRamp(Api.Taskqueue.V1.RampByPercentage)

    }

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  /// These rules apply to tasks assigned to a particular Build ID
  /// (`source_build_id`) to redirect them to another *compatible* Build ID
  /// (`target_build_id`).
  ///
  /// It is user's responsibility to ensure that the target Build ID is compatible
  /// with the source Build ID (e.g. by using the Patching API).
  ///
  /// Most deployments are not expected to need these rules, however following
  /// situations can greatly benefit from redirects:
  ///  - Need to move long-running Workflow Executions from an old Build ID to a
  ///    newer one.
  ///  - Need to hotfix some broken or stuck Workflow Executions.
  ///
  /// In steady state, redirect rules are beneficial when dealing with old
  /// Executions ran on now-decommissioned Build IDs:
  ///  - To redirecting the Workflow Queries to the current (compatible) Build ID.
  ///  - To be able to Reset an old Execution so it can run on the current
  ///    (compatible) Build ID.
  ///
  /// Redirect rules can be chained.
  package struct CompatibleBuildIdRedirectRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var sourceBuildID: String = String()

    /// Target Build ID must be compatible with the Source Build ID; that is it
    /// must be able to process event histories made by the Source Build ID by
    /// using [Patching](https://docs.temporal.io/workflows#patching) or other
    /// means.
    package var targetBuildID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct TimestampedBuildIdAssignmentRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var rule: Api.Taskqueue.V1.BuildIdAssignmentRule {
      get {_rule ?? Api.Taskqueue.V1.BuildIdAssignmentRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createTime = newValue}
    }
    /// Returns true if `createTime` has been explicitly set.
    package var hasCreateTime: Bool {self._createTime != nil}
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreateTime() {self._createTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Api.Taskqueue.V1.BuildIdAssignmentRule? = nil
    fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Taskqueue.V1 {


  package struct TimestampedCompatibleBuildIdRedirectRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule {
      get {_rule ?? Api.Taskqueue.V1.CompatibleBuildIdRedirectRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    package var hasRule: Bool {self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    package mutating func clearRule() {self._rule = nil}

    package var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createTime = newValue}
    }
    /// Returns true if `createTime` has been explicitly set.
    package var hasCreateTime: Bool {self._createTime != nil}
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreateTime() {self._createTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule? = nil
    fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Taskqueue.V1 {


  /// Attached to task responses to give hints to the SDK about how it may adjust its number of
  /// pollers.
  package struct PollerScalingDecision: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// How many poll requests to suggest should be added or removed, if any. As of now, server only
    /// scales up or down by 1. However, SDKs should allow for other values (while staying within
    /// defined min/max).
    ///
    /// The SDK is free to ignore this suggestion, EX: making more polls would not make sense because
    /// all slots are already occupied.
    package var pollRequestDeltaSuggestion: Int32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct RateLimit: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Zero is a valid rate limit.
    package var requestsPerSecond: Float = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Taskqueue.V1 {


  package struct ConfigMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Reason for why the config was set.
    package var reason: String = String()

    /// Identity of the last updater.
    /// Set by the request's identity field.
    package var updateIdentity: String = String()

    /// Time of the last update.
    package var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_updateTime = newValue}
    }
    /// Returns true if `updateTime` has been explicitly set.
    package var hasUpdateTime: Bool {self._updateTime != nil}
    /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
    package mutating func clearUpdateTime() {self._updateTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Taskqueue.V1 {


  package struct RateLimitConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var rateLimit: Api.Taskqueue.V1.RateLimit {
      get {_rateLimit ?? Api.Taskqueue.V1.RateLimit()}
      set {_rateLimit = newValue}
    }
    /// Returns true if `rateLimit` has been explicitly set.
    package var hasRateLimit: Bool {self._rateLimit != nil}
    /// Clears the value of `rateLimit`. Subsequent reads from it will return its default value.
    package mutating func clearRateLimit() {self._rateLimit = nil}

    package var metadata: Api.Taskqueue.V1.ConfigMetadata {
      get {_metadata ?? Api.Taskqueue.V1.ConfigMetadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    package var hasMetadata: Bool {self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    package mutating func clearMetadata() {self._metadata = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _rateLimit: Api.Taskqueue.V1.RateLimit? = nil
    fileprivate var _metadata: Api.Taskqueue.V1.ConfigMetadata? = nil
  }
}
extension Api.Taskqueue.V1 {


  package struct TaskQueueConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unless modified, this is the system-defined rate limit.
    package var queueRateLimit: Api.Taskqueue.V1.RateLimitConfig {
      get {_queueRateLimit ?? Api.Taskqueue.V1.RateLimitConfig()}
      set {_queueRateLimit = newValue}
    }
    /// Returns true if `queueRateLimit` has been explicitly set.
    package var hasQueueRateLimit: Bool {self._queueRateLimit != nil}
    /// Clears the value of `queueRateLimit`. Subsequent reads from it will return its default value.
    package mutating func clearQueueRateLimit() {self._queueRateLimit = nil}

    /// If set, each individual fairness key will be limited to this rate, scaled by the weight of the fairness key.
    package var fairnessKeysRateLimitDefault: Api.Taskqueue.V1.RateLimitConfig {
      get {_fairnessKeysRateLimitDefault ?? Api.Taskqueue.V1.RateLimitConfig()}
      set {_fairnessKeysRateLimitDefault = newValue}
    }
    /// Returns true if `fairnessKeysRateLimitDefault` has been explicitly set.
    package var hasFairnessKeysRateLimitDefault: Bool {self._fairnessKeysRateLimitDefault != nil}
    /// Clears the value of `fairnessKeysRateLimitDefault`. Subsequent reads from it will return its default value.
    package mutating func clearFairnessKeysRateLimitDefault() {self._fairnessKeysRateLimitDefault = nil}

    /// If set, overrides the fairness weights for the corresponding fairness keys.
    package var fairnessWeightOverrides: Dictionary<String,Float> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _queueRateLimit: Api.Taskqueue.V1.RateLimitConfig? = nil
    fileprivate var _fairnessKeysRateLimitDefault: Api.Taskqueue.V1.RateLimitConfig? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.taskqueue.v1"

extension Api.Taskqueue.V1.TaskQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueue"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}kind\0\u{3}normal_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.kind) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.normalName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.kind != .unspecified {
      try visitor.visitSingularEnumField(value: self.kind, fieldNumber: 2)
    }
    if !self.normalName.isEmpty {
      try visitor.visitSingularStringField(value: self.normalName, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueue, rhs: Api.Taskqueue.V1.TaskQueue) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.kind != rhs.kind {return false}
    if lhs.normalName != rhs.normalName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}max_tasks_per_second\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._maxTasksPerSecond) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxTasksPerSecond {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueMetadata, rhs: Api.Taskqueue.V1.TaskQueueMetadata) -> Bool {
    if lhs._maxTasksPerSecond != rhs._maxTasksPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueVersioningInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersioningInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_version\0\u{3}ramping_version\0\u{3}ramping_version_percentage\0\u{3}update_time\0\u{4}\u{3}current_deployment_version\0\u{4}\u{2}ramping_deployment_version\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.currentVersion) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.rampingVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.rampingVersionPercentage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._rampingDeploymentVersion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.currentVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.currentVersion, fieldNumber: 1)
    }
    if !self.rampingVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.rampingVersion, fieldNumber: 2)
    }
    if self.rampingVersionPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rampingVersionPercentage, fieldNumber: 3)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._currentDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._rampingDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueVersioningInfo, rhs: Api.Taskqueue.V1.TaskQueueVersioningInfo) -> Bool {
    if lhs._currentDeploymentVersion != rhs._currentDeploymentVersion {return false}
    if lhs.currentVersion != rhs.currentVersion {return false}
    if lhs._rampingDeploymentVersion != rhs._rampingDeploymentVersion {return false}
    if lhs.rampingVersion != rhs.rampingVersion {return false}
    if lhs.rampingVersionPercentage != rhs.rampingVersionPercentage {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueVersionSelection: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersionSelection"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_ids\0\u{1}unversioned\0\u{3}all_active\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.unversioned) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.allActive) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 1)
    }
    if self.unversioned != false {
      try visitor.visitSingularBoolField(value: self.unversioned, fieldNumber: 2)
    }
    if self.allActive != false {
      try visitor.visitSingularBoolField(value: self.allActive, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueVersionSelection, rhs: Api.Taskqueue.V1.TaskQueueVersionSelection) -> Bool {
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.unversioned != rhs.unversioned {return false}
    if lhs.allActive != rhs.allActive {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueVersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueVersionInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}types_info\0\u{3}task_reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueTypeInfo>.self, value: &self.typesInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.taskReachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.typesInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueTypeInfo>.self, value: self.typesInfo, fieldNumber: 1)
    }
    if self.taskReachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskReachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueVersionInfo, rhs: Api.Taskqueue.V1.TaskQueueVersionInfo) -> Bool {
    if lhs.typesInfo != rhs.typesInfo {return false}
    if lhs.taskReachability != rhs.taskReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueTypeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueTypeInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pollers\0\u{1}stats\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pollers) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pollers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pollers, fieldNumber: 1)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueTypeInfo, rhs: Api.Taskqueue.V1.TaskQueueTypeInfo) -> Bool {
    if lhs.pollers != rhs.pollers {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueStats: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueStats"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}approximate_backlog_count\0\u{3}approximate_backlog_age\0\u{3}tasks_add_rate\0\u{3}tasks_dispatch_rate\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.approximateBacklogCount) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._approximateBacklogAge) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.tasksAddRate) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.tasksDispatchRate) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.approximateBacklogCount != 0 {
      try visitor.visitSingularInt64Field(value: self.approximateBacklogCount, fieldNumber: 1)
    }
    try { if let v = self._approximateBacklogAge {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.tasksAddRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tasksAddRate, fieldNumber: 3)
    }
    if self.tasksDispatchRate.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.tasksDispatchRate, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueStats, rhs: Api.Taskqueue.V1.TaskQueueStats) -> Bool {
    if lhs.approximateBacklogCount != rhs.approximateBacklogCount {return false}
    if lhs._approximateBacklogAge != rhs._approximateBacklogAge {return false}
    if lhs.tasksAddRate != rhs.tasksAddRate {return false}
    if lhs.tasksDispatchRate != rhs.tasksDispatchRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueStatus"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}backlog_count_hint\0\u{3}read_level\0\u{3}ack_level\0\u{3}rate_per_second\0\u{3}task_id_block\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.backlogCountHint) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.readLevel) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.ackLevel) }()
      case 4: try { try decoder.decodeSingularDoubleField(value: &self.ratePerSecond) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._taskIDBlock) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.backlogCountHint != 0 {
      try visitor.visitSingularInt64Field(value: self.backlogCountHint, fieldNumber: 1)
    }
    if self.readLevel != 0 {
      try visitor.visitSingularInt64Field(value: self.readLevel, fieldNumber: 2)
    }
    if self.ackLevel != 0 {
      try visitor.visitSingularInt64Field(value: self.ackLevel, fieldNumber: 3)
    }
    if self.ratePerSecond.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.ratePerSecond, fieldNumber: 4)
    }
    try { if let v = self._taskIDBlock {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueStatus, rhs: Api.Taskqueue.V1.TaskQueueStatus) -> Bool {
    if lhs.backlogCountHint != rhs.backlogCountHint {return false}
    if lhs.readLevel != rhs.readLevel {return false}
    if lhs.ackLevel != rhs.ackLevel {return false}
    if lhs.ratePerSecond != rhs.ratePerSecond {return false}
    if lhs._taskIDBlock != rhs._taskIDBlock {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskIdBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskIdBlock"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_id\0\u{3}end_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.startID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.endID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startID != 0 {
      try visitor.visitSingularInt64Field(value: self.startID, fieldNumber: 1)
    }
    if self.endID != 0 {
      try visitor.visitSingularInt64Field(value: self.endID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskIdBlock, rhs: Api.Taskqueue.V1.TaskIdBlock) -> Bool {
    if lhs.startID != rhs.startID {return false}
    if lhs.endID != rhs.endID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueuePartitionMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueuePartitionMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}owner_host_name\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerHostName) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.ownerHostName.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerHostName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueuePartitionMetadata, rhs: Api.Taskqueue.V1.TaskQueuePartitionMetadata) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.ownerHostName != rhs.ownerHostName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.PollerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollerInfo"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_access_time\0\u{1}identity\0\u{3}rate_per_second\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastAccessTime) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.ratePerSecond) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastAccessTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if self.ratePerSecond.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.ratePerSecond, fieldNumber: 3)
    }
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.PollerInfo, rhs: Api.Taskqueue.V1.PollerInfo) -> Bool {
    if lhs._lastAccessTime != rhs._lastAccessTime {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ratePerSecond != rhs.ratePerSecond {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.StickyExecutionAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StickyExecutionAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_task_queue\0\u{3}schedule_to_start_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerTaskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduleToStartTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerTaskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._scheduleToStartTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.StickyExecutionAttributes, rhs: Api.Taskqueue.V1.StickyExecutionAttributes) -> Bool {
    if lhs._workerTaskQueue != rhs._workerTaskQueue {return false}
    if lhs._scheduleToStartTimeout != rhs._scheduleToStartTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.CompatibleVersionSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompatibleVersionSet"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_ids\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.CompatibleVersionSet, rhs: Api.Taskqueue.V1.CompatibleVersionSet) -> Bool {
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueReachability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueReachability"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{1}reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 2: try { try decoder.decodeRepeatedEnumField(value: &self.reachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 1)
    }
    if !self.reachability.isEmpty {
      try visitor.visitPackedEnumField(value: self.reachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueReachability, rhs: Api.Taskqueue.V1.TaskQueueReachability) -> Bool {
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.BuildIdReachability: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BuildIdReachability"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id\0\u{3}task_queue_reachability\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.taskQueueReachability) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 1)
    }
    if !self.taskQueueReachability.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taskQueueReachability, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.BuildIdReachability, rhs: Api.Taskqueue.V1.BuildIdReachability) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.taskQueueReachability != rhs.taskQueueReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.RampByPercentage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RampByPercentage"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}ramp_percentage\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.rampPercentage) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rampPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.rampPercentage, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.RampByPercentage, rhs: Api.Taskqueue.V1.RampByPercentage) -> Bool {
    if lhs.rampPercentage != rhs.rampPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.BuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".BuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_build_id\0\u{4}\u{2}percentage_ramp\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      case 3: try {
        var v: Api.Taskqueue.V1.RampByPercentage?
        var hadOneofValue = false
        if let current = self.ramp {
          hadOneofValue = true
          if case .percentageRamp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.ramp = .percentageRamp(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 1)
    }
    try { if case .percentageRamp(let v)? = self.ramp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.BuildIdAssignmentRule, rhs: Api.Taskqueue.V1.BuildIdAssignmentRule) -> Bool {
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.ramp != rhs.ramp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.CompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_build_id\0\u{3}target_build_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceBuildID, fieldNumber: 1)
    }
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule, rhs: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule) -> Bool {
    if lhs.sourceBuildID != rhs.sourceBuildID {return false}
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TimestampedBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimestampedBuildIdAssignmentRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}create_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TimestampedBuildIdAssignmentRule, rhs: Api.Taskqueue.V1.TimestampedBuildIdAssignmentRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TimestampedCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TimestampedCompatibleBuildIdRedirectRule"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}create_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TimestampedCompatibleBuildIdRedirectRule, rhs: Api.Taskqueue.V1.TimestampedCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.PollerScalingDecision: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".PollerScalingDecision"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}poll_request_delta_suggestion\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pollRequestDeltaSuggestion) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pollRequestDeltaSuggestion != 0 {
      try visitor.visitSingularInt32Field(value: self.pollRequestDeltaSuggestion, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.PollerScalingDecision, rhs: Api.Taskqueue.V1.PollerScalingDecision) -> Bool {
    if lhs.pollRequestDeltaSuggestion != rhs.pollRequestDeltaSuggestion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.RateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RateLimit"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requests_per_second\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.requestsPerSecond) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestsPerSecond.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.requestsPerSecond, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.RateLimit, rhs: Api.Taskqueue.V1.RateLimit) -> Bool {
    if lhs.requestsPerSecond != rhs.requestsPerSecond {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.ConfigMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ConfigMetadata"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{3}update_identity\0\u{3}update_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.updateIdentity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 1)
    }
    if !self.updateIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.updateIdentity, fieldNumber: 2)
    }
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.ConfigMetadata, rhs: Api.Taskqueue.V1.ConfigMetadata) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.updateIdentity != rhs.updateIdentity {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.RateLimitConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RateLimitConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rate_limit\0\u{1}metadata\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rateLimit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.RateLimitConfig, rhs: Api.Taskqueue.V1.RateLimitConfig) -> Bool {
    if lhs._rateLimit != rhs._rateLimit {return false}
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Taskqueue.V1.TaskQueueConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".TaskQueueConfig"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}queue_rate_limit\0\u{3}fairness_keys_rate_limit_default\0\u{3}fairness_weight_overrides\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queueRateLimit) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._fairnessKeysRateLimitDefault) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: &self.fairnessWeightOverrides) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queueRateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fairnessKeysRateLimitDefault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.fairnessWeightOverrides.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: self.fairnessWeightOverrides, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Taskqueue.V1.TaskQueueConfig, rhs: Api.Taskqueue.V1.TaskQueueConfig) -> Bool {
    if lhs._queueRateLimit != rhs._queueRateLimit {return false}
    if lhs._fairnessKeysRateLimitDefault != rhs._fairnessKeysRateLimitDefault {return false}
    if lhs.fairnessWeightOverrides != rhs.fairnessWeightOverrides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
