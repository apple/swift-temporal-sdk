// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/operatorservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import Foundation
public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Operatorservice.V1 {


  public struct AddSearchAttributesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Mapping between search attribute name and its IndexedValueType.
    public var searchAttributes: Dictionary<String,Api.Enums.V1.IndexedValueType> = [:]

    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct AddSearchAttributesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct RemoveSearchAttributesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Search attribute names to delete.
    public var searchAttributes: [String] = []

    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct RemoveSearchAttributesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListSearchAttributesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListSearchAttributesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Mapping between custom (user-registered) search attribute name to its IndexedValueType.
    public var customAttributes: Dictionary<String,Api.Enums.V1.IndexedValueType> = [:]

    /// Mapping between system (predefined) search attribute name to its IndexedValueType.
    public var systemAttributes: Dictionary<String,Api.Enums.V1.IndexedValueType> = [:]

    /// Mapping from the attribute name to the visibility storage native type.
    public var storageSchema: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct DeleteNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Only one of namespace or namespace_id must be specified to identify namespace.
    public var namespace: String = String()

    public var namespaceID: String = String()

    /// If provided, the deletion of namespace info will be delayed for the given duration (0 means no delay).
    /// If not provided, the default delay configured in the cluster will be used.
    public var namespaceDeleteDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {_namespaceDeleteDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_namespaceDeleteDelay = newValue}
    }
    /// Returns true if `namespaceDeleteDelay` has been explicitly set.
    public var hasNamespaceDeleteDelay: Bool {self._namespaceDeleteDelay != nil}
    /// Clears the value of `namespaceDeleteDelay`. Subsequent reads from it will return its default value.
    public mutating func clearNamespaceDeleteDelay() {self._namespaceDeleteDelay = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _namespaceDeleteDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct DeleteNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Temporary namespace name that is used during reclaim resources step.
    public var deletedNamespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct AddOrUpdateRemoteClusterRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Frontend Address is a cross cluster accessible address for gRPC traffic. This field is required.
    public var frontendAddress: String = String()

    /// Flag to enable / disable the cross cluster connection.
    public var enableRemoteClusterConnection: Bool = false

    /// Frontend HTTP Address is a cross cluster accessible address for HTTP traffic. This field is optional. If not provided
    ///  on update, the existing HTTP address will be removed.
    public var frontendHTTPAddress: String = String()

    /// Controls whether replication streams are active.
    public var enableReplication: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct AddOrUpdateRemoteClusterResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct RemoveRemoteClusterRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Remote cluster name to be removed.
    public var clusterName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct RemoveRemoteClusterResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListClustersRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListClustersResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of all cluster information
    public var clusters: [Api.Operatorservice.V1.ClusterMetadata] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ClusterMetadata: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Name of the cluster name.
    public var clusterName: String = String()

    /// Id of the cluster.
    public var clusterID: String = String()

    /// gRPC address.
    public var address: String = String()

    /// HTTP address, if one exists.
    public var httpAddress: String = String()

    /// A unique failover version across all connected clusters.
    public var initialFailoverVersion: Int64 = 0

    /// History service shard number.
    public var historyShardCount: Int32 = 0

    /// A flag to indicate if a connection is active.
    public var isConnectionEnabled: Bool = false

    /// A flag to indicate if replication is enabled.
    public var isReplicationEnabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct GetNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server-generated unique endpoint ID.
    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct GetNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var endpoint: Api.Nexus.V1.Endpoint {
      get {_endpoint ?? Api.Nexus.V1.Endpoint()}
      set {_endpoint = newValue}
    }
    /// Returns true if `endpoint` has been explicitly set.
    public var hasEndpoint: Bool {self._endpoint != nil}
    /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
    public mutating func clearEndpoint() {self._endpoint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endpoint: Api.Nexus.V1.Endpoint? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct CreateNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Endpoint definition to create.
    public var spec: Api.Nexus.V1.EndpointSpec {
      get {_spec ?? Api.Nexus.V1.EndpointSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Nexus.V1.EndpointSpec? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct CreateNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Data post acceptance. Can be used to issue additional updates to this record.
    public var endpoint: Api.Nexus.V1.Endpoint {
      get {_endpoint ?? Api.Nexus.V1.Endpoint()}
      set {_endpoint = newValue}
    }
    /// Returns true if `endpoint` has been explicitly set.
    public var hasEndpoint: Bool {self._endpoint != nil}
    /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
    public mutating func clearEndpoint() {self._endpoint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endpoint: Api.Nexus.V1.Endpoint? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct UpdateNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server-generated unique endpoint ID.
    public var id: String = String()

    /// Data version for this endpoint. Must match current version.
    public var version: Int64 = 0

    public var spec: Api.Nexus.V1.EndpointSpec {
      get {_spec ?? Api.Nexus.V1.EndpointSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Nexus.V1.EndpointSpec? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct UpdateNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Data post acceptance. Can be used to issue additional updates to this record.
    public var endpoint: Api.Nexus.V1.Endpoint {
      get {_endpoint ?? Api.Nexus.V1.Endpoint()}
      set {_endpoint = newValue}
    }
    /// Returns true if `endpoint` has been explicitly set.
    public var hasEndpoint: Bool {self._endpoint != nil}
    /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
    public mutating func clearEndpoint() {self._endpoint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endpoint: Api.Nexus.V1.Endpoint? = nil
  }
}
extension Api.Operatorservice.V1 {


  public struct DeleteNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server-generated unique endpoint ID.
    public var id: String = String()

    /// Data version for this endpoint. Must match current version.
    public var version: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct DeleteNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListNexusEndpointsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pageSize: Int32 = 0

    /// To get the next page, pass in `ListNexusEndpointsResponse.next_page_token` from the previous page's
    /// response, the token will be empty if there's no other page.
    /// Note: the last page may be empty if the total number of endpoints registered is a multiple of the page size.
    public var nextPageToken: Data = Data()

    /// Name of the incoming endpoint to filter on - optional. Specifying this will result in zero or one results.
    /// (-- api-linter: core::203::field-behavior-required=disabled
    ///     aip.dev/not-precedent: Not following linter rules. --)
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Operatorservice.V1 {


  public struct ListNexusEndpointsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Token for getting the next page.
    public var nextPageToken: Data = Data()

    public var endpoints: [Api.Nexus.V1.Endpoint] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.operatorservice.v1"

extension Api.Operatorservice.V1.AddSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddSearchAttributesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: &self.searchAttributes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: self.searchAttributes, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.AddSearchAttributesRequest, rhs: Api.Operatorservice.V1.AddSearchAttributesRequest) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.AddSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddSearchAttributesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.AddSearchAttributesResponse, rhs: Api.Operatorservice.V1.AddSearchAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.RemoveSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveSearchAttributesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.searchAttributes) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitRepeatedStringField(value: self.searchAttributes, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.RemoveSearchAttributesRequest, rhs: Api.Operatorservice.V1.RemoveSearchAttributesRequest) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.RemoveSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveSearchAttributesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.RemoveSearchAttributesResponse, rhs: Api.Operatorservice.V1.RemoveSearchAttributesResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSearchAttributesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListSearchAttributesRequest, rhs: Api.Operatorservice.V1.ListSearchAttributesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSearchAttributesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}custom_attributes\0\u{3}system_attributes\0\u{3}storage_schema\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: &self.customAttributes) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: &self.systemAttributes) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.storageSchema) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.customAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: self.customAttributes, fieldNumber: 1)
    }
    if !self.systemAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: self.systemAttributes, fieldNumber: 2)
    }
    if !self.storageSchema.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.storageSchema, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListSearchAttributesResponse, rhs: Api.Operatorservice.V1.ListSearchAttributesResponse) -> Bool {
    if lhs.customAttributes != rhs.customAttributes {return false}
    if lhs.systemAttributes != rhs.systemAttributes {return false}
    if lhs.storageSchema != rhs.storageSchema {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.DeleteNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}namespace_id\0\u{3}namespace_delete_delay\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespaceID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._namespaceDeleteDelay) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.namespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.namespaceID, fieldNumber: 2)
    }
    try { if let v = self._namespaceDeleteDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.DeleteNamespaceRequest, rhs: Api.Operatorservice.V1.DeleteNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.namespaceID != rhs.namespaceID {return false}
    if lhs._namespaceDeleteDelay != rhs._namespaceDeleteDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.DeleteNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deleted_namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deletedNamespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deletedNamespace.isEmpty {
      try visitor.visitSingularStringField(value: self.deletedNamespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.DeleteNamespaceResponse, rhs: Api.Operatorservice.V1.DeleteNamespaceResponse) -> Bool {
    if lhs.deletedNamespace != rhs.deletedNamespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.AddOrUpdateRemoteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddOrUpdateRemoteClusterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}frontend_address\0\u{3}enable_remote_cluster_connection\0\u{3}frontend_http_address\0\u{3}enable_replication\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.frontendAddress) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enableRemoteClusterConnection) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.frontendHTTPAddress) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.enableReplication) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.frontendAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.frontendAddress, fieldNumber: 1)
    }
    if self.enableRemoteClusterConnection != false {
      try visitor.visitSingularBoolField(value: self.enableRemoteClusterConnection, fieldNumber: 2)
    }
    if !self.frontendHTTPAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.frontendHTTPAddress, fieldNumber: 3)
    }
    if self.enableReplication != false {
      try visitor.visitSingularBoolField(value: self.enableReplication, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.AddOrUpdateRemoteClusterRequest, rhs: Api.Operatorservice.V1.AddOrUpdateRemoteClusterRequest) -> Bool {
    if lhs.frontendAddress != rhs.frontendAddress {return false}
    if lhs.enableRemoteClusterConnection != rhs.enableRemoteClusterConnection {return false}
    if lhs.frontendHTTPAddress != rhs.frontendHTTPAddress {return false}
    if lhs.enableReplication != rhs.enableReplication {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.AddOrUpdateRemoteClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddOrUpdateRemoteClusterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.AddOrUpdateRemoteClusterResponse, rhs: Api.Operatorservice.V1.AddOrUpdateRemoteClusterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.RemoveRemoteClusterRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveRemoteClusterRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.RemoveRemoteClusterRequest, rhs: Api.Operatorservice.V1.RemoveRemoteClusterRequest) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.RemoveRemoteClusterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveRemoteClusterResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.RemoveRemoteClusterResponse, rhs: Api.Operatorservice.V1.RemoveRemoteClusterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListClustersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListClustersRequest, rhs: Api.Operatorservice.V1.ListClustersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListClustersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClustersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}clusters\0\u{4}\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListClustersResponse, rhs: Api.Operatorservice.V1.ListClustersResponse) -> Bool {
    if lhs.clusters != rhs.clusters {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ClusterMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ClusterMetadata"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cluster_name\0\u{3}cluster_id\0\u{1}address\0\u{3}initial_failover_version\0\u{3}history_shard_count\0\u{3}is_connection_enabled\0\u{3}http_address\0\u{3}is_replication_enabled\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clusterName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.clusterID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initialFailoverVersion) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.historyShardCount) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isConnectionEnabled) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.httpAddress) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isReplicationEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterName, fieldNumber: 1)
    }
    if !self.clusterID.isEmpty {
      try visitor.visitSingularStringField(value: self.clusterID, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    if self.initialFailoverVersion != 0 {
      try visitor.visitSingularInt64Field(value: self.initialFailoverVersion, fieldNumber: 4)
    }
    if self.historyShardCount != 0 {
      try visitor.visitSingularInt32Field(value: self.historyShardCount, fieldNumber: 5)
    }
    if self.isConnectionEnabled != false {
      try visitor.visitSingularBoolField(value: self.isConnectionEnabled, fieldNumber: 6)
    }
    if !self.httpAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.httpAddress, fieldNumber: 7)
    }
    if self.isReplicationEnabled != false {
      try visitor.visitSingularBoolField(value: self.isReplicationEnabled, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ClusterMetadata, rhs: Api.Operatorservice.V1.ClusterMetadata) -> Bool {
    if lhs.clusterName != rhs.clusterName {return false}
    if lhs.clusterID != rhs.clusterID {return false}
    if lhs.address != rhs.address {return false}
    if lhs.httpAddress != rhs.httpAddress {return false}
    if lhs.initialFailoverVersion != rhs.initialFailoverVersion {return false}
    if lhs.historyShardCount != rhs.historyShardCount {return false}
    if lhs.isConnectionEnabled != rhs.isConnectionEnabled {return false}
    if lhs.isReplicationEnabled != rhs.isReplicationEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.GetNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.GetNexusEndpointRequest, rhs: Api.Operatorservice.V1.GetNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.GetNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.GetNexusEndpointResponse, rhs: Api.Operatorservice.V1.GetNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.CreateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.CreateNexusEndpointRequest, rhs: Api.Operatorservice.V1.CreateNexusEndpointRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.CreateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.CreateNexusEndpointResponse, rhs: Api.Operatorservice.V1.CreateNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.UpdateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}version\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.UpdateNexusEndpointRequest, rhs: Api.Operatorservice.V1.UpdateNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.UpdateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.UpdateNexusEndpointResponse, rhs: Api.Operatorservice.V1.UpdateNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.DeleteNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt64Field(value: self.version, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.DeleteNexusEndpointRequest, rhs: Api.Operatorservice.V1.DeleteNexusEndpointRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.version != rhs.version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.DeleteNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.DeleteNexusEndpointResponse, rhs: Api.Operatorservice.V1.DeleteNexusEndpointResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListNexusEndpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNexusEndpointsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListNexusEndpointsRequest, rhs: Api.Operatorservice.V1.ListNexusEndpointsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Operatorservice.V1.ListNexusEndpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNexusEndpointsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{1}endpoints\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Operatorservice.V1.ListNexusEndpointsResponse, rhs: Api.Operatorservice.V1.ListNexusEndpointsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
