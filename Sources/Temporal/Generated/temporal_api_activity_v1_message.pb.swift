// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/activity/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Activity.V1 {


  /// The outcome of a completed activity execution: either a successful result or a failure.
  public struct ActivityExecutionOutcome: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var value: Api.Activity.V1.ActivityExecutionOutcome.OneOf_Value? = nil

    /// The result if the activity completed successfully.
    public var result: Api.Common.V1.Payloads {
      get {
        if case .result(let v)? = value {return v}
        return Api.Common.V1.Payloads()
      }
      set {value = .result(newValue)}
    }

    /// The failure if the activity completed unsuccessfully.
    public var failure: Api.Failure.V1.Failure {
      get {
        if case .failure(let v)? = value {return v}
        return Api.Failure.V1.Failure()
      }
      set {value = .failure(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Value: Equatable, Sendable {
      /// The result if the activity completed successfully.
      case result(Api.Common.V1.Payloads)
      /// The failure if the activity completed unsuccessfully.
      case failure(Api.Failure.V1.Failure)

    }

    public init() {}
  }
}
extension Api.Activity.V1 {


  public struct ActivityOptions: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted. Either this or `start_to_close_timeout` must be specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    public var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable, as all a retry would achieve is to put it back into the same
    /// queue. Defaults to `schedule_to_close_timeout` or workflow execution timeout if not
    /// specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    public var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time an activity is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be
    /// specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    public var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Maximum permitted time between successful worker heartbeats.
    public var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    public var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// The retry policy for the activity. Will never exceed `schedule_to_close_timeout`.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Activity.V1 {


  /// Information about a standalone activity.
  public struct ActivityExecutionInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique identifier of this activity within its namespace along with run ID (below).
    public var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    public var runID: String {
      get {_storage._runID}
      set {_uniqueStorage()._runID = newValue}
    }

    /// The type of the activity, a string that maps to a registered activity on a worker.
    public var activityType: Api.Common.V1.ActivityType {
      get {_storage._activityType ?? Api.Common.V1.ActivityType()}
      set {_uniqueStorage()._activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {_storage._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

    /// A general status for this activity, indicates whether it is currently running or in one of the terminal statuses.
    public var status: Api.Enums.V1.ActivityExecutionStatus {
      get {_storage._status}
      set {_uniqueStorage()._status = newValue}
    }

    /// More detailed breakdown of ACTIVITY_EXECUTION_STATUS_RUNNING.
    public var runState: Api.Enums.V1.PendingActivityState {
      get {_storage._runState}
      set {_uniqueStorage()._runState = newValue}
    }

    public var taskQueue: String {
      get {_storage._taskQueue}
      set {_uniqueStorage()._taskQueue = newValue}
    }

    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    public var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable, as all a retry would achieve is to put it back into the same
    /// queue. Defaults to `schedule_to_close_timeout`.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    public var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time a single activity attempt is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    public var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Maximum permitted time between successful worker heartbeats.
    public var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    public var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// The retry policy for the activity. Will never exceed `schedule_to_close_timeout`.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Details provided in the last recorded activity heartbeat.
    public var heartbeatDetails: Api.Common.V1.Payloads {
      get {_storage._heartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._heartbeatDetails = newValue}
    }
    /// Returns true if `heartbeatDetails` has been explicitly set.
    public var hasHeartbeatDetails: Bool {_storage._heartbeatDetails != nil}
    /// Clears the value of `heartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatDetails() {_uniqueStorage()._heartbeatDetails = nil}

    /// Time the last heartbeat was recorded.
    public var lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastHeartbeatTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastHeartbeatTime = newValue}
    }
    /// Returns true if `lastHeartbeatTime` has been explicitly set.
    public var hasLastHeartbeatTime: Bool {_storage._lastHeartbeatTime != nil}
    /// Clears the value of `lastHeartbeatTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatTime() {_uniqueStorage()._lastHeartbeatTime = nil}

    /// Time the last attempt was started.
    public var lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastStartedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastStartedTime = newValue}
    }
    /// Returns true if `lastStartedTime` has been explicitly set.
    public var hasLastStartedTime: Bool {_storage._lastStartedTime != nil}
    /// Clears the value of `lastStartedTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastStartedTime() {_uniqueStorage()._lastStartedTime = nil}

    /// The attempt this activity is currently on. Incremented each time a new attempt is scheduled.
    public var attempt: Int32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// How long this activity has been running for, including all attempts and backoff between attempts.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._executionDuration = newValue}
    }
    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool {_storage._executionDuration != nil}
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() {_uniqueStorage()._executionDuration = nil}

    /// Time the activity was originally scheduled via a StartActivityExecution request.
    public var scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduleTime = newValue}
    }
    /// Returns true if `scheduleTime` has been explicitly set.
    public var hasScheduleTime: Bool {_storage._scheduleTime != nil}
    /// Clears the value of `scheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleTime() {_uniqueStorage()._scheduleTime = nil}

    /// Scheduled time + schedule to close timeout.
    public var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._expirationTime = newValue}
    }
    /// Returns true if `expirationTime` has been explicitly set.
    public var hasExpirationTime: Bool {_storage._expirationTime != nil}
    /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

    /// Time when the activity transitioned to a closed state.
    public var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._closeTime = newValue}
    }
    /// Returns true if `closeTime` has been explicitly set.
    public var hasCloseTime: Bool {_storage._closeTime != nil}
    /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCloseTime() {_uniqueStorage()._closeTime = nil}

    /// Failure details from the last failed attempt.
    public var lastFailure: Api.Failure.V1.Failure {
      get {_storage._lastFailure ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._lastFailure = newValue}
    }
    /// Returns true if `lastFailure` has been explicitly set.
    public var hasLastFailure: Bool {_storage._lastFailure != nil}
    /// Clears the value of `lastFailure`. Subsequent reads from it will return its default value.
    public mutating func clearLastFailure() {_uniqueStorage()._lastFailure = nil}

    public var lastWorkerIdentity: String {
      get {_storage._lastWorkerIdentity}
      set {_uniqueStorage()._lastWorkerIdentity = newValue}
    }

    /// Time from the last attempt failure to the next activity retry.
    /// If the activity is currently running, this represents the next retry interval in case the attempt fails.
    /// If activity is currently backing off between attempt, this represents the current retry interval.
    /// If there is no next retry allowed, this field will be null.
    /// This interval is typically calculated from the specified retry policy, but may be modified if an activity fails
    /// with a retryable application failure specifying a retry delay.
    public var currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._currentRetryInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._currentRetryInterval = newValue}
    }
    /// Returns true if `currentRetryInterval` has been explicitly set.
    public var hasCurrentRetryInterval: Bool {_storage._currentRetryInterval != nil}
    /// Clears the value of `currentRetryInterval`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentRetryInterval() {_uniqueStorage()._currentRetryInterval = nil}

    /// The time when the last activity attempt completed. If activity has not been completed yet, it will be null.
    public var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastAttemptCompleteTime = newValue}
    }
    /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
    public var hasLastAttemptCompleteTime: Bool {_storage._lastAttemptCompleteTime != nil}
    /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptCompleteTime() {_uniqueStorage()._lastAttemptCompleteTime = nil}

    /// The time when the next activity attempt will be scheduled.
    /// If activity is currently scheduled or started, this field will be null.
    public var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._nextAttemptScheduleTime = newValue}
    }
    /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
    public var hasNextAttemptScheduleTime: Bool {_storage._nextAttemptScheduleTime != nil}
    /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextAttemptScheduleTime() {_uniqueStorage()._nextAttemptScheduleTime = nil}

    /// The Worker Deployment Version this activity was dispatched to most recently.
    /// If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
    public var lastDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_storage._lastDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_uniqueStorage()._lastDeploymentVersion = newValue}
    }
    /// Returns true if `lastDeploymentVersion` has been explicitly set.
    public var hasLastDeploymentVersion: Bool {_storage._lastDeploymentVersion != nil}
    /// Clears the value of `lastDeploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearLastDeploymentVersion() {_uniqueStorage()._lastDeploymentVersion = nil}

    /// Priority metadata.
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    /// Incremented each time the activity's state is mutated in persistence.
    public var stateTransitionCount: Int64 {
      get {_storage._stateTransitionCount}
      set {_uniqueStorage()._stateTransitionCount = newValue}
    }

    /// Updated once on scheduled and once on terminal status.
    public var stateSizeBytes: Int64 {
      get {_storage._stateSizeBytes}
      set {_uniqueStorage()._stateSizeBytes = newValue}
    }

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Metadata for use by user interfaces to display the fixed as-of-start summary and details of the activity.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// Set if activity cancelation was requested.
    public var canceledReason: String {
      get {_storage._canceledReason}
      set {_uniqueStorage()._canceledReason = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Activity.V1 {


  /// Limited activity information returned in the list response.
  /// When adding fields here, ensure that it is also present in ActivityExecutionInfo (note that it
  /// may already be present in ActivityExecutionInfo but not at the top-level).
  public struct ActivityExecutionListInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier of this activity within its namespace along with run ID (below).
    public var activityID: String = String()

    /// The run ID of the standalone activity.
    public var runID: String = String()

    /// The type of the activity, a string that maps to a registered activity on a worker.
    public var activityType: Api.Common.V1.ActivityType {
      get {_activityType ?? Api.Common.V1.ActivityType()}
      set {_activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {self._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {self._activityType = nil}

    /// Time the activity was originally scheduled via a StartActivityExecution request.
    public var scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_scheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_scheduleTime = newValue}
    }
    /// Returns true if `scheduleTime` has been explicitly set.
    public var hasScheduleTime: Bool {self._scheduleTime != nil}
    /// Clears the value of `scheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleTime() {self._scheduleTime = nil}

    /// If the activity is in a terminal status, this field represents the time the activity transitioned to that status.
    public var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_closeTime = newValue}
    }
    /// Returns true if `closeTime` has been explicitly set.
    public var hasCloseTime: Bool {self._closeTime != nil}
    /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCloseTime() {self._closeTime = nil}

    /// Only scheduled and terminal statuses appear here. More detailed information in PendingActivityInfo but not
    /// available in the list response.
    public var status: Api.Enums.V1.ActivityExecutionStatus = .unspecified

    /// Search attributes from the start request.
    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {self._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {self._searchAttributes = nil}

    /// The task queue this activity was scheduled on when it was originally started, updated on activity options update.
    public var taskQueue: String = String()

    /// Updated on terminal status.
    public var stateTransitionCount: Int64 = 0

    /// Updated once on scheduled and once on terminal status.
    public var stateSizeBytes: Int64 = 0

    /// The difference between close time and scheduled time.
    /// This field is only populated if the activity is closed.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {_executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_executionDuration = newValue}
    }
    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool {self._executionDuration != nil}
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() {self._executionDuration = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _activityType: Api.Common.V1.ActivityType? = nil
    fileprivate var _scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    fileprivate var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.activity.v1"

extension Api.Activity.V1.ActivityExecutionOutcome: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityExecutionOutcome"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0\u{1}failure\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Common.V1.Payloads?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .result(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .result(v)
        }
      }()
      case 2: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .failure(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .failure(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.value {
    case .result?: try {
      guard case .result(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failure?: try {
      guard case .failure(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Activity.V1.ActivityExecutionOutcome, rhs: Api.Activity.V1.ActivityExecutionOutcome) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Activity.V1.ActivityOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskQueue = source._taskQueue
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Activity.V1.ActivityOptions, rhs: Api.Activity.V1.ActivityOptions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Activity.V1.ActivityExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityExecutionInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}run_id\0\u{3}activity_type\0\u{1}status\0\u{3}run_state\0\u{3}task_queue\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}heartbeat_details\0\u{3}last_heartbeat_time\0\u{3}last_started_time\0\u{1}attempt\0\u{3}execution_duration\0\u{3}schedule_time\0\u{3}expiration_time\0\u{3}close_time\0\u{3}last_failure\0\u{3}last_worker_identity\0\u{3}current_retry_interval\0\u{3}last_attempt_complete_time\0\u{3}next_attempt_schedule_time\0\u{3}last_deployment_version\0\u{1}priority\0\u{3}state_transition_count\0\u{3}state_size_bytes\0\u{3}search_attributes\0\u{1}header\0\u{3}user_metadata\0\u{3}canceled_reason\0")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _runID: String = String()
    var _activityType: Api.Common.V1.ActivityType? = nil
    var _status: Api.Enums.V1.ActivityExecutionStatus = .unspecified
    var _runState: Api.Enums.V1.PendingActivityState = .unspecified
    var _taskQueue: String = String()
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _heartbeatDetails: Api.Common.V1.Payloads? = nil
    var _lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: Int32 = 0
    var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastFailure: Api.Failure.V1.Failure? = nil
    var _lastWorkerIdentity: String = String()
    var _currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    var _priority: Api.Common.V1.Priority? = nil
    var _stateTransitionCount: Int64 = 0
    var _stateSizeBytes: Int64 = 0
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _header: Api.Common.V1.Header? = nil
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _canceledReason: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _runID = source._runID
      _activityType = source._activityType
      _status = source._status
      _runState = source._runState
      _taskQueue = source._taskQueue
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _heartbeatDetails = source._heartbeatDetails
      _lastHeartbeatTime = source._lastHeartbeatTime
      _lastStartedTime = source._lastStartedTime
      _attempt = source._attempt
      _executionDuration = source._executionDuration
      _scheduleTime = source._scheduleTime
      _expirationTime = source._expirationTime
      _closeTime = source._closeTime
      _lastFailure = source._lastFailure
      _lastWorkerIdentity = source._lastWorkerIdentity
      _currentRetryInterval = source._currentRetryInterval
      _lastAttemptCompleteTime = source._lastAttemptCompleteTime
      _nextAttemptScheduleTime = source._nextAttemptScheduleTime
      _lastDeploymentVersion = source._lastDeploymentVersion
      _priority = source._priority
      _stateTransitionCount = source._stateTransitionCount
      _stateSizeBytes = source._stateSizeBytes
      _searchAttributes = source._searchAttributes
      _header = source._header
      _userMetadata = source._userMetadata
      _canceledReason = source._canceledReason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._runID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._runState) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatDetails) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._lastHeartbeatTime) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._lastStartedTime) }()
        case 15: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._executionDuration) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleTime) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._closeTime) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._lastFailure) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._lastWorkerIdentity) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._currentRetryInterval) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptCompleteTime) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._nextAttemptScheduleTime) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeploymentVersion) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 27: try { try decoder.decodeSingularInt64Field(value: &_storage._stateTransitionCount) }()
        case 28: try { try decoder.decodeSingularInt64Field(value: &_storage._stateSizeBytes) }()
        case 29: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 30: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 32: try { try decoder.decodeSingularStringField(value: &_storage._canceledReason) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      if !_storage._runID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._runID, fieldNumber: 2)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 4)
      }
      if _storage._runState != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._runState, fieldNumber: 5)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 6)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._heartbeatDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._lastHeartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._lastStartedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 15)
      }
      try { if let v = _storage._executionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._scheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._closeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._lastFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._lastWorkerIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastWorkerIdentity, fieldNumber: 21)
      }
      try { if let v = _storage._currentRetryInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._lastAttemptCompleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._nextAttemptScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._lastDeploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      if _storage._stateTransitionCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stateTransitionCount, fieldNumber: 27)
      }
      if _storage._stateSizeBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stateSizeBytes, fieldNumber: 28)
      }
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      } }()
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      if !_storage._canceledReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._canceledReason, fieldNumber: 32)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Activity.V1.ActivityExecutionInfo, rhs: Api.Activity.V1.ActivityExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._runID != rhs_storage._runID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._runState != rhs_storage._runState {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._lastHeartbeatTime != rhs_storage._lastHeartbeatTime {return false}
        if _storage._lastStartedTime != rhs_storage._lastStartedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._executionDuration != rhs_storage._executionDuration {return false}
        if _storage._scheduleTime != rhs_storage._scheduleTime {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._closeTime != rhs_storage._closeTime {return false}
        if _storage._lastFailure != rhs_storage._lastFailure {return false}
        if _storage._lastWorkerIdentity != rhs_storage._lastWorkerIdentity {return false}
        if _storage._currentRetryInterval != rhs_storage._currentRetryInterval {return false}
        if _storage._lastAttemptCompleteTime != rhs_storage._lastAttemptCompleteTime {return false}
        if _storage._nextAttemptScheduleTime != rhs_storage._nextAttemptScheduleTime {return false}
        if _storage._lastDeploymentVersion != rhs_storage._lastDeploymentVersion {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._stateTransitionCount != rhs_storage._stateTransitionCount {return false}
        if _storage._stateSizeBytes != rhs_storage._stateSizeBytes {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._canceledReason != rhs_storage._canceledReason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Activity.V1.ActivityExecutionListInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityExecutionListInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}run_id\0\u{3}activity_type\0\u{3}schedule_time\0\u{3}close_time\0\u{1}status\0\u{3}search_attributes\0\u{3}task_queue\0\u{3}state_transition_count\0\u{3}state_size_bytes\0\u{3}execution_duration\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._activityType) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._scheduleTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.stateTransitionCount) }()
      case 10: try { try decoder.decodeSingularInt64Field(value: &self.stateSizeBytes) }()
      case 11: try { try decoder.decodeSingularMessageField(value: &self._executionDuration) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    try { if let v = self._activityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._scheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 6)
    }
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 8)
    }
    if self.stateTransitionCount != 0 {
      try visitor.visitSingularInt64Field(value: self.stateTransitionCount, fieldNumber: 9)
    }
    if self.stateSizeBytes != 0 {
      try visitor.visitSingularInt64Field(value: self.stateSizeBytes, fieldNumber: 10)
    }
    try { if let v = self._executionDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Activity.V1.ActivityExecutionListInfo, rhs: Api.Activity.V1.ActivityExecutionListInfo) -> Bool {
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs._activityType != rhs._activityType {return false}
    if lhs._scheduleTime != rhs._scheduleTime {return false}
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.stateTransitionCount != rhs.stateTransitionCount {return false}
    if lhs.stateSizeBytes != rhs.stateSizeBytes {return false}
    if lhs._executionDuration != rhs._executionDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
