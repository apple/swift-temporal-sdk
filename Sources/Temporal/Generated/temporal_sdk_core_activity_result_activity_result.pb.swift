// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/activity_result/activity_result.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Coresdk.ActivityResult {


  /// Used to report activity completions to core
  package struct ActivityExecutionResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var status: Coresdk.ActivityResult.ActivityExecutionResult.OneOf_Status? = nil

    package var completed: Coresdk.ActivityResult.Success {
      get {
        if case .completed(let v)? = status {return v}
        return Coresdk.ActivityResult.Success()
      }
      set {status = .completed(newValue)}
    }

    package var failed: Coresdk.ActivityResult.Failure {
      get {
        if case .failed(let v)? = status {return v}
        return Coresdk.ActivityResult.Failure()
      }
      set {status = .failed(newValue)}
    }

    package var cancelled: Coresdk.ActivityResult.Cancellation {
      get {
        if case .cancelled(let v)? = status {return v}
        return Coresdk.ActivityResult.Cancellation()
      }
      set {status = .cancelled(newValue)}
    }

    package var willCompleteAsync: Coresdk.ActivityResult.WillCompleteAsync {
      get {
        if case .willCompleteAsync(let v)? = status {return v}
        return Coresdk.ActivityResult.WillCompleteAsync()
      }
      set {status = .willCompleteAsync(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Status: Equatable, Sendable {
      case completed(Coresdk.ActivityResult.Success)
      case failed(Coresdk.ActivityResult.Failure)
      case cancelled(Coresdk.ActivityResult.Cancellation)
      case willCompleteAsync(Coresdk.ActivityResult.WillCompleteAsync)

    }

    package init() {}
  }
}
extension Coresdk.ActivityResult {


  /// Used to report activity resolutions to lang. IE: This is what the activities are resolved with
  /// in the workflow.
  package struct ActivityResolution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var status: Coresdk.ActivityResult.ActivityResolution.OneOf_Status? = nil

    package var completed: Coresdk.ActivityResult.Success {
      get {
        if case .completed(let v)? = status {return v}
        return Coresdk.ActivityResult.Success()
      }
      set {status = .completed(newValue)}
    }

    package var failed: Coresdk.ActivityResult.Failure {
      get {
        if case .failed(let v)? = status {return v}
        return Coresdk.ActivityResult.Failure()
      }
      set {status = .failed(newValue)}
    }

    package var cancelled: Coresdk.ActivityResult.Cancellation {
      get {
        if case .cancelled(let v)? = status {return v}
        return Coresdk.ActivityResult.Cancellation()
      }
      set {status = .cancelled(newValue)}
    }

    package var backoff: Coresdk.ActivityResult.DoBackoff {
      get {
        if case .backoff(let v)? = status {return v}
        return Coresdk.ActivityResult.DoBackoff()
      }
      set {status = .backoff(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Status: Equatable, Sendable {
      case completed(Coresdk.ActivityResult.Success)
      case failed(Coresdk.ActivityResult.Failure)
      case cancelled(Coresdk.ActivityResult.Cancellation)
      case backoff(Coresdk.ActivityResult.DoBackoff)

    }

    package init() {}
  }
}
extension Coresdk.ActivityResult {


  /// Used to report successful completion either when executing or resolving
  package struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var result: Api.Common.V1.Payload {
      get {_result ?? Api.Common.V1.Payload()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    package var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    package mutating func clearResult() {self._result = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _result: Api.Common.V1.Payload? = nil
  }
}
extension Coresdk.ActivityResult {


  /// Used to report activity failure either when executing or resolving
  package struct Failure: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Coresdk.ActivityResult {


  ///
  /// Used to report cancellation from both Core and Lang.
  /// When Lang reports a cancelled activity, it must put a CancelledFailure in the failure field.
  /// When Core reports a cancelled activity, it must put an ActivityFailure with CancelledFailure
  /// as the cause in the failure field.
  package struct Cancellation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Coresdk.ActivityResult {


  ///
  /// Used in ActivityExecutionResult to notify Core that this Activity will complete asynchronously.
  /// Core will forget about this Activity and free up resources used to track this Activity.
  package struct WillCompleteAsync: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.ActivityResult {


  ///
  /// Issued when a local activity needs to retry but also wants to back off more than would be
  /// reasonable to WFT heartbeat for. Lang is expected to schedule a timer for the duration
  /// and then start a local activity of the same type & same inputs with the provided attempt number
  /// after the timer has elapsed.
  ///
  /// This exists because Core does not have a concept of starting commands by itself, they originate
  /// from lang. So expecting lang to start the timer / next pass of the activity fits more smoothly.
  package struct DoBackoff: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The attempt number that lang should provide when scheduling the retry. If the LA failed
    /// on attempt 4 and we told lang to back off with a timer, this number will be 5.
    package var attempt: UInt32 = 0

    package var backoffDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {_backoffDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_backoffDuration = newValue}
    }
    /// Returns true if `backoffDuration` has been explicitly set.
    package var hasBackoffDuration: Bool {self._backoffDuration != nil}
    /// Clears the value of `backoffDuration`. Subsequent reads from it will return its default value.
    package mutating func clearBackoffDuration() {self._backoffDuration = nil}

    /// The time the first attempt of this local activity was scheduled. Must be passed with attempt
    /// to the retry LA.
    package var originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_originalScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_originalScheduleTime = newValue}
    }
    /// Returns true if `originalScheduleTime` has been explicitly set.
    package var hasOriginalScheduleTime: Bool {self._originalScheduleTime != nil}
    /// Clears the value of `originalScheduleTime`. Subsequent reads from it will return its default value.
    package mutating func clearOriginalScheduleTime() {self._originalScheduleTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _backoffDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.activity_result"

extension Coresdk.ActivityResult.ActivityExecutionResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityExecutionResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{3}will_complete_async\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk.ActivityResult.Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk.ActivityResult.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk.ActivityResult.Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Coresdk.ActivityResult.WillCompleteAsync?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .willCompleteAsync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .willCompleteAsync(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .willCompleteAsync?: try {
      guard case .willCompleteAsync(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.ActivityExecutionResult, rhs: Coresdk.ActivityResult.ActivityExecutionResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.ActivityResolution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityResolution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{1}backoff\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk.ActivityResult.Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk.ActivityResult.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk.ActivityResult.Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Coresdk.ActivityResult.DoBackoff?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .backoff(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .backoff(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .backoff?: try {
      guard case .backoff(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.ActivityResolution, rhs: Coresdk.ActivityResult.ActivityResolution) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Success"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.Success, rhs: Coresdk.ActivityResult.Success) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Failure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.Failure, rhs: Coresdk.ActivityResult.Failure) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.Cancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancellation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.Cancellation, rhs: Coresdk.ActivityResult.Cancellation) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.WillCompleteAsync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WillCompleteAsync"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.WillCompleteAsync, rhs: Coresdk.ActivityResult.WillCompleteAsync) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityResult.DoBackoff: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".DoBackoff"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attempt\0\u{3}backoff_duration\0\u{3}original_schedule_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.attempt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._backoffDuration) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originalScheduleTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.attempt != 0 {
      try visitor.visitSingularUInt32Field(value: self.attempt, fieldNumber: 1)
    }
    try { if let v = self._backoffDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityResult.DoBackoff, rhs: Coresdk.ActivityResult.DoBackoff) -> Bool {
    if lhs.attempt != rhs.attempt {return false}
    if lhs._backoffDuration != rhs._backoffDuration {return false}
    if lhs._originalScheduleTime != rhs._originalScheduleTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
