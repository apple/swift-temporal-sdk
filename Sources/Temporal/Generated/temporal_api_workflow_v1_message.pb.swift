// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/workflow/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Workflow.V1 {


  /// Hold basic information about a workflow execution.
  /// This structure is a part of visibility, and thus contain a limited subset of information.
  public struct WorkflowExecutionInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_storage._execution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {_storage._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {_uniqueStorage()._execution = nil}

    public var type: Api.Common.V1.WorkflowType {
      get {_storage._type ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    public var hasType: Bool {_storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    public mutating func clearType() {_uniqueStorage()._type = nil}

    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {_storage._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {_uniqueStorage()._startTime = nil}

    public var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._closeTime = newValue}
    }
    /// Returns true if `closeTime` has been explicitly set.
    public var hasCloseTime: Bool {_storage._closeTime != nil}
    /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCloseTime() {_uniqueStorage()._closeTime = nil}

    public var status: Api.Enums.V1.WorkflowExecutionStatus {
      get {_storage._status}
      set {_uniqueStorage()._status = newValue}
    }

    public var historyLength: Int64 {
      get {_storage._historyLength}
      set {_uniqueStorage()._historyLength = newValue}
    }

    public var parentNamespaceID: String {
      get {_storage._parentNamespaceID}
      set {_uniqueStorage()._parentNamespaceID = newValue}
    }

    public var parentExecution: Api.Common.V1.WorkflowExecution {
      get {_storage._parentExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._parentExecution = newValue}
    }
    /// Returns true if `parentExecution` has been explicitly set.
    public var hasParentExecution: Bool {_storage._parentExecution != nil}
    /// Clears the value of `parentExecution`. Subsequent reads from it will return its default value.
    public mutating func clearParentExecution() {_uniqueStorage()._parentExecution = nil}

    public var executionTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._executionTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._executionTime = newValue}
    }
    /// Returns true if `executionTime` has been explicitly set.
    public var hasExecutionTime: Bool {_storage._executionTime != nil}
    /// Clears the value of `executionTime`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionTime() {_uniqueStorage()._executionTime = nil}

    public var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {_uniqueStorage()._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    public var autoResetPoints: Api.Workflow.V1.ResetPoints {
      get {_storage._autoResetPoints ?? Api.Workflow.V1.ResetPoints()}
      set {_uniqueStorage()._autoResetPoints = newValue}
    }
    /// Returns true if `autoResetPoints` has been explicitly set.
    public var hasAutoResetPoints: Bool {_storage._autoResetPoints != nil}
    /// Clears the value of `autoResetPoints`. Subsequent reads from it will return its default value.
    public mutating func clearAutoResetPoints() {_uniqueStorage()._autoResetPoints = nil}

    public var taskQueue: String {
      get {_storage._taskQueue}
      set {_uniqueStorage()._taskQueue = newValue}
    }

    public var stateTransitionCount: Int64 {
      get {_storage._stateTransitionCount}
      set {_uniqueStorage()._stateTransitionCount = newValue}
    }

    public var historySizeBytes: Int64 {
      get {_storage._historySizeBytes}
      set {_uniqueStorage()._historySizeBytes = newValue}
    }

    /// If set, the most recent worker version stamp that appeared in a workflow task completion
    /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var mostRecentWorkerVersionStamp: Api.Common.V1.WorkerVersionStamp {
      get {_storage._mostRecentWorkerVersionStamp ?? Api.Common.V1.WorkerVersionStamp()}
      set {_uniqueStorage()._mostRecentWorkerVersionStamp = newValue}
    }
    /// Returns true if `mostRecentWorkerVersionStamp` has been explicitly set.
    public var hasMostRecentWorkerVersionStamp: Bool {_storage._mostRecentWorkerVersionStamp != nil}
    /// Clears the value of `mostRecentWorkerVersionStamp`. Subsequent reads from it will return its default value.
    public mutating func clearMostRecentWorkerVersionStamp() {_uniqueStorage()._mostRecentWorkerVersionStamp = nil}

    /// Workflow execution duration is defined as difference between close time and execution time.
    /// This field is only populated if the workflow is closed.
    public var executionDuration: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._executionDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._executionDuration = newValue}
    }
    /// Returns true if `executionDuration` has been explicitly set.
    public var hasExecutionDuration: Bool {_storage._executionDuration != nil}
    /// Clears the value of `executionDuration`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionDuration() {_uniqueStorage()._executionDuration = nil}

    /// Contains information about the root workflow execution.
    /// The root workflow execution is defined as follows:
    /// 1. A workflow without parent workflow is its own root workflow.
    /// 2. A workflow that has a parent workflow has the same root workflow as its parent workflow.
    /// Note: workflows continued as new or reseted may or may not have parents, check examples below.
    ///
    /// Examples:
    ///   Scenario 1: Workflow W1 starts child workflow W2, and W2 starts child workflow W3.
    ///     - The root workflow of all three workflows is W1.
    ///   Scenario 2: Workflow W1 starts child workflow W2, and W2 continued as new W3.
    ///     - The root workflow of all three workflows is W1.
    ///   Scenario 3: Workflow W1 continued as new W2.
    ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
    ///   Scenario 4: Workflow W1 starts child workflow W2, and W2 is reseted, creating W3
    ///     - The root workflow of all three workflows is W1.
    ///   Scenario 5: Workflow W1 is reseted, creating W2.
    ///     - The root workflow of W1 is W1 and the root workflow of W2 is W2.
    public var rootExecution: Api.Common.V1.WorkflowExecution {
      get {_storage._rootExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._rootExecution = newValue}
    }
    /// Returns true if `rootExecution` has been explicitly set.
    public var hasRootExecution: Bool {_storage._rootExecution != nil}
    /// Clears the value of `rootExecution`. Subsequent reads from it will return its default value.
    public mutating func clearRootExecution() {_uniqueStorage()._rootExecution = nil}

    /// The currently assigned build ID for this execution. Presence of this value means worker versioning is used
    /// for this execution. Assigned build ID is selected based on Worker Versioning Assignment Rules
    /// when the first workflow task of the execution is scheduled. If the first workflow task fails and is scheduled
    /// again, the assigned build ID may change according to the latest versioning rules.
    /// Assigned build ID can also change in the middle of a execution if Compatible Redirect Rules are applied to
    /// this execution.
    /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var assignedBuildID: String {
      get {_storage._assignedBuildID}
      set {_uniqueStorage()._assignedBuildID = newValue}
    }

    /// Build ID inherited from a previous/parent execution. If present, assigned_build_id will be set to this, instead
    /// of using the assignment rules.
    /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var inheritedBuildID: String {
      get {_storage._inheritedBuildID}
      set {_uniqueStorage()._inheritedBuildID = newValue}
    }

    /// The first run ID in the execution chain.
    /// Executions created via the following operations are considered to be in the same chain
    /// - ContinueAsNew
    /// - Workflow Retry
    /// - Workflow Reset
    /// - Cron Schedule
    public var firstRunID: String {
      get {_storage._firstRunID}
      set {_uniqueStorage()._firstRunID = newValue}
    }

    /// Absent value means the workflow execution is not versioned. When present, the execution might
    /// be versioned or unversioned, depending on `versioning_info.behavior` and `versioning_info.versioning_override`.
    /// Experimental. Versioning info is experimental and might change in the future.
    public var versioningInfo: Api.Workflow.V1.WorkflowExecutionVersioningInfo {
      get {_storage._versioningInfo ?? Api.Workflow.V1.WorkflowExecutionVersioningInfo()}
      set {_uniqueStorage()._versioningInfo = newValue}
    }
    /// Returns true if `versioningInfo` has been explicitly set.
    public var hasVersioningInfo: Bool {_storage._versioningInfo != nil}
    /// Clears the value of `versioningInfo`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningInfo() {_uniqueStorage()._versioningInfo = nil}

    /// The name of Worker Deployment that completed the most recent workflow task.
    /// Experimental. Worker Deployments are experimental and might change in the future.
    public var workerDeploymentName: String {
      get {_storage._workerDeploymentName}
      set {_uniqueStorage()._workerDeploymentName = newValue}
    }

    /// Priority metadata
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    /// Total size in bytes of all external payloads referenced in workflow history.
    public var externalPayloadSizeBytes: Int64 {
      get {_storage._externalPayloadSizeBytes}
      set {_uniqueStorage()._externalPayloadSizeBytes = newValue}
    }

    /// Count of external payloads referenced in workflow history.
    public var externalPayloadCount: Int64 {
      get {_storage._externalPayloadCount}
      set {_uniqueStorage()._externalPayloadCount = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflow.V1 {


  /// Holds all the extra information about workflow execution that is not part of Visibility.
  public struct WorkflowExecutionExtendedInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Workflow execution expiration time is defined as workflow start time plus expiration timeout.
    /// Workflow start time may change after workflow reset.
    public var executionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_executionExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_executionExpirationTime = newValue}
    }
    /// Returns true if `executionExpirationTime` has been explicitly set.
    public var hasExecutionExpirationTime: Bool {self._executionExpirationTime != nil}
    /// Clears the value of `executionExpirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionExpirationTime() {self._executionExpirationTime = nil}

    /// Workflow run expiration time is defined as current workflow run start time plus workflow run timeout.
    public var runExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_runExpirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_runExpirationTime = newValue}
    }
    /// Returns true if `runExpirationTime` has been explicitly set.
    public var hasRunExpirationTime: Bool {self._runExpirationTime != nil}
    /// Clears the value of `runExpirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearRunExpirationTime() {self._runExpirationTime = nil}

    /// indicates if the workflow received a cancel request
    public var cancelRequested: Bool = false

    /// Last workflow reset time. Nil if the workflow was never reset.
    public var lastResetTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastResetTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastResetTime = newValue}
    }
    /// Returns true if `lastResetTime` has been explicitly set.
    public var hasLastResetTime: Bool {self._lastResetTime != nil}
    /// Clears the value of `lastResetTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastResetTime() {self._lastResetTime = nil}

    /// Original workflow start time.
    public var originalStartTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_originalStartTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_originalStartTime = newValue}
    }
    /// Returns true if `originalStartTime` has been explicitly set.
    public var hasOriginalStartTime: Bool {self._originalStartTime != nil}
    /// Clears the value of `originalStartTime`. Subsequent reads from it will return its default value.
    public mutating func clearOriginalStartTime() {self._originalStartTime = nil}

    /// Reset Run ID points to the new run when this execution is reset. If the execution is reset multiple times, it points to the latest run.
    public var resetRunID: String = String()

    /// Request ID information (eg: history event information associated with the request ID).
    /// Note: It only contains request IDs from StartWorkflowExecution requests, including indirect
    /// calls (eg: if SignalWithStartWorkflowExecution starts a new workflow, then the request ID is
    /// used in the StartWorkflowExecution request).
    public var requestIDInfos: Dictionary<String,Api.Workflow.V1.RequestIdInfo> = [:]

    /// Information about the workflow execution pause operation.
    public var pauseInfo: Api.Workflow.V1.WorkflowExecutionPauseInfo {
      get {_pauseInfo ?? Api.Workflow.V1.WorkflowExecutionPauseInfo()}
      set {_pauseInfo = newValue}
    }
    /// Returns true if `pauseInfo` has been explicitly set.
    public var hasPauseInfo: Bool {self._pauseInfo != nil}
    /// Clears the value of `pauseInfo`. Subsequent reads from it will return its default value.
    public mutating func clearPauseInfo() {self._pauseInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _executionExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _runExpirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastResetTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _originalStartTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _pauseInfo: Api.Workflow.V1.WorkflowExecutionPauseInfo? = nil
  }
}
extension Api.Workflow.V1 {


  /// Holds all the information about worker versioning for a particular workflow execution.
  /// Experimental. Versioning info is experimental and might change in the future.
  public struct WorkflowExecutionVersioningInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Versioning behavior determines how the server should treat this execution when workers are
    /// upgraded. When present it means this workflow execution is versioned; UNSPECIFIED means
    /// unversioned. See the comments in `VersioningBehavior` enum for more info about different
    /// behaviors.
    ///
    /// Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning 
    /// Behavior and Version (except when the new execution runs on a task queue not belonging to the 
    /// same deployment version as the parent/previous run's task queue). The first workflow task will
    /// be dispatched according to the inherited behavior (or to the current version of the task-queue's 
    /// deployment in the case of AutoUpgrade.) After completion of their first workflow task the 
    /// Deployment Version and Behavior of the execution will update according to configuration on the worker.
    /// 
    /// Note that `behavior` is overridden by `versioning_override` if the latter is present.
    public var behavior: Api.Enums.V1.VersioningBehavior {
      get {_storage._behavior}
      set {_uniqueStorage()._behavior = newValue}
    }

    /// The worker deployment that completed the last workflow task of this workflow execution. Must
    /// be present if `behavior` is set. Absent value means no workflow task is completed, or the
    /// last workflow task was completed by an unversioned worker. Unversioned workers may still send
    /// a deployment value which will be stored here, so the right way to check if an execution is
    /// versioned if an execution is versioned or not is via the `behavior` field.
    /// Note that `deployment` is overridden by `versioning_override` if the latter is present.
    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_storage._deployment ?? Api.Deployment.V1.Deployment()}
      set {_uniqueStorage()._deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {_storage._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String {
      get {_storage._version}
      set {_uniqueStorage()._version = newValue}
    }

    /// The Worker Deployment Version that completed the last workflow task of this workflow execution.
    /// An absent value means no workflow task is completed, or the workflow is unversioned.
    /// If present, and `behavior` is UNSPECIFIED, the last task of this workflow execution was completed
    /// by a worker that is not using versioning but _is_ passing Deployment Name and Build ID.
    ///
    /// Child workflows or CaN executions **inherit** their parent/previous run's effective Versioning 
    /// Behavior and Version (except when the new execution runs on a task queue not belonging to the 
    /// same deployment version as the parent/previous run's task queue). The first workflow task will
    /// be dispatched according to the inherited behavior (or to the current version of the task-queue's 
    /// deployment in the case of AutoUpgrade.) After completion of their first workflow task the 
    /// Deployment Version and Behavior of the execution will update according to configuration on the worker.
    ///
    /// Note that if `versioning_override.behavior` is PINNED then `versioning_override.pinned_version`
    /// will override this value. 
    public var deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_storage._deploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_uniqueStorage()._deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    public var hasDeploymentVersion: Bool {_storage._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentVersion() {_uniqueStorage()._deploymentVersion = nil}

    /// Present if user has set an execution-specific versioning override. This override takes
    /// precedence over SDK-sent `behavior` (and `version` when override is PINNED). An
    /// override can be set when starting a new execution, as well as afterwards by calling the
    /// `UpdateWorkflowExecutionOptions` API.
    /// Pinned overrides are automatically inherited by child workflows, continue-as-new workflows,
    /// workflow retries, and cron workflows.
    public var versioningOverride: Api.Workflow.V1.VersioningOverride {
      get {_storage._versioningOverride ?? Api.Workflow.V1.VersioningOverride()}
      set {_uniqueStorage()._versioningOverride = newValue}
    }
    /// Returns true if `versioningOverride` has been explicitly set.
    public var hasVersioningOverride: Bool {_storage._versioningOverride != nil}
    /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

    /// When present, indicates the workflow is transitioning to a different deployment. Can
    /// indicate one of the following transitions: unversioned -> versioned, versioned -> versioned
    /// on a different deployment, or versioned -> unversioned.
    /// Not applicable to workflows with PINNED behavior.
    /// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
    /// start a transition to the task queue's current deployment if the task queue's current
    /// deployment is different from the workflow's deployment.
    /// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
    /// tasks will be redirected to the task queue's current deployment. As soon as a poller from
    /// that deployment is available to receive the task, the workflow will automatically start a
    /// transition to that deployment and continue execution there.
    /// A deployment transition can only exist while there is a pending or started workflow task.
    /// Once the pending workflow task completes on the transition's target deployment, the
    /// transition completes and the workflow's `deployment` and `behavior` fields are updated per
    /// the worker's task completion response.
    /// Pending activities will not start new attempts during a transition. Once the transition is
    /// completed, pending activities will start their next attempt on the new deployment.
    /// Deprecated. Use version_transition.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deploymentTransition: Api.Workflow.V1.DeploymentTransition {
      get {_storage._deploymentTransition ?? Api.Workflow.V1.DeploymentTransition()}
      set {_uniqueStorage()._deploymentTransition = newValue}
    }
    /// Returns true if `deploymentTransition` has been explicitly set.
    public var hasDeploymentTransition: Bool {_storage._deploymentTransition != nil}
    /// Clears the value of `deploymentTransition`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentTransition() {_uniqueStorage()._deploymentTransition = nil}

    /// When present, indicates the workflow is transitioning to a different deployment version
    /// (which may belong to the same deployment name or another). Can indicate one of the following
    /// transitions: unversioned -> versioned, versioned -> versioned
    /// on a different deployment version, or versioned -> unversioned.
    /// Not applicable to workflows with PINNED behavior.
    /// When a workflow with AUTO_UPGRADE behavior creates a new workflow task, it will automatically
    /// start a transition to the task queue's current version if the task queue's current version is
    /// different from the workflow's current deployment version.
    /// If the AUTO_UPGRADE workflow is stuck due to backlogged activity or workflow tasks, those
    /// tasks will be redirected to the task queue's current version. As soon as a poller from
    /// that deployment version is available to receive the task, the workflow will automatically
    /// start a transition to that version and continue execution there.
    /// A version transition can only exist while there is a pending or started workflow task.
    /// Once the pending workflow task completes on the transition's target version, the
    /// transition completes and the workflow's `behavior`, and `deployment_version` fields are updated per the
    /// worker's task completion response.
    /// Pending activities will not start new attempts during a transition. Once the transition is
    /// completed, pending activities will start their next attempt on the new version.
    public var versionTransition: Api.Workflow.V1.DeploymentVersionTransition {
      get {_storage._versionTransition ?? Api.Workflow.V1.DeploymentVersionTransition()}
      set {_uniqueStorage()._versionTransition = newValue}
    }
    /// Returns true if `versionTransition` has been explicitly set.
    public var hasVersionTransition: Bool {_storage._versionTransition != nil}
    /// Clears the value of `versionTransition`. Subsequent reads from it will return its default value.
    public mutating func clearVersionTransition() {_uniqueStorage()._versionTransition = nil}

    /// Monotonic counter reflecting the latest routing decision for this workflow execution.
    /// Used for staleness detection between history and matching when dispatching tasks to workers.
    /// Incremented when a workflow execution routes to a new deployment version, which happens
    /// when a worker of the new deployment version completes a workflow task.
    /// Note: Pinned tasks and sticky tasks send a value of 0 for this field since these tasks do not
    /// face the problem of inconsistent dispatching that arises from eventual consistency between
    /// task queues and their partitions.
    public var revisionNumber: Int64 {
      get {_storage._revisionNumber}
      set {_uniqueStorage()._revisionNumber = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflow.V1 {


  /// Holds information about ongoing transition of a workflow execution from one deployment to another.
  /// Deprecated. Use DeploymentVersionTransition.
  public struct DeploymentTransition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The target deployment of the transition. Null means a so-far-versioned workflow is
    /// transitioning to unversioned workers.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
  }
}
extension Api.Workflow.V1 {


  /// Holds information about ongoing transition of a workflow execution from one worker
  /// deployment version to another.
  /// Experimental. Might change in the future.
  public struct DeploymentVersionTransition: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// The target Version of the transition.
    /// If nil, a so-far-versioned workflow is transitioning to unversioned workers.
    public var deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_deploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    public var hasDeploymentVersion: Bool {self._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflow.V1 {


  public struct WorkflowExecutionConfig: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    public var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    public var hasWorkflowExecutionTimeout: Bool {self._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionTimeout() {self._workflowExecutionTimeout = nil}

    public var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    public var hasWorkflowRunTimeout: Bool {self._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowRunTimeout() {self._workflowRunTimeout = nil}

    public var defaultWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_defaultWorkflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_defaultWorkflowTaskTimeout = newValue}
    }
    /// Returns true if `defaultWorkflowTaskTimeout` has been explicitly set.
    public var hasDefaultWorkflowTaskTimeout: Bool {self._defaultWorkflowTaskTimeout != nil}
    /// Clears the value of `defaultWorkflowTaskTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearDefaultWorkflowTaskTimeout() {self._defaultWorkflowTaskTimeout = nil}

    /// User metadata provided on start workflow.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {self._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {self._userMetadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _defaultWorkflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
  }
}
extension Api.Workflow.V1 {


  public struct PendingActivityInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    public var activityType: Api.Common.V1.ActivityType {
      get {_storage._activityType ?? Api.Common.V1.ActivityType()}
      set {_uniqueStorage()._activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {_storage._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

    public var state: Api.Enums.V1.PendingActivityState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    public var heartbeatDetails: Api.Common.V1.Payloads {
      get {_storage._heartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._heartbeatDetails = newValue}
    }
    /// Returns true if `heartbeatDetails` has been explicitly set.
    public var hasHeartbeatDetails: Bool {_storage._heartbeatDetails != nil}
    /// Clears the value of `heartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatDetails() {_uniqueStorage()._heartbeatDetails = nil}

    public var lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastHeartbeatTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastHeartbeatTime = newValue}
    }
    /// Returns true if `lastHeartbeatTime` has been explicitly set.
    public var hasLastHeartbeatTime: Bool {_storage._lastHeartbeatTime != nil}
    /// Clears the value of `lastHeartbeatTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatTime() {_uniqueStorage()._lastHeartbeatTime = nil}

    public var lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastStartedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastStartedTime = newValue}
    }
    /// Returns true if `lastStartedTime` has been explicitly set.
    public var hasLastStartedTime: Bool {_storage._lastStartedTime != nil}
    /// Clears the value of `lastStartedTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastStartedTime() {_uniqueStorage()._lastStartedTime = nil}

    public var attempt: Int32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    public var maximumAttempts: Int32 {
      get {_storage._maximumAttempts}
      set {_uniqueStorage()._maximumAttempts = newValue}
    }

    public var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {_storage._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

    public var expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._expirationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._expirationTime = newValue}
    }
    /// Returns true if `expirationTime` has been explicitly set.
    public var hasExpirationTime: Bool {_storage._expirationTime != nil}
    /// Clears the value of `expirationTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpirationTime() {_uniqueStorage()._expirationTime = nil}

    public var lastFailure: Api.Failure.V1.Failure {
      get {_storage._lastFailure ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._lastFailure = newValue}
    }
    /// Returns true if `lastFailure` has been explicitly set.
    public var hasLastFailure: Bool {_storage._lastFailure != nil}
    /// Clears the value of `lastFailure`. Subsequent reads from it will return its default value.
    public mutating func clearLastFailure() {_uniqueStorage()._lastFailure = nil}

    public var lastWorkerIdentity: String {
      get {_storage._lastWorkerIdentity}
      set {_uniqueStorage()._lastWorkerIdentity = newValue}
    }

    /// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
    /// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
    /// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
    /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    public var assignedBuildID: OneOf_AssignedBuildID? {
      get {return _storage._assignedBuildID}
      set {_uniqueStorage()._assignedBuildID = newValue}
    }

    /// Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var useWorkflowBuildID: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .useWorkflowBuildID(let v)? = _storage._assignedBuildID {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {_uniqueStorage()._assignedBuildID = .useWorkflowBuildID(newValue)}
    }

    /// Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
    /// The activity will use the build id in this field instead.
    /// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
    /// rules.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var lastIndependentlyAssignedBuildID: String {
      get {
        if case .lastIndependentlyAssignedBuildID(let v)? = _storage._assignedBuildID {return v}
        return String()
      }
      set {_uniqueStorage()._assignedBuildID = .lastIndependentlyAssignedBuildID(newValue)}
    }

    /// Deprecated. The version stamp of the worker to whom this activity was most recently dispatched
    /// This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var lastWorkerVersionStamp: Api.Common.V1.WorkerVersionStamp {
      get {_storage._lastWorkerVersionStamp ?? Api.Common.V1.WorkerVersionStamp()}
      set {_uniqueStorage()._lastWorkerVersionStamp = newValue}
    }
    /// Returns true if `lastWorkerVersionStamp` has been explicitly set.
    public var hasLastWorkerVersionStamp: Bool {_storage._lastWorkerVersionStamp != nil}
    /// Clears the value of `lastWorkerVersionStamp`. Subsequent reads from it will return its default value.
    public mutating func clearLastWorkerVersionStamp() {_uniqueStorage()._lastWorkerVersionStamp = nil}

    /// The time activity will wait until the next retry.
    /// If activity is currently running it will be next retry interval if activity failed.
    /// If activity is currently waiting it will be current retry interval.
    /// If there will be no retry it will be null.
    public var currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._currentRetryInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._currentRetryInterval = newValue}
    }
    /// Returns true if `currentRetryInterval` has been explicitly set.
    public var hasCurrentRetryInterval: Bool {_storage._currentRetryInterval != nil}
    /// Clears the value of `currentRetryInterval`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentRetryInterval() {_uniqueStorage()._currentRetryInterval = nil}

    /// The time when the last activity attempt was completed. If activity has not been completed yet then it will be null.
    public var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastAttemptCompleteTime = newValue}
    }
    /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
    public var hasLastAttemptCompleteTime: Bool {_storage._lastAttemptCompleteTime != nil}
    /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptCompleteTime() {_uniqueStorage()._lastAttemptCompleteTime = nil}

    /// Next time when activity will be scheduled.
    /// If activity is currently scheduled or started it will be null.
    public var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._nextAttemptScheduleTime = newValue}
    }
    /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
    public var hasNextAttemptScheduleTime: Bool {_storage._nextAttemptScheduleTime != nil}
    /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextAttemptScheduleTime() {_uniqueStorage()._nextAttemptScheduleTime = nil}

    /// Indicates if activity is paused.
    public var paused: Bool {
      get {_storage._paused}
      set {_uniqueStorage()._paused = newValue}
    }

    /// The deployment this activity was dispatched to most recently. Present only if the activity
    /// was dispatched to a versioned worker.
    /// Deprecated. Use `last_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var lastDeployment: Api.Deployment.V1.Deployment {
      get {_storage._lastDeployment ?? Api.Deployment.V1.Deployment()}
      set {_uniqueStorage()._lastDeployment = newValue}
    }
    /// Returns true if `lastDeployment` has been explicitly set.
    public var hasLastDeployment: Bool {_storage._lastDeployment != nil}
    /// Clears the value of `lastDeployment`. Subsequent reads from it will return its default value.
    public mutating func clearLastDeployment() {_uniqueStorage()._lastDeployment = nil}

    /// The Worker Deployment Version this activity was dispatched to most recently.
    /// Deprecated. Use `last_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var lastWorkerDeploymentVersion: String {
      get {_storage._lastWorkerDeploymentVersion}
      set {_uniqueStorage()._lastWorkerDeploymentVersion = newValue}
    }

    /// The Worker Deployment Version this activity was dispatched to most recently.
    /// If nil, the activity has not yet been dispatched or was last dispatched to an unversioned worker.
    public var lastDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_storage._lastDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_uniqueStorage()._lastDeploymentVersion = newValue}
    }
    /// Returns true if `lastDeploymentVersion` has been explicitly set.
    public var hasLastDeploymentVersion: Bool {_storage._lastDeploymentVersion != nil}
    /// Clears the value of `lastDeploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearLastDeploymentVersion() {_uniqueStorage()._lastDeploymentVersion = nil}

    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    public var pauseInfo: Api.Workflow.V1.PendingActivityInfo.PauseInfo {
      get {_storage._pauseInfo ?? Api.Workflow.V1.PendingActivityInfo.PauseInfo()}
      set {_uniqueStorage()._pauseInfo = newValue}
    }
    /// Returns true if `pauseInfo` has been explicitly set.
    public var hasPauseInfo: Bool {_storage._pauseInfo != nil}
    /// Clears the value of `pauseInfo`. Subsequent reads from it will return its default value.
    public mutating func clearPauseInfo() {_uniqueStorage()._pauseInfo = nil}

    /// Current activity options. May be different from the one used to start the activity.
    public var activityOptions: Api.Activity.V1.ActivityOptions {
      get {_storage._activityOptions ?? Api.Activity.V1.ActivityOptions()}
      set {_uniqueStorage()._activityOptions = newValue}
    }
    /// Returns true if `activityOptions` has been explicitly set.
    public var hasActivityOptions: Bool {_storage._activityOptions != nil}
    /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
    public mutating func clearActivityOptions() {_uniqueStorage()._activityOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Absence of `assigned_build_id` generally means this task is on an "unversioned" task queue.
    /// In rare cases, it can also mean that the task queue is versioned but we failed to write activity's
    /// independently-assigned build ID to the database. This case heals automatically once the task is dispatched.
    /// Deprecated. This field should be cleaned up when versioning-2 API is removed. [cleanup-experimental-wv]
    public enum OneOf_AssignedBuildID: Equatable, Sendable {
      /// Deprecated. When present, it means this activity is assigned to the build ID of its workflow.
      ///
      /// NOTE: This field was marked as deprecated in the .proto file.
      case useWorkflowBuildID(SwiftProtobuf.Google_Protobuf_Empty)
      /// Deprecated. This means the activity is independently versioned and not bound to the build ID of its workflow.
      /// The activity will use the build id in this field instead.
      /// If the task fails and is scheduled again, the assigned build ID may change according to the latest versioning
      /// rules.
      ///
      /// NOTE: This field was marked as deprecated in the .proto file.
      case lastIndependentlyAssignedBuildID(String)

    }

    public struct PauseInfo: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The time when the activity was paused.
      public var pauseTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {_pauseTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_pauseTime = newValue}
      }
      /// Returns true if `pauseTime` has been explicitly set.
      public var hasPauseTime: Bool {self._pauseTime != nil}
      /// Clears the value of `pauseTime`. Subsequent reads from it will return its default value.
      public mutating func clearPauseTime() {self._pauseTime = nil}

      public var pausedBy: Api.Workflow.V1.PendingActivityInfo.PauseInfo.OneOf_PausedBy? = nil

      /// activity was paused by the manual intervention
      public var manual: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual {
        get {
          if case .manual(let v)? = pausedBy {return v}
          return Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual()
        }
        set {pausedBy = .manual(newValue)}
      }

      /// activity was paused by the rule
      public var rule: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule {
        get {
          if case .rule(let v)? = pausedBy {return v}
          return Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule()
        }
        set {pausedBy = .rule(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_PausedBy: Equatable, Sendable {
        /// activity was paused by the manual intervention
        case manual(Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual)
        /// activity was paused by the rule
        case rule(Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule)

      }

      public struct Manual: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The identity of the actor that paused the activity.
        public var identity: String = String()

        /// Reason for pausing the activity.
        public var reason: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public struct Rule: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// The rule that paused the activity.
        public var ruleID: String = String()

        /// The identity of the actor that created the rule.
        public var identity: String = String()

        /// Reason why rule was created. Populated from rule description.
        public var reason: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _pauseTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflow.V1 {


  public struct PendingChildExecutionInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var workflowID: String = String()

    public var runID: String = String()

    public var workflowTypeName: String = String()

    public var initiatedID: Int64 = 0

    /// Default: PARENT_CLOSE_POLICY_TERMINATE.
    public var parentClosePolicy: Api.Enums.V1.ParentClosePolicy = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflow.V1 {


  public struct PendingWorkflowTaskInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var state: Api.Enums.V1.PendingWorkflowTaskState = .unspecified

    public var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {self._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {self._scheduledTime = nil}

    /// original_scheduled_time is the scheduled time of the first workflow task during workflow task heartbeat.
    /// Heartbeat workflow task is done by RespondWorkflowTaskComplete with ForceCreateNewWorkflowTask == true and no command
    /// In this case, OriginalScheduledTime won't change. Then when current time - original_scheduled_time exceeds
    /// some threshold, the workflow task will be forced timeout.
    public var originalScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_originalScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_originalScheduledTime = newValue}
    }
    /// Returns true if `originalScheduledTime` has been explicitly set.
    public var hasOriginalScheduledTime: Bool {self._originalScheduledTime != nil}
    /// Clears the value of `originalScheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearOriginalScheduledTime() {self._originalScheduledTime = nil}

    public var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startedTime = newValue}
    }
    /// Returns true if `startedTime` has been explicitly set.
    public var hasStartedTime: Bool {self._startedTime != nil}
    /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartedTime() {self._startedTime = nil}

    public var attempt: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _originalScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflow.V1 {


  public struct ResetPoints: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var points: [Api.Workflow.V1.ResetPointInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflow.V1 {


  /// ResetPointInfo records the workflow event id that is the first one processed by a given
  /// build id or binary checksum. A new reset point will be created if either build id or binary
  /// checksum changes (although in general only one or the other will be used at a time).
  public struct ResetPointInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Worker build id.
    public var buildID: String = String()

    /// Deprecated. A worker binary version identifier.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var binaryChecksum: String = String()

    /// The first run ID in the execution chain that was touched by this worker build.
    public var runID: String = String()

    /// Event ID of the first WorkflowTaskCompleted event processed by this worker build.
    public var firstWorkflowTaskCompletedID: Int64 = 0

    public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createTime = newValue}
    }
    /// Returns true if `createTime` has been explicitly set.
    public var hasCreateTime: Bool {self._createTime != nil}
    /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreateTime() {self._createTime = nil}

    /// (-- api-linter: core::0214::resource-expiry=disabled
    ///     aip.dev/not-precedent: TTL is not defined for ResetPointInfo. --)
    /// The time that the run is deleted due to retention.
    public var expireTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_expireTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expireTime = newValue}
    }
    /// Returns true if `expireTime` has been explicitly set.
    public var hasExpireTime: Bool {self._expireTime != nil}
    /// Clears the value of `expireTime`. Subsequent reads from it will return its default value.
    public mutating func clearExpireTime() {self._expireTime = nil}

    /// false if the reset point has pending childWFs/reqCancels/signalExternals.
    public var resettable: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _expireTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflow.V1 {


  /// NewWorkflowExecutionInfo is a shared message that encapsulates all the
  /// required arguments to starting a workflow in different contexts.
  public struct NewWorkflowExecutionInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var workflowID: String {
      get {_storage._workflowID}
      set {_uniqueStorage()._workflowID = newValue}
    }

    public var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    /// Serialized arguments to the workflow.
    public var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Total workflow execution timeout including retries and continue as new.
    public var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    public var hasWorkflowExecutionTimeout: Bool {_storage._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

    /// Timeout of a single workflow run.
    public var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    public var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task.
    public var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    public var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    public var workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy {
      get {_storage._workflowIDReusePolicy}
      set {_uniqueStorage()._workflowIDReusePolicy = newValue}
    }

    /// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    public var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    public var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {_uniqueStorage()._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionConfig
    /// for use by user interfaces to display the fixed as-of-start summary and details of the
    /// workflow.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    public var versioningOverride: Api.Workflow.V1.VersioningOverride {
      get {_storage._versioningOverride ?? Api.Workflow.V1.VersioningOverride()}
      set {_uniqueStorage()._versioningOverride = newValue}
    }
    /// Returns true if `versioningOverride` has been explicitly set.
    public var hasVersioningOverride: Bool {_storage._versioningOverride != nil}
    /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

    /// Priority metadata
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflow.V1 {


  /// CallbackInfo contains the state of an attached workflow callback.
  public struct CallbackInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Information on how this callback should be invoked (e.g. its URL and type).
    public var callback: Api.Common.V1.Callback {
      get {_callback ?? Api.Common.V1.Callback()}
      set {_callback = newValue}
    }
    /// Returns true if `callback` has been explicitly set.
    public var hasCallback: Bool {self._callback != nil}
    /// Clears the value of `callback`. Subsequent reads from it will return its default value.
    public mutating func clearCallback() {self._callback = nil}

    /// Trigger for this callback.
    public var trigger: Api.Workflow.V1.CallbackInfo.Trigger {
      get {_trigger ?? Api.Workflow.V1.CallbackInfo.Trigger()}
      set {_trigger = newValue}
    }
    /// Returns true if `trigger` has been explicitly set.
    public var hasTrigger: Bool {self._trigger != nil}
    /// Clears the value of `trigger`. Subsequent reads from it will return its default value.
    public mutating func clearTrigger() {self._trigger = nil}

    /// The time when the callback was registered.
    public var registrationTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_registrationTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_registrationTime = newValue}
    }
    /// Returns true if `registrationTime` has been explicitly set.
    public var hasRegistrationTime: Bool {self._registrationTime != nil}
    /// Clears the value of `registrationTime`. Subsequent reads from it will return its default value.
    public mutating func clearRegistrationTime() {self._registrationTime = nil}

    public var state: Api.Enums.V1.CallbackState = .unspecified

    /// The number of attempts made to deliver the callback.
    /// This number represents a minimum bound since the attempt is incremented after the callback request completes.
    public var attempt: Int32 = 0

    /// The time when the last attempt completed.
    public var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastAttemptCompleteTime = newValue}
    }
    /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
    public var hasLastAttemptCompleteTime: Bool {self._lastAttemptCompleteTime != nil}
    /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptCompleteTime() {self._lastAttemptCompleteTime = nil}

    /// The last attempt's failure, if any.
    public var lastAttemptFailure: Api.Failure.V1.Failure {
      get {_lastAttemptFailure ?? Api.Failure.V1.Failure()}
      set {_lastAttemptFailure = newValue}
    }
    /// Returns true if `lastAttemptFailure` has been explicitly set.
    public var hasLastAttemptFailure: Bool {self._lastAttemptFailure != nil}
    /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptFailure() {self._lastAttemptFailure = nil}

    /// The time when the next attempt is scheduled.
    public var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_nextAttemptScheduleTime = newValue}
    }
    /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
    public var hasNextAttemptScheduleTime: Bool {self._nextAttemptScheduleTime != nil}
    /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextAttemptScheduleTime() {self._nextAttemptScheduleTime = nil}

    /// If the state is BLOCKED, blocked reason provides additional information.
    public var blockedReason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Trigger for when the workflow is closed.
    public struct WorkflowClosed: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct Trigger: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var variant: Api.Workflow.V1.CallbackInfo.Trigger.OneOf_Variant? = nil

      public var workflowClosed: Api.Workflow.V1.CallbackInfo.WorkflowClosed {
        get {
          if case .workflowClosed(let v)? = variant {return v}
          return Api.Workflow.V1.CallbackInfo.WorkflowClosed()
        }
        set {variant = .workflowClosed(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Variant: Equatable, Sendable {
        case workflowClosed(Api.Workflow.V1.CallbackInfo.WorkflowClosed)

      }

      public init() {}
    }

    public init() {}

    fileprivate var _callback: Api.Common.V1.Callback? = nil
    fileprivate var _trigger: Api.Workflow.V1.CallbackInfo.Trigger? = nil
    fileprivate var _registrationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastAttemptFailure: Api.Failure.V1.Failure? = nil
    fileprivate var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflow.V1 {


  /// PendingNexusOperationInfo contains the state of a pending Nexus operation.
  public struct PendingNexusOperationInfo: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Endpoint name.
    /// Resolved to a URL via the cluster's endpoint registry.
    public var endpoint: String {
      get {_storage._endpoint}
      set {_uniqueStorage()._endpoint = newValue}
    }

    /// Service name.
    public var service: String {
      get {_storage._service}
      set {_uniqueStorage()._service = newValue}
    }

    /// Operation name.
    public var operation: String {
      get {_storage._operation}
      set {_uniqueStorage()._operation = newValue}
    }

    /// Operation ID. Only set for asynchronous operations after a successful StartOperation call.
    ///
    /// Deprecated. Renamed to operation_token.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var operationID: String {
      get {_storage._operationID}
      set {_uniqueStorage()._operationID = newValue}
    }

    /// Schedule-to-close timeout for this operation.
    /// This is the only timeout settable by a workflow.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    public var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// The time when the operation was scheduled.
    public var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {_storage._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

    public var state: Api.Enums.V1.PendingNexusOperationState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The number of attempts made to deliver the start operation request.
    /// This number represents a minimum bound since the attempt is incremented after the request completes.
    public var attempt: Int32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// The time when the last attempt completed.
    public var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastAttemptCompleteTime = newValue}
    }
    /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
    public var hasLastAttemptCompleteTime: Bool {_storage._lastAttemptCompleteTime != nil}
    /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptCompleteTime() {_uniqueStorage()._lastAttemptCompleteTime = nil}

    /// The last attempt's failure, if any.
    public var lastAttemptFailure: Api.Failure.V1.Failure {
      get {_storage._lastAttemptFailure ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._lastAttemptFailure = newValue}
    }
    /// Returns true if `lastAttemptFailure` has been explicitly set.
    public var hasLastAttemptFailure: Bool {_storage._lastAttemptFailure != nil}
    /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptFailure() {_uniqueStorage()._lastAttemptFailure = nil}

    /// The time when the next attempt is scheduled.
    public var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._nextAttemptScheduleTime = newValue}
    }
    /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
    public var hasNextAttemptScheduleTime: Bool {_storage._nextAttemptScheduleTime != nil}
    /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextAttemptScheduleTime() {_uniqueStorage()._nextAttemptScheduleTime = nil}

    public var cancellationInfo: Api.Workflow.V1.NexusOperationCancellationInfo {
      get {_storage._cancellationInfo ?? Api.Workflow.V1.NexusOperationCancellationInfo()}
      set {_uniqueStorage()._cancellationInfo = newValue}
    }
    /// Returns true if `cancellationInfo` has been explicitly set.
    public var hasCancellationInfo: Bool {_storage._cancellationInfo != nil}
    /// Clears the value of `cancellationInfo`. Subsequent reads from it will return its default value.
    public mutating func clearCancellationInfo() {_uniqueStorage()._cancellationInfo = nil}

    /// The event ID of the NexusOperationScheduled event. Can be used to correlate an operation in the
    /// DescribeWorkflowExecution response with workflow history.
    public var scheduledEventID: Int64 {
      get {_storage._scheduledEventID}
      set {_uniqueStorage()._scheduledEventID = newValue}
    }

    /// If the state is BLOCKED, blocked reason provides additional information.
    public var blockedReason: String {
      get {_storage._blockedReason}
      set {_uniqueStorage()._blockedReason = newValue}
    }

    /// Operation token. Only set for asynchronous operations after a successful StartOperation call.
    public var operationToken: String {
      get {_storage._operationToken}
      set {_uniqueStorage()._operationToken = newValue}
    }

    /// Schedule-to-start timeout for this operation.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    public var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Start-to-close timeout for this operation.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    public var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflow.V1 {


  /// NexusOperationCancellationInfo contains the state of a nexus operation cancellation.
  public struct NexusOperationCancellationInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The time when cancellation was requested.
    public var requestedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_requestedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_requestedTime = newValue}
    }
    /// Returns true if `requestedTime` has been explicitly set.
    public var hasRequestedTime: Bool {self._requestedTime != nil}
    /// Clears the value of `requestedTime`. Subsequent reads from it will return its default value.
    public mutating func clearRequestedTime() {self._requestedTime = nil}

    public var state: Api.Enums.V1.NexusOperationCancellationState = .unspecified

    /// The number of attempts made to deliver the cancel operation request.
    /// This number represents a minimum bound since the attempt is incremented after the request completes.
    public var attempt: Int32 = 0

    /// The time when the last attempt completed.
    public var lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastAttemptCompleteTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastAttemptCompleteTime = newValue}
    }
    /// Returns true if `lastAttemptCompleteTime` has been explicitly set.
    public var hasLastAttemptCompleteTime: Bool {self._lastAttemptCompleteTime != nil}
    /// Clears the value of `lastAttemptCompleteTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptCompleteTime() {self._lastAttemptCompleteTime = nil}

    /// The last attempt's failure, if any.
    public var lastAttemptFailure: Api.Failure.V1.Failure {
      get {_lastAttemptFailure ?? Api.Failure.V1.Failure()}
      set {_lastAttemptFailure = newValue}
    }
    /// Returns true if `lastAttemptFailure` has been explicitly set.
    public var hasLastAttemptFailure: Bool {self._lastAttemptFailure != nil}
    /// Clears the value of `lastAttemptFailure`. Subsequent reads from it will return its default value.
    public mutating func clearLastAttemptFailure() {self._lastAttemptFailure = nil}

    /// The time when the next attempt is scheduled.
    public var nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_nextAttemptScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_nextAttemptScheduleTime = newValue}
    }
    /// Returns true if `nextAttemptScheduleTime` has been explicitly set.
    public var hasNextAttemptScheduleTime: Bool {self._nextAttemptScheduleTime != nil}
    /// Clears the value of `nextAttemptScheduleTime`. Subsequent reads from it will return its default value.
    public mutating func clearNextAttemptScheduleTime() {self._nextAttemptScheduleTime = nil}

    /// If the state is BLOCKED, blocked reason provides additional information.
    public var blockedReason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _requestedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastAttemptFailure: Api.Failure.V1.Failure? = nil
    fileprivate var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflow.V1 {


  public struct WorkflowExecutionOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    public var versioningOverride: Api.Workflow.V1.VersioningOverride {
      get {_versioningOverride ?? Api.Workflow.V1.VersioningOverride()}
      set {_versioningOverride = newValue}
    }
    /// Returns true if `versioningOverride` has been explicitly set.
    public var hasVersioningOverride: Bool {self._versioningOverride != nil}
    /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningOverride() {self._versioningOverride = nil}

    /// If set, overrides the workflow's priority sent by the SDK.
    public var priority: Api.Common.V1.Priority {
      get {_priority ?? Api.Common.V1.Priority()}
      set {_priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {self._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {self._priority = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _versioningOverride: Api.Workflow.V1.VersioningOverride? = nil
    fileprivate var _priority: Api.Common.V1.Priority? = nil
  }
}
extension Api.Workflow.V1 {


  /// Used to override the versioning behavior (and pinned deployment version, if applicable) of a
  /// specific workflow execution. If set, this override takes precedence over worker-sent values.
  /// See `WorkflowExecutionInfo.VersioningInfo` for more information.
  ///
  /// To remove the override, call `UpdateWorkflowExecutionOptions` with a null
  /// `VersioningOverride`, and use the `update_mask` to indicate that it should be mutated.
  ///
  /// Pinned behavior overrides are automatically inherited by child workflows, workflow retries, continue-as-new
  /// workflows, and cron workflows.
  public struct VersioningOverride: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Indicates whether to override the workflow to be AutoUpgrade or Pinned.
    public var override: Api.Workflow.V1.VersioningOverride.OneOf_Override? = nil

    /// Override the workflow to have Pinned behavior.
    public var pinned: Api.Workflow.V1.VersioningOverride.PinnedOverride {
      get {
        if case .pinned(let v)? = override {return v}
        return Api.Workflow.V1.VersioningOverride.PinnedOverride()
      }
      set {override = .pinned(newValue)}
    }

    /// Override the workflow to have AutoUpgrade behavior.
    public var autoUpgrade: Bool {
      get {
        if case .autoUpgrade(let v)? = override {return v}
        return false
      }
      set {override = .autoUpgrade(newValue)}
    }

    /// Required.
    /// Deprecated. Use `override`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var behavior: Api.Enums.V1.VersioningBehavior = .unspecified

    /// Required if behavior is `PINNED`. Must be null if behavior is `AUTO_UPGRADE`.
    /// Identifies the worker deployment to pin the workflow to.
    /// Deprecated. Use `override.pinned.version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Required if behavior is `PINNED`. Must be absent if behavior is not `PINNED`.
    /// Identifies the worker deployment version to pin the workflow to, in the format
    /// "<deployment_name>.<build_id>".
    /// Deprecated. Use `override.pinned.version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var pinnedVersion: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Indicates whether to override the workflow to be AutoUpgrade or Pinned.
    public enum OneOf_Override: Equatable, Sendable {
      /// Override the workflow to have Pinned behavior.
      case pinned(Api.Workflow.V1.VersioningOverride.PinnedOverride)
      /// Override the workflow to have AutoUpgrade behavior.
      case autoUpgrade(Bool)

    }

    public enum PinnedOverrideBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int

      /// Unspecified.
      case unspecified // = 0

      /// Override workflow behavior to be Pinned.
      case pinned // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .pinned
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .pinned: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Api.Workflow.V1.VersioningOverride.PinnedOverrideBehavior] = [
        .unspecified,
        .pinned,
      ]

    }

    public struct PinnedOverride: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Defaults to PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED.
      /// See `PinnedOverrideBehavior` for details.
      public var behavior: Api.Workflow.V1.VersioningOverride.PinnedOverrideBehavior = .unspecified

      /// Specifies the Worker Deployment Version to pin this workflow to.
      /// Required if the target workflow is not already pinned to a version.
      ///
      /// If omitted and the target workflow is already pinned, the effective
      /// pinned version will be the existing pinned version.
      ///
      /// If omitted and the target workflow is not pinned, the override request
      /// will be rejected with a PreconditionFailed error.
      public var version: Api.Deployment.V1.WorkerDeploymentVersion {
        get {_version ?? Api.Deployment.V1.WorkerDeploymentVersion()}
        set {_version = newValue}
      }
      /// Returns true if `version` has been explicitly set.
      public var hasVersion: Bool {self._version != nil}
      /// Clears the value of `version`. Subsequent reads from it will return its default value.
      public mutating func clearVersion() {self._version = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _version: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    }

    public init() {}

    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
  }
}
extension Api.Workflow.V1 {


  /// When StartWorkflowExecution uses the conflict policy WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING and
  /// there is already an existing running workflow, OnConflictOptions defines actions to be taken on
  /// the existing running workflow. In this case, it will create a WorkflowExecutionOptionsUpdatedEvent
  /// history event in the running workflow with the changes requested in this object.
  public struct OnConflictOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Attaches the request ID to the running workflow.
    public var attachRequestID: Bool = false

    /// Attaches the completion callbacks to the running workflow.
    public var attachCompletionCallbacks: Bool = false

    /// Attaches the links to the WorkflowExecutionOptionsUpdatedEvent history event.
    public var attachLinks: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflow.V1 {


  /// RequestIdInfo contains details of a request ID.
  public struct RequestIdInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The event type of the history event generated by the request.
    public var eventType: Api.Enums.V1.EventType = .unspecified

    /// The event id of the history event generated by the request. It's possible the event ID is not
    /// known (unflushed buffered event). In this case, the value will be zero or a negative value,
    /// representing an invalid ID.
    public var eventID: Int64 = 0

    /// Indicate if the request is still buffered. If so, the event ID is not known and its value
    /// will be an invalid event ID.
    public var buffered: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflow.V1 {


  /// PostResetOperation represents an operation to be performed on the new workflow execution after a workflow reset.
  public struct PostResetOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var variant: Api.Workflow.V1.PostResetOperation.OneOf_Variant? = nil

    public var signalWorkflow: Api.Workflow.V1.PostResetOperation.SignalWorkflow {
      get {
        if case .signalWorkflow(let v)? = variant {return v}
        return Api.Workflow.V1.PostResetOperation.SignalWorkflow()
      }
      set {variant = .signalWorkflow(newValue)}
    }

    public var updateWorkflowOptions: Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions {
      get {
        if case .updateWorkflowOptions(let v)? = variant {return v}
        return Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions()
      }
      set {variant = .updateWorkflowOptions(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Variant: Equatable, Sendable {
      case signalWorkflow(Api.Workflow.V1.PostResetOperation.SignalWorkflow)
      case updateWorkflowOptions(Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions)

    }

    /// SignalWorkflow represents sending a signal after a workflow reset.
    /// Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
    public struct SignalWorkflow: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The workflow author-defined name of the signal to send to the workflow.
      public var signalName: String = String()

      /// Serialized value(s) to provide with the signal.
      public var input: Api.Common.V1.Payloads {
        get {_input ?? Api.Common.V1.Payloads()}
        set {_input = newValue}
      }
      /// Returns true if `input` has been explicitly set.
      public var hasInput: Bool {self._input != nil}
      /// Clears the value of `input`. Subsequent reads from it will return its default value.
      public mutating func clearInput() {self._input = nil}

      /// Headers that are passed with the signal to the processing workflow.
      public var header: Api.Common.V1.Header {
        get {_header ?? Api.Common.V1.Header()}
        set {_header = newValue}
      }
      /// Returns true if `header` has been explicitly set.
      public var hasHeader: Bool {self._header != nil}
      /// Clears the value of `header`. Subsequent reads from it will return its default value.
      public mutating func clearHeader() {self._header = nil}

      /// Links to be associated with the WorkflowExecutionSignaled event.
      public var links: [Api.Common.V1.Link] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _input: Api.Common.V1.Payloads? = nil
      fileprivate var _header: Api.Common.V1.Header? = nil
    }

    /// UpdateWorkflowOptions represents updating workflow execution options after a workflow reset.
    /// Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
    public struct UpdateWorkflowOptions: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
      public var workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions {
        get {_workflowExecutionOptions ?? Api.Workflow.V1.WorkflowExecutionOptions()}
        set {_workflowExecutionOptions = newValue}
      }
      /// Returns true if `workflowExecutionOptions` has been explicitly set.
      public var hasWorkflowExecutionOptions: Bool {self._workflowExecutionOptions != nil}
      /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
      public mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

      /// Controls which fields from `workflow_execution_options` will be applied.
      /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
      public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
        get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
        set {_updateMask = newValue}
      }
      /// Returns true if `updateMask` has been explicitly set.
      public var hasUpdateMask: Bool {self._updateMask != nil}
      /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
      public mutating func clearUpdateMask() {self._updateMask = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions? = nil
      fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    }

    public init() {}
  }
}
extension Api.Workflow.V1 {


  /// WorkflowExecutionPauseInfo contains the information about a workflow execution pause.
  public struct WorkflowExecutionPauseInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the client who paused the workflow execution.
    public var identity: String = String()

    /// The time when the workflow execution was paused.
    public var pausedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_pausedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_pausedTime = newValue}
    }
    /// Returns true if `pausedTime` has been explicitly set.
    public var hasPausedTime: Bool {self._pausedTime != nil}
    /// Clears the value of `pausedTime`. Subsequent reads from it will return its default value.
    public mutating func clearPausedTime() {self._pausedTime = nil}

    /// The reason for pausing the workflow execution.
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pausedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.workflow.v1"

extension Api.Workflow.V1.WorkflowExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}execution\0\u{1}type\0\u{3}start_time\0\u{3}close_time\0\u{1}status\0\u{3}history_length\0\u{3}parent_namespace_id\0\u{3}parent_execution\0\u{3}execution_time\0\u{1}memo\0\u{3}search_attributes\0\u{3}auto_reset_points\0\u{3}task_queue\0\u{3}state_transition_count\0\u{3}history_size_bytes\0\u{3}most_recent_worker_version_stamp\0\u{3}execution_duration\0\u{3}root_execution\0\u{3}assigned_build_id\0\u{3}inherited_build_id\0\u{3}first_run_id\0\u{3}versioning_info\0\u{3}worker_deployment_name\0\u{1}priority\0\u{3}external_payload_size_bytes\0\u{3}external_payload_count\0")

  fileprivate class _StorageClass {
    var _execution: Api.Common.V1.WorkflowExecution? = nil
    var _type: Api.Common.V1.WorkflowType? = nil
    var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _status: Api.Enums.V1.WorkflowExecutionStatus = .unspecified
    var _historyLength: Int64 = 0
    var _parentNamespaceID: String = String()
    var _parentExecution: Api.Common.V1.WorkflowExecution? = nil
    var _executionTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _autoResetPoints: Api.Workflow.V1.ResetPoints? = nil
    var _taskQueue: String = String()
    var _stateTransitionCount: Int64 = 0
    var _historySizeBytes: Int64 = 0
    var _mostRecentWorkerVersionStamp: Api.Common.V1.WorkerVersionStamp? = nil
    var _executionDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _rootExecution: Api.Common.V1.WorkflowExecution? = nil
    var _assignedBuildID: String = String()
    var _inheritedBuildID: String = String()
    var _firstRunID: String = String()
    var _versioningInfo: Api.Workflow.V1.WorkflowExecutionVersioningInfo? = nil
    var _workerDeploymentName: String = String()
    var _priority: Api.Common.V1.Priority? = nil
    var _externalPayloadSizeBytes: Int64 = 0
    var _externalPayloadCount: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _execution = source._execution
      _type = source._type
      _startTime = source._startTime
      _closeTime = source._closeTime
      _status = source._status
      _historyLength = source._historyLength
      _parentNamespaceID = source._parentNamespaceID
      _parentExecution = source._parentExecution
      _executionTime = source._executionTime
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _autoResetPoints = source._autoResetPoints
      _taskQueue = source._taskQueue
      _stateTransitionCount = source._stateTransitionCount
      _historySizeBytes = source._historySizeBytes
      _mostRecentWorkerVersionStamp = source._mostRecentWorkerVersionStamp
      _executionDuration = source._executionDuration
      _rootExecution = source._rootExecution
      _assignedBuildID = source._assignedBuildID
      _inheritedBuildID = source._inheritedBuildID
      _firstRunID = source._firstRunID
      _versioningInfo = source._versioningInfo
      _workerDeploymentName = source._workerDeploymentName
      _priority = source._priority
      _externalPayloadSizeBytes = source._externalPayloadSizeBytes
      _externalPayloadCount = source._externalPayloadCount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._execution) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._startTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._closeTime) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 6: try { try decoder.decodeSingularInt64Field(value: &_storage._historyLength) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._parentNamespaceID) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._parentExecution) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._executionTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._autoResetPoints) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 14: try { try decoder.decodeSingularInt64Field(value: &_storage._stateTransitionCount) }()
        case 15: try { try decoder.decodeSingularInt64Field(value: &_storage._historySizeBytes) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._mostRecentWorkerVersionStamp) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._executionDuration) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._rootExecution) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._assignedBuildID) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._inheritedBuildID) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._firstRunID) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._versioningInfo) }()
        case 23: try { try decoder.decodeSingularStringField(value: &_storage._workerDeploymentName) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 25: try { try decoder.decodeSingularInt64Field(value: &_storage._externalPayloadSizeBytes) }()
        case 26: try { try decoder.decodeSingularInt64Field(value: &_storage._externalPayloadCount) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._execution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._type {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._startTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._closeTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._status != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 5)
      }
      if _storage._historyLength != 0 {
        try visitor.visitSingularInt64Field(value: _storage._historyLength, fieldNumber: 6)
      }
      if !_storage._parentNamespaceID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._parentNamespaceID, fieldNumber: 7)
      }
      try { if let v = _storage._parentExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._executionTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._autoResetPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 13)
      }
      if _storage._stateTransitionCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._stateTransitionCount, fieldNumber: 14)
      }
      if _storage._historySizeBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._historySizeBytes, fieldNumber: 15)
      }
      try { if let v = _storage._mostRecentWorkerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._executionDuration {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._rootExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if !_storage._assignedBuildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assignedBuildID, fieldNumber: 19)
      }
      if !_storage._inheritedBuildID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._inheritedBuildID, fieldNumber: 20)
      }
      if !_storage._firstRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._firstRunID, fieldNumber: 21)
      }
      try { if let v = _storage._versioningInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      if !_storage._workerDeploymentName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workerDeploymentName, fieldNumber: 23)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      if _storage._externalPayloadSizeBytes != 0 {
        try visitor.visitSingularInt64Field(value: _storage._externalPayloadSizeBytes, fieldNumber: 25)
      }
      if _storage._externalPayloadCount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._externalPayloadCount, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionInfo, rhs: Api.Workflow.V1.WorkflowExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._execution != rhs_storage._execution {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._startTime != rhs_storage._startTime {return false}
        if _storage._closeTime != rhs_storage._closeTime {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._historyLength != rhs_storage._historyLength {return false}
        if _storage._parentNamespaceID != rhs_storage._parentNamespaceID {return false}
        if _storage._parentExecution != rhs_storage._parentExecution {return false}
        if _storage._executionTime != rhs_storage._executionTime {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._autoResetPoints != rhs_storage._autoResetPoints {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._stateTransitionCount != rhs_storage._stateTransitionCount {return false}
        if _storage._historySizeBytes != rhs_storage._historySizeBytes {return false}
        if _storage._mostRecentWorkerVersionStamp != rhs_storage._mostRecentWorkerVersionStamp {return false}
        if _storage._executionDuration != rhs_storage._executionDuration {return false}
        if _storage._rootExecution != rhs_storage._rootExecution {return false}
        if _storage._assignedBuildID != rhs_storage._assignedBuildID {return false}
        if _storage._inheritedBuildID != rhs_storage._inheritedBuildID {return false}
        if _storage._firstRunID != rhs_storage._firstRunID {return false}
        if _storage._versioningInfo != rhs_storage._versioningInfo {return false}
        if _storage._workerDeploymentName != rhs_storage._workerDeploymentName {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._externalPayloadSizeBytes != rhs_storage._externalPayloadSizeBytes {return false}
        if _storage._externalPayloadCount != rhs_storage._externalPayloadCount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.WorkflowExecutionExtendedInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionExtendedInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_expiration_time\0\u{3}run_expiration_time\0\u{3}cancel_requested\0\u{3}last_reset_time\0\u{3}original_start_time\0\u{3}reset_run_id\0\u{3}request_id_infos\0\u{3}pause_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._executionExpirationTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._runExpirationTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastResetTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._originalStartTime) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.resetRunID) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Workflow.V1.RequestIdInfo>.self, value: &self.requestIDInfos) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._pauseInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._executionExpirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._runExpirationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 3)
    }
    try { if let v = self._lastResetTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._originalStartTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.resetRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.resetRunID, fieldNumber: 6)
    }
    if !self.requestIDInfos.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Workflow.V1.RequestIdInfo>.self, value: self.requestIDInfos, fieldNumber: 7)
    }
    try { if let v = self._pauseInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionExtendedInfo, rhs: Api.Workflow.V1.WorkflowExecutionExtendedInfo) -> Bool {
    if lhs._executionExpirationTime != rhs._executionExpirationTime {return false}
    if lhs._runExpirationTime != rhs._runExpirationTime {return false}
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs._lastResetTime != rhs._lastResetTime {return false}
    if lhs._originalStartTime != rhs._originalStartTime {return false}
    if lhs.resetRunID != rhs.resetRunID {return false}
    if lhs.requestIDInfos != rhs.requestIDInfos {return false}
    if lhs._pauseInfo != rhs._pauseInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.WorkflowExecutionVersioningInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionVersioningInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}deployment\0\u{3}versioning_override\0\u{3}deployment_transition\0\u{1}version\0\u{3}version_transition\0\u{3}deployment_version\0\u{3}revision_number\0")

  fileprivate class _StorageClass {
    var _behavior: Api.Enums.V1.VersioningBehavior = .unspecified
    var _deployment: Api.Deployment.V1.Deployment? = nil
    var _version: String = String()
    var _deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    var _versioningOverride: Api.Workflow.V1.VersioningOverride? = nil
    var _deploymentTransition: Api.Workflow.V1.DeploymentTransition? = nil
    var _versionTransition: Api.Workflow.V1.DeploymentVersionTransition? = nil
    var _revisionNumber: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _behavior = source._behavior
      _deployment = source._deployment
      _version = source._version
      _deploymentVersion = source._deploymentVersion
      _versioningOverride = source._versioningOverride
      _deploymentTransition = source._deploymentTransition
      _versionTransition = source._versionTransition
      _revisionNumber = source._revisionNumber
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._behavior) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentTransition) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._version) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._versionTransition) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentVersion) }()
        case 8: try { try decoder.decodeSingularInt64Field(value: &_storage._revisionNumber) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._behavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._behavior, fieldNumber: 1)
      }
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._deploymentTransition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._version.isEmpty {
        try visitor.visitSingularStringField(value: _storage._version, fieldNumber: 5)
      }
      try { if let v = _storage._versionTransition {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._deploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._revisionNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._revisionNumber, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionVersioningInfo, rhs: Api.Workflow.V1.WorkflowExecutionVersioningInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._behavior != rhs_storage._behavior {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._version != rhs_storage._version {return false}
        if _storage._deploymentVersion != rhs_storage._deploymentVersion {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._deploymentTransition != rhs_storage._deploymentTransition {return false}
        if _storage._versionTransition != rhs_storage._versionTransition {return false}
        if _storage._revisionNumber != rhs_storage._revisionNumber {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.DeploymentTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeploymentTransition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deployment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.DeploymentTransition, rhs: Api.Workflow.V1.DeploymentTransition) -> Bool {
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.DeploymentVersionTransition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeploymentVersionTransition"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{3}deployment_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 1)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.DeploymentVersionTransition, rhs: Api.Workflow.V1.DeploymentVersionTransition) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.WorkflowExecutionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionConfig"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_queue\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}default_workflow_task_timeout\0\u{3}user_metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionTimeout) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowRunTimeout) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._defaultWorkflowTaskTimeout) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._userMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._workflowExecutionTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowRunTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._defaultWorkflowTaskTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._userMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionConfig, rhs: Api.Workflow.V1.WorkflowExecutionConfig) -> Bool {
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs._workflowExecutionTimeout != rhs._workflowExecutionTimeout {return false}
    if lhs._workflowRunTimeout != rhs._workflowRunTimeout {return false}
    if lhs._defaultWorkflowTaskTimeout != rhs._defaultWorkflowTaskTimeout {return false}
    if lhs._userMetadata != rhs._userMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingActivityInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingActivityInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}activity_type\0\u{1}state\0\u{3}heartbeat_details\0\u{3}last_heartbeat_time\0\u{3}last_started_time\0\u{1}attempt\0\u{3}maximum_attempts\0\u{3}scheduled_time\0\u{3}expiration_time\0\u{3}last_failure\0\u{3}last_worker_identity\0\u{3}use_workflow_build_id\0\u{3}last_independently_assigned_build_id\0\u{3}last_worker_version_stamp\0\u{3}current_retry_interval\0\u{3}last_attempt_complete_time\0\u{3}next_attempt_schedule_time\0\u{1}paused\0\u{3}last_deployment\0\u{3}last_worker_deployment_version\0\u{1}priority\0\u{3}pause_info\0\u{3}activity_options\0\u{3}last_deployment_version\0")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _activityType: Api.Common.V1.ActivityType? = nil
    var _state: Api.Enums.V1.PendingActivityState = .unspecified
    var _heartbeatDetails: Api.Common.V1.Payloads? = nil
    var _lastHeartbeatTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastStartedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: Int32 = 0
    var _maximumAttempts: Int32 = 0
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expirationTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastFailure: Api.Failure.V1.Failure? = nil
    var _lastWorkerIdentity: String = String()
    var _assignedBuildID: Api.Workflow.V1.PendingActivityInfo.OneOf_AssignedBuildID?
    var _lastWorkerVersionStamp: Api.Common.V1.WorkerVersionStamp? = nil
    var _currentRetryInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _paused: Bool = false
    var _lastDeployment: Api.Deployment.V1.Deployment? = nil
    var _lastWorkerDeploymentVersion: String = String()
    var _lastDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
    var _priority: Api.Common.V1.Priority? = nil
    var _pauseInfo: Api.Workflow.V1.PendingActivityInfo.PauseInfo? = nil
    var _activityOptions: Api.Activity.V1.ActivityOptions? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _activityType = source._activityType
      _state = source._state
      _heartbeatDetails = source._heartbeatDetails
      _lastHeartbeatTime = source._lastHeartbeatTime
      _lastStartedTime = source._lastStartedTime
      _attempt = source._attempt
      _maximumAttempts = source._maximumAttempts
      _scheduledTime = source._scheduledTime
      _expirationTime = source._expirationTime
      _lastFailure = source._lastFailure
      _lastWorkerIdentity = source._lastWorkerIdentity
      _assignedBuildID = source._assignedBuildID
      _lastWorkerVersionStamp = source._lastWorkerVersionStamp
      _currentRetryInterval = source._currentRetryInterval
      _lastAttemptCompleteTime = source._lastAttemptCompleteTime
      _nextAttemptScheduleTime = source._nextAttemptScheduleTime
      _paused = source._paused
      _lastDeployment = source._lastDeployment
      _lastWorkerDeploymentVersion = source._lastWorkerDeploymentVersion
      _lastDeploymentVersion = source._lastDeploymentVersion
      _priority = source._priority
      _pauseInfo = source._pauseInfo
      _activityOptions = source._activityOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatDetails) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._lastHeartbeatTime) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._lastStartedTime) }()
        case 7: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._maximumAttempts) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._expirationTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastFailure) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._lastWorkerIdentity) }()
        case 13: try {
          var v: SwiftProtobuf.Google_Protobuf_Empty?
          var hadOneofValue = false
          if let current = _storage._assignedBuildID {
            hadOneofValue = true
            if case .useWorkflowBuildID(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._assignedBuildID = .useWorkflowBuildID(v)
          }
        }()
        case 14: try {
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {
            if _storage._assignedBuildID != nil {try decoder.handleConflictingOneOf()}
            _storage._assignedBuildID = .lastIndependentlyAssignedBuildID(v)
          }
        }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._lastWorkerVersionStamp) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._currentRetryInterval) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptCompleteTime) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._nextAttemptScheduleTime) }()
        case 19: try { try decoder.decodeSingularBoolField(value: &_storage._paused) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeployment) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._lastWorkerDeploymentVersion) }()
        case 22: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._pauseInfo) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._activityOptions) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._lastDeploymentVersion) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._heartbeatDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._lastHeartbeatTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._lastStartedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 7)
      }
      if _storage._maximumAttempts != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maximumAttempts, fieldNumber: 8)
      }
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._expirationTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lastFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._lastWorkerIdentity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastWorkerIdentity, fieldNumber: 12)
      }
      switch _storage._assignedBuildID {
      case .useWorkflowBuildID?: try {
        guard case .useWorkflowBuildID(let v)? = _storage._assignedBuildID else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .lastIndependentlyAssignedBuildID?: try {
        guard case .lastIndependentlyAssignedBuildID(let v)? = _storage._assignedBuildID else { preconditionFailure() }
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._lastWorkerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._currentRetryInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._lastAttemptCompleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._nextAttemptScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      if _storage._paused != false {
        try visitor.visitSingularBoolField(value: _storage._paused, fieldNumber: 19)
      }
      try { if let v = _storage._lastDeployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._lastWorkerDeploymentVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastWorkerDeploymentVersion, fieldNumber: 21)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._pauseInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._activityOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._lastDeploymentVersion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingActivityInfo, rhs: Api.Workflow.V1.PendingActivityInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._lastHeartbeatTime != rhs_storage._lastHeartbeatTime {return false}
        if _storage._lastStartedTime != rhs_storage._lastStartedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._maximumAttempts != rhs_storage._maximumAttempts {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._expirationTime != rhs_storage._expirationTime {return false}
        if _storage._lastFailure != rhs_storage._lastFailure {return false}
        if _storage._lastWorkerIdentity != rhs_storage._lastWorkerIdentity {return false}
        if _storage._assignedBuildID != rhs_storage._assignedBuildID {return false}
        if _storage._lastWorkerVersionStamp != rhs_storage._lastWorkerVersionStamp {return false}
        if _storage._currentRetryInterval != rhs_storage._currentRetryInterval {return false}
        if _storage._lastAttemptCompleteTime != rhs_storage._lastAttemptCompleteTime {return false}
        if _storage._nextAttemptScheduleTime != rhs_storage._nextAttemptScheduleTime {return false}
        if _storage._paused != rhs_storage._paused {return false}
        if _storage._lastDeployment != rhs_storage._lastDeployment {return false}
        if _storage._lastWorkerDeploymentVersion != rhs_storage._lastWorkerDeploymentVersion {return false}
        if _storage._lastDeploymentVersion != rhs_storage._lastDeploymentVersion {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._pauseInfo != rhs_storage._pauseInfo {return false}
        if _storage._activityOptions != rhs_storage._activityOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingActivityInfo.PauseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.PendingActivityInfo.protoMessageName + ".PauseInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}pause_time\0\u{1}manual\0\u{2}\u{2}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._pauseTime) }()
      case 2: try {
        var v: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual?
        var hadOneofValue = false
        if let current = self.pausedBy {
          hadOneofValue = true
          if case .manual(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pausedBy = .manual(v)
        }
      }()
      case 4: try {
        var v: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule?
        var hadOneofValue = false
        if let current = self.pausedBy {
          hadOneofValue = true
          if case .rule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.pausedBy = .rule(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pauseTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.pausedBy {
    case .manual?: try {
      guard case .manual(let v)? = self.pausedBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rule?: try {
      guard case .rule(let v)? = self.pausedBy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo, rhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo) -> Bool {
    if lhs._pauseTime != rhs._pauseTime {return false}
    if lhs.pausedBy != rhs.pausedBy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.PendingActivityInfo.PauseInfo.protoMessageName + ".Manual"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual, rhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Manual) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.PendingActivityInfo.PauseInfo.protoMessageName + ".Rule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_id\0\u{1}identity\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule, rhs: Api.Workflow.V1.PendingActivityInfo.PauseInfo.Rule) -> Bool {
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingChildExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingChildExecutionInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}run_id\0\u{3}workflow_type_name\0\u{3}initiated_id\0\u{3}parent_close_policy\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.workflowTypeName) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.parentClosePolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    if !self.workflowTypeName.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowTypeName, fieldNumber: 3)
    }
    if self.initiatedID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedID, fieldNumber: 4)
    }
    if self.parentClosePolicy != .unspecified {
      try visitor.visitSingularEnumField(value: self.parentClosePolicy, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingChildExecutionInfo, rhs: Api.Workflow.V1.PendingChildExecutionInfo) -> Bool {
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.workflowTypeName != rhs.workflowTypeName {return false}
    if lhs.initiatedID != rhs.initiatedID {return false}
    if lhs.parentClosePolicy != rhs.parentClosePolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingWorkflowTaskInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingWorkflowTaskInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}state\0\u{3}scheduled_time\0\u{3}original_scheduled_time\0\u{3}started_time\0\u{1}attempt\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._scheduledTime) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._originalScheduledTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startedTime) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    try { if let v = self._scheduledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._originalScheduledTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._startedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingWorkflowTaskInfo, rhs: Api.Workflow.V1.PendingWorkflowTaskInfo) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs._scheduledTime != rhs._scheduledTime {return false}
    if lhs._originalScheduledTime != rhs._originalScheduledTime {return false}
    if lhs._startedTime != rhs._startedTime {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.ResetPoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}points\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.ResetPoints, rhs: Api.Workflow.V1.ResetPoints) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.ResetPointInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetPointInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}binary_checksum\0\u{3}run_id\0\u{3}first_workflow_task_completed_id\0\u{3}create_time\0\u{3}expire_time\0\u{1}resettable\0\u{3}build_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.firstWorkflowTaskCompletedID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expireTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.resettable) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 1)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 2)
    }
    if self.firstWorkflowTaskCompletedID != 0 {
      try visitor.visitSingularInt64Field(value: self.firstWorkflowTaskCompletedID, fieldNumber: 3)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._expireTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.resettable != false {
      try visitor.visitSingularBoolField(value: self.resettable, fieldNumber: 6)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.ResetPointInfo, rhs: Api.Workflow.V1.ResetPointInfo) -> Bool {
    if lhs.buildID != rhs.buildID {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.firstWorkflowTaskCompletedID != rhs.firstWorkflowTaskCompletedID {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._expireTime != rhs._expireTime {return false}
    if lhs.resettable != rhs.resettable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.NewWorkflowExecutionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NewWorkflowExecutionInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}user_metadata\0\u{3}versioning_override\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _workflowID: String = String()
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _header: Api.Common.V1.Header? = nil
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _versioningOverride: Api.Workflow.V1.VersioningOverride? = nil
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _userMetadata = source._userMetadata
      _versioningOverride = source._versioningOverride
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 1)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 8)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 10)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.NewWorkflowExecutionInfo, rhs: Api.Workflow.V1.NewWorkflowExecutionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.CallbackInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CallbackInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}callback\0\u{1}trigger\0\u{3}registration_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}blocked_reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._callback) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._trigger) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._registrationTime) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptCompleteTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptFailure) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._nextAttemptScheduleTime) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.blockedReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callback {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._trigger {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._registrationTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 5)
    }
    try { if let v = self._lastAttemptCompleteTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastAttemptFailure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._nextAttemptScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.blockedReason.isEmpty {
      try visitor.visitSingularStringField(value: self.blockedReason, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.CallbackInfo, rhs: Api.Workflow.V1.CallbackInfo) -> Bool {
    if lhs._callback != rhs._callback {return false}
    if lhs._trigger != rhs._trigger {return false}
    if lhs._registrationTime != rhs._registrationTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs._lastAttemptCompleteTime != rhs._lastAttemptCompleteTime {return false}
    if lhs._lastAttemptFailure != rhs._lastAttemptFailure {return false}
    if lhs._nextAttemptScheduleTime != rhs._nextAttemptScheduleTime {return false}
    if lhs.blockedReason != rhs.blockedReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.CallbackInfo.WorkflowClosed: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.CallbackInfo.protoMessageName + ".WorkflowClosed"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.CallbackInfo.WorkflowClosed, rhs: Api.Workflow.V1.CallbackInfo.WorkflowClosed) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.CallbackInfo.Trigger: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.CallbackInfo.protoMessageName + ".Trigger"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_closed\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Workflow.V1.CallbackInfo.WorkflowClosed?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .workflowClosed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .workflowClosed(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .workflowClosed(let v)? = self.variant {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.CallbackInfo.Trigger, rhs: Api.Workflow.V1.CallbackInfo.Trigger) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PendingNexusOperationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PendingNexusOperationInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{3}operation_id\0\u{3}schedule_to_close_timeout\0\u{3}scheduled_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}cancellation_info\0\u{3}scheduled_event_id\0\u{3}blocked_reason\0\u{3}operation_token\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0")

  fileprivate class _StorageClass {
    var _endpoint: String = String()
    var _service: String = String()
    var _operation: String = String()
    var _operationID: String = String()
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: Api.Enums.V1.PendingNexusOperationState = .unspecified
    var _attempt: Int32 = 0
    var _lastAttemptCompleteTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastAttemptFailure: Api.Failure.V1.Failure? = nil
    var _nextAttemptScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _cancellationInfo: Api.Workflow.V1.NexusOperationCancellationInfo? = nil
    var _scheduledEventID: Int64 = 0
    var _blockedReason: String = String()
    var _operationToken: String = String()
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _endpoint = source._endpoint
      _service = source._service
      _operation = source._operation
      _operationID = source._operationID
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduledTime = source._scheduledTime
      _state = source._state
      _attempt = source._attempt
      _lastAttemptCompleteTime = source._lastAttemptCompleteTime
      _lastAttemptFailure = source._lastAttemptFailure
      _nextAttemptScheduleTime = source._nextAttemptScheduleTime
      _cancellationInfo = source._cancellationInfo
      _scheduledEventID = source._scheduledEventID
      _blockedReason = source._blockedReason
      _operationToken = source._operationToken
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._endpoint) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._service) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._operation) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._operationID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 8: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptCompleteTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastAttemptFailure) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._nextAttemptScheduleTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cancellationInfo) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._scheduledEventID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._blockedReason) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._operationToken) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._endpoint.isEmpty {
        try visitor.visitSingularStringField(value: _storage._endpoint, fieldNumber: 1)
      }
      if !_storage._service.isEmpty {
        try visitor.visitSingularStringField(value: _storage._service, fieldNumber: 2)
      }
      if !_storage._operation.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operation, fieldNumber: 3)
      }
      if !_storage._operationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operationID, fieldNumber: 4)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 7)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 8)
      }
      try { if let v = _storage._lastAttemptCompleteTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastAttemptFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._nextAttemptScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._cancellationInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._scheduledEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._scheduledEventID, fieldNumber: 13)
      }
      if !_storage._blockedReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._blockedReason, fieldNumber: 14)
      }
      if !_storage._operationToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._operationToken, fieldNumber: 15)
      }
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PendingNexusOperationInfo, rhs: Api.Workflow.V1.PendingNexusOperationInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._endpoint != rhs_storage._endpoint {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._operationID != rhs_storage._operationID {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._lastAttemptCompleteTime != rhs_storage._lastAttemptCompleteTime {return false}
        if _storage._lastAttemptFailure != rhs_storage._lastAttemptFailure {return false}
        if _storage._nextAttemptScheduleTime != rhs_storage._nextAttemptScheduleTime {return false}
        if _storage._cancellationInfo != rhs_storage._cancellationInfo {return false}
        if _storage._scheduledEventID != rhs_storage._scheduledEventID {return false}
        if _storage._blockedReason != rhs_storage._blockedReason {return false}
        if _storage._operationToken != rhs_storage._operationToken {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.NexusOperationCancellationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NexusOperationCancellationInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requested_time\0\u{1}state\0\u{1}attempt\0\u{3}last_attempt_complete_time\0\u{3}last_attempt_failure\0\u{3}next_attempt_schedule_time\0\u{3}blocked_reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._requestedTime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.attempt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptCompleteTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastAttemptFailure) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._nextAttemptScheduleTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.blockedReason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    if self.attempt != 0 {
      try visitor.visitSingularInt32Field(value: self.attempt, fieldNumber: 3)
    }
    try { if let v = self._lastAttemptCompleteTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._lastAttemptFailure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nextAttemptScheduleTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.blockedReason.isEmpty {
      try visitor.visitSingularStringField(value: self.blockedReason, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.NexusOperationCancellationInfo, rhs: Api.Workflow.V1.NexusOperationCancellationInfo) -> Bool {
    if lhs._requestedTime != rhs._requestedTime {return false}
    if lhs.state != rhs.state {return false}
    if lhs.attempt != rhs.attempt {return false}
    if lhs._lastAttemptCompleteTime != rhs._lastAttemptCompleteTime {return false}
    if lhs._lastAttemptFailure != rhs._lastAttemptFailure {return false}
    if lhs._nextAttemptScheduleTime != rhs._nextAttemptScheduleTime {return false}
    if lhs.blockedReason != rhs.blockedReason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.WorkflowExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}versioning_override\0\u{1}priority\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._versioningOverride) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._priority) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._versioningOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._priority {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionOptions, rhs: Api.Workflow.V1.WorkflowExecutionOptions) -> Bool {
    if lhs._versioningOverride != rhs._versioningOverride {return false}
    if lhs._priority != rhs._priority {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.VersioningOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersioningOverride"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}deployment\0\u{1}pinned\0\u{3}auto_upgrade\0\u{4}\u{5}pinned_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.behavior) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 3: try {
        var v: Api.Workflow.V1.VersioningOverride.PinnedOverride?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .pinned(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .pinned(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .autoUpgrade(v)
        }
      }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.pinnedVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.behavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.behavior, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.override {
    case .pinned?: try {
      guard case .pinned(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .autoUpgrade?: try {
      guard case .autoUpgrade(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.pinnedVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.pinnedVersion, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.VersioningOverride, rhs: Api.Workflow.V1.VersioningOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.behavior != rhs.behavior {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.pinnedVersion != rhs.pinnedVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.VersioningOverride.PinnedOverrideBehavior: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PINNED_OVERRIDE_BEHAVIOR_UNSPECIFIED\0\u{1}PINNED_OVERRIDE_BEHAVIOR_PINNED\0")
}

extension Api.Workflow.V1.VersioningOverride.PinnedOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.VersioningOverride.protoMessageName + ".PinnedOverride"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}behavior\0\u{1}version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.behavior) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._version) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.behavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.behavior, fieldNumber: 1)
    }
    try { if let v = self._version {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.VersioningOverride.PinnedOverride, rhs: Api.Workflow.V1.VersioningOverride.PinnedOverride) -> Bool {
    if lhs.behavior != rhs.behavior {return false}
    if lhs._version != rhs._version {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.OnConflictOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OnConflictOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}attach_request_id\0\u{3}attach_completion_callbacks\0\u{3}attach_links\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.attachRequestID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.attachCompletionCallbacks) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.attachLinks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.attachRequestID != false {
      try visitor.visitSingularBoolField(value: self.attachRequestID, fieldNumber: 1)
    }
    if self.attachCompletionCallbacks != false {
      try visitor.visitSingularBoolField(value: self.attachCompletionCallbacks, fieldNumber: 2)
    }
    if self.attachLinks != false {
      try visitor.visitSingularBoolField(value: self.attachLinks, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.OnConflictOptions, rhs: Api.Workflow.V1.OnConflictOptions) -> Bool {
    if lhs.attachRequestID != rhs.attachRequestID {return false}
    if lhs.attachCompletionCallbacks != rhs.attachCompletionCallbacks {return false}
    if lhs.attachLinks != rhs.attachLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.RequestIdInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestIdInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}event_type\0\u{3}event_id\0\u{1}buffered\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.eventID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.buffered) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventType != .unspecified {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 1)
    }
    if self.eventID != 0 {
      try visitor.visitSingularInt64Field(value: self.eventID, fieldNumber: 2)
    }
    if self.buffered != false {
      try visitor.visitSingularBoolField(value: self.buffered, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.RequestIdInfo, rhs: Api.Workflow.V1.RequestIdInfo) -> Bool {
    if lhs.eventType != rhs.eventType {return false}
    if lhs.eventID != rhs.eventID {return false}
    if lhs.buffered != rhs.buffered {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PostResetOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PostResetOperation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_workflow\0\u{3}update_workflow_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Workflow.V1.PostResetOperation.SignalWorkflow?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .signalWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .signalWorkflow(v)
        }
      }()
      case 2: try {
        var v: Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .updateWorkflowOptions(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .updateWorkflowOptions(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.variant {
    case .signalWorkflow?: try {
      guard case .signalWorkflow(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflowOptions?: try {
      guard case .updateWorkflowOptions(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PostResetOperation, rhs: Api.Workflow.V1.PostResetOperation) -> Bool {
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PostResetOperation.SignalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.PostResetOperation.protoMessageName + ".SignalWorkflow"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_name\0\u{1}input\0\u{1}header\0\u{1}links\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PostResetOperation.SignalWorkflow, rhs: Api.Workflow.V1.PostResetOperation.SignalWorkflow) -> Bool {
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs._header != rhs._header {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflow.V1.PostResetOperation.protoMessageName + ".UpdateWorkflowOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_execution_options\0\u{3}update_mask\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions, rhs: Api.Workflow.V1.PostResetOperation.UpdateWorkflowOptions) -> Bool {
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflow.V1.WorkflowExecutionPauseInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WorkflowExecutionPauseInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{3}paused_time\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._pausedTime) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try { if let v = self._pausedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflow.V1.WorkflowExecutionPauseInfo, rhs: Api.Workflow.V1.WorkflowExecutionPauseInfo) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs._pausedTime != rhs._pausedTime {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
