// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/workflow_commands/workflow_commands.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Coresdk.WorkflowCommands {


  package enum ActivityCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Initiate a cancellation request and immediately report cancellation to the workflow.
    case tryCancel // = 0

    /// Wait for activity cancellation completion. Note that activity must heartbeat to receive a
    /// cancellation notification. This can block the cancellation for a long time if activity
    /// doesn't heartbeat or chooses to ignore the cancellation request.
    case waitCancellationCompleted // = 1

    /// Do not request cancellation of the activity and immediately report cancellation to the
    /// workflow
    case abandon // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .tryCancel
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .tryCancel
      case 1: self = .waitCancellationCompleted
      case 2: self = .abandon
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .tryCancel: return 0
      case .waitCancellationCompleted: return 1
      case .abandon: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.WorkflowCommands.ActivityCancellationType] = [
      .tryCancel,
      .waitCancellationCompleted,
      .abandon,
    ]

  }
}
extension Coresdk.WorkflowCommands {


  package struct WorkflowCommand: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// User metadata that may or may not be persisted into history depending on the command type.
    /// Lang layers are expected to expose the setting of the internals of this metadata on a
    /// per-command basis where applicable.
    package var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    package var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    package var variant: OneOf_Variant? {
      get {return _storage._variant}
      set {_uniqueStorage()._variant = newValue}
    }

    package var startTimer: Coresdk.WorkflowCommands.StartTimer {
      get {
        if case .startTimer(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.StartTimer()
      }
      set {_uniqueStorage()._variant = .startTimer(newValue)}
    }

    package var scheduleActivity: Coresdk.WorkflowCommands.ScheduleActivity {
      get {
        if case .scheduleActivity(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.ScheduleActivity()
      }
      set {_uniqueStorage()._variant = .scheduleActivity(newValue)}
    }

    package var respondToQuery: Coresdk.WorkflowCommands.QueryResult {
      get {
        if case .respondToQuery(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.QueryResult()
      }
      set {_uniqueStorage()._variant = .respondToQuery(newValue)}
    }

    package var requestCancelActivity: Coresdk.WorkflowCommands.RequestCancelActivity {
      get {
        if case .requestCancelActivity(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.RequestCancelActivity()
      }
      set {_uniqueStorage()._variant = .requestCancelActivity(newValue)}
    }

    package var cancelTimer: Coresdk.WorkflowCommands.CancelTimer {
      get {
        if case .cancelTimer(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.CancelTimer()
      }
      set {_uniqueStorage()._variant = .cancelTimer(newValue)}
    }

    package var completeWorkflowExecution: Coresdk.WorkflowCommands.CompleteWorkflowExecution {
      get {
        if case .completeWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.CompleteWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .completeWorkflowExecution(newValue)}
    }

    package var failWorkflowExecution: Coresdk.WorkflowCommands.FailWorkflowExecution {
      get {
        if case .failWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.FailWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .failWorkflowExecution(newValue)}
    }

    package var continueAsNewWorkflowExecution: Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution {
      get {
        if case .continueAsNewWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .continueAsNewWorkflowExecution(newValue)}
    }

    package var cancelWorkflowExecution: Coresdk.WorkflowCommands.CancelWorkflowExecution {
      get {
        if case .cancelWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.CancelWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .cancelWorkflowExecution(newValue)}
    }

    package var setPatchMarker: Coresdk.WorkflowCommands.SetPatchMarker {
      get {
        if case .setPatchMarker(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.SetPatchMarker()
      }
      set {_uniqueStorage()._variant = .setPatchMarker(newValue)}
    }

    package var startChildWorkflowExecution: Coresdk.WorkflowCommands.StartChildWorkflowExecution {
      get {
        if case .startChildWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.StartChildWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .startChildWorkflowExecution(newValue)}
    }

    package var cancelChildWorkflowExecution: Coresdk.WorkflowCommands.CancelChildWorkflowExecution {
      get {
        if case .cancelChildWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.CancelChildWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .cancelChildWorkflowExecution(newValue)}
    }

    package var requestCancelExternalWorkflowExecution: Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution {
      get {
        if case .requestCancelExternalWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .requestCancelExternalWorkflowExecution(newValue)}
    }

    package var signalExternalWorkflowExecution: Coresdk.WorkflowCommands.SignalExternalWorkflowExecution {
      get {
        if case .signalExternalWorkflowExecution(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.SignalExternalWorkflowExecution()
      }
      set {_uniqueStorage()._variant = .signalExternalWorkflowExecution(newValue)}
    }

    package var cancelSignalWorkflow: Coresdk.WorkflowCommands.CancelSignalWorkflow {
      get {
        if case .cancelSignalWorkflow(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.CancelSignalWorkflow()
      }
      set {_uniqueStorage()._variant = .cancelSignalWorkflow(newValue)}
    }

    package var scheduleLocalActivity: Coresdk.WorkflowCommands.ScheduleLocalActivity {
      get {
        if case .scheduleLocalActivity(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.ScheduleLocalActivity()
      }
      set {_uniqueStorage()._variant = .scheduleLocalActivity(newValue)}
    }

    package var requestCancelLocalActivity: Coresdk.WorkflowCommands.RequestCancelLocalActivity {
      get {
        if case .requestCancelLocalActivity(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.RequestCancelLocalActivity()
      }
      set {_uniqueStorage()._variant = .requestCancelLocalActivity(newValue)}
    }

    package var upsertWorkflowSearchAttributes: Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes {
      get {
        if case .upsertWorkflowSearchAttributes(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes()
      }
      set {_uniqueStorage()._variant = .upsertWorkflowSearchAttributes(newValue)}
    }

    package var modifyWorkflowProperties: Coresdk.WorkflowCommands.ModifyWorkflowProperties {
      get {
        if case .modifyWorkflowProperties(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.ModifyWorkflowProperties()
      }
      set {_uniqueStorage()._variant = .modifyWorkflowProperties(newValue)}
    }

    package var updateResponse: Coresdk.WorkflowCommands.UpdateResponse {
      get {
        if case .updateResponse(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.UpdateResponse()
      }
      set {_uniqueStorage()._variant = .updateResponse(newValue)}
    }

    package var scheduleNexusOperation: Coresdk.WorkflowCommands.ScheduleNexusOperation {
      get {
        if case .scheduleNexusOperation(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.ScheduleNexusOperation()
      }
      set {_uniqueStorage()._variant = .scheduleNexusOperation(newValue)}
    }

    package var requestCancelNexusOperation: Coresdk.WorkflowCommands.RequestCancelNexusOperation {
      get {
        if case .requestCancelNexusOperation(let v)? = _storage._variant {return v}
        return Coresdk.WorkflowCommands.RequestCancelNexusOperation()
      }
      set {_uniqueStorage()._variant = .requestCancelNexusOperation(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Variant: Equatable, Sendable {
      case startTimer(Coresdk.WorkflowCommands.StartTimer)
      case scheduleActivity(Coresdk.WorkflowCommands.ScheduleActivity)
      case respondToQuery(Coresdk.WorkflowCommands.QueryResult)
      case requestCancelActivity(Coresdk.WorkflowCommands.RequestCancelActivity)
      case cancelTimer(Coresdk.WorkflowCommands.CancelTimer)
      case completeWorkflowExecution(Coresdk.WorkflowCommands.CompleteWorkflowExecution)
      case failWorkflowExecution(Coresdk.WorkflowCommands.FailWorkflowExecution)
      case continueAsNewWorkflowExecution(Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution)
      case cancelWorkflowExecution(Coresdk.WorkflowCommands.CancelWorkflowExecution)
      case setPatchMarker(Coresdk.WorkflowCommands.SetPatchMarker)
      case startChildWorkflowExecution(Coresdk.WorkflowCommands.StartChildWorkflowExecution)
      case cancelChildWorkflowExecution(Coresdk.WorkflowCommands.CancelChildWorkflowExecution)
      case requestCancelExternalWorkflowExecution(Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution)
      case signalExternalWorkflowExecution(Coresdk.WorkflowCommands.SignalExternalWorkflowExecution)
      case cancelSignalWorkflow(Coresdk.WorkflowCommands.CancelSignalWorkflow)
      case scheduleLocalActivity(Coresdk.WorkflowCommands.ScheduleLocalActivity)
      case requestCancelLocalActivity(Coresdk.WorkflowCommands.RequestCancelLocalActivity)
      case upsertWorkflowSearchAttributes(Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes)
      case modifyWorkflowProperties(Coresdk.WorkflowCommands.ModifyWorkflowProperties)
      case updateResponse(Coresdk.WorkflowCommands.UpdateResponse)
      case scheduleNexusOperation(Coresdk.WorkflowCommands.ScheduleNexusOperation)
      case requestCancelNexusOperation(Coresdk.WorkflowCommands.RequestCancelNexusOperation)

    }

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.WorkflowCommands {


  package struct StartTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 = 0

    package var startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_startToFireTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startToFireTimeout = newValue}
    }
    /// Returns true if `startToFireTimeout` has been explicitly set.
    package var hasStartToFireTimeout: Bool {self._startToFireTimeout != nil}
    /// Clears the value of `startToFireTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToFireTimeout() {self._startToFireTimeout = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Coresdk.WorkflowCommands {


  package struct CancelTimer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number as passed to `StartTimer`
    package var seq: UInt32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct ScheduleActivity: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 {
      get {_storage._seq}
      set {_uniqueStorage()._seq = newValue}
    }

    package var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    package var activityType: String {
      get {_storage._activityType}
      set {_uniqueStorage()._activityType = newValue}
    }

    /// The name of the task queue to place this activity request in
    package var taskQueue: String {
      get {_storage._taskQueue}
      set {_uniqueStorage()._taskQueue = newValue}
    }

    package var headers: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._headers}
      set {_uniqueStorage()._headers = newValue}
    }

    /// Arguments/input to the activity. Called "input" upstream.
    package var arguments: [Api.Common.V1.Payload] {
      get {_storage._arguments}
      set {_uniqueStorage()._arguments = newValue}
    }

    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted. Either this or start_to_close_timeout_seconds must be specified.
    /// When not specified defaults to the workflow execution timeout.
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable as all a retry would achieve is to put it back into the same
    /// queue. Defaults to schedule_to_close_timeout or workflow execution timeout if not specified.
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time an activity is allowed to execute after a pick up by a worker. This timeout is
    /// always retryable. Either this or schedule_to_close_timeout must be specified.
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Maximum time allowed between successful worker heartbeats.
    package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    package var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// Activities are provided by a default retry policy controlled through the service dynamic
    /// configuration. Retries are happening up to schedule_to_close_timeout. To disable retries set
    /// retry_policy.maximum_attempts to 1.
    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Defines how the workflow will wait (or not) for cancellation of the activity to be confirmed
    package var cancellationType: Coresdk.WorkflowCommands.ActivityCancellationType {
      get {_storage._cancellationType}
      set {_uniqueStorage()._cancellationType = newValue}
    }

    /// If set, the worker will not tell the service that it can immediately start executing this
    /// activity. When unset/default, workers will always attempt to do so if activity execution
    /// slots are available.
    package var doNotEagerlyExecute: Bool {
      get {_storage._doNotEagerlyExecute}
      set {_uniqueStorage()._doNotEagerlyExecute = newValue}
    }

    /// Whether this activity should run on a worker with a compatible build id or not.
    package var versioningIntent: Coresdk.Common.VersioningIntent {
      get {_storage._versioningIntent}
      set {_uniqueStorage()._versioningIntent = newValue}
    }

    /// The Priority to use for this activity
    package var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    package var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    package mutating func clearPriority() {_uniqueStorage()._priority = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.WorkflowCommands {


  package struct ScheduleLocalActivity: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 {
      get {_storage._seq}
      set {_uniqueStorage()._seq = newValue}
    }

    package var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    package var activityType: String {
      get {_storage._activityType}
      set {_uniqueStorage()._activityType = newValue}
    }

    /// Local activities can start with a non-1 attempt, if lang has been told to backoff using
    /// a timer before retrying. It should pass the attempt number from a `DoBackoff` activity
    /// resolution.
    package var attempt: UInt32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// If this local activity is a retry (as per the attempt field) this needs to be the original
    /// scheduling time (as provided in `DoBackoff`)
    package var originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._originalScheduleTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._originalScheduleTime = newValue}
    }
    /// Returns true if `originalScheduleTime` has been explicitly set.
    package var hasOriginalScheduleTime: Bool {_storage._originalScheduleTime != nil}
    /// Clears the value of `originalScheduleTime`. Subsequent reads from it will return its default value.
    package mutating func clearOriginalScheduleTime() {_uniqueStorage()._originalScheduleTime = nil}

    package var headers: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._headers}
      set {_uniqueStorage()._headers = newValue}
    }

    /// Arguments/input to the activity.
    package var arguments: [Api.Common.V1.Payload] {
      get {_storage._arguments}
      set {_uniqueStorage()._arguments = newValue}
    }

    /// Indicates how long the caller is willing to wait for local activity completion. Limits how
    /// long retries will be attempted. When not specified defaults to the workflow execution
    /// timeout (which may be unset).
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits time the local activity can idle internally before being executed. That can happen if
    /// the worker is currently at max concurrent local activity executions. This timeout is always
    /// non retryable as all a retry would achieve is to put it back into the same queue. Defaults
    /// to `schedule_to_close_timeout` if not specified and that is set. Must be <=
    /// `schedule_to_close_timeout` when set, otherwise, it will be clamped down.
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time the local activity is allowed to execute after the task is dispatched. This
    /// timeout is always retryable. Either or both of `schedule_to_close_timeout` and this must be
    /// specified. If set, this must be <= `schedule_to_close_timeout`, otherwise, it will be
    /// clamped down.
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Specify a retry policy for the local activity. By default local activities will be retried
    /// indefinitely.
    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// If the activity is retrying and backoff would exceed this value, lang will be told to
    /// schedule a timer and retry the activity after. Otherwise, backoff will happen internally in
    /// core. Defaults to 1 minute.
    package var localRetryThreshold: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._localRetryThreshold ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._localRetryThreshold = newValue}
    }
    /// Returns true if `localRetryThreshold` has been explicitly set.
    package var hasLocalRetryThreshold: Bool {_storage._localRetryThreshold != nil}
    /// Clears the value of `localRetryThreshold`. Subsequent reads from it will return its default value.
    package mutating func clearLocalRetryThreshold() {_uniqueStorage()._localRetryThreshold = nil}

    /// Defines how the workflow will wait (or not) for cancellation of the activity to be
    /// confirmed. Lang should default this to `WAIT_CANCELLATION_COMPLETED`, even though proto
    /// will default to `TRY_CANCEL` automatically.
    package var cancellationType: Coresdk.WorkflowCommands.ActivityCancellationType {
      get {_storage._cancellationType}
      set {_uniqueStorage()._cancellationType = newValue}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.WorkflowCommands {


  package struct RequestCancelActivity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number as passed to `ScheduleActivity`
    package var seq: UInt32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct RequestCancelLocalActivity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number as passed to `ScheduleLocalActivity`
    package var seq: UInt32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct QueryResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Corresponds to the id provided in the activation job
    package var queryID: String = String()

    package var variant: Coresdk.WorkflowCommands.QueryResult.OneOf_Variant? = nil

    package var succeeded: Coresdk.WorkflowCommands.QuerySuccess {
      get {
        if case .succeeded(let v)? = variant {return v}
        return Coresdk.WorkflowCommands.QuerySuccess()
      }
      set {variant = .succeeded(newValue)}
    }

    package var failed: Api.Failure.V1.Failure {
      get {
        if case .failed(let v)? = variant {return v}
        return Api.Failure.V1.Failure()
      }
      set {variant = .failed(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Variant: Equatable, Sendable {
      case succeeded(Coresdk.WorkflowCommands.QuerySuccess)
      case failed(Api.Failure.V1.Failure)

    }

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct QuerySuccess: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var response: Api.Common.V1.Payload {
      get {_response ?? Api.Common.V1.Payload()}
      set {_response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    package var hasResponse: Bool {self._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    package mutating func clearResponse() {self._response = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _response: Api.Common.V1.Payload? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// Issued when the workflow completes successfully
  package struct CompleteWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var result: Api.Common.V1.Payload {
      get {_result ?? Api.Common.V1.Payload()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    package var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    package mutating func clearResult() {self._result = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _result: Api.Common.V1.Payload? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// Issued when the workflow errors out
  package struct FailWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// Continue the workflow as a new execution
  package struct ContinueAsNewWorkflowExecution: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identifier the lang-specific sdk uses to execute workflow code
    package var workflowType: String {
      get {_storage._workflowType}
      set {_uniqueStorage()._workflowType = newValue}
    }

    /// Task queue for the new workflow execution
    package var taskQueue: String {
      get {_storage._taskQueue}
      set {_uniqueStorage()._taskQueue = newValue}
    }

    /// Inputs to the workflow code. Should be specified. Will not re-use old arguments, as that
    /// typically wouldn't make any sense.
    package var arguments: [Api.Common.V1.Payload] {
      get {_storage._arguments}
      set {_uniqueStorage()._arguments = newValue}
    }

    /// Timeout for a single run of the new workflow. Will not re-use current workflow's value.
    package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    package var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task. Will not re-use current workflow's value.
    package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    package var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// If set, the new workflow will have this memo. If unset, re-uses the current workflow's memo
    package var memo: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._memo}
      set {_uniqueStorage()._memo = newValue}
    }

    /// If set, the new workflow will have these headers. Will *not* re-use current workflow's
    /// headers otherwise.
    package var headers: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._headers}
      set {_uniqueStorage()._headers = newValue}
    }

    /// If set, the new workflow will have these search attributes. If unset, re-uses the current
    /// workflow's search attributes.
    package var searchAttributes: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._searchAttributes}
      set {_uniqueStorage()._searchAttributes = newValue}
    }

    /// If set, the new workflow will have this retry policy. If unset, re-uses the current
    /// workflow's retry policy.
    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Whether the continued workflow should run on a worker with a compatible build id or not.
    package var versioningIntent: Coresdk.Common.VersioningIntent {
      get {_storage._versioningIntent}
      set {_uniqueStorage()._versioningIntent = newValue}
    }

    /// Experimental. Optionally decide the versioning behavior that the first task of the new run should use.
    /// For example, choose to AutoUpgrade on continue-as-new instead of inheriting the pinned version
    /// of the previous run.
    package var initialVersioningBehavior: Api.Enums.V1.ContinueAsNewVersioningBehavior {
      get {_storage._initialVersioningBehavior}
      set {_uniqueStorage()._initialVersioningBehavior = newValue}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.WorkflowCommands {


  /// Indicate a workflow has completed as cancelled. Generally sent as a response to an activation
  /// containing a cancellation job.
  package struct CancelWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  /// A request to set/check if a certain patch is present or not
  package struct SetPatchMarker: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A user-chosen identifier for this patch. If the same identifier is used in multiple places in
    /// the code, those places are considered to be versioned as one unit. IE: The check call will
    /// return the same result for all of them
    package var patchID: String = String()

    /// Can be set to true to indicate that branches using this change are being removed, and all
    /// future worker deployments will only have the "with change" code in them.
    package var deprecated: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  /// Start a child workflow execution
  package struct StartChildWorkflowExecution: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 {
      get {_storage._seq}
      set {_uniqueStorage()._seq = newValue}
    }

    package var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    package var workflowID: String {
      get {_storage._workflowID}
      set {_uniqueStorage()._workflowID = newValue}
    }

    package var workflowType: String {
      get {_storage._workflowType}
      set {_uniqueStorage()._workflowType = newValue}
    }

    package var taskQueue: String {
      get {_storage._taskQueue}
      set {_uniqueStorage()._taskQueue = newValue}
    }

    package var input: [Api.Common.V1.Payload] {
      get {_storage._input}
      set {_uniqueStorage()._input = newValue}
    }

    /// Total workflow execution timeout including retries and continue as new.
    package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    package var hasWorkflowExecutionTimeout: Bool {_storage._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

    /// Timeout of a single workflow run.
    package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    package var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task.
    package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    package var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// Default: PARENT_CLOSE_POLICY_TERMINATE.
    package var parentClosePolicy: Coresdk.ChildWorkflow.ParentClosePolicy {
      get {_storage._parentClosePolicy}
      set {_uniqueStorage()._parentClosePolicy = newValue}
    }

    /// string control = 11; (unused from StartChildWorkflowExecutionCommandAttributes)
    /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    package var workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy {
      get {_storage._workflowIDReusePolicy}
      set {_uniqueStorage()._workflowIDReusePolicy = newValue}
    }

    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    package var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    /// Header fields
    package var headers: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._headers}
      set {_uniqueStorage()._headers = newValue}
    }

    /// Memo fields
    package var memo: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._memo}
      set {_uniqueStorage()._memo = newValue}
    }

    /// Search attributes
    package var searchAttributes: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._searchAttributes}
      set {_uniqueStorage()._searchAttributes = newValue}
    }

    /// Defines behaviour of the underlying workflow when child workflow cancellation has been requested.
    package var cancellationType: Coresdk.ChildWorkflow.ChildWorkflowCancellationType {
      get {_storage._cancellationType}
      set {_uniqueStorage()._cancellationType = newValue}
    }

    /// Whether this child should run on a worker with a compatible build id or not.
    package var versioningIntent: Coresdk.Common.VersioningIntent {
      get {_storage._versioningIntent}
      set {_uniqueStorage()._versioningIntent = newValue}
    }

    /// The Priority to use for this activity
    package var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    package var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    package mutating func clearPriority() {_uniqueStorage()._priority = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.WorkflowCommands {


  /// Cancel a child workflow
  package struct CancelChildWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Sequence number as given to the `StartChildWorkflowExecution` command
    package var childWorkflowSeq: UInt32 = 0

    /// A reason for the cancellation
    package var reason: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  /// Request cancellation of an external workflow execution. For cancellation of a child workflow,
  /// prefer `CancelChildWorkflowExecution` instead, as it guards against cancel-before-start issues.
  package struct RequestCancelExternalWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 = 0

    /// The workflow instance being targeted
    package var workflowExecution: Coresdk.Common.NamespacedWorkflowExecution {
      get {_workflowExecution ?? Coresdk.Common.NamespacedWorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    package var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    /// A reason for the cancellation
    package var reason: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _workflowExecution: Coresdk.Common.NamespacedWorkflowExecution? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// Send a signal to an external or child workflow
  package struct SignalExternalWorkflowExecution: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 = 0

    /// What workflow is being targeted
    package var target: Coresdk.WorkflowCommands.SignalExternalWorkflowExecution.OneOf_Target? = nil

    /// A specific workflow instance
    package var workflowExecution: Coresdk.Common.NamespacedWorkflowExecution {
      get {
        if case .workflowExecution(let v)? = target {return v}
        return Coresdk.Common.NamespacedWorkflowExecution()
      }
      set {target = .workflowExecution(newValue)}
    }

    /// The desired target must be a child of the issuing workflow, and this is its workflow id
    package var childWorkflowID: String {
      get {
        if case .childWorkflowID(let v)? = target {return v}
        return String()
      }
      set {target = .childWorkflowID(newValue)}
    }

    /// Name of the signal handler
    package var signalName: String = String()

    /// Arguments for the handler
    package var args: [Api.Common.V1.Payload] = []

    /// Headers to attach to the signal
    package var headers: Dictionary<String,Api.Common.V1.Payload> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    /// What workflow is being targeted
    package enum OneOf_Target: Equatable, Sendable {
      /// A specific workflow instance
      case workflowExecution(Coresdk.Common.NamespacedWorkflowExecution)
      /// The desired target must be a child of the issuing workflow, and this is its workflow id
      case childWorkflowID(String)

    }

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  /// Can be used to cancel not-already-sent `SignalExternalWorkflowExecution` commands
  package struct CancelSignalWorkflow: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number as passed to `SignalExternalWorkflowExecution`
    package var seq: UInt32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct UpsertWorkflowSearchAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// SearchAttributes fields - equivalent to indexed_fields on api. Key = search index, Value =
    /// value?
    package var searchAttributes: Dictionary<String,Api.Common.V1.Payload> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  package struct ModifyWorkflowProperties: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If set, update the workflow memo with the provided values. The values will be merged with
    /// the existing memo. If the user wants to delete values, a default/empty Payload should be
    /// used as the value for the key being deleted.
    package var upsertedMemo: Api.Common.V1.Memo {
      get {_upsertedMemo ?? Api.Common.V1.Memo()}
      set {_upsertedMemo = newValue}
    }
    /// Returns true if `upsertedMemo` has been explicitly set.
    package var hasUpsertedMemo: Bool {self._upsertedMemo != nil}
    /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
    package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _upsertedMemo: Api.Common.V1.Memo? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// A reply to a `DoUpdate` job - lang must run the update's validator if told to, and then
  /// immediately run the handler, if the update was accepted.
  ///
  /// There must always be an accepted or rejected response immediately, in the same activation as
  /// this job, to indicate the result of the validator. Accepted for ran and accepted or skipped, or
  /// rejected for rejected.
  ///
  /// Then, in the same or any subsequent activation, after the update handler has completed, respond
  /// with completed or rejected as appropriate for the result of the handler.
  package struct UpdateResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The protocol message instance ID
    package var protocolInstanceID: String = String()

    package var response: Coresdk.WorkflowCommands.UpdateResponse.OneOf_Response? = nil

    /// Must be sent if the update's validator has passed (or lang was not asked to run it, and
    /// thus should be considered already-accepted, allowing lang to always send the same
    /// sequence on replay).
    package var accepted: SwiftProtobuf.Google_Protobuf_Empty {
      get {
        if case .accepted(let v)? = response {return v}
        return SwiftProtobuf.Google_Protobuf_Empty()
      }
      set {response = .accepted(newValue)}
    }

    /// Must be sent if the update's validator does not pass, or after acceptance if the update
    /// handler fails.
    package var rejected: Api.Failure.V1.Failure {
      get {
        if case .rejected(let v)? = response {return v}
        return Api.Failure.V1.Failure()
      }
      set {response = .rejected(newValue)}
    }

    /// Must be sent once the update handler completes successfully.
    package var completed: Api.Common.V1.Payload {
      get {
        if case .completed(let v)? = response {return v}
        return Api.Common.V1.Payload()
      }
      set {response = .completed(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Response: Equatable, Sendable {
      /// Must be sent if the update's validator has passed (or lang was not asked to run it, and
      /// thus should be considered already-accepted, allowing lang to always send the same
      /// sequence on replay).
      case accepted(SwiftProtobuf.Google_Protobuf_Empty)
      /// Must be sent if the update's validator does not pass, or after acceptance if the update
      /// handler fails.
      case rejected(Api.Failure.V1.Failure)
      /// Must be sent once the update handler completes successfully.
      case completed(Api.Common.V1.Payload)

    }

    package init() {}
  }
}
extension Coresdk.WorkflowCommands {


  /// A request to begin a Nexus operation
  package struct ScheduleNexusOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number, used as the operation identifier
    package var seq: UInt32 = 0

    /// Endpoint name, must exist in the endpoint registry or this command will fail.
    package var endpoint: String = String()

    /// Service name.
    package var service: String = String()

    /// Operation name.
    package var operation: String = String()

    /// Input for the operation. The server converts this into Nexus request content and the
    /// appropriate content headers internally when sending the StartOperation request. On the
    /// handler side, if it is also backed by Temporal, the content is transformed back to the
    /// original Payload sent in this command.
    package var input: Api.Common.V1.Payload {
      get {_input ?? Api.Common.V1.Payload()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {self._input = nil}

    /// Schedule-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for operation completion.
    /// Calls are retried internally by the server.
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {self._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {self._scheduleToCloseTimeout = nil}

    /// Header to attach to the Nexus request.
    /// Users are responsible for encrypting sensitive data in this header as it is stored in
    /// workflow history and transmitted to external services as-is. This is useful for propagating
    /// tracing information. Note these headers are not the same as Temporal headers on internal
    /// activities and child workflows, these are transmitted to Nexus operations that may be
    /// external and are not traditional payloads.
    package var nexusHeader: Dictionary<String,String> = [:]

    /// Defines behaviour of the underlying nexus operation when operation cancellation has been requested.
    package var cancellationType: Coresdk.Nexus.NexusOperationCancellationType = .waitCancellationCompleted

    /// Schedule-to-start timeout for this operation.
    /// Indicates how long the caller is willing to wait for the operation to be started (or completed if synchronous)
    /// by the handler. If the operation is not started within this timeout, it will fail with
    /// TIMEOUT_TYPE_SCHEDULE_TO_START.
    /// If not set or zero, no schedule-to-start timeout is enforced.
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {self._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {self._scheduleToStartTimeout = nil}

    /// Start-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for an asynchronous operation to complete after it has been
    /// started. If the operation does not complete within this timeout after starting, it will fail with
    /// TIMEOUT_TYPE_START_TO_CLOSE.
    /// Only applies to asynchronous operations. Synchronous operations ignore this timeout.
    /// If not set or zero, no start-to-close timeout is enforced.
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {self._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {self._startToCloseTimeout = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _input: Api.Common.V1.Payload? = nil
    fileprivate var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Coresdk.WorkflowCommands {


  /// Request cancellation of a nexus operation started via `ScheduleNexusOperation`
  package struct RequestCancelNexusOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Lang's incremental sequence number as passed to `ScheduleNexusOperation`
    package var seq: UInt32 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.workflow_commands"

extension Coresdk.WorkflowCommands.ActivityCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TRY_CANCEL\0\u{1}WAIT_CANCELLATION_COMPLETED\0\u{1}ABANDON\0")
}

extension Coresdk.WorkflowCommands.WorkflowCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".WorkflowCommand"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_timer\0\u{3}schedule_activity\0\u{3}respond_to_query\0\u{3}request_cancel_activity\0\u{3}cancel_timer\0\u{3}complete_workflow_execution\0\u{3}fail_workflow_execution\0\u{3}continue_as_new_workflow_execution\0\u{3}cancel_workflow_execution\0\u{3}set_patch_marker\0\u{3}start_child_workflow_execution\0\u{3}cancel_child_workflow_execution\0\u{3}request_cancel_external_workflow_execution\0\u{3}signal_external_workflow_execution\0\u{3}cancel_signal_workflow\0\u{3}schedule_local_activity\0\u{3}request_cancel_local_activity\0\u{3}upsert_workflow_search_attributes\0\u{3}modify_workflow_properties\0\u{3}update_response\0\u{3}schedule_nexus_operation\0\u{3}request_cancel_nexus_operation\0\u{4}N\u{1}user_metadata\0")

  fileprivate class _StorageClass {
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _variant: Coresdk.WorkflowCommands.WorkflowCommand.OneOf_Variant?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _userMetadata = source._userMetadata
      _variant = source._variant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Coresdk.WorkflowCommands.StartTimer?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .startTimer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .startTimer(v)
          }
        }()
        case 2: try {
          var v: Coresdk.WorkflowCommands.ScheduleActivity?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .scheduleActivity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .scheduleActivity(v)
          }
        }()
        case 3: try {
          var v: Coresdk.WorkflowCommands.QueryResult?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .respondToQuery(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .respondToQuery(v)
          }
        }()
        case 4: try {
          var v: Coresdk.WorkflowCommands.RequestCancelActivity?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .requestCancelActivity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .requestCancelActivity(v)
          }
        }()
        case 5: try {
          var v: Coresdk.WorkflowCommands.CancelTimer?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .cancelTimer(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .cancelTimer(v)
          }
        }()
        case 6: try {
          var v: Coresdk.WorkflowCommands.CompleteWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .completeWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .completeWorkflowExecution(v)
          }
        }()
        case 7: try {
          var v: Coresdk.WorkflowCommands.FailWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .failWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .failWorkflowExecution(v)
          }
        }()
        case 8: try {
          var v: Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .continueAsNewWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .continueAsNewWorkflowExecution(v)
          }
        }()
        case 9: try {
          var v: Coresdk.WorkflowCommands.CancelWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .cancelWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .cancelWorkflowExecution(v)
          }
        }()
        case 10: try {
          var v: Coresdk.WorkflowCommands.SetPatchMarker?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .setPatchMarker(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .setPatchMarker(v)
          }
        }()
        case 11: try {
          var v: Coresdk.WorkflowCommands.StartChildWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .startChildWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .startChildWorkflowExecution(v)
          }
        }()
        case 12: try {
          var v: Coresdk.WorkflowCommands.CancelChildWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .cancelChildWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .cancelChildWorkflowExecution(v)
          }
        }()
        case 13: try {
          var v: Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .requestCancelExternalWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .requestCancelExternalWorkflowExecution(v)
          }
        }()
        case 14: try {
          var v: Coresdk.WorkflowCommands.SignalExternalWorkflowExecution?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .signalExternalWorkflowExecution(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .signalExternalWorkflowExecution(v)
          }
        }()
        case 15: try {
          var v: Coresdk.WorkflowCommands.CancelSignalWorkflow?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .cancelSignalWorkflow(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .cancelSignalWorkflow(v)
          }
        }()
        case 16: try {
          var v: Coresdk.WorkflowCommands.ScheduleLocalActivity?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .scheduleLocalActivity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .scheduleLocalActivity(v)
          }
        }()
        case 17: try {
          var v: Coresdk.WorkflowCommands.RequestCancelLocalActivity?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .requestCancelLocalActivity(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .requestCancelLocalActivity(v)
          }
        }()
        case 18: try {
          var v: Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .upsertWorkflowSearchAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .upsertWorkflowSearchAttributes(v)
          }
        }()
        case 19: try {
          var v: Coresdk.WorkflowCommands.ModifyWorkflowProperties?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .modifyWorkflowProperties(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .modifyWorkflowProperties(v)
          }
        }()
        case 20: try {
          var v: Coresdk.WorkflowCommands.UpdateResponse?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .updateResponse(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .updateResponse(v)
          }
        }()
        case 21: try {
          var v: Coresdk.WorkflowCommands.ScheduleNexusOperation?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .scheduleNexusOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .scheduleNexusOperation(v)
          }
        }()
        case 22: try {
          var v: Coresdk.WorkflowCommands.RequestCancelNexusOperation?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .requestCancelNexusOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .requestCancelNexusOperation(v)
          }
        }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._variant {
      case .startTimer?: try {
        guard case .startTimer(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .scheduleActivity?: try {
        guard case .scheduleActivity(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .respondToQuery?: try {
        guard case .respondToQuery(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .requestCancelActivity?: try {
        guard case .requestCancelActivity(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .cancelTimer?: try {
        guard case .cancelTimer(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .completeWorkflowExecution?: try {
        guard case .completeWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .failWorkflowExecution?: try {
        guard case .failWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .continueAsNewWorkflowExecution?: try {
        guard case .continueAsNewWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .cancelWorkflowExecution?: try {
        guard case .cancelWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .setPatchMarker?: try {
        guard case .setPatchMarker(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .startChildWorkflowExecution?: try {
        guard case .startChildWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .cancelChildWorkflowExecution?: try {
        guard case .cancelChildWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .requestCancelExternalWorkflowExecution?: try {
        guard case .requestCancelExternalWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .signalExternalWorkflowExecution?: try {
        guard case .signalExternalWorkflowExecution(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .cancelSignalWorkflow?: try {
        guard case .cancelSignalWorkflow(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .scheduleLocalActivity?: try {
        guard case .scheduleLocalActivity(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .requestCancelLocalActivity?: try {
        guard case .requestCancelLocalActivity(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .upsertWorkflowSearchAttributes?: try {
        guard case .upsertWorkflowSearchAttributes(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .modifyWorkflowProperties?: try {
        guard case .modifyWorkflowProperties(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .updateResponse?: try {
        guard case .updateResponse(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .scheduleNexusOperation?: try {
        guard case .scheduleNexusOperation(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .requestCancelNexusOperation?: try {
        guard case .requestCancelNexusOperation(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case nil: break
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.WorkflowCommand, rhs: Coresdk.WorkflowCommands.WorkflowCommand) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._variant != rhs_storage._variant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.StartTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartTimer"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}start_to_fire_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToFireTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._startToFireTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.StartTimer, rhs: Coresdk.WorkflowCommands.StartTimer) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._startToFireTimeout != rhs._startToFireTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.CancelTimer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelTimer"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.CancelTimer, rhs: Coresdk.WorkflowCommands.CancelTimer) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.ScheduleActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}activity_id\0\u{3}activity_type\0\u{4}\u{2}task_queue\0\u{1}headers\0\u{1}arguments\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}cancellation_type\0\u{3}do_not_eagerly_execute\0\u{3}versioning_intent\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _activityID: String = String()
    var _activityType: String = String()
    var _taskQueue: String = String()
    var _headers: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _arguments: [Api.Common.V1.Payload] = []
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cancellationType: Coresdk.WorkflowCommands.ActivityCancellationType = .tryCancel
    var _doNotEagerlyExecute: Bool = false
    var _versioningIntent: Coresdk.Common.VersioningIntent = .unspecified
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _headers = source._headers
      _arguments = source._arguments
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _cancellationType = source._cancellationType
      _doNotEagerlyExecute = source._doNotEagerlyExecute
      _versioningIntent = source._versioningIntent
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._headers) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._doNotEagerlyExecute) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 2)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 3)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 5)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._headers, fieldNumber: 6)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 7)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._cancellationType != .tryCancel {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 13)
      }
      if _storage._doNotEagerlyExecute != false {
        try visitor.visitSingularBoolField(value: _storage._doNotEagerlyExecute, fieldNumber: 14)
      }
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 15)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.ScheduleActivity, rhs: Coresdk.WorkflowCommands.ScheduleActivity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        if _storage._doNotEagerlyExecute != rhs_storage._doNotEagerlyExecute {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.ScheduleLocalActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleLocalActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}activity_id\0\u{3}activity_type\0\u{1}attempt\0\u{3}original_schedule_time\0\u{1}headers\0\u{1}arguments\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}retry_policy\0\u{3}local_retry_threshold\0\u{3}cancellation_type\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _activityID: String = String()
    var _activityType: String = String()
    var _attempt: UInt32 = 0
    var _originalScheduleTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _headers: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _arguments: [Api.Common.V1.Payload] = []
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _localRetryThreshold: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _cancellationType: Coresdk.WorkflowCommands.ActivityCancellationType = .tryCancel

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _activityID = source._activityID
      _activityType = source._activityType
      _attempt = source._attempt
      _originalScheduleTime = source._originalScheduleTime
      _headers = source._headers
      _arguments = source._arguments
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _retryPolicy = source._retryPolicy
      _localRetryThreshold = source._localRetryThreshold
      _cancellationType = source._cancellationType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._attempt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._originalScheduleTime) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._headers) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._localRetryThreshold) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 2)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 3)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._attempt, fieldNumber: 4)
      }
      try { if let v = _storage._originalScheduleTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._headers, fieldNumber: 6)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 7)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._localRetryThreshold {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._cancellationType != .tryCancel {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.ScheduleLocalActivity, rhs: Coresdk.WorkflowCommands.ScheduleLocalActivity) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._originalScheduleTime != rhs_storage._originalScheduleTime {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._localRetryThreshold != rhs_storage._localRetryThreshold {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.RequestCancelActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.RequestCancelActivity, rhs: Coresdk.WorkflowCommands.RequestCancelActivity) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.RequestCancelLocalActivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelLocalActivity"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.RequestCancelLocalActivity, rhs: Coresdk.WorkflowCommands.RequestCancelLocalActivity) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.QueryResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QueryResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}query_id\0\u{1}succeeded\0\u{1}failed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.queryID) }()
      case 2: try {
        var v: Coresdk.WorkflowCommands.QuerySuccess?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .succeeded(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .succeeded(v)
        }
      }()
      case 3: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .failed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.queryID.isEmpty {
      try visitor.visitSingularStringField(value: self.queryID, fieldNumber: 1)
    }
    switch self.variant {
    case .succeeded?: try {
      guard case .succeeded(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.QueryResult, rhs: Coresdk.WorkflowCommands.QueryResult) -> Bool {
    if lhs.queryID != rhs.queryID {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.QuerySuccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".QuerySuccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}response\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.QuerySuccess, rhs: Coresdk.WorkflowCommands.QuerySuccess) -> Bool {
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.CompleteWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompleteWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.CompleteWorkflowExecution, rhs: Coresdk.WorkflowCommands.CompleteWorkflowExecution) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.FailWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.FailWorkflowExecution, rhs: Coresdk.WorkflowCommands.FailWorkflowExecution) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ContinueAsNewWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}arguments\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}memo\0\u{1}headers\0\u{3}search_attributes\0\u{3}retry_policy\0\u{3}versioning_intent\0\u{3}initial_versioning_behavior\0")

  fileprivate class _StorageClass {
    var _workflowType: String = String()
    var _taskQueue: String = String()
    var _arguments: [Api.Common.V1.Payload] = []
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _memo: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _headers: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _searchAttributes: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _versioningIntent: Coresdk.Common.VersioningIntent = .unspecified
    var _initialVersioningBehavior: Api.Enums.V1.ContinueAsNewVersioningBehavior = .unspecified

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _arguments = source._arguments
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _memo = source._memo
      _headers = source._headers
      _searchAttributes = source._searchAttributes
      _retryPolicy = source._retryPolicy
      _versioningIntent = source._versioningIntent
      _initialVersioningBehavior = source._initialVersioningBehavior
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._arguments) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._memo) }()
        case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._headers) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._searchAttributes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._initialVersioningBehavior) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 1)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 2)
      }
      if !_storage._arguments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._arguments, fieldNumber: 3)
      }
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._memo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._memo, fieldNumber: 6)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._headers, fieldNumber: 7)
      }
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._searchAttributes, fieldNumber: 8)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 10)
      }
      if _storage._initialVersioningBehavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initialVersioningBehavior, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution, rhs: Coresdk.WorkflowCommands.ContinueAsNewWorkflowExecution) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._arguments != rhs_storage._arguments {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        if _storage._initialVersioningBehavior != rhs_storage._initialVersioningBehavior {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.CancelWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.CancelWorkflowExecution, rhs: Coresdk.WorkflowCommands.CancelWorkflowExecution) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.SetPatchMarker: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SetPatchMarker"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}patch_id\0\u{1}deprecated\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.patchID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.deprecated) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.patchID.isEmpty {
      try visitor.visitSingularStringField(value: self.patchID, fieldNumber: 1)
    }
    if self.deprecated != false {
      try visitor.visitSingularBoolField(value: self.deprecated, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.SetPatchMarker, rhs: Coresdk.WorkflowCommands.SetPatchMarker) -> Bool {
    if lhs.patchID != rhs.patchID {return false}
    if lhs.deprecated != rhs.deprecated {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.StartChildWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}parent_close_policy\0\u{4}\u{2}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}headers\0\u{1}memo\0\u{3}search_attributes\0\u{3}cancellation_type\0\u{3}versioning_intent\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _seq: UInt32 = 0
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: String = String()
    var _taskQueue: String = String()
    var _input: [Api.Common.V1.Payload] = []
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parentClosePolicy: Coresdk.ChildWorkflow.ParentClosePolicy = .unspecified
    var _workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _headers: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _memo: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _searchAttributes: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _cancellationType: Coresdk.ChildWorkflow.ChildWorkflowCancellationType = .abandon
    var _versioningIntent: Coresdk.Common.VersioningIntent = .unspecified
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _seq = source._seq
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _parentClosePolicy = source._parentClosePolicy
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _headers = source._headers
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _cancellationType = source._cancellationType
      _versioningIntent = source._versioningIntent
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._seq) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._taskQueue) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._parentClosePolicy) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._headers) }()
        case 16: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._memo) }()
        case 17: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._searchAttributes) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._cancellationType) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._versioningIntent) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._seq != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._seq, fieldNumber: 1)
      }
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 2)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 3)
      }
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 4)
      }
      if !_storage._taskQueue.isEmpty {
        try visitor.visitSingularStringField(value: _storage._taskQueue, fieldNumber: 5)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._input, fieldNumber: 6)
      }
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._parentClosePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._parentClosePolicy, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 12)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 14)
      }
      if !_storage._headers.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._headers, fieldNumber: 15)
      }
      if !_storage._memo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._memo, fieldNumber: 16)
      }
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._searchAttributes, fieldNumber: 17)
      }
      if _storage._cancellationType != .abandon {
        try visitor.visitSingularEnumField(value: _storage._cancellationType, fieldNumber: 18)
      }
      if _storage._versioningIntent != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningIntent, fieldNumber: 19)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.StartChildWorkflowExecution, rhs: Coresdk.WorkflowCommands.StartChildWorkflowExecution) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._seq != rhs_storage._seq {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._parentClosePolicy != rhs_storage._parentClosePolicy {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._headers != rhs_storage._headers {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._cancellationType != rhs_storage._cancellationType {return false}
        if _storage._versioningIntent != rhs_storage._versioningIntent {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.CancelChildWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelChildWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}child_workflow_seq\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.childWorkflowSeq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.childWorkflowSeq != 0 {
      try visitor.visitSingularUInt32Field(value: self.childWorkflowSeq, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.CancelChildWorkflowExecution, rhs: Coresdk.WorkflowCommands.CancelChildWorkflowExecution) -> Bool {
    if lhs.childWorkflowSeq != rhs.childWorkflowSeq {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}workflow_execution\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution, rhs: Coresdk.WorkflowCommands.RequestCancelExternalWorkflowExecution) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.SignalExternalWorkflowExecution: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecution"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{3}workflow_execution\0\u{3}child_workflow_id\0\u{3}signal_name\0\u{1}args\0\u{1}headers\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try {
        var v: Coresdk.Common.NamespacedWorkflowExecution?
        var hadOneofValue = false
        if let current = self.target {
          hadOneofValue = true
          if case .workflowExecution(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.target = .workflowExecution(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.target != nil {try decoder.handleConflictingOneOf()}
          self.target = .childWorkflowID(v)
        }
      }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.args) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &self.headers) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    switch self.target {
    case .workflowExecution?: try {
      guard case .workflowExecution(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .childWorkflowID?: try {
      guard case .childWorkflowID(let v)? = self.target else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 4)
    }
    if !self.args.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.args, fieldNumber: 5)
    }
    if !self.headers.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: self.headers, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.SignalExternalWorkflowExecution, rhs: Coresdk.WorkflowCommands.SignalExternalWorkflowExecution) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.target != rhs.target {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs.args != rhs.args {return false}
    if lhs.headers != rhs.headers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.CancelSignalWorkflow: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelSignalWorkflow"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.CancelSignalWorkflow, rhs: Coresdk.WorkflowCommands.CancelSignalWorkflow) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpsertWorkflowSearchAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &self.searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.searchAttributes.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: self.searchAttributes, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes, rhs: Coresdk.WorkflowCommands.UpsertWorkflowSearchAttributes) -> Bool {
    if lhs.searchAttributes != rhs.searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.ModifyWorkflowProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ModifyWorkflowProperties"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.ModifyWorkflowProperties, rhs: Coresdk.WorkflowCommands.ModifyWorkflowProperties) -> Bool {
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.UpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpdateResponse"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}protocol_instance_id\0\u{1}accepted\0\u{1}rejected\0\u{1}completed\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.protocolInstanceID) }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Empty?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .accepted(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .accepted(v)
        }
      }()
      case 3: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .rejected(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .rejected(v)
        }
      }()
      case 4: try {
        var v: Api.Common.V1.Payload?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .completed(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.protocolInstanceID.isEmpty {
      try visitor.visitSingularStringField(value: self.protocolInstanceID, fieldNumber: 1)
    }
    switch self.response {
    case .accepted?: try {
      guard case .accepted(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rejected?: try {
      guard case .rejected(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .completed?: try {
      guard case .completed(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.UpdateResponse, rhs: Coresdk.WorkflowCommands.UpdateResponse) -> Bool {
    if lhs.protocolInstanceID != rhs.protocolInstanceID {return false}
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.ScheduleNexusOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleNexusOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}nexus_header\0\u{3}cancellation_type\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._scheduleToCloseTimeout) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.nexusHeader) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cancellationType) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._scheduleToStartTimeout) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._startToCloseTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 3)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 4)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scheduleToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.nexusHeader.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.nexusHeader, fieldNumber: 7)
    }
    if self.cancellationType != .waitCancellationCompleted {
      try visitor.visitSingularEnumField(value: self.cancellationType, fieldNumber: 8)
    }
    try { if let v = self._scheduleToStartTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._startToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.ScheduleNexusOperation, rhs: Coresdk.WorkflowCommands.ScheduleNexusOperation) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._scheduleToCloseTimeout != rhs._scheduleToCloseTimeout {return false}
    if lhs.nexusHeader != rhs.nexusHeader {return false}
    if lhs.cancellationType != rhs.cancellationType {return false}
    if lhs._scheduleToStartTimeout != rhs._scheduleToStartTimeout {return false}
    if lhs._startToCloseTimeout != rhs._startToCloseTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.WorkflowCommands.RequestCancelNexusOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelNexusOperation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}seq\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.seq) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.seq != 0 {
      try visitor.visitSingularUInt32Field(value: self.seq, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.WorkflowCommands.RequestCancelNexusOperation, rhs: Coresdk.WorkflowCommands.RequestCancelNexusOperation) -> Bool {
    if lhs.seq != rhs.seq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
