// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/deployment.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Enums.V1 {


  /// Specify the reachability level for a deployment so users can decide if it is time to
  /// decommission the deployment.
  public enum DeploymentReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Reachability level is not specified.
    case unspecified // = 0

    /// The deployment is reachable by new and/or open workflows. The deployment cannot be
    /// decommissioned safely.
    case reachable // = 1

    /// The deployment is not reachable by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The deployment can be decommissioned safely if user does
    /// not query closed workflows.
    case closedWorkflowsOnly // = 2

    /// The deployment is not reachable by any workflow because all the workflows who needed this
    /// deployment went out of retention period. The deployment can be decommissioned safely.
    case unreachable // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .reachable
      case 2: self = .closedWorkflowsOnly
      case 3: self = .unreachable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .reachable: return 1
      case .closedWorkflowsOnly: return 2
      case .unreachable: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Api.Enums.V1.DeploymentReachability] = [
      .unspecified,
      .reachable,
      .closedWorkflowsOnly,
      .unreachable,
    ]

  }
}
extension Api.Enums.V1 {


  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: Call this status because it is . --)
  /// Specify the drainage status for a Worker Deployment Version so users can decide whether they
  /// can safely decommission the version.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  public enum VersionDrainageStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int

    /// Drainage Status is not specified.
    case unspecified // = 0

    /// The Worker Deployment Version is not used by new workflows but is still used by
    /// open pinned workflows. The version cannot be decommissioned safely.
    case draining // = 1

    /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The version can be decommissioned safely if user does
    /// not query closed workflows. If the user does query closed workflows for some time x after
    /// workflows are closed, they should decommission the version after it has been drained for that duration.
    case drained // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .draining
      case 2: self = .drained
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .draining: return 1
      case .drained: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Api.Enums.V1.VersionDrainageStatus] = [
      .unspecified,
      .draining,
      .drained,
    ]

  }
}
extension Api.Enums.V1 {


  /// Versioning Mode of a worker is set by the app developer in the worker code, and specifies the
  /// behavior of the system in the following related aspects:
  /// - Whether or not Temporal Server considers this worker's version (Build ID) when dispatching
  ///   tasks to it.
  /// - Whether or not the workflows processed by this worker are versioned using the worker's version.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  public enum WorkerVersioningMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0

    /// Workers with this mode are not distinguished from each other for task routing, even if they
    /// have different Build IDs.
    /// Workflows processed by this worker will be unversioned and user needs to use Patching to keep
    /// the new code compatible with prior versions.
    /// This mode is recommended to be used along with Rolling Upgrade deployment strategies.
    /// Workers with this mode are represented by the special string `__unversioned__` in the APIs.
    case unversioned // = 1

    /// Workers with this mode are part of a Worker Deployment Version which is identified as
    /// "<deployment_name>.<build_id>". Such workers are called "versioned" as opposed to
    /// "unversioned".
    /// Each Deployment Version is distinguished from other Versions for task routing and users can
    /// configure Temporal Server to send tasks to a particular Version (see
    /// `WorkerDeploymentInfo.routing_config`). This mode is the best option for Blue/Green and
    /// Rainbow strategies (but typically not suitable for Rolling upgrades.)
    /// Workflow Versioning Behaviors are enabled in this mode: each workflow type must choose
    /// between the Pinned and AutoUpgrade behaviors. Depending on the chosen behavior, the user may
    /// or may not need to use Patching to keep the new code compatible with prior versions. (see
    /// VersioningBehavior enum.)
    case versioned // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unversioned
      case 2: self = .versioned
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unversioned: return 1
      case .versioned: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Api.Enums.V1.WorkerVersioningMode] = [
      .unspecified,
      .unversioned,
      .versioned,
    ]

  }
}
extension Api.Enums.V1 {


  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: Call this status because it is . --)
  /// Specify the status of a Worker Deployment Version.
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  public enum WorkerDeploymentVersionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0

    /// The Worker Deployment Version has been created inside the Worker Deployment but is not used by any
    /// workflow executions. These Versions can still have workflows if they have an explicit Versioning Override targeting
    /// this Version. Such Versioning Override could be set at workflow start time, or at a later time via `UpdateWorkflowExecutionOptions`.
    case inactive // = 1

    /// The Worker Deployment Version is the current version of the Worker Deployment. All new workflow executions 
    /// and tasks of existing unversioned or AutoUpgrade workflows are routed to this version.
    case current // = 2

    /// The Worker Deployment Version is the ramping version of the Worker Deployment. A subset of new Pinned workflow executions are 
    /// routed to this version. Moreover, a portion of existing unversioned or AutoUpgrade workflow executions are also routed to this version.
    case ramping // = 3

    /// The Worker Deployment Version is not used by new workflows but is still used by
    /// open pinned workflows. The version cannot be decommissioned safely.
    case draining // = 4

    /// The Worker Deployment Version is not used by new or open workflows, but might be still needed by
    /// Queries sent to closed workflows. The version can be decommissioned safely if user does
    /// not query closed workflows. If the user does query closed workflows for some time x after
    /// workflows are closed, they should decommission the version after it has been drained for that duration.
    case drained // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inactive
      case 2: self = .current
      case 3: self = .ramping
      case 4: self = .draining
      case 5: self = .drained
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inactive: return 1
      case .current: return 2
      case .ramping: return 3
      case .draining: return 4
      case .drained: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Api.Enums.V1.WorkerDeploymentVersionStatus] = [
      .unspecified,
      .inactive,
      .current,
      .ramping,
      .draining,
      .drained,
    ]

  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Api.Enums.V1.DeploymentReachability: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DEPLOYMENT_REACHABILITY_UNSPECIFIED\0\u{1}DEPLOYMENT_REACHABILITY_REACHABLE\0\u{1}DEPLOYMENT_REACHABILITY_CLOSED_WORKFLOWS_ONLY\0\u{1}DEPLOYMENT_REACHABILITY_UNREACHABLE\0")
}

extension Api.Enums.V1.VersionDrainageStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VERSION_DRAINAGE_STATUS_UNSPECIFIED\0\u{1}VERSION_DRAINAGE_STATUS_DRAINING\0\u{1}VERSION_DRAINAGE_STATUS_DRAINED\0")
}

extension Api.Enums.V1.WorkerVersioningMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKER_VERSIONING_MODE_UNSPECIFIED\0\u{1}WORKER_VERSIONING_MODE_UNVERSIONED\0\u{1}WORKER_VERSIONING_MODE_VERSIONED\0")
}

extension Api.Enums.V1.WorkerDeploymentVersionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKER_DEPLOYMENT_VERSION_STATUS_UNSPECIFIED\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_INACTIVE\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_CURRENT\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_RAMPING\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_DRAINING\0\u{1}WORKER_DEPLOYMENT_VERSION_STATUS_DRAINED\0")
}
