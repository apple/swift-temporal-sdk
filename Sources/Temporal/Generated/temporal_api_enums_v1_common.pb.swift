// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/common.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Enums.V1 {


  package enum EncodingType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case proto3 // = 1
    case json // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .proto3
      case 2: self = .json
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .proto3: return 1
      case .json: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.EncodingType] = [
      .unspecified,
      .proto3,
      .json,
    ]

  }
}
extension Api.Enums.V1 {


  package enum IndexedValueType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case text // = 1
    case keyword // = 2
    case int // = 3
    case double // = 4
    case bool // = 5
    case datetime // = 6
    case keywordList // = 7
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .text
      case 2: self = .keyword
      case 3: self = .int
      case 4: self = .double
      case 5: self = .bool
      case 6: self = .datetime
      case 7: self = .keywordList
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .text: return 1
      case .keyword: return 2
      case .int: return 3
      case .double: return 4
      case .bool: return 5
      case .datetime: return 6
      case .keywordList: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.IndexedValueType] = [
      .unspecified,
      .text,
      .keyword,
      .int,
      .double,
      .bool,
      .datetime,
      .keywordList,
    ]

  }
}
extension Api.Enums.V1 {


  package enum Severity: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case high // = 1
    case medium // = 2
    case low // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .high
      case 2: self = .medium
      case 3: self = .low
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .high: return 1
      case .medium: return 2
      case .low: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.Severity] = [
      .unspecified,
      .high,
      .medium,
      .low,
    ]

  }
}
extension Api.Enums.V1 {


  /// State of a callback.
  package enum CallbackState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Default value, unspecified state.
    case unspecified // = 0

    /// Callback is standing by, waiting to be triggered.
    case standby // = 1

    /// Callback is in the queue waiting to be executed or is currently executing.
    case scheduled // = 2

    /// Callback has failed with a retryable error and is backing off before the next attempt.
    case backingOff // = 3

    /// Callback has failed.
    case failed // = 4

    /// Callback has succeeded.
    case succeeded // = 5

    /// Callback is blocked (eg: by circuit breaker).
    case blocked // = 6
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .standby
      case 2: self = .scheduled
      case 3: self = .backingOff
      case 4: self = .failed
      case 5: self = .succeeded
      case 6: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .standby: return 1
      case .scheduled: return 2
      case .backingOff: return 3
      case .failed: return 4
      case .succeeded: return 5
      case .blocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.CallbackState] = [
      .unspecified,
      .standby,
      .scheduled,
      .backingOff,
      .failed,
      .succeeded,
      .blocked,
    ]

  }
}
extension Api.Enums.V1 {


  /// State of a pending Nexus operation.
  package enum PendingNexusOperationState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Default value, unspecified state.
    case unspecified // = 0

    /// Operation is in the queue waiting to be executed or is currently executing.
    case scheduled // = 1

    /// Operation has failed with a retryable error and is backing off before the next attempt.
    case backingOff // = 2

    /// Operation was started and will complete asynchronously.
    case started // = 3

    /// Operation is blocked (eg: by circuit breaker).
    case blocked // = 4
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .scheduled
      case 2: self = .backingOff
      case 3: self = .started
      case 4: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .scheduled: return 1
      case .backingOff: return 2
      case .started: return 3
      case .blocked: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.PendingNexusOperationState] = [
      .unspecified,
      .scheduled,
      .backingOff,
      .started,
      .blocked,
    ]

  }
}
extension Api.Enums.V1 {


  /// State of a Nexus operation cancellation.
  package enum NexusOperationCancellationState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Default value, unspecified state.
    case unspecified // = 0

    /// Cancellation request is in the queue waiting to be executed or is currently executing.
    case scheduled // = 1

    /// Cancellation request has failed with a retryable error and is backing off before the next attempt.
    case backingOff // = 2

    /// Cancellation request succeeded.
    case succeeded // = 3

    /// Cancellation request failed with a non-retryable error.
    case failed // = 4

    /// The associated operation timed out - exceeded the user supplied schedule-to-close timeout.
    case timedOut // = 5

    /// Cancellation request is blocked (eg: by circuit breaker).
    case blocked // = 6
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .scheduled
      case 2: self = .backingOff
      case 3: self = .succeeded
      case 4: self = .failed
      case 5: self = .timedOut
      case 6: self = .blocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .scheduled: return 1
      case .backingOff: return 2
      case .succeeded: return 3
      case .failed: return 4
      case .timedOut: return 5
      case .blocked: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.NexusOperationCancellationState] = [
      .unspecified,
      .scheduled,
      .backingOff,
      .succeeded,
      .failed,
      .timedOut,
      .blocked,
    ]

  }
}
extension Api.Enums.V1 {


  package enum WorkflowRuleActionScope: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Default value, unspecified scope.
    case unspecified // = 0

    /// The action will be applied to the entire workflow.
    case workflow // = 1

    /// The action will be applied to a specific activity.
    case activity // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .workflow
      case 2: self = .activity
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .workflow: return 1
      case .activity: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkflowRuleActionScope] = [
      .unspecified,
      .workflow,
      .activity,
    ]

  }
}
extension Api.Enums.V1 {


  package enum ApplicationErrorCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Expected application error with little/no severity.
    case benign // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .benign
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .benign: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ApplicationErrorCategory] = [
      .unspecified,
      .benign,
    ]

  }
}
extension Api.Enums.V1 {


  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: It seems we have both state and status, and status is a better fit for workers. --)
  package enum WorkerStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case running // = 1
    case shuttingDown // = 2
    case shutdown // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .shuttingDown
      case 3: self = .shutdown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .shuttingDown: return 2
      case .shutdown: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkerStatus] = [
      .unspecified,
      .running,
      .shuttingDown,
      .shutdown,
    ]

  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Api.Enums.V1.EncodingType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ENCODING_TYPE_UNSPECIFIED\0\u{1}ENCODING_TYPE_PROTO3\0\u{1}ENCODING_TYPE_JSON\0")
}

extension Api.Enums.V1.IndexedValueType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0INDEXED_VALUE_TYPE_UNSPECIFIED\0\u{1}INDEXED_VALUE_TYPE_TEXT\0\u{1}INDEXED_VALUE_TYPE_KEYWORD\0\u{1}INDEXED_VALUE_TYPE_INT\0\u{1}INDEXED_VALUE_TYPE_DOUBLE\0\u{1}INDEXED_VALUE_TYPE_BOOL\0\u{1}INDEXED_VALUE_TYPE_DATETIME\0\u{1}INDEXED_VALUE_TYPE_KEYWORD_LIST\0")
}

extension Api.Enums.V1.Severity: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SEVERITY_UNSPECIFIED\0\u{1}SEVERITY_HIGH\0\u{1}SEVERITY_MEDIUM\0\u{1}SEVERITY_LOW\0")
}

extension Api.Enums.V1.CallbackState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CALLBACK_STATE_UNSPECIFIED\0\u{1}CALLBACK_STATE_STANDBY\0\u{1}CALLBACK_STATE_SCHEDULED\0\u{1}CALLBACK_STATE_BACKING_OFF\0\u{1}CALLBACK_STATE_FAILED\0\u{1}CALLBACK_STATE_SUCCEEDED\0\u{1}CALLBACK_STATE_BLOCKED\0")
}

extension Api.Enums.V1.PendingNexusOperationState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PENDING_NEXUS_OPERATION_STATE_UNSPECIFIED\0\u{1}PENDING_NEXUS_OPERATION_STATE_SCHEDULED\0\u{1}PENDING_NEXUS_OPERATION_STATE_BACKING_OFF\0\u{1}PENDING_NEXUS_OPERATION_STATE_STARTED\0\u{1}PENDING_NEXUS_OPERATION_STATE_BLOCKED\0")
}

extension Api.Enums.V1.NexusOperationCancellationState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NEXUS_OPERATION_CANCELLATION_STATE_UNSPECIFIED\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_SCHEDULED\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_BACKING_OFF\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_SUCCEEDED\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_FAILED\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_TIMED_OUT\0\u{1}NEXUS_OPERATION_CANCELLATION_STATE_BLOCKED\0")
}

extension Api.Enums.V1.WorkflowRuleActionScope: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_RULE_ACTION_SCOPE_UNSPECIFIED\0\u{1}WORKFLOW_RULE_ACTION_SCOPE_WORKFLOW\0\u{1}WORKFLOW_RULE_ACTION_SCOPE_ACTIVITY\0")
}

extension Api.Enums.V1.ApplicationErrorCategory: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0APPLICATION_ERROR_CATEGORY_UNSPECIFIED\0\u{1}APPLICATION_ERROR_CATEGORY_BENIGN\0")
}

extension Api.Enums.V1.WorkerStatus: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKER_STATUS_UNSPECIFIED\0\u{1}WORKER_STATUS_RUNNING\0\u{1}WORKER_STATUS_SHUTTING_DOWN\0\u{1}WORKER_STATUS_SHUTDOWN\0")
}
