// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/namespace/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import Foundation
public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Cloud.Namespace.V1 {


  public struct CertificateFilterSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The common_name in the certificate.
    /// Optional, default is empty.
    public var commonName: String = String()

    /// The organization in the certificate.
    /// Optional, default is empty.
    public var organization: String = String()

    /// The organizational_unit in the certificate.
    /// Optional, default is empty.
    public var organizationalUnit: String = String()

    /// The subject_alternative_name in the certificate.
    /// Optional, default is empty.
    public var subjectAlternativeName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct MtlsAuthSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The base64 encoded ca cert(s) in PEM format that the clients can use for authentication and authorization.
    /// This must only be one value, but the CA can have a chain.
    ///
    /// (-- api-linter: core::0140::base64=disabled --)
    /// Deprecated: Not supported after v0.2.0 api version. Use accepted_client_ca instead.
    /// temporal:versioning:max_version=v0.2.0
    public var acceptedClientCaDeprecated: String = String()

    /// The ca cert(s) in PEM format that the clients can use for authentication and authorization.
    /// This must only be one value, but the CA can have a chain.
    /// temporal:versioning:min_version=v0.2.0
    public var acceptedClientCa: Data = Data()

    /// Certificate filters which, if specified, only allow connections from client certificates whose distinguished name properties match at least one of the filters.
    /// This allows limiting access to specific end-entity certificates.
    /// Optional, default is empty.
    public var certificateFilters: [Api.Cloud.Namespace.V1.CertificateFilterSpec] = []

    /// Flag to enable mTLS auth (default: disabled).
    /// Note: disabling mTLS auth will cause existing mTLS connections to fail.
    /// temporal:versioning:min_version=v0.2.0
    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct ApiKeyAuthSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Flag to enable API key auth (default: disabled).
    /// Note: disabling API key auth will cause existing API key connections to fail.
    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct CodecServerSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The codec server endpoint.
    public var endpoint: String = String()

    /// Whether to pass the user access token with your endpoint.
    public var passAccessToken: Bool = false

    /// Whether to include cross-origin credentials.
    public var includeCrossOriginCredentials: Bool = false

    /// A custom error message to display for remote codec server errors.
    /// temporal:versioning:min_version=v0.5.1
    public var customErrorMessage: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage {
      get {_customErrorMessage ?? Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage()}
      set {_customErrorMessage = newValue}
    }
    /// Returns true if `customErrorMessage` has been explicitly set.
    public var hasCustomErrorMessage: Bool {self._customErrorMessage != nil}
    /// Clears the value of `customErrorMessage`. Subsequent reads from it will return its default value.
    public mutating func clearCustomErrorMessage() {self._customErrorMessage = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct CustomErrorMessage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The error message to display by default for any remote codec server errors.
      public var `default`: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage {
        get {_default ?? Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage()}
        set {_default = newValue}
      }
      /// Returns true if ``default`` has been explicitly set.
      public var hasDefault: Bool {self._default != nil}
      /// Clears the value of ``default``. Subsequent reads from it will return its default value.
      public mutating func clearDefault() {self._default = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct ErrorMessage: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// A message to display.
        public var message: String = String()

        /// A link that is displayed along side the configured message.
        public var link: String = String()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _default: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage? = nil
    }

    public init() {}

    fileprivate var _customErrorMessage: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage? = nil
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct LifecycleSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Flag to enable delete protection for the namespace.
    public var enableDeleteProtection: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct HighAvailabilitySpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Flag to disable managed failover for the namespace.
    public var disableManagedFailover: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct NamespaceSpec: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name to use for the namespace.
    /// This will create a namespace that's available at '<name>.<account>.tmprl.cloud:7233'.
    /// The name is immutable. Once set, it cannot be changed.
    public var name: String {
      get {_storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    /// The ids of the regions where the namespace should be available.
    /// The GetRegions API can be used to get the list of valid region ids.
    /// Specifying more than one region makes the namespace "global", which is currently a preview only feature with restricted access.
    /// Please reach out to Temporal support for more information on global namespaces.
    /// When provisioned the global namespace will be active on the first region in the list and passive on the rest.
    /// Number of supported regions is 2.
    /// The regions is immutable. Once set, it cannot be changed.
    /// Example: ["aws-us-west-2"].
    public var regions: [String] {
      get {_storage._regions}
      set {_uniqueStorage()._regions = newValue}
    }

    /// The number of days the workflows data will be retained for.
    /// Changes to the retention period may impact your storage costs.
    /// Any changes to the retention period will be applied to all new running workflows.
    public var retentionDays: Int32 {
      get {_storage._retentionDays}
      set {_uniqueStorage()._retentionDays = newValue}
    }

    /// The mTLS auth configuration for the namespace.
    /// If unspecified, mTLS will be disabled.
    public var mtlsAuth: Api.Cloud.Namespace.V1.MtlsAuthSpec {
      get {_storage._mtlsAuth ?? Api.Cloud.Namespace.V1.MtlsAuthSpec()}
      set {_uniqueStorage()._mtlsAuth = newValue}
    }
    /// Returns true if `mtlsAuth` has been explicitly set.
    public var hasMtlsAuth: Bool {_storage._mtlsAuth != nil}
    /// Clears the value of `mtlsAuth`. Subsequent reads from it will return its default value.
    public mutating func clearMtlsAuth() {_uniqueStorage()._mtlsAuth = nil}

    /// The API key auth configuration for the namespace.
    /// If unspecified, API keys will be disabled.
    /// temporal:versioning:min_version=v0.2.0
    public var apiKeyAuth: Api.Cloud.Namespace.V1.ApiKeyAuthSpec {
      get {_storage._apiKeyAuth ?? Api.Cloud.Namespace.V1.ApiKeyAuthSpec()}
      set {_uniqueStorage()._apiKeyAuth = newValue}
    }
    /// Returns true if `apiKeyAuth` has been explicitly set.
    public var hasApiKeyAuth: Bool {_storage._apiKeyAuth != nil}
    /// Clears the value of `apiKeyAuth`. Subsequent reads from it will return its default value.
    public mutating func clearApiKeyAuth() {_uniqueStorage()._apiKeyAuth = nil}

    /// The custom search attributes to use for the namespace.
    /// The name of the attribute is the key and the type is the value.
    /// Supported attribute types: text, keyword, int, double, bool, datetime, keyword_list.
    /// NOTE: currently deleting a search attribute is not supported.
    /// Optional, default is empty.
    /// Deprecated: Not supported after v0.3.0 api version. Use search_attributes instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var customSearchAttributes: Dictionary<String,String> {
      get {_storage._customSearchAttributes}
      set {_uniqueStorage()._customSearchAttributes = newValue}
    }

    /// The custom search attributes to use for the namespace.
    /// The name of the attribute is the key and the type is the value.
    /// Note: currently deleting a search attribute is not supported.
    /// Optional, default is empty.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=custom_search_attributes
    public var searchAttributes: Dictionary<String,Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType> {
      get {_storage._searchAttributes}
      set {_uniqueStorage()._searchAttributes = newValue}
    }

    /// Codec server spec used by UI to decode payloads for all users interacting with this namespace.
    /// Optional, default is unset.
    public var codecServer: Api.Cloud.Namespace.V1.CodecServerSpec {
      get {_storage._codecServer ?? Api.Cloud.Namespace.V1.CodecServerSpec()}
      set {_uniqueStorage()._codecServer = newValue}
    }
    /// Returns true if `codecServer` has been explicitly set.
    public var hasCodecServer: Bool {_storage._codecServer != nil}
    /// Clears the value of `codecServer`. Subsequent reads from it will return its default value.
    public mutating func clearCodecServer() {_uniqueStorage()._codecServer = nil}

    /// The lifecycle configuration for the namespace.
    /// temporal:versioning:min_version=v0.4.0
    public var lifecycle: Api.Cloud.Namespace.V1.LifecycleSpec {
      get {_storage._lifecycle ?? Api.Cloud.Namespace.V1.LifecycleSpec()}
      set {_uniqueStorage()._lifecycle = newValue}
    }
    /// Returns true if `lifecycle` has been explicitly set.
    public var hasLifecycle: Bool {_storage._lifecycle != nil}
    /// Clears the value of `lifecycle`. Subsequent reads from it will return its default value.
    public mutating func clearLifecycle() {_uniqueStorage()._lifecycle = nil}

    /// The high availability configuration for the namespace.
    /// temporal:versioning:min_version=v0.4.0
    public var highAvailability: Api.Cloud.Namespace.V1.HighAvailabilitySpec {
      get {_storage._highAvailability ?? Api.Cloud.Namespace.V1.HighAvailabilitySpec()}
      set {_uniqueStorage()._highAvailability = newValue}
    }
    /// Returns true if `highAvailability` has been explicitly set.
    public var hasHighAvailability: Bool {_storage._highAvailability != nil}
    /// Clears the value of `highAvailability`. Subsequent reads from it will return its default value.
    public mutating func clearHighAvailability() {_uniqueStorage()._highAvailability = nil}

    /// The private connectivity configuration for the namespace.
    /// This will apply the connectivity rules specified to the namespace.
    /// temporal:versioning:min_version=v0.6.0
    public var connectivityRuleIds: [String] {
      get {_storage._connectivityRuleIds}
      set {_uniqueStorage()._connectivityRuleIds = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum SearchAttributeType: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unspecified // = 0
      case text // = 1
      case keyword // = 2
      case int // = 3
      case double // = 4
      case bool // = 5
      case datetime // = 6
      case keywordList // = 7
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .text
        case 2: self = .keyword
        case 3: self = .int
        case 4: self = .double
        case 5: self = .bool
        case 6: self = .datetime
        case 7: self = .keywordList
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .text: return 1
        case .keyword: return 2
        case .int: return 3
        case .double: return 4
        case .bool: return 5
        case .datetime: return 6
        case .keywordList: return 7
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType] = [
        .unspecified,
        .text,
        .keyword,
        .int,
        .double,
        .bool,
        .datetime,
        .keywordList,
      ]

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct Endpoints: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The web UI address.
    public var webAddress: String = String()

    /// The gRPC address for mTLS client connections (may be empty if mTLS is disabled).
    public var mtlsGrpcAddress: String = String()

    /// The gRPC address for API key client connections (may be empty if API keys are disabled).
    public var grpcAddress: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct Limits: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The number of actions per second (APS) that is currently allowed for the namespace.
    /// The namespace may be throttled if its APS exceeds the limit.
    public var actionsPerSecondLimit: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct AWSPrivateLinkInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of principal arns that are allowed to access the namespace on the private link.
    public var allowedPrincipalArns: [String] = []

    /// The list of vpc endpoint service names that are associated with the namespace.
    public var vpcEndpointServiceNames: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct PrivateConnectivity: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the region where the private connectivity applies.
    public var region: String = String()

    /// The AWS PrivateLink info.
    /// This will only be set for an aws region.
    public var awsPrivateLink: Api.Cloud.Namespace.V1.AWSPrivateLinkInfo {
      get {_awsPrivateLink ?? Api.Cloud.Namespace.V1.AWSPrivateLinkInfo()}
      set {_awsPrivateLink = newValue}
    }
    /// Returns true if `awsPrivateLink` has been explicitly set.
    public var hasAwsPrivateLink: Bool {self._awsPrivateLink != nil}
    /// Clears the value of `awsPrivateLink`. Subsequent reads from it will return its default value.
    public mutating func clearAwsPrivateLink() {self._awsPrivateLink = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _awsPrivateLink: Api.Cloud.Namespace.V1.AWSPrivateLinkInfo? = nil
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct Namespace: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace identifier.
    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    /// The current version of the namespace specification.
    /// The next update operation will have to include this version.
    public var resourceVersion: String {
      get {_storage._resourceVersion}
      set {_uniqueStorage()._resourceVersion = newValue}
    }

    /// The namespace specification.
    public var spec: Api.Cloud.Namespace.V1.NamespaceSpec {
      get {_storage._spec ?? Api.Cloud.Namespace.V1.NamespaceSpec()}
      set {_uniqueStorage()._spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {_storage._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {_uniqueStorage()._spec = nil}

    /// The current state of the namespace.
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var stateDeprecated: String {
      get {_storage._stateDeprecated}
      set {_uniqueStorage()._stateDeprecated = newValue}
    }

    /// The current state of the namespace.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    public var state: Api.Cloud.Resource.V1.ResourceState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The id of the async operation that is creating/updating/deleting the namespace, if any.
    public var asyncOperationID: String {
      get {_storage._asyncOperationID}
      set {_uniqueStorage()._asyncOperationID = newValue}
    }

    /// The endpoints for the namespace.
    public var endpoints: Api.Cloud.Namespace.V1.Endpoints {
      get {_storage._endpoints ?? Api.Cloud.Namespace.V1.Endpoints()}
      set {_uniqueStorage()._endpoints = newValue}
    }
    /// Returns true if `endpoints` has been explicitly set.
    public var hasEndpoints: Bool {_storage._endpoints != nil}
    /// Clears the value of `endpoints`. Subsequent reads from it will return its default value.
    public mutating func clearEndpoints() {_uniqueStorage()._endpoints = nil}

    /// The currently active region for the namespace.
    public var activeRegion: String {
      get {_storage._activeRegion}
      set {_uniqueStorage()._activeRegion = newValue}
    }

    /// The limits set on the namespace currently.
    public var limits: Api.Cloud.Namespace.V1.Limits {
      get {_storage._limits ?? Api.Cloud.Namespace.V1.Limits()}
      set {_uniqueStorage()._limits = newValue}
    }
    /// Returns true if `limits` has been explicitly set.
    public var hasLimits: Bool {_storage._limits != nil}
    /// Clears the value of `limits`. Subsequent reads from it will return its default value.
    public mutating func clearLimits() {_uniqueStorage()._limits = nil}

    /// The private connectivities for the namespace, if any.
    public var privateConnectivities: [Api.Cloud.Namespace.V1.PrivateConnectivity] {
      get {_storage._privateConnectivities}
      set {_uniqueStorage()._privateConnectivities = newValue}
    }

    /// The date and time when the namespace was created.
    public var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    public var hasCreatedTime: Bool {_storage._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    public mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

    /// The date and time when the namespace was last modified.
    /// Will not be set if the namespace has never been modified.
    public var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    public var hasLastModifiedTime: Bool {_storage._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

    /// The status of each region where the namespace is available.
    /// The id of the region is the key and the status is the value of the map.
    public var regionStatus: Dictionary<String,Api.Cloud.Namespace.V1.NamespaceRegionStatus> {
      get {_storage._regionStatus}
      set {_uniqueStorage()._regionStatus = newValue}
    }

    /// The connectivity rules that are set on this namespace.
    public var connectivityRules: [Api.Cloud.Connectivityrule.V1.ConnectivityRule] {
      get {_storage._connectivityRules}
      set {_uniqueStorage()._connectivityRules = newValue}
    }

    /// The tags for the namespace.
    public var tags: Dictionary<String,String> {
      get {_storage._tags}
      set {_uniqueStorage()._tags = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct NamespaceRegionStatus: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The current state of the namespace region.
    /// Possible values: adding, active, passive, removing, failed.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var stateDeprecated: String = String()

    /// The current state of the namespace region.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    public var state: Api.Cloud.Namespace.V1.NamespaceRegionStatus.State = .unspecified

    /// The id of the async operation that is making changes to where the namespace is available, if any.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum State: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unspecified // = 0

      /// The region is being added to the namespace.
      case adding // = 1

      /// The namespace is active in this region.
      case active // = 2

      /// The namespace is passive in this region.
      case passive // = 3

      /// The region is being removed from the namespace.
      case removing // = 4

      /// The region failed to be added/removed, check failure_reason in the last async_operation status for more details.
      case failed // = 5
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .adding
        case 2: self = .active
        case 3: self = .passive
        case 4: self = .removing
        case 5: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .adding: return 1
        case .active: return 2
        case .passive: return 3
        case .removing: return 4
        case .failed: return 5
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Api.Cloud.Namespace.V1.NamespaceRegionStatus.State] = [
        .unspecified,
        .adding,
        .active,
        .passive,
        .removing,
        .failed,
      ]

    }

    public init() {}
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct ExportSinkSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unique name of the export sink, it can't be changed once set. 
    public var name: String = String()

    /// A flag indicating whether the export sink is enabled or not.
    public var enabled: Bool = false

    /// The S3 configuration details when destination_type is S3.
    public var s3: Api.Cloud.Sink.V1.S3Spec {
      get {_s3 ?? Api.Cloud.Sink.V1.S3Spec()}
      set {_s3 = newValue}
    }
    /// Returns true if `s3` has been explicitly set.
    public var hasS3: Bool {self._s3 != nil}
    /// Clears the value of `s3`. Subsequent reads from it will return its default value.
    public mutating func clearS3() {self._s3 = nil}

    /// The GCS configuration details when destination_type is GCS. 
    public var gcs: Api.Cloud.Sink.V1.GCSSpec {
      get {_gcs ?? Api.Cloud.Sink.V1.GCSSpec()}
      set {_gcs = newValue}
    }
    /// Returns true if `gcs` has been explicitly set.
    public var hasGcs: Bool {self._gcs != nil}
    /// Clears the value of `gcs`. Subsequent reads from it will return its default value.
    public mutating func clearGcs() {self._gcs = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _s3: Api.Cloud.Sink.V1.S3Spec? = nil
    fileprivate var _gcs: Api.Cloud.Sink.V1.GCSSpec? = nil
  }
}
extension Api.Cloud.Namespace.V1 {


  public struct ExportSink: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unique name of the export sink.
    public var name: String {
      get {_storage._name}
      set {_uniqueStorage()._name = newValue}
    }

    /// The version of the export sink resource.
    public var resourceVersion: String {
      get {_storage._resourceVersion}
      set {_uniqueStorage()._resourceVersion = newValue}
    }

    /// The current state of the export sink.
    public var state: Api.Cloud.Resource.V1.ResourceState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The specification details of the export sink.
    public var spec: Api.Cloud.Namespace.V1.ExportSinkSpec {
      get {_storage._spec ?? Api.Cloud.Namespace.V1.ExportSinkSpec()}
      set {_uniqueStorage()._spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {_storage._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {_uniqueStorage()._spec = nil}

    /// The health status of the export sink.
    public var health: Api.Cloud.Namespace.V1.ExportSink.Health {
      get {_storage._health}
      set {_uniqueStorage()._health = newValue}
    }

    /// An error message describing any issues with the export sink, if applicable.
    public var errorMessage: String {
      get {_storage._errorMessage}
      set {_uniqueStorage()._errorMessage = newValue}
    }

    /// The timestamp of the latest successful data export.
    public var latestDataExportTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._latestDataExportTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._latestDataExportTime = newValue}
    }
    /// Returns true if `latestDataExportTime` has been explicitly set.
    public var hasLatestDataExportTime: Bool {_storage._latestDataExportTime != nil}
    /// Clears the value of `latestDataExportTime`. Subsequent reads from it will return its default value.
    public mutating func clearLatestDataExportTime() {_uniqueStorage()._latestDataExportTime = nil}

    /// The timestamp of the last health check performed on the export sink.
    public var lastHealthCheckTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastHealthCheckTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastHealthCheckTime = newValue}
    }
    /// Returns true if `lastHealthCheckTime` has been explicitly set.
    public var hasLastHealthCheckTime: Bool {_storage._lastHealthCheckTime != nil}
    /// Clears the value of `lastHealthCheckTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastHealthCheckTime() {_uniqueStorage()._lastHealthCheckTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum Health: SwiftProtobuf.Enum, Swift.CaseIterable {
      public typealias RawValue = Int
      case unspecified // = 0
      case ok // = 1
      case errorInternal // = 2
      case errorUserConfiguration // = 3
      case UNRECOGNIZED(Int)

      public init() {
        self = .unspecified
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .ok
        case 2: self = .errorInternal
        case 3: self = .errorUserConfiguration
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .ok: return 1
        case .errorInternal: return 2
        case .errorUserConfiguration: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      public static let allCases: [Api.Cloud.Namespace.V1.ExportSink.Health] = [
        .unspecified,
        .ok,
        .errorInternal,
        .errorUserConfiguration,
      ]

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.namespace.v1"

extension Api.Cloud.Namespace.V1.CertificateFilterSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CertificateFilterSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}common_name\0\u{1}organization\0\u{3}organizational_unit\0\u{3}subject_alternative_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.commonName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.organization) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.organizationalUnit) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subjectAlternativeName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.commonName.isEmpty {
      try visitor.visitSingularStringField(value: self.commonName, fieldNumber: 1)
    }
    if !self.organization.isEmpty {
      try visitor.visitSingularStringField(value: self.organization, fieldNumber: 2)
    }
    if !self.organizationalUnit.isEmpty {
      try visitor.visitSingularStringField(value: self.organizationalUnit, fieldNumber: 3)
    }
    if !self.subjectAlternativeName.isEmpty {
      try visitor.visitSingularStringField(value: self.subjectAlternativeName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.CertificateFilterSpec, rhs: Api.Cloud.Namespace.V1.CertificateFilterSpec) -> Bool {
    if lhs.commonName != rhs.commonName {return false}
    if lhs.organization != rhs.organization {return false}
    if lhs.organizationalUnit != rhs.organizationalUnit {return false}
    if lhs.subjectAlternativeName != rhs.subjectAlternativeName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.MtlsAuthSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MtlsAuthSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}accepted_client_ca_deprecated\0\u{3}certificate_filters\0\u{1}enabled\0\u{3}accepted_client_ca\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.acceptedClientCaDeprecated) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.certificateFilters) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.acceptedClientCa) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.acceptedClientCaDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.acceptedClientCaDeprecated, fieldNumber: 1)
    }
    if !self.certificateFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.certificateFilters, fieldNumber: 2)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    if !self.acceptedClientCa.isEmpty {
      try visitor.visitSingularBytesField(value: self.acceptedClientCa, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.MtlsAuthSpec, rhs: Api.Cloud.Namespace.V1.MtlsAuthSpec) -> Bool {
    if lhs.acceptedClientCaDeprecated != rhs.acceptedClientCaDeprecated {return false}
    if lhs.acceptedClientCa != rhs.acceptedClientCa {return false}
    if lhs.certificateFilters != rhs.certificateFilters {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.ApiKeyAuthSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApiKeyAuthSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.ApiKeyAuthSpec, rhs: Api.Cloud.Namespace.V1.ApiKeyAuthSpec) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.CodecServerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CodecServerSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{3}pass_access_token\0\u{3}include_cross_origin_credentials\0\u{3}custom_error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.passAccessToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.includeCrossOriginCredentials) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._customErrorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if self.passAccessToken != false {
      try visitor.visitSingularBoolField(value: self.passAccessToken, fieldNumber: 2)
    }
    if self.includeCrossOriginCredentials != false {
      try visitor.visitSingularBoolField(value: self.includeCrossOriginCredentials, fieldNumber: 3)
    }
    try { if let v = self._customErrorMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.CodecServerSpec, rhs: Api.Cloud.Namespace.V1.CodecServerSpec) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.passAccessToken != rhs.passAccessToken {return false}
    if lhs.includeCrossOriginCredentials != rhs.includeCrossOriginCredentials {return false}
    if lhs._customErrorMessage != rhs._customErrorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Cloud.Namespace.V1.CodecServerSpec.protoMessageName + ".CustomErrorMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}default\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._default) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._default {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage, rhs: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage) -> Bool {
    if lhs._default != rhs._default {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.protoMessageName + ".ErrorMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}link\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.link) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if !self.link.isEmpty {
      try visitor.visitSingularStringField(value: self.link, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage, rhs: Api.Cloud.Namespace.V1.CodecServerSpec.CustomErrorMessage.ErrorMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.link != rhs.link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.LifecycleSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LifecycleSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}enable_delete_protection\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enableDeleteProtection) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enableDeleteProtection != false {
      try visitor.visitSingularBoolField(value: self.enableDeleteProtection, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.LifecycleSpec, rhs: Api.Cloud.Namespace.V1.LifecycleSpec) -> Bool {
    if lhs.enableDeleteProtection != rhs.enableDeleteProtection {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.HighAvailabilitySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HighAvailabilitySpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}disable_managed_failover\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.disableManagedFailover) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.disableManagedFailover != false {
      try visitor.visitSingularBoolField(value: self.disableManagedFailover, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.HighAvailabilitySpec, rhs: Api.Cloud.Namespace.V1.HighAvailabilitySpec) -> Bool {
    if lhs.disableManagedFailover != rhs.disableManagedFailover {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.NamespaceSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamespaceSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}regions\0\u{3}retention_days\0\u{3}mtls_auth\0\u{3}custom_search_attributes\0\u{3}codec_server\0\u{3}api_key_auth\0\u{3}search_attributes\0\u{1}lifecycle\0\u{3}high_availability\0\u{3}connectivity_rule_ids\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _regions: [String] = []
    var _retentionDays: Int32 = 0
    var _mtlsAuth: Api.Cloud.Namespace.V1.MtlsAuthSpec? = nil
    var _apiKeyAuth: Api.Cloud.Namespace.V1.ApiKeyAuthSpec? = nil
    var _customSearchAttributes: Dictionary<String,String> = [:]
    var _searchAttributes: Dictionary<String,Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType> = [:]
    var _codecServer: Api.Cloud.Namespace.V1.CodecServerSpec? = nil
    var _lifecycle: Api.Cloud.Namespace.V1.LifecycleSpec? = nil
    var _highAvailability: Api.Cloud.Namespace.V1.HighAvailabilitySpec? = nil
    var _connectivityRuleIds: [String] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _regions = source._regions
      _retentionDays = source._retentionDays
      _mtlsAuth = source._mtlsAuth
      _apiKeyAuth = source._apiKeyAuth
      _customSearchAttributes = source._customSearchAttributes
      _searchAttributes = source._searchAttributes
      _codecServer = source._codecServer
      _lifecycle = source._lifecycle
      _highAvailability = source._highAvailability
      _connectivityRuleIds = source._connectivityRuleIds
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeRepeatedStringField(value: &_storage._regions) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._retentionDays) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mtlsAuth) }()
        case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._customSearchAttributes) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._codecServer) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._apiKeyAuth) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType>.self, value: &_storage._searchAttributes) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._lifecycle) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._highAvailability) }()
        case 11: try { try decoder.decodeRepeatedStringField(value: &_storage._connectivityRuleIds) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._regions.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._regions, fieldNumber: 2)
      }
      if _storage._retentionDays != 0 {
        try visitor.visitSingularInt32Field(value: _storage._retentionDays, fieldNumber: 3)
      }
      try { if let v = _storage._mtlsAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._customSearchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._customSearchAttributes, fieldNumber: 5)
      }
      try { if let v = _storage._codecServer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._apiKeyAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._searchAttributes.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType>.self, value: _storage._searchAttributes, fieldNumber: 8)
      }
      try { if let v = _storage._lifecycle {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._highAvailability {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._connectivityRuleIds.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._connectivityRuleIds, fieldNumber: 11)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.NamespaceSpec, rhs: Api.Cloud.Namespace.V1.NamespaceSpec) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._regions != rhs_storage._regions {return false}
        if _storage._retentionDays != rhs_storage._retentionDays {return false}
        if _storage._mtlsAuth != rhs_storage._mtlsAuth {return false}
        if _storage._apiKeyAuth != rhs_storage._apiKeyAuth {return false}
        if _storage._customSearchAttributes != rhs_storage._customSearchAttributes {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._codecServer != rhs_storage._codecServer {return false}
        if _storage._lifecycle != rhs_storage._lifecycle {return false}
        if _storage._highAvailability != rhs_storage._highAvailability {return false}
        if _storage._connectivityRuleIds != rhs_storage._connectivityRuleIds {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.NamespaceSpec.SearchAttributeType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SEARCH_ATTRIBUTE_TYPE_UNSPECIFIED\0\u{1}SEARCH_ATTRIBUTE_TYPE_TEXT\0\u{1}SEARCH_ATTRIBUTE_TYPE_KEYWORD\0\u{1}SEARCH_ATTRIBUTE_TYPE_INT\0\u{1}SEARCH_ATTRIBUTE_TYPE_DOUBLE\0\u{1}SEARCH_ATTRIBUTE_TYPE_BOOL\0\u{1}SEARCH_ATTRIBUTE_TYPE_DATETIME\0\u{1}SEARCH_ATTRIBUTE_TYPE_KEYWORD_LIST\0")
}

extension Api.Cloud.Namespace.V1.Endpoints: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Endpoints"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}web_address\0\u{3}mtls_grpc_address\0\u{3}grpc_address\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.webAddress) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mtlsGrpcAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.grpcAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.webAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.webAddress, fieldNumber: 1)
    }
    if !self.mtlsGrpcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.mtlsGrpcAddress, fieldNumber: 2)
    }
    if !self.grpcAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.grpcAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.Endpoints, rhs: Api.Cloud.Namespace.V1.Endpoints) -> Bool {
    if lhs.webAddress != rhs.webAddress {return false}
    if lhs.mtlsGrpcAddress != rhs.mtlsGrpcAddress {return false}
    if lhs.grpcAddress != rhs.grpcAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.Limits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Limits"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}actions_per_second_limit\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.actionsPerSecondLimit) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.actionsPerSecondLimit != 0 {
      try visitor.visitSingularInt32Field(value: self.actionsPerSecondLimit, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.Limits, rhs: Api.Cloud.Namespace.V1.Limits) -> Bool {
    if lhs.actionsPerSecondLimit != rhs.actionsPerSecondLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.AWSPrivateLinkInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AWSPrivateLinkInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}allowed_principal_arns\0\u{3}vpc_endpoint_service_names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.allowedPrincipalArns) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.vpcEndpointServiceNames) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.allowedPrincipalArns.isEmpty {
      try visitor.visitRepeatedStringField(value: self.allowedPrincipalArns, fieldNumber: 1)
    }
    if !self.vpcEndpointServiceNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.vpcEndpointServiceNames, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.AWSPrivateLinkInfo, rhs: Api.Cloud.Namespace.V1.AWSPrivateLinkInfo) -> Bool {
    if lhs.allowedPrincipalArns != rhs.allowedPrincipalArns {return false}
    if lhs.vpcEndpointServiceNames != rhs.vpcEndpointServiceNames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.PrivateConnectivity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrivateConnectivity"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0\u{3}aws_private_link\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._awsPrivateLink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    try { if let v = self._awsPrivateLink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.PrivateConnectivity, rhs: Api.Cloud.Namespace.V1.PrivateConnectivity) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs._awsPrivateLink != rhs._awsPrivateLink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.Namespace: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Namespace"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}endpoints\0\u{3}active_region\0\u{1}limits\0\u{3}private_connectivities\0\u{3}created_time\0\u{3}last_modified_time\0\u{3}region_status\0\u{1}state\0\u{3}connectivity_rules\0\u{1}tags\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _resourceVersion: String = String()
    var _spec: Api.Cloud.Namespace.V1.NamespaceSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Api.Cloud.Resource.V1.ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _endpoints: Api.Cloud.Namespace.V1.Endpoints? = nil
    var _activeRegion: String = String()
    var _limits: Api.Cloud.Namespace.V1.Limits? = nil
    var _privateConnectivities: [Api.Cloud.Namespace.V1.PrivateConnectivity] = []
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _regionStatus: Dictionary<String,Api.Cloud.Namespace.V1.NamespaceRegionStatus> = [:]
    var _connectivityRules: [Api.Cloud.Connectivityrule.V1.ConnectivityRule] = []
    var _tags: Dictionary<String,String> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _endpoints = source._endpoints
      _activeRegion = source._activeRegion
      _limits = source._limits
      _privateConnectivities = source._privateConnectivities
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
      _regionStatus = source._regionStatus
      _connectivityRules = source._connectivityRules
      _tags = source._tags
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._endpoints) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._activeRegion) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._limits) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._privateConnectivities) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 12: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Cloud.Namespace.V1.NamespaceRegionStatus>.self, value: &_storage._regionStatus) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 14: try { try decoder.decodeRepeatedMessageField(value: &_storage._connectivityRules) }()
        case 15: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._tags) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._endpoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      if !_storage._activeRegion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activeRegion, fieldNumber: 7)
      }
      try { if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._privateConnectivities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._privateConnectivities, fieldNumber: 9)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._regionStatus.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Cloud.Namespace.V1.NamespaceRegionStatus>.self, value: _storage._regionStatus, fieldNumber: 12)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 13)
      }
      if !_storage._connectivityRules.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._connectivityRules, fieldNumber: 14)
      }
      if !_storage._tags.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._tags, fieldNumber: 15)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.Namespace, rhs: Api.Cloud.Namespace.V1.Namespace) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._endpoints != rhs_storage._endpoints {return false}
        if _storage._activeRegion != rhs_storage._activeRegion {return false}
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._privateConnectivities != rhs_storage._privateConnectivities {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        if _storage._regionStatus != rhs_storage._regionStatus {return false}
        if _storage._connectivityRules != rhs_storage._connectivityRules {return false}
        if _storage._tags != rhs_storage._tags {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.NamespaceRegionStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NamespaceRegionStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}state\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stateDeprecated) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stateDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDeprecated, fieldNumber: 1)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.NamespaceRegionStatus, rhs: Api.Cloud.Namespace.V1.NamespaceRegionStatus) -> Bool {
    if lhs.stateDeprecated != rhs.stateDeprecated {return false}
    if lhs.state != rhs.state {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.NamespaceRegionStatus.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STATE_UNSPECIFIED\0\u{1}STATE_ADDING\0\u{1}STATE_ACTIVE\0\u{1}STATE_PASSIVE\0\u{1}STATE_REMOVING\0\u{1}STATE_FAILED\0")
}

extension Api.Cloud.Namespace.V1.ExportSinkSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportSinkSpec"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}enabled\0\u{1}s3\0\u{1}gcs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._s3) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._gcs) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try { if let v = self._s3 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gcs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.ExportSinkSpec, rhs: Api.Cloud.Namespace.V1.ExportSinkSpec) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs._s3 != rhs._s3 {return false}
    if lhs._gcs != rhs._gcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.ExportSink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExportSink"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}resource_version\0\u{1}state\0\u{1}spec\0\u{1}health\0\u{3}error_message\0\u{3}latest_data_export_time\0\u{3}last_health_check_time\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _resourceVersion: String = String()
    var _state: Api.Cloud.Resource.V1.ResourceState = .unspecified
    var _spec: Api.Cloud.Namespace.V1.ExportSinkSpec? = nil
    var _health: Api.Cloud.Namespace.V1.ExportSink.Health = .unspecified
    var _errorMessage: String = String()
    var _latestDataExportTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastHealthCheckTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _resourceVersion = source._resourceVersion
      _state = source._state
      _spec = source._spec
      _health = source._health
      _errorMessage = source._errorMessage
      _latestDataExportTime = source._latestDataExportTime
      _lastHealthCheckTime = source._lastHealthCheckTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._health) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._errorMessage) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._latestDataExportTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastHealthCheckTime) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 3)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._health != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._health, fieldNumber: 5)
      }
      if !_storage._errorMessage.isEmpty {
        try visitor.visitSingularStringField(value: _storage._errorMessage, fieldNumber: 6)
      }
      try { if let v = _storage._latestDataExportTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastHealthCheckTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Namespace.V1.ExportSink, rhs: Api.Cloud.Namespace.V1.ExportSink) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._health != rhs_storage._health {return false}
        if _storage._errorMessage != rhs_storage._errorMessage {return false}
        if _storage._latestDataExportTime != rhs_storage._latestDataExportTime {return false}
        if _storage._lastHealthCheckTime != rhs_storage._lastHealthCheckTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Namespace.V1.ExportSink.Health: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HEALTH_UNSPECIFIED\0\u{1}HEALTH_OK\0\u{1}HEALTH_ERROR_INTERNAL\0\u{1}HEALTH_ERROR_USER_CONFIGURATION\0")
}
