// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/workflowservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import Foundation
public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Workflowservice.V1 {


  public struct RegisterNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var description_p: String = String()

    public var ownerEmail: String = String()

    public var workflowExecutionRetentionPeriod: SwiftProtobuf.Google_Protobuf_Duration {
      get {_workflowExecutionRetentionPeriod ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_workflowExecutionRetentionPeriod = newValue}
    }
    /// Returns true if `workflowExecutionRetentionPeriod` has been explicitly set.
    public var hasWorkflowExecutionRetentionPeriod: Bool {self._workflowExecutionRetentionPeriod != nil}
    /// Clears the value of `workflowExecutionRetentionPeriod`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionRetentionPeriod() {self._workflowExecutionRetentionPeriod = nil}

    public var clusters: [Api.Replication.V1.ClusterReplicationConfig] = []

    public var activeClusterName: String = String()

    /// A key-value map for any customized purpose.
    public var data: Dictionary<String,String> = [:]

    public var securityToken: String = String()

    public var isGlobalNamespace: Bool = false

    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    public var historyArchivalState: Api.Enums.V1.ArchivalState = .unspecified

    public var historyArchivalUri: String = String()

    /// If unspecified (ARCHIVAL_STATE_UNSPECIFIED) then default server configuration is used.
    public var visibilityArchivalState: Api.Enums.V1.ArchivalState = .unspecified

    public var visibilityArchivalUri: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecutionRetentionPeriod: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RegisterNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListNamespacesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var namespaceFilter: Api.Namespace.V1.NamespaceFilter {
      get {_namespaceFilter ?? Api.Namespace.V1.NamespaceFilter()}
      set {_namespaceFilter = newValue}
    }
    /// Returns true if `namespaceFilter` has been explicitly set.
    public var hasNamespaceFilter: Bool {self._namespaceFilter != nil}
    /// Clears the value of `namespaceFilter`. Subsequent reads from it will return its default value.
    public mutating func clearNamespaceFilter() {self._namespaceFilter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _namespaceFilter: Api.Namespace.V1.NamespaceFilter? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListNamespacesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespaces: [Api.Workflowservice.V1.DescribeNamespaceResponse] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeNamespaceResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespaceInfo: Api.Namespace.V1.NamespaceInfo {
      get {_storage._namespaceInfo ?? Api.Namespace.V1.NamespaceInfo()}
      set {_uniqueStorage()._namespaceInfo = newValue}
    }
    /// Returns true if `namespaceInfo` has been explicitly set.
    public var hasNamespaceInfo: Bool {_storage._namespaceInfo != nil}
    /// Clears the value of `namespaceInfo`. Subsequent reads from it will return its default value.
    public mutating func clearNamespaceInfo() {_uniqueStorage()._namespaceInfo = nil}

    public var config: Api.Namespace.V1.NamespaceConfig {
      get {_storage._config ?? Api.Namespace.V1.NamespaceConfig()}
      set {_uniqueStorage()._config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {_storage._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {_uniqueStorage()._config = nil}

    public var replicationConfig: Api.Replication.V1.NamespaceReplicationConfig {
      get {_storage._replicationConfig ?? Api.Replication.V1.NamespaceReplicationConfig()}
      set {_uniqueStorage()._replicationConfig = newValue}
    }
    /// Returns true if `replicationConfig` has been explicitly set.
    public var hasReplicationConfig: Bool {_storage._replicationConfig != nil}
    /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
    public mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

    public var failoverVersion: Int64 {
      get {_storage._failoverVersion}
      set {_uniqueStorage()._failoverVersion = newValue}
    }

    public var isGlobalNamespace: Bool {
      get {_storage._isGlobalNamespace}
      set {_uniqueStorage()._isGlobalNamespace = newValue}
    }

    /// Contains the historical state of failover_versions for the cluster, truncated to contain only the last N
    /// states to ensure that the list does not grow unbounded.
    public var failoverHistory: [Api.Replication.V1.FailoverStatus] {
      get {_storage._failoverHistory}
      set {_uniqueStorage()._failoverHistory = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateNamespaceRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    public var updateInfo: Api.Namespace.V1.UpdateNamespaceInfo {
      get {_storage._updateInfo ?? Api.Namespace.V1.UpdateNamespaceInfo()}
      set {_uniqueStorage()._updateInfo = newValue}
    }
    /// Returns true if `updateInfo` has been explicitly set.
    public var hasUpdateInfo: Bool {_storage._updateInfo != nil}
    /// Clears the value of `updateInfo`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateInfo() {_uniqueStorage()._updateInfo = nil}

    public var config: Api.Namespace.V1.NamespaceConfig {
      get {_storage._config ?? Api.Namespace.V1.NamespaceConfig()}
      set {_uniqueStorage()._config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {_storage._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {_uniqueStorage()._config = nil}

    public var replicationConfig: Api.Replication.V1.NamespaceReplicationConfig {
      get {_storage._replicationConfig ?? Api.Replication.V1.NamespaceReplicationConfig()}
      set {_uniqueStorage()._replicationConfig = newValue}
    }
    /// Returns true if `replicationConfig` has been explicitly set.
    public var hasReplicationConfig: Bool {_storage._replicationConfig != nil}
    /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
    public mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

    public var securityToken: String {
      get {_storage._securityToken}
      set {_uniqueStorage()._securityToken = newValue}
    }

    public var deleteBadBinary: String {
      get {_storage._deleteBadBinary}
      set {_uniqueStorage()._deleteBadBinary = newValue}
    }

    /// promote local namespace to global namespace. Ignored if namespace is already global namespace.
    public var promoteNamespace: Bool {
      get {_storage._promoteNamespace}
      set {_uniqueStorage()._promoteNamespace = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateNamespaceResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespaceInfo: Api.Namespace.V1.NamespaceInfo {
      get {_storage._namespaceInfo ?? Api.Namespace.V1.NamespaceInfo()}
      set {_uniqueStorage()._namespaceInfo = newValue}
    }
    /// Returns true if `namespaceInfo` has been explicitly set.
    public var hasNamespaceInfo: Bool {_storage._namespaceInfo != nil}
    /// Clears the value of `namespaceInfo`. Subsequent reads from it will return its default value.
    public mutating func clearNamespaceInfo() {_uniqueStorage()._namespaceInfo = nil}

    public var config: Api.Namespace.V1.NamespaceConfig {
      get {_storage._config ?? Api.Namespace.V1.NamespaceConfig()}
      set {_uniqueStorage()._config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {_storage._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {_uniqueStorage()._config = nil}

    public var replicationConfig: Api.Replication.V1.NamespaceReplicationConfig {
      get {_storage._replicationConfig ?? Api.Replication.V1.NamespaceReplicationConfig()}
      set {_uniqueStorage()._replicationConfig = newValue}
    }
    /// Returns true if `replicationConfig` has been explicitly set.
    public var hasReplicationConfig: Bool {_storage._replicationConfig != nil}
    /// Clears the value of `replicationConfig`. Subsequent reads from it will return its default value.
    public mutating func clearReplicationConfig() {_uniqueStorage()._replicationConfig = nil}

    public var failoverVersion: Int64 {
      get {_storage._failoverVersion}
      set {_uniqueStorage()._failoverVersion = newValue}
    }

    public var isGlobalNamespace: Bool {
      get {_storage._isGlobalNamespace}
      set {_uniqueStorage()._isGlobalNamespace = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  /// Deprecated.
  public struct DeprecateNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var securityToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Deprecated.
  public struct DeprecateNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct StartWorkflowExecutionRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    public var workflowID: String {
      get {_storage._workflowID}
      set {_uniqueStorage()._workflowID = newValue}
    }

    public var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    public var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Total workflow execution timeout including retries and continue as new.
    public var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    public var hasWorkflowExecutionTimeout: Bool {_storage._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

    /// Timeout of a single workflow run.
    public var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    public var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task.
    public var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    public var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// The identity of the client who initiated this request
    public var identity: String {
      get {_storage._identity}
      set {_uniqueStorage()._identity = newValue}
    }

    /// A unique identifier for this start request. Typically UUIDv4.
    public var requestID: String {
      get {_storage._requestID}
      set {_uniqueStorage()._requestID = newValue}
    }

    /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    ///
    /// See `workflow_id_conflict_policy` for handling a workflow id duplication with a *running* workflow.
    public var workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy {
      get {_storage._workflowIDReusePolicy}
      set {_uniqueStorage()._workflowIDReusePolicy = newValue}
    }

    /// Defines how to resolve a workflow id conflict with a *running* workflow.
    /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_FAIL.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    public var workflowIDConflictPolicy: Api.Enums.V1.WorkflowIdConflictPolicy {
      get {_storage._workflowIDConflictPolicy}
      set {_uniqueStorage()._workflowIDConflictPolicy = newValue}
    }

    /// The retry policy for the workflow. Will never exceed `workflow_execution_timeout`.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    public var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    public var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {_uniqueStorage()._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Request to get the first workflow task inline in the response bypassing matching service and worker polling.
    /// If set to `true` the caller is expected to have a worker available and capable of processing the task.
    /// The returned task will be marked as started and is expected to be completed by the specified
    /// `workflow_task_timeout`.
    public var requestEagerExecution: Bool {
      get {_storage._requestEagerExecution}
      set {_uniqueStorage()._requestEagerExecution = newValue}
    }

    /// These values will be available as ContinuedFailure and LastCompletionResult in the
    /// WorkflowExecutionStarted event and through SDKs. The are currently only used by the
    /// server itself (for the schedules feature) and are not intended to be exposed in
    /// StartWorkflowExecution.
    public var continuedFailure: Api.Failure.V1.Failure {
      get {_storage._continuedFailure ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._continuedFailure = newValue}
    }
    /// Returns true if `continuedFailure` has been explicitly set.
    public var hasContinuedFailure: Bool {_storage._continuedFailure != nil}
    /// Clears the value of `continuedFailure`. Subsequent reads from it will return its default value.
    public mutating func clearContinuedFailure() {_uniqueStorage()._continuedFailure = nil}

    public var lastCompletionResult: Api.Common.V1.Payloads {
      get {_storage._lastCompletionResult ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._lastCompletionResult = newValue}
    }
    /// Returns true if `lastCompletionResult` has been explicitly set.
    public var hasLastCompletionResult: Bool {_storage._lastCompletionResult != nil}
    /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
    public mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

    /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    /// If the workflow gets a signal before the delay, a workflow task will be dispatched and the rest
    /// of the delay will be ignored.
    public var workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowStartDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowStartDelay = newValue}
    }
    /// Returns true if `workflowStartDelay` has been explicitly set.
    public var hasWorkflowStartDelay: Bool {_storage._workflowStartDelay != nil}
    /// Clears the value of `workflowStartDelay`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowStartDelay() {_uniqueStorage()._workflowStartDelay = nil}

    /// Callbacks to be called by the server when this workflow reaches a terminal state.
    /// If the workflow continues-as-new, these callbacks will be carried over to the new execution.
    /// Callback addresses must be whitelisted in the server's dynamic configuration.
    public var completionCallbacks: [Api.Common.V1.Callback] {
      get {_storage._completionCallbacks}
      set {_uniqueStorage()._completionCallbacks = newValue}
    }

    /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
    /// for use by user interfaces to display the fixed as-of-start summary and details of the
    /// workflow.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// Links to be associated with the workflow.
    public var links: [Api.Common.V1.Link] {
      get {_storage._links}
      set {_uniqueStorage()._links = newValue}
    }

    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    public var versioningOverride: Api.Workflow.V1.VersioningOverride {
      get {_storage._versioningOverride ?? Api.Workflow.V1.VersioningOverride()}
      set {_uniqueStorage()._versioningOverride = newValue}
    }
    /// Returns true if `versioningOverride` has been explicitly set.
    public var hasVersioningOverride: Bool {_storage._versioningOverride != nil}
    /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

    /// Defines actions to be done to the existing running workflow when the conflict policy
    /// WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING is used. If not set (ie., nil value) or set to a
    /// empty object (ie., all options with default value), it won't do anything to the existing
    /// running workflow. If set, it will add a history event to the running workflow.
    public var onConflictOptions: Api.Workflow.V1.OnConflictOptions {
      get {_storage._onConflictOptions ?? Api.Workflow.V1.OnConflictOptions()}
      set {_uniqueStorage()._onConflictOptions = newValue}
    }
    /// Returns true if `onConflictOptions` has been explicitly set.
    public var hasOnConflictOptions: Bool {_storage._onConflictOptions != nil}
    /// Clears the value of `onConflictOptions`. Subsequent reads from it will return its default value.
    public mutating func clearOnConflictOptions() {_uniqueStorage()._onConflictOptions = nil}

    /// Priority metadata
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    /// Deployment Options of the worker who will process the eager task. Passed when `request_eager_execution=true`.
    public var eagerWorkerDeploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_storage._eagerWorkerDeploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_uniqueStorage()._eagerWorkerDeploymentOptions = newValue}
    }
    /// Returns true if `eagerWorkerDeploymentOptions` has been explicitly set.
    public var hasEagerWorkerDeploymentOptions: Bool {_storage._eagerWorkerDeploymentOptions != nil}
    /// Clears the value of `eagerWorkerDeploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearEagerWorkerDeploymentOptions() {_uniqueStorage()._eagerWorkerDeploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct StartWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The run id of the workflow that was started - or used (via WorkflowIdConflictPolicy USE_EXISTING).
    public var runID: String = String()

    /// If true, a new workflow was started.
    public var started: Bool = false

    /// Current execution status of the workflow. Typically remains WORKFLOW_EXECUTION_STATUS_RUNNING
    /// unless a de-dupe occurs or in specific scenarios handled within the ExecuteMultiOperation (refer to its docs).
    public var status: Api.Enums.V1.WorkflowExecutionStatus = .unspecified

    /// When `request_eager_execution` is set on the `StartWorkflowExecutionRequest`, the server - if supported - will
    /// return the first workflow task to be eagerly executed.
    /// The caller is expected to have a worker available to process the task.
    public var eagerWorkflowTask: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse {
      get {_eagerWorkflowTask ?? Api.Workflowservice.V1.PollWorkflowTaskQueueResponse()}
      set {_eagerWorkflowTask = newValue}
    }
    /// Returns true if `eagerWorkflowTask` has been explicitly set.
    public var hasEagerWorkflowTask: Bool {self._eagerWorkflowTask != nil}
    /// Clears the value of `eagerWorkflowTask`. Subsequent reads from it will return its default value.
    public mutating func clearEagerWorkflowTask() {self._eagerWorkflowTask = nil}

    /// Link to the workflow event.
    public var link: Api.Common.V1.Link {
      get {_link ?? Api.Common.V1.Link()}
      set {_link = newValue}
    }
    /// Returns true if `link` has been explicitly set.
    public var hasLink: Bool {self._link != nil}
    /// Clears the value of `link`. Subsequent reads from it will return its default value.
    public mutating func clearLink() {self._link = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _eagerWorkflowTask: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse? = nil
    fileprivate var _link: Api.Common.V1.Link? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct GetWorkflowExecutionHistoryRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    public var maximumPageSize: Int32 = 0

    /// If a `GetWorkflowExecutionHistoryResponse` or a `PollWorkflowTaskQueueResponse` had one of
    /// these, it should be passed here to fetch the next page.
    public var nextPageToken: Data = Data()

    /// If set to true, the RPC call will not resolve until there is a new event which matches
    /// the `history_event_filter_type`, or a timeout is hit.
    public var waitNewEvent: Bool = false

    /// Filter returned events such that they match the specified filter type.
    /// Default: HISTORY_EVENT_FILTER_TYPE_ALL_EVENT.
    public var historyEventFilterType: Api.Enums.V1.HistoryEventFilterType = .unspecified

    public var skipArchival: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct GetWorkflowExecutionHistoryResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var history: Api.History.V1.History {
      get {_history ?? Api.History.V1.History()}
      set {_history = newValue}
    }
    /// Returns true if `history` has been explicitly set.
    public var hasHistory: Bool {self._history != nil}
    /// Clears the value of `history`. Subsequent reads from it will return its default value.
    public mutating func clearHistory() {self._history = nil}

    /// Raw history is an alternate representation of history that may be returned if configured on
    /// the frontend. This is not supported by all SDKs. Either this or `history` will be set.
    public var rawHistory: [Api.Common.V1.DataBlob] = []

    /// Will be set if there are more history events than were included in this response
    public var nextPageToken: Data = Data()

    public var archived: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _history: Api.History.V1.History? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct GetWorkflowExecutionHistoryReverseRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    public var maximumPageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct GetWorkflowExecutionHistoryReverseResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var history: Api.History.V1.History {
      get {_history ?? Api.History.V1.History()}
      set {_history = newValue}
    }
    /// Returns true if `history` has been explicitly set.
    public var hasHistory: Bool {self._history != nil}
    /// Clears the value of `history`. Subsequent reads from it will return its default value.
    public mutating func clearHistory() {self._history = nil}

    /// Will be set if there are more history events than were included in this response
    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _history: Api.History.V1.History? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollWorkflowTaskQueueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    /// The identity of the worker/client who is polling this task queue
    public var identity: String = String()

    /// Deprecated. Use deployment_options instead.
    /// Each worker process should provide an ID unique to the specific set of code it is running
    /// "checksum" in this field name isn't very accurate, it should be though of as an id.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var binaryChecksum: String = String()

    /// Deprecated. Use deployment_options instead.
    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities {
      get {_workerVersionCapabilities ?? Api.Common.V1.WorkerVersionCapabilities()}
      set {_workerVersionCapabilities = newValue}
    }
    /// Returns true if `workerVersionCapabilities` has been explicitly set.
    public var hasWorkerVersionCapabilities: Bool {self._workerVersionCapabilities != nil}
    /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

    /// Worker deployment options that user has set in the worker.
    /// Experimental. Worker Deployments are experimental and might significantly change in the future.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollWorkflowTaskQueueResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier for this task
    public var taskToken: Data {
      get {_storage._taskToken}
      set {_uniqueStorage()._taskToken = newValue}
    }

    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_storage._workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {_storage._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

    public var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    /// The last workflow task started event which was processed by some worker for this execution.
    /// Will be zero if no task has ever started.
    public var previousStartedEventID: Int64 {
      get {_storage._previousStartedEventID}
      set {_uniqueStorage()._previousStartedEventID = newValue}
    }

    /// The id of the most recent workflow task started event, which will have been generated as a
    /// result of this poll request being served. Will be zero if the task
    /// does not contain any events which would advance history (no new WFT started).
    /// Currently this can happen for queries.
    public var startedEventID: Int64 {
      get {_storage._startedEventID}
      set {_uniqueStorage()._startedEventID = newValue}
    }

    /// Starting at 1, the number of attempts to complete this task by any worker.
    public var attempt: Int32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// A hint that there are more tasks already present in this task queue
    /// partition. Can be used to prioritize draining a sticky queue.
    ///
    /// Specifically, the returned number is the number of tasks remaining in
    /// the in-memory buffer for this partition, which is currently capped at
    /// 1000. Because sticky queues only have one partition, this number is
    /// more useful when draining them. Normal queues, typically having more than one
    /// partition, will return a number representing only some portion of the
    /// overall backlog. Subsequent RPCs may not hit the same partition as
    /// this call.
    public var backlogCountHint: Int64 {
      get {_storage._backlogCountHint}
      set {_uniqueStorage()._backlogCountHint = newValue}
    }

    /// The history for this workflow, which will either be complete or partial. Partial histories
    /// are sent to workers who have signaled that they are using a sticky queue when completing
    /// a workflow task.
    public var history: Api.History.V1.History {
      get {_storage._history ?? Api.History.V1.History()}
      set {_uniqueStorage()._history = newValue}
    }
    /// Returns true if `history` has been explicitly set.
    public var hasHistory: Bool {_storage._history != nil}
    /// Clears the value of `history`. Subsequent reads from it will return its default value.
    public mutating func clearHistory() {_uniqueStorage()._history = nil}

    /// Will be set if there are more history events than were included in this response. Such events
    /// should be fetched via `GetWorkflowExecutionHistory`.
    public var nextPageToken: Data {
      get {_storage._nextPageToken}
      set {_uniqueStorage()._nextPageToken = newValue}
    }

    /// Legacy queries appear in this field. The query must be responded to via
    /// `RespondQueryTaskCompleted`. If the workflow is already closed (queries are permitted on
    /// closed workflows) then the `history` field will be populated with the entire history. It
    /// may also be populated if this task originates on a non-sticky queue.
    public var query: Api.Query.V1.WorkflowQuery {
      get {_storage._query ?? Api.Query.V1.WorkflowQuery()}
      set {_uniqueStorage()._query = newValue}
    }
    /// Returns true if `query` has been explicitly set.
    public var hasQuery: Bool {_storage._query != nil}
    /// Clears the value of `query`. Subsequent reads from it will return its default value.
    public mutating func clearQuery() {_uniqueStorage()._query = nil}

    /// The task queue this task originated from, which will always be the original non-sticky name
    /// for the queue, even if this response came from polling a sticky queue.
    public var workflowExecutionTaskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._workflowExecutionTaskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._workflowExecutionTaskQueue = newValue}
    }
    /// Returns true if `workflowExecutionTaskQueue` has been explicitly set.
    public var hasWorkflowExecutionTaskQueue: Bool {_storage._workflowExecutionTaskQueue != nil}
    /// Clears the value of `workflowExecutionTaskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionTaskQueue() {_uniqueStorage()._workflowExecutionTaskQueue = nil}

    /// When this task was scheduled by the server
    public var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {_storage._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

    /// When the current workflow task started event was generated, meaning the current attempt.
    public var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._startedTime = newValue}
    }
    /// Returns true if `startedTime` has been explicitly set.
    public var hasStartedTime: Bool {_storage._startedTime != nil}
    /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

    /// Queries that should be executed after applying the history in this task. Responses should be
    /// attached to `RespondWorkflowTaskCompletedRequest::query_results`
    public var queries: Dictionary<String,Api.Query.V1.WorkflowQuery> {
      get {_storage._queries}
      set {_uniqueStorage()._queries = newValue}
    }

    /// Protocol messages piggybacking on a WFT as a transport
    public var messages: [Api.`Protocol`.V1.Message] {
      get {_storage._messages}
      set {_uniqueStorage()._messages = newValue}
    }

    /// Server-advised information the SDK may use to adjust its poller count.
    public var pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision {
      get {_storage._pollerScalingDecision ?? Api.Taskqueue.V1.PollerScalingDecision()}
      set {_uniqueStorage()._pollerScalingDecision = newValue}
    }
    /// Returns true if `pollerScalingDecision` has been explicitly set.
    public var hasPollerScalingDecision: Bool {_storage._pollerScalingDecision != nil}
    /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
    public mutating func clearPollerScalingDecision() {_uniqueStorage()._pollerScalingDecision = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondWorkflowTaskCompletedRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollWorkflowTaskQueueResponse`
    public var taskToken: Data {
      get {_storage._taskToken}
      set {_uniqueStorage()._taskToken = newValue}
    }

    /// A list of commands generated when driving the workflow code in response to the new task
    public var commands: [Api.Command.V1.Command] {
      get {_storage._commands}
      set {_uniqueStorage()._commands = newValue}
    }

    /// The identity of the worker/client
    public var identity: String {
      get {_storage._identity}
      set {_uniqueStorage()._identity = newValue}
    }

    /// May be set by workers to indicate that the worker desires future tasks to be provided with
    /// incremental history on a sticky queue.
    public var stickyAttributes: Api.Taskqueue.V1.StickyExecutionAttributes {
      get {_storage._stickyAttributes ?? Api.Taskqueue.V1.StickyExecutionAttributes()}
      set {_uniqueStorage()._stickyAttributes = newValue}
    }
    /// Returns true if `stickyAttributes` has been explicitly set.
    public var hasStickyAttributes: Bool {_storage._stickyAttributes != nil}
    /// Clears the value of `stickyAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearStickyAttributes() {_uniqueStorage()._stickyAttributes = nil}

    /// If set, the worker wishes to immediately receive the next workflow task as a response to
    /// this completion. This can save on polling round-trips.
    public var returnNewWorkflowTask: Bool {
      get {_storage._returnNewWorkflowTask}
      set {_uniqueStorage()._returnNewWorkflowTask = newValue}
    }

    /// Can be used to *force* creation of a new workflow task, even if no commands have resolved or
    /// one would not otherwise have been generated. This is used when the worker knows it is doing
    /// something useful, but cannot complete it within the workflow task timeout. Local activities
    /// which run for longer than the task timeout being the prime example.
    public var forceCreateNewWorkflowTask: Bool {
      get {_storage._forceCreateNewWorkflowTask}
      set {_uniqueStorage()._forceCreateNewWorkflowTask = newValue}
    }

    /// Deprecated. Use `deployment_options` instead.
    /// Worker process' unique binary id
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var binaryChecksum: String {
      get {_storage._binaryChecksum}
      set {_uniqueStorage()._binaryChecksum = newValue}
    }

    /// Responses to the `queries` field in the task being responded to
    public var queryResults: Dictionary<String,Api.Query.V1.WorkflowQueryResult> {
      get {_storage._queryResults}
      set {_uniqueStorage()._queryResults = newValue}
    }

    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` and `versioning_behavior` instead.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersionStamp: Api.Common.V1.WorkerVersionStamp {
      get {_storage._workerVersionStamp ?? Api.Common.V1.WorkerVersionStamp()}
      set {_uniqueStorage()._workerVersionStamp = newValue}
    }
    /// Returns true if `workerVersionStamp` has been explicitly set.
    public var hasWorkerVersionStamp: Bool {_storage._workerVersionStamp != nil}
    /// Clears the value of `workerVersionStamp`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersionStamp() {_uniqueStorage()._workerVersionStamp = nil}

    /// Protocol messages piggybacking on a WFT as a transport
    public var messages: [Api.`Protocol`.V1.Message] {
      get {_storage._messages}
      set {_uniqueStorage()._messages = newValue}
    }

    /// Data the SDK wishes to record for itself, but server need not interpret, and does not
    /// directly impact workflow state.
    public var sdkMetadata: Api.Sdk.V1.WorkflowTaskCompletedMetadata {
      get {_storage._sdkMetadata ?? Api.Sdk.V1.WorkflowTaskCompletedMetadata()}
      set {_uniqueStorage()._sdkMetadata = newValue}
    }
    /// Returns true if `sdkMetadata` has been explicitly set.
    public var hasSdkMetadata: Bool {_storage._sdkMetadata != nil}
    /// Clears the value of `sdkMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearSdkMetadata() {_uniqueStorage()._sdkMetadata = nil}

    /// Local usage data collected for metering
    public var meteringMetadata: Api.Common.V1.MeteringMetadata {
      get {_storage._meteringMetadata ?? Api.Common.V1.MeteringMetadata()}
      set {_uniqueStorage()._meteringMetadata = newValue}
    }
    /// Returns true if `meteringMetadata` has been explicitly set.
    public var hasMeteringMetadata: Bool {_storage._meteringMetadata != nil}
    /// Clears the value of `meteringMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearMeteringMetadata() {_uniqueStorage()._meteringMetadata = nil}

    /// All capabilities the SDK supports.
    public var capabilities: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities {
      get {_storage._capabilities ?? Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities()}
      set {_uniqueStorage()._capabilities = newValue}
    }
    /// Returns true if `capabilities` has been explicitly set.
    public var hasCapabilities: Bool {_storage._capabilities != nil}
    /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
    public mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_storage._deployment ?? Api.Deployment.V1.Deployment()}
      set {_uniqueStorage()._deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {_storage._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {_uniqueStorage()._deployment = nil}

    /// Versioning behavior of this workflow execution as set on the worker that completed this task.
    /// UNSPECIFIED means versioning is not enabled in the worker.
    public var versioningBehavior: Api.Enums.V1.VersioningBehavior {
      get {_storage._versioningBehavior}
      set {_uniqueStorage()._versioningBehavior = newValue}
    }

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_storage._deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_uniqueStorage()._deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {_storage._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {_uniqueStorage()._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// SDK capability details.
    public struct Capabilities: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// True if the SDK can handle speculative workflow task with command events. If true, the
      /// server may choose, at its discretion, to discard a speculative workflow task even if that
      /// speculative task included command events the SDK had not previously processed.
      ///
      /// (-- api-linter: core::0140::prepositions=disabled
      ///     aip.dev/not-precedent: "with" used to describe the workflow task. --)
      public var discardSpeculativeWorkflowTaskWithEvents: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondWorkflowTaskCompletedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// See `RespondWorkflowTaskCompletedResponse::return_new_workflow_task`
    public var workflowTask: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse {
      get {_workflowTask ?? Api.Workflowservice.V1.PollWorkflowTaskQueueResponse()}
      set {_workflowTask = newValue}
    }
    /// Returns true if `workflowTask` has been explicitly set.
    public var hasWorkflowTask: Bool {self._workflowTask != nil}
    /// Clears the value of `workflowTask`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowTask() {self._workflowTask = nil}

    /// See `ScheduleActivityTaskCommandAttributes::request_eager_execution`
    public var activityTasks: [Api.Workflowservice.V1.PollActivityTaskQueueResponse] = []

    /// If non zero, indicates the server has discarded the workflow task that was being responded to.
    /// Will be the event ID of the last workflow task started event in the history before the new workflow task.
    /// Server is only expected to discard a workflow task if it could not have modified the workflow state.
    public var resetHistoryEventID: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowTask: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondWorkflowTaskFailedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollWorkflowTaskQueueResponse`
    public var taskToken: Data = Data()

    /// Why did the task fail? It's important to note that many of the variants in this enum cannot
    /// apply to worker responses. See the type's doc for more.
    public var cause: Api.Enums.V1.WorkflowTaskFailedCause = .unspecified

    /// Failure details
    public var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    public var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    public mutating func clearFailure() {self._failure = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// Deprecated. Use `deployment_options` instead.
    /// Worker process' unique binary id
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var binaryChecksum: String = String()

    public var namespace: String = String()

    /// Protocol messages piggybacking on a WFT as a transport
    public var messages: [Api.`Protocol`.V1.Message] = []

    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersion: Api.Common.V1.WorkerVersionStamp {
      get {_workerVersion ?? Api.Common.V1.WorkerVersionStamp()}
      set {_workerVersion = newValue}
    }
    /// Returns true if `workerVersion` has been explicitly set.
    public var hasWorkerVersion: Bool {self._workerVersion != nil}
    /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersion() {self._workerVersion = nil}

    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
    fileprivate var _workerVersion: Api.Common.V1.WorkerVersionStamp? = nil
    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondWorkflowTaskFailedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct PollActivityTaskQueueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var taskQueueMetadata: Api.Taskqueue.V1.TaskQueueMetadata {
      get {_taskQueueMetadata ?? Api.Taskqueue.V1.TaskQueueMetadata()}
      set {_taskQueueMetadata = newValue}
    }
    /// Returns true if `taskQueueMetadata` has been explicitly set.
    public var hasTaskQueueMetadata: Bool {self._taskQueueMetadata != nil}
    /// Clears the value of `taskQueueMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueueMetadata() {self._taskQueueMetadata = nil}

    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    /// Deprecated. Replaced by deployment_options.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities {
      get {_workerVersionCapabilities ?? Api.Common.V1.WorkerVersionCapabilities()}
      set {_workerVersionCapabilities = newValue}
    }
    /// Returns true if `workerVersionCapabilities` has been explicitly set.
    public var hasWorkerVersionCapabilities: Bool {self._workerVersionCapabilities != nil}
    /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _taskQueueMetadata: Api.Taskqueue.V1.TaskQueueMetadata? = nil
    fileprivate var _workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollActivityTaskQueueResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier for this task
    public var taskToken: Data {
      get {_storage._taskToken}
      set {_uniqueStorage()._taskToken = newValue}
    }

    /// The namespace the workflow which requested this activity lives in
    public var workflowNamespace: String {
      get {_storage._workflowNamespace}
      set {_uniqueStorage()._workflowNamespace = newValue}
    }

    /// Type of the requesting workflow
    public var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    /// Execution info of the requesting workflow
    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_storage._workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {_storage._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

    public var activityType: Api.Common.V1.ActivityType {
      get {_storage._activityType ?? Api.Common.V1.ActivityType()}
      set {_uniqueStorage()._activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {_storage._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

    /// The autogenerated or user specified identifier of this activity. Can be used to complete the
    /// activity via `RespondActivityTaskCompletedById`. May be re-used as long as the last usage
    /// has resolved, but unique IDs for every activity invocation is a good idea.
    /// Note that only a workflow activity ID may be autogenerated.
    public var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    /// Headers specified by the scheduling workflow. Commonly used to propagate contextual info
    /// from the workflow to its activities. For example, tracing contexts.
    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Arguments to the activity invocation
    public var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Details of the last heartbeat that was recorded for this activity as of the time this task
    /// was delivered.
    public var heartbeatDetails: Api.Common.V1.Payloads {
      get {_storage._heartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._heartbeatDetails = newValue}
    }
    /// Returns true if `heartbeatDetails` has been explicitly set.
    public var hasHeartbeatDetails: Bool {_storage._heartbeatDetails != nil}
    /// Clears the value of `heartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatDetails() {_uniqueStorage()._heartbeatDetails = nil}

    /// When was this task first scheduled
    public var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    public var hasScheduledTime: Bool {_storage._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

    /// When was this task attempt scheduled
    public var currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._currentAttemptScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._currentAttemptScheduledTime = newValue}
    }
    /// Returns true if `currentAttemptScheduledTime` has been explicitly set.
    public var hasCurrentAttemptScheduledTime: Bool {_storage._currentAttemptScheduledTime != nil}
    /// Clears the value of `currentAttemptScheduledTime`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentAttemptScheduledTime() {_uniqueStorage()._currentAttemptScheduledTime = nil}

    /// When was this task started (this attempt)
    public var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._startedTime = newValue}
    }
    /// Returns true if `startedTime` has been explicitly set.
    public var hasStartedTime: Bool {_storage._startedTime != nil}
    /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

    /// Starting at 1, the number of attempts to perform this activity
    public var attempt: Int32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// First scheduled -> final result reported timeout
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    public var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Current attempt start -> final result reported timeout
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    public var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Window within which the activity must report a heartbeat, or be timed out.
    public var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    public var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// This is the retry policy the service uses which may be different from the one provided
    /// (or not) during activity scheduling. The service can override the provided one if some
    /// values are not specified or exceed configured system limits.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Server-advised information the SDK may use to adjust its poller count.
    public var pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision {
      get {_storage._pollerScalingDecision ?? Api.Taskqueue.V1.PollerScalingDecision()}
      set {_uniqueStorage()._pollerScalingDecision = newValue}
    }
    /// Returns true if `pollerScalingDecision` has been explicitly set.
    public var hasPollerScalingDecision: Bool {_storage._pollerScalingDecision != nil}
    /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
    public mutating func clearPollerScalingDecision() {_uniqueStorage()._pollerScalingDecision = nil}

    /// Priority metadata
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    /// The run ID of the activity execution, only set for standalone activities.
    public var activityRunID: String {
      get {_storage._activityRunID}
      set {_uniqueStorage()._activityRunID = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordActivityTaskHeartbeatRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollActivityTaskQueueResponse`
    public var taskToken: Data = Data()

    /// Arbitrary data, of which the most recent call is kept, to store for this activity
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordActivityTaskHeartbeatResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
    /// notify the activity of cancellation if it is still running.
    public var cancelRequested: Bool = false

    /// Will be set to true if the activity is paused.
    public var activityPaused: Bool = false

    /// Will be set to true if the activity was reset.
    /// Applies only to the current run.
    public var activityReset: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordActivityTaskHeartbeatByIdRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity
    public var namespace: String = String()

    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    public var workflowID: String = String()

    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    public var runID: String = String()

    /// Id of the activity we're heartbeating
    public var activityID: String = String()

    /// Arbitrary data, of which the most recent call is kept, to store for this activity
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordActivityTaskHeartbeatByIdResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Will be set to true if the activity has been asked to cancel itself. The SDK should then
    /// notify the activity of cancellation if it is still running.
    public var cancelRequested: Bool = false

    /// Will be set to true if the activity is paused.
    public var activityPaused: Bool = false

    /// Will be set to true if the activity was reset.
    /// Applies only to the current run.
    public var activityReset: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCompletedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollActivityTaskQueueResponse`
    public var taskToken: Data = Data()

    /// The result of successfully executing the activity
    public var result: Api.Common.V1.Payloads {
      get {_result ?? Api.Common.V1.Payloads()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    public var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    public mutating func clearResult() {self._result = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var namespace: String = String()

    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersion: Api.Common.V1.WorkerVersionStamp {
      get {_workerVersion ?? Api.Common.V1.WorkerVersionStamp()}
      set {_workerVersion = newValue}
    }
    /// Returns true if `workerVersion` has been explicitly set.
    public var hasWorkerVersion: Bool {self._workerVersion != nil}
    /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersion() {self._workerVersion = nil}

    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _result: Api.Common.V1.Payloads? = nil
    fileprivate var _workerVersion: Api.Common.V1.WorkerVersionStamp? = nil
    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCompletedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCompletedByIdRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity
    public var namespace: String = String()

    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    public var workflowID: String = String()

    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    public var runID: String = String()

    /// Id of the activity to complete
    public var activityID: String = String()

    /// The serialized result of activity execution
    public var result: Api.Common.V1.Payloads {
      get {_result ?? Api.Common.V1.Payloads()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    public var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    public mutating func clearResult() {self._result = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _result: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCompletedByIdResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskFailedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollActivityTaskQueueResponse`
    public var taskToken: Data = Data()

    /// Detailed failure information
    public var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    public var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    public mutating func clearFailure() {self._failure = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var namespace: String = String()

    /// Additional details to be stored as last activity heartbeat
    public var lastHeartbeatDetails: Api.Common.V1.Payloads {
      get {_lastHeartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_lastHeartbeatDetails = newValue}
    }
    /// Returns true if `lastHeartbeatDetails` has been explicitly set.
    public var hasLastHeartbeatDetails: Bool {self._lastHeartbeatDetails != nil}
    /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersion: Api.Common.V1.WorkerVersionStamp {
      get {_workerVersion ?? Api.Common.V1.WorkerVersionStamp()}
      set {_workerVersion = newValue}
    }
    /// Returns true if `workerVersion` has been explicitly set.
    public var hasWorkerVersion: Bool {self._workerVersion != nil}
    /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersion() {self._workerVersion = nil}

    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
    fileprivate var _lastHeartbeatDetails: Api.Common.V1.Payloads? = nil
    fileprivate var _workerVersion: Api.Common.V1.WorkerVersionStamp? = nil
    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskFailedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server validation failures could include
    /// last_heartbeat_details payload is too large, request failure is too large
    public var failures: [Api.Failure.V1.Failure] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskFailedByIdRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity
    public var namespace: String = String()

    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    public var workflowID: String = String()

    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    public var runID: String = String()

    /// Id of the activity to fail
    public var activityID: String = String()

    /// Detailed failure information
    public var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    public var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    public mutating func clearFailure() {self._failure = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// Additional details to be stored as last activity heartbeat
    public var lastHeartbeatDetails: Api.Common.V1.Payloads {
      get {_lastHeartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_lastHeartbeatDetails = newValue}
    }
    /// Returns true if `lastHeartbeatDetails` has been explicitly set.
    public var hasLastHeartbeatDetails: Bool {self._lastHeartbeatDetails != nil}
    /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
    fileprivate var _lastHeartbeatDetails: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskFailedByIdResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Server validation failures could include
    /// last_heartbeat_details payload is too large, request failure is too large
    public var failures: [Api.Failure.V1.Failure] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCanceledRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token as received in `PollActivityTaskQueueResponse`
    public var taskToken: Data = Data()

    /// Serialized additional information to attach to the cancellation
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var namespace: String = String()

    /// Version info of the worker who processed this task. This message's `build_id` field should
    /// always be set by SDKs. Workers opting into versioning will also set the `use_versioning`
    /// field to true. See message docstrings for more.
    /// Deprecated. Use `deployment_options` instead.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersion: Api.Common.V1.WorkerVersionStamp {
      get {_workerVersion ?? Api.Common.V1.WorkerVersionStamp()}
      set {_workerVersion = newValue}
    }
    /// Returns true if `workerVersion` has been explicitly set.
    public var hasWorkerVersion: Bool {self._workerVersion != nil}
    /// Clears the value of `workerVersion`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersion() {self._workerVersion = nil}

    /// Deployment info of the worker that completed this task. Must be present if user has set
    /// `WorkerDeploymentOptions` regardless of versioning being enabled or not.
    /// Deprecated. Replaced with `deployment_options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
    fileprivate var _workerVersion: Api.Common.V1.WorkerVersionStamp? = nil
    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCanceledResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCanceledByIdRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity
    public var namespace: String = String()

    /// Id of the workflow which scheduled this activity, leave empty to target a standalone activity
    public var workflowID: String = String()

    /// For a workflow activity - the run ID of the workflow which scheduled this activity.
    /// For a standalone activity - the run ID of the activity.
    public var runID: String = String()

    /// Id of the activity to confirm is cancelled
    public var activityID: String = String()

    /// Serialized additional information to attach to the cancellation
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondActivityTaskCanceledByIdResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RequestCancelWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// Used to de-dupe cancellation requests
    public var requestID: String = String()

    /// If set, this call will error if the most recent (if no run id is set on
    /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    /// execution chain as this id.
    public var firstExecutionRunID: String = String()

    /// Reason for requesting the cancellation
    public var reason: String = String()

    /// Links to be associated with the WorkflowExecutionCanceled event.
    public var links: [Api.Common.V1.Link] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RequestCancelWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Keep the parameters in sync with:
  ///   - temporal.api.batch.v1.BatchOperationSignal.
  ///   - temporal.api.workflow.v1.PostResetOperation.SignalWorkflow.
  public struct SignalWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    /// The workflow author-defined name of the signal to send to the workflow
    public var signalName: String = String()

    /// Serialized value(s) to provide with the signal
    public var input: Api.Common.V1.Payloads {
      get {_input ?? Api.Common.V1.Payloads()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {self._input = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// Used to de-dupe sent signals
    public var requestID: String = String()

    /// Deprecated.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var control: String = String()

    /// Headers that are passed with the signal to the processing workflow.
    /// These can include things like auth or tracing tokens.
    public var header: Api.Common.V1.Header {
      get {_header ?? Api.Common.V1.Header()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {self._header = nil}

    /// Links to be associated with the WorkflowExecutionSignaled event.
    public var links: [Api.Common.V1.Link] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _input: Api.Common.V1.Payloads? = nil
    fileprivate var _header: Api.Common.V1.Header? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct SignalWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct SignalWithStartWorkflowExecutionRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    public var workflowID: String {
      get {_storage._workflowID}
      set {_uniqueStorage()._workflowID = newValue}
    }

    public var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    /// The task queue to start this workflow on, if it will be started
    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    /// Serialized arguments to the workflow. These are passed as arguments to the workflow function.
    public var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Total workflow execution timeout including retries and continue as new
    public var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    public var hasWorkflowExecutionTimeout: Bool {_storage._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

    /// Timeout of a single workflow run
    public var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    public var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task
    public var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    public var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// The identity of the worker/client
    public var identity: String {
      get {_storage._identity}
      set {_uniqueStorage()._identity = newValue}
    }

    /// Used to de-dupe signal w/ start requests
    public var requestID: String {
      get {_storage._requestID}
      set {_uniqueStorage()._requestID = newValue}
    }

    /// Defines whether to allow re-using the workflow id from a previously *closed* workflow.
    /// The default policy is WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *running* workflow.
    public var workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy {
      get {_storage._workflowIDReusePolicy}
      set {_uniqueStorage()._workflowIDReusePolicy = newValue}
    }

    /// Defines how to resolve a workflow id conflict with a *running* workflow.
    /// The default policy is WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING.
    /// Note that WORKFLOW_ID_CONFLICT_POLICY_FAIL is an invalid option.
    ///
    /// See `workflow_id_reuse_policy` for handling a workflow id duplication with a *closed* workflow.
    public var workflowIDConflictPolicy: Api.Enums.V1.WorkflowIdConflictPolicy {
      get {_storage._workflowIDConflictPolicy}
      set {_uniqueStorage()._workflowIDConflictPolicy = newValue}
    }

    /// The workflow author-defined name of the signal to send to the workflow
    public var signalName: String {
      get {_storage._signalName}
      set {_uniqueStorage()._signalName = newValue}
    }

    /// Serialized value(s) to provide with the signal
    public var signalInput: Api.Common.V1.Payloads {
      get {_storage._signalInput ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._signalInput = newValue}
    }
    /// Returns true if `signalInput` has been explicitly set.
    public var hasSignalInput: Bool {_storage._signalInput != nil}
    /// Clears the value of `signalInput`. Subsequent reads from it will return its default value.
    public mutating func clearSignalInput() {_uniqueStorage()._signalInput = nil}

    /// Deprecated.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var control: String {
      get {_storage._control}
      set {_uniqueStorage()._control = newValue}
    }

    /// Retry policy for the workflow
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// See https://docs.temporal.io/docs/content/what-is-a-temporal-cron-job/
    public var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    public var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {_uniqueStorage()._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Time to wait before dispatching the first workflow task. Cannot be used with `cron_schedule`.
    /// Note that the signal will be delivered with the first workflow task. If the workflow gets
    /// another SignalWithStartWorkflow before the delay a workflow task will be dispatched immediately
    /// and the rest of the delay period will be ignored, even if that request also had a delay.
    /// Signal via SignalWorkflowExecution will not unblock the workflow.
    public var workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowStartDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowStartDelay = newValue}
    }
    /// Returns true if `workflowStartDelay` has been explicitly set.
    public var hasWorkflowStartDelay: Bool {_storage._workflowStartDelay != nil}
    /// Clears the value of `workflowStartDelay`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowStartDelay() {_uniqueStorage()._workflowStartDelay = nil}

    /// Metadata on the workflow if it is started. This is carried over to the WorkflowExecutionInfo
    /// for use by user interfaces to display the fixed as-of-start summary and details of the
    /// workflow.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// Links to be associated with the WorkflowExecutionStarted and WorkflowExecutionSignaled events.
    public var links: [Api.Common.V1.Link] {
      get {_storage._links}
      set {_uniqueStorage()._links = newValue}
    }

    /// If set, takes precedence over the Versioning Behavior sent by the SDK on Workflow Task completion.
    /// To unset the override after the workflow is running, use UpdateWorkflowExecutionOptions.
    public var versioningOverride: Api.Workflow.V1.VersioningOverride {
      get {_storage._versioningOverride ?? Api.Workflow.V1.VersioningOverride()}
      set {_uniqueStorage()._versioningOverride = newValue}
    }
    /// Returns true if `versioningOverride` has been explicitly set.
    public var hasVersioningOverride: Bool {_storage._versioningOverride != nil}
    /// Clears the value of `versioningOverride`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningOverride() {_uniqueStorage()._versioningOverride = nil}

    /// Priority metadata
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct SignalWithStartWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The run id of the workflow that was started - or just signaled, if it was already running.
    public var runID: String = String()

    /// If true, a new workflow was started.
    public var started: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ResetWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// The workflow to reset. If this contains a run ID then the workflow will be reset back to the
    /// provided event ID in that run. Otherwise it will be reset to the provided event ID in the
    /// current run. In all cases the current run will be terminated and a new run started.
    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    public var reason: String = String()

    /// The id of a `WORKFLOW_TASK_COMPLETED`,`WORKFLOW_TASK_TIMED_OUT`, `WORKFLOW_TASK_FAILED`, or
    /// `WORKFLOW_TASK_STARTED` event to reset to.
    public var workflowTaskFinishEventID: Int64 = 0

    /// Used to de-dupe reset requests
    public var requestID: String = String()

    /// Deprecated. Use `options`.
    /// Default: RESET_REAPPLY_TYPE_SIGNAL
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var resetReapplyType: Api.Enums.V1.ResetReapplyType = .unspecified

    /// Event types not to be reapplied
    public var resetReapplyExcludeTypes: [Api.Enums.V1.ResetReapplyExcludeType] = []

    /// Operations to perform after the workflow has been reset. These operations will be applied
    /// to the *new* run of the workflow execution in the order they are provided.
    /// All operations are applied to the workflow before the first new workflow task is generated
    public var postResetOperations: [Api.Workflow.V1.PostResetOperation] = []

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ResetWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var runID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct TerminateWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    public var reason: String = String()

    /// Serialized additional information to attach to the termination event
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    /// If set, this call will error if the most recent (if no run id is set on
    /// `workflow_execution`), or specified (if it is) workflow execution is not part of the same
    /// execution chain as this id.
    public var firstExecutionRunID: String = String()

    /// Links to be associated with the WorkflowExecutionTerminated event.
    public var links: [Api.Common.V1.Link] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct TerminateWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Workflow Execution to delete. If run_id is not specified, the latest one is used.
    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListOpenWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var maximumPageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var startTimeFilter: Api.Filter.V1.StartTimeFilter {
      get {_startTimeFilter ?? Api.Filter.V1.StartTimeFilter()}
      set {_startTimeFilter = newValue}
    }
    /// Returns true if `startTimeFilter` has been explicitly set.
    public var hasStartTimeFilter: Bool {self._startTimeFilter != nil}
    /// Clears the value of `startTimeFilter`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeFilter() {self._startTimeFilter = nil}

    public var filters: Api.Workflowservice.V1.ListOpenWorkflowExecutionsRequest.OneOf_Filters? = nil

    public var executionFilter: Api.Filter.V1.WorkflowExecutionFilter {
      get {
        if case .executionFilter(let v)? = filters {return v}
        return Api.Filter.V1.WorkflowExecutionFilter()
      }
      set {filters = .executionFilter(newValue)}
    }

    public var typeFilter: Api.Filter.V1.WorkflowTypeFilter {
      get {
        if case .typeFilter(let v)? = filters {return v}
        return Api.Filter.V1.WorkflowTypeFilter()
      }
      set {filters = .typeFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Filters: Equatable, Sendable {
      case executionFilter(Api.Filter.V1.WorkflowExecutionFilter)
      case typeFilter(Api.Filter.V1.WorkflowTypeFilter)

    }

    public init() {}

    fileprivate var _startTimeFilter: Api.Filter.V1.StartTimeFilter? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListOpenWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Workflow.V1.WorkflowExecutionInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListClosedWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var maximumPageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var startTimeFilter: Api.Filter.V1.StartTimeFilter {
      get {_startTimeFilter ?? Api.Filter.V1.StartTimeFilter()}
      set {_startTimeFilter = newValue}
    }
    /// Returns true if `startTimeFilter` has been explicitly set.
    public var hasStartTimeFilter: Bool {self._startTimeFilter != nil}
    /// Clears the value of `startTimeFilter`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeFilter() {self._startTimeFilter = nil}

    public var filters: Api.Workflowservice.V1.ListClosedWorkflowExecutionsRequest.OneOf_Filters? = nil

    public var executionFilter: Api.Filter.V1.WorkflowExecutionFilter {
      get {
        if case .executionFilter(let v)? = filters {return v}
        return Api.Filter.V1.WorkflowExecutionFilter()
      }
      set {filters = .executionFilter(newValue)}
    }

    public var typeFilter: Api.Filter.V1.WorkflowTypeFilter {
      get {
        if case .typeFilter(let v)? = filters {return v}
        return Api.Filter.V1.WorkflowTypeFilter()
      }
      set {filters = .typeFilter(newValue)}
    }

    public var statusFilter: Api.Filter.V1.StatusFilter {
      get {
        if case .statusFilter(let v)? = filters {return v}
        return Api.Filter.V1.StatusFilter()
      }
      set {filters = .statusFilter(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Filters: Equatable, Sendable {
      case executionFilter(Api.Filter.V1.WorkflowExecutionFilter)
      case typeFilter(Api.Filter.V1.WorkflowTypeFilter)
      case statusFilter(Api.Filter.V1.StatusFilter)

    }

    public init() {}

    fileprivate var _startTimeFilter: Api.Filter.V1.StartTimeFilter? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListClosedWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Workflow.V1.WorkflowExecutionInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Workflow.V1.WorkflowExecutionInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListArchivedWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListArchivedWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Workflow.V1.WorkflowExecutionInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Deprecated: Use with `ListWorkflowExecutions`.
  public struct ScanWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Deprecated: Use with `ListWorkflowExecutions`.
  public struct ScanWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Workflow.V1.WorkflowExecutionInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct CountWorkflowExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct CountWorkflowExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If `query` is not grouping by any field, the count is an approximate number
    /// of workflows that matches the query.
    /// If `query` is grouping by a field, the count is simply the sum of the counts
    /// of the groups returned in the response. This number can be smaller than the
    /// total number of workflows matching the query.
    public var count: Int64 = 0

    /// `groups` contains the groups if the request is grouping by a field.
    /// The list might not be complete, and the counts of each group is approximate.
    public var groups: [Api.Workflowservice.V1.CountWorkflowExecutionsResponse.AggregationGroup] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct AggregationGroup: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var groupValues: [Api.Common.V1.Payload] = []

      public var count: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct GetSearchAttributesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct GetSearchAttributesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var keys: Dictionary<String,Api.Enums.V1.IndexedValueType> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondQueryTaskCompletedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var taskToken: Data = Data()

    public var completedType: Api.Enums.V1.QueryResultType = .unspecified

    /// The result of the query.
    /// Mutually exclusive with `error_message` and `failure`. Set when the query succeeds.
    public var queryResult: Api.Common.V1.Payloads {
      get {_queryResult ?? Api.Common.V1.Payloads()}
      set {_queryResult = newValue}
    }
    /// Returns true if `queryResult` has been explicitly set.
    public var hasQueryResult: Bool {self._queryResult != nil}
    /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
    public mutating func clearQueryResult() {self._queryResult = nil}

    /// A plain error message that must be set if completed_type is QUERY_RESULT_TYPE_FAILED.
    /// SDKs should also fill in the more complete `failure` field to provide the full context and
    /// support encryption of failure information.
    /// `error_message` will be duplicated if the `failure` field is present to support callers
    /// that pre-date the addition of that field, regardless of whether or not a custom failure
    /// converter is used.
    /// Mutually exclusive with `query_result`. Set when the query fails.
    public var errorMessage: String = String()

    public var namespace: String = String()

    /// The full reason for this query failure. This field is newer than `error_message` and can be
    /// encoded by the SDK's failure converter to support E2E encryption of messages and stack
    /// traces.
    /// Mutually exclusive with `query_result`. Set when the query fails.
    public var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    public var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    public mutating func clearFailure() {self._failure = nil}

    /// Why did the task fail? It's important to note that many of the variants in this enum cannot
    /// apply to worker responses. See the type's doc for more.
    public var cause: Api.Enums.V1.WorkflowTaskFailedCause = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _queryResult: Api.Common.V1.Payloads? = nil
    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondQueryTaskCompletedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ResetStickyTaskQueueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ResetStickyTaskQueueResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ShutdownWorkerRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var stickyTaskQueue: String = String()

    public var identity: String = String()

    public var reason: String = String()

    public var workerHeartbeat: Api.Worker.V1.WorkerHeartbeat {
      get {_workerHeartbeat ?? Api.Worker.V1.WorkerHeartbeat()}
      set {_workerHeartbeat = newValue}
    }
    /// Returns true if `workerHeartbeat` has been explicitly set.
    public var hasWorkerHeartbeat: Bool {self._workerHeartbeat != nil}
    /// Clears the value of `workerHeartbeat`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerHeartbeat() {self._workerHeartbeat = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workerHeartbeat: Api.Worker.V1.WorkerHeartbeat? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ShutdownWorkerResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct QueryWorkflowRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    public var query: Api.Query.V1.WorkflowQuery {
      get {_query ?? Api.Query.V1.WorkflowQuery()}
      set {_query = newValue}
    }
    /// Returns true if `query` has been explicitly set.
    public var hasQuery: Bool {self._query != nil}
    /// Clears the value of `query`. Subsequent reads from it will return its default value.
    public mutating func clearQuery() {self._query = nil}

    /// QueryRejectCondition can used to reject the query if workflow state does not satisfy condition.
    /// Default: QUERY_REJECT_CONDITION_NONE.
    public var queryRejectCondition: Api.Enums.V1.QueryRejectCondition = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _query: Api.Query.V1.WorkflowQuery? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct QueryWorkflowResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var queryResult: Api.Common.V1.Payloads {
      get {_queryResult ?? Api.Common.V1.Payloads()}
      set {_queryResult = newValue}
    }
    /// Returns true if `queryResult` has been explicitly set.
    public var hasQueryResult: Bool {self._queryResult != nil}
    /// Clears the value of `queryResult`. Subsequent reads from it will return its default value.
    public mutating func clearQueryResult() {self._queryResult = nil}

    public var queryRejected: Api.Query.V1.QueryRejected {
      get {_queryRejected ?? Api.Query.V1.QueryRejected()}
      set {_queryRejected = newValue}
    }
    /// Returns true if `queryRejected` has been explicitly set.
    public var hasQueryRejected: Bool {self._queryRejected != nil}
    /// Clears the value of `queryRejected`. Subsequent reads from it will return its default value.
    public mutating func clearQueryRejected() {self._queryRejected = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _queryResult: Api.Common.V1.Payloads? = nil
    fileprivate var _queryRejected: Api.Query.V1.QueryRejected? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkflowExecutionResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executionConfig: Api.Workflow.V1.WorkflowExecutionConfig {
      get {_storage._executionConfig ?? Api.Workflow.V1.WorkflowExecutionConfig()}
      set {_uniqueStorage()._executionConfig = newValue}
    }
    /// Returns true if `executionConfig` has been explicitly set.
    public var hasExecutionConfig: Bool {_storage._executionConfig != nil}
    /// Clears the value of `executionConfig`. Subsequent reads from it will return its default value.
    public mutating func clearExecutionConfig() {_uniqueStorage()._executionConfig = nil}

    public var workflowExecutionInfo: Api.Workflow.V1.WorkflowExecutionInfo {
      get {_storage._workflowExecutionInfo ?? Api.Workflow.V1.WorkflowExecutionInfo()}
      set {_uniqueStorage()._workflowExecutionInfo = newValue}
    }
    /// Returns true if `workflowExecutionInfo` has been explicitly set.
    public var hasWorkflowExecutionInfo: Bool {_storage._workflowExecutionInfo != nil}
    /// Clears the value of `workflowExecutionInfo`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionInfo() {_uniqueStorage()._workflowExecutionInfo = nil}

    public var pendingActivities: [Api.Workflow.V1.PendingActivityInfo] {
      get {_storage._pendingActivities}
      set {_uniqueStorage()._pendingActivities = newValue}
    }

    public var pendingChildren: [Api.Workflow.V1.PendingChildExecutionInfo] {
      get {_storage._pendingChildren}
      set {_uniqueStorage()._pendingChildren = newValue}
    }

    public var pendingWorkflowTask: Api.Workflow.V1.PendingWorkflowTaskInfo {
      get {_storage._pendingWorkflowTask ?? Api.Workflow.V1.PendingWorkflowTaskInfo()}
      set {_uniqueStorage()._pendingWorkflowTask = newValue}
    }
    /// Returns true if `pendingWorkflowTask` has been explicitly set.
    public var hasPendingWorkflowTask: Bool {_storage._pendingWorkflowTask != nil}
    /// Clears the value of `pendingWorkflowTask`. Subsequent reads from it will return its default value.
    public mutating func clearPendingWorkflowTask() {_uniqueStorage()._pendingWorkflowTask = nil}

    public var callbacks: [Api.Workflow.V1.CallbackInfo] {
      get {_storage._callbacks}
      set {_uniqueStorage()._callbacks = newValue}
    }

    public var pendingNexusOperations: [Api.Workflow.V1.PendingNexusOperationInfo] {
      get {_storage._pendingNexusOperations}
      set {_uniqueStorage()._pendingNexusOperations = newValue}
    }

    public var workflowExtendedInfo: Api.Workflow.V1.WorkflowExecutionExtendedInfo {
      get {_storage._workflowExtendedInfo ?? Api.Workflow.V1.WorkflowExecutionExtendedInfo()}
      set {_uniqueStorage()._workflowExtendedInfo = newValue}
    }
    /// Returns true if `workflowExtendedInfo` has been explicitly set.
    public var hasWorkflowExtendedInfo: Bool {_storage._workflowExtendedInfo != nil}
    /// Clears the value of `workflowExtendedInfo`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExtendedInfo() {_uniqueStorage()._workflowExtendedInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  /// (-- api-linter: core::0203::optional=disabled
  ///     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
  public struct DescribeTaskQueueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Sticky queues are not supported in deprecated ENHANCED mode.
    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    /// If unspecified (TASK_QUEUE_TYPE_UNSPECIFIED), then default value (TASK_QUEUE_TYPE_WORKFLOW) will be used.
    /// Only supported in default mode (use `task_queue_types` in ENHANCED mode instead).
    public var taskQueueType: Api.Enums.V1.TaskQueueType = .unspecified

    /// Report stats for the requested task queue type(s).
    public var reportStats: Bool = false

    /// Report Task Queue Config
    public var reportConfig: Bool = false

    /// Deprecated, use `report_stats` instead.
    /// If true, the task queue status will be included in the response.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var includeTaskQueueStatus: Bool = false

    /// Deprecated. ENHANCED mode is also being deprecated.
    /// Select the API mode to use for this request: DEFAULT mode (if unset) or ENHANCED mode.
    /// Consult the documentation for each field to understand which mode it is supported in.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var apiMode: Api.Enums.V1.DescribeTaskQueueMode = .unspecified

    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Optional. If not provided, the result for the default Build ID will be returned. The default Build ID is the one
    /// mentioned in the first unconditional Assignment Rule. If there is no default Build ID, the result for the
    /// unversioned queue will be returned.
    /// (-- api-linter: core::0140::prepositions --)
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var versions: Api.Taskqueue.V1.TaskQueueVersionSelection {
      get {_versions ?? Api.Taskqueue.V1.TaskQueueVersionSelection()}
      set {_versions = newValue}
    }
    /// Returns true if `versions` has been explicitly set.
    public var hasVersions: Bool {self._versions != nil}
    /// Clears the value of `versions`. Subsequent reads from it will return its default value.
    public mutating func clearVersions() {self._versions = nil}

    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Task queue types to report info about. If not specified, all types are considered.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var taskQueueTypes: [Api.Enums.V1.TaskQueueType] = []

    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Report list of pollers for requested task queue types and versions.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var reportPollers: Bool = false

    /// Deprecated (as part of the ENHANCED mode deprecation).
    /// Report task reachability for the requested versions and all task types (task reachability is not reported
    /// per task type).
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var reportTaskReachability: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _versions: Api.Taskqueue.V1.TaskQueueVersionSelection? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeTaskQueueResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var pollers: [Api.Taskqueue.V1.PollerInfo] {
      get {_storage._pollers}
      set {_uniqueStorage()._pollers = newValue}
    }

    /// Statistics for the task queue.
    /// Only set if `report_stats` is set on the request.
    public var stats: Api.Taskqueue.V1.TaskQueueStats {
      get {_storage._stats ?? Api.Taskqueue.V1.TaskQueueStats()}
      set {_uniqueStorage()._stats = newValue}
    }
    /// Returns true if `stats` has been explicitly set.
    public var hasStats: Bool {_storage._stats != nil}
    /// Clears the value of `stats`. Subsequent reads from it will return its default value.
    public mutating func clearStats() {_uniqueStorage()._stats = nil}

    /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
    /// Only set if `report_stats` is set on the request.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "by" is used to clarify the keys and values. --)
    public var statsByPriorityKey: Dictionary<Int32,Api.Taskqueue.V1.TaskQueueStats> {
      get {_storage._statsByPriorityKey}
      set {_uniqueStorage()._statsByPriorityKey = newValue}
    }

    /// Specifies which Worker Deployment Version(s) Server routes this Task Queue's tasks to.
    /// When not present, it means the tasks are routed to Unversioned workers (workers with
    /// UNVERSIONED or unspecified WorkerVersioningMode.)
    /// Task Queue Versioning info is updated indirectly by calling SetWorkerDeploymentCurrentVersion
    /// and SetWorkerDeploymentRampingVersion on Worker Deployments.
    /// Note: This information is not relevant to Pinned workflow executions and their activities as
    /// they are always routed to their Pinned Deployment Version. However, new workflow executions
    /// are typically not Pinned until they complete their first task (unless they are started with
    /// a Pinned VersioningOverride or are Child Workflows of a Pinned parent).
    public var versioningInfo: Api.Taskqueue.V1.TaskQueueVersioningInfo {
      get {_storage._versioningInfo ?? Api.Taskqueue.V1.TaskQueueVersioningInfo()}
      set {_uniqueStorage()._versioningInfo = newValue}
    }
    /// Returns true if `versioningInfo` has been explicitly set.
    public var hasVersioningInfo: Bool {_storage._versioningInfo != nil}
    /// Clears the value of `versioningInfo`. Subsequent reads from it will return its default value.
    public mutating func clearVersioningInfo() {_uniqueStorage()._versioningInfo = nil}

    /// Only populated if report_task_queue_config is set to true.
    public var config: Api.Taskqueue.V1.TaskQueueConfig {
      get {_storage._config ?? Api.Taskqueue.V1.TaskQueueConfig()}
      set {_uniqueStorage()._config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {_storage._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {_uniqueStorage()._config = nil}

    public var effectiveRateLimit: Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit {
      get {_storage._effectiveRateLimit ?? Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit()}
      set {_uniqueStorage()._effectiveRateLimit = newValue}
    }
    /// Returns true if `effectiveRateLimit` has been explicitly set.
    public var hasEffectiveRateLimit: Bool {_storage._effectiveRateLimit != nil}
    /// Clears the value of `effectiveRateLimit`. Subsequent reads from it will return its default value.
    public mutating func clearEffectiveRateLimit() {_uniqueStorage()._effectiveRateLimit = nil}

    /// Deprecated.
    /// Status of the task queue. Only populated when `include_task_queue_status` is set to true in the request.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var taskQueueStatus: Api.Taskqueue.V1.TaskQueueStatus {
      get {_storage._taskQueueStatus ?? Api.Taskqueue.V1.TaskQueueStatus()}
      set {_uniqueStorage()._taskQueueStatus = newValue}
    }
    /// Returns true if `taskQueueStatus` has been explicitly set.
    public var hasTaskQueueStatus: Bool {_storage._taskQueueStatus != nil}
    /// Clears the value of `taskQueueStatus`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueueStatus() {_uniqueStorage()._taskQueueStatus = nil}

    /// Deprecated.
    /// Only returned in ENHANCED mode.
    /// This map contains Task Queue information for each Build ID. Empty string as key value means unversioned.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var versionsInfo: Dictionary<String,Api.Taskqueue.V1.TaskQueueVersionInfo> {
      get {_storage._versionsInfo}
      set {_uniqueStorage()._versionsInfo = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct EffectiveRateLimit: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// The effective rate limit for the task queue.
      public var requestsPerSecond: Float = 0

      /// Source of the RateLimit Configuration,which can be one of the following values:
      /// - SOURCE_API: The rate limit that is set via the TaskQueueConfig api.
      /// - SOURCE_WORKER: The rate limit is the value set using the workerOptions in TaskQueueActivitiesPerSecond.
      /// - SOURCE_SYSTEM: The rate limit is the default value set by the system
      public var rateLimitSource: Api.Enums.V1.RateLimitSource = .unspecified

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct GetClusterInfoRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// GetClusterInfoResponse contains information about Temporal cluster.
  public struct GetClusterInfoResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Key is client name i.e "temporal-go", "temporal-java", or "temporal-cli".
    /// Value is ranges of supported versions of this client i.e ">1.1.1 <=1.4.0 || ^5.0.0".
    public var supportedClients: Dictionary<String,String> {
      get {_storage._supportedClients}
      set {_uniqueStorage()._supportedClients = newValue}
    }

    public var serverVersion: String {
      get {_storage._serverVersion}
      set {_uniqueStorage()._serverVersion = newValue}
    }

    public var clusterID: String {
      get {_storage._clusterID}
      set {_uniqueStorage()._clusterID = newValue}
    }

    public var versionInfo: Api.Version.V1.VersionInfo {
      get {_storage._versionInfo ?? Api.Version.V1.VersionInfo()}
      set {_uniqueStorage()._versionInfo = newValue}
    }
    /// Returns true if `versionInfo` has been explicitly set.
    public var hasVersionInfo: Bool {_storage._versionInfo != nil}
    /// Clears the value of `versionInfo`. Subsequent reads from it will return its default value.
    public mutating func clearVersionInfo() {_uniqueStorage()._versionInfo = nil}

    public var clusterName: String {
      get {_storage._clusterName}
      set {_uniqueStorage()._clusterName = newValue}
    }

    public var historyShardCount: Int32 {
      get {_storage._historyShardCount}
      set {_uniqueStorage()._historyShardCount = newValue}
    }

    public var persistenceStore: String {
      get {_storage._persistenceStore}
      set {_uniqueStorage()._persistenceStore = newValue}
    }

    public var visibilityStore: String {
      get {_storage._visibilityStore}
      set {_uniqueStorage()._visibilityStore = newValue}
    }

    public var initialFailoverVersion: Int64 {
      get {_storage._initialFailoverVersion}
      set {_uniqueStorage()._initialFailoverVersion = newValue}
    }

    public var failoverVersionIncrement: Int64 {
      get {_storage._failoverVersionIncrement}
      set {_uniqueStorage()._failoverVersionIncrement = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct GetSystemInfoRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct GetSystemInfoResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Version of the server.
    public var serverVersion: String = String()

    /// All capabilities the system supports.
    public var capabilities: Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities {
      get {_capabilities ?? Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities()}
      set {_capabilities = newValue}
    }
    /// Returns true if `capabilities` has been explicitly set.
    public var hasCapabilities: Bool {self._capabilities != nil}
    /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
    public mutating func clearCapabilities() {self._capabilities = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// System capability details.
    public struct Capabilities: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// True if signal and query headers are supported.
      public var signalAndQueryHeader: Bool = false

      /// True if internal errors are differentiated from other types of errors for purposes of
      /// retrying non-internal errors.
      ///
      /// When unset/false, clients retry all failures. When true, clients should only retry
      /// non-internal errors.
      public var internalErrorDifferentiation: Bool = false

      /// True if RespondActivityTaskFailed API supports including heartbeat details
      public var activityFailureIncludeHeartbeat: Bool = false

      /// Supports scheduled workflow features.
      public var supportsSchedules: Bool = false

      /// True if server uses protos that include temporal.api.failure.v1.Failure.encoded_attributes
      public var encodedFailureAttributes: Bool = false

      /// True if server supports dispatching Workflow and Activity tasks based on a worker's build_id
      /// (see:
      /// https://github.com/temporalio/proposals/blob/a123af3b559f43db16ea6dd31870bfb754c4dc5e/versioning/worker-versions.md)
      public var buildIDBasedVersioning: Bool = false

      /// True if server supports upserting workflow memo
      public var upsertMemo: Bool = false

      /// True if server supports eager workflow task dispatching for the StartWorkflowExecution API
      public var eagerWorkflowStart: Bool = false

      /// True if the server knows about the sdk metadata field on WFT completions and will record
      /// it in history
      public var sdkMetadata: Bool = false

      /// True if the server supports count group by execution status
      /// (-- api-linter: core::0140::prepositions=disabled --)
      public var countGroupByExecutionStatus: Bool = false

      /// True if the server supports Nexus operations.
      /// This flag is dependent both on server version and for Nexus to be enabled via server configuration.
      public var nexus: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _capabilities: Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListTaskQueuePartitionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListTaskQueuePartitionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var activityTaskQueuePartitions: [Api.Taskqueue.V1.TaskQueuePartitionMetadata] = []

    public var workflowTaskQueuePartitions: [Api.Taskqueue.V1.TaskQueuePartitionMetadata] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// (-- api-linter: core::0203::optional=disabled
  ///     aip.dev/not-precedent: field_behavior annotation not available in our gogo fork --)
  public struct CreateScheduleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace the schedule should be created in.
    public var namespace: String = String()

    /// The id of the new schedule.
    public var scheduleID: String = String()

    /// The schedule spec, policies, action, and initial state.
    public var schedule: Api.Schedule.V1.Schedule {
      get {_schedule ?? Api.Schedule.V1.Schedule()}
      set {_schedule = newValue}
    }
    /// Returns true if `schedule` has been explicitly set.
    public var hasSchedule: Bool {self._schedule != nil}
    /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
    public mutating func clearSchedule() {self._schedule = nil}

    /// Optional initial patch (e.g. to run the action once immediately).
    public var initialPatch: Api.Schedule.V1.SchedulePatch {
      get {_initialPatch ?? Api.Schedule.V1.SchedulePatch()}
      set {_initialPatch = newValue}
    }
    /// Returns true if `initialPatch` has been explicitly set.
    public var hasInitialPatch: Bool {self._initialPatch != nil}
    /// Clears the value of `initialPatch`. Subsequent reads from it will return its default value.
    public mutating func clearInitialPatch() {self._initialPatch = nil}

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// A unique identifier for this create request for idempotence. Typically UUIDv4.
    public var requestID: String = String()

    /// Memo and search attributes to attach to the schedule itself.
    public var memo: Api.Common.V1.Memo {
      get {_memo ?? Api.Common.V1.Memo()}
      set {_memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {self._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {self._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {self._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {self._searchAttributes = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _schedule: Api.Schedule.V1.Schedule? = nil
    fileprivate var _initialPatch: Api.Schedule.V1.SchedulePatch? = nil
    fileprivate var _memo: Api.Common.V1.Memo? = nil
    fileprivate var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct CreateScheduleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var conflictToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeScheduleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the schedule to describe.
    public var namespace: String = String()

    /// The id of the schedule to describe.
    public var scheduleID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeScheduleResponse: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The complete current schedule details. This may not match the schedule as
    /// created because:
    /// - some types of schedule specs may get compiled into others (e.g.
    ///   CronString into StructuredCalendarSpec)
    /// - some unspecified fields may be replaced by defaults
    /// - some fields in the state are modified automatically
    /// - the schedule may have been modified by UpdateSchedule or PatchSchedule
    public var schedule: Api.Schedule.V1.Schedule {
      get {_storage._schedule ?? Api.Schedule.V1.Schedule()}
      set {_uniqueStorage()._schedule = newValue}
    }
    /// Returns true if `schedule` has been explicitly set.
    public var hasSchedule: Bool {_storage._schedule != nil}
    /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
    public mutating func clearSchedule() {_uniqueStorage()._schedule = nil}

    /// Extra schedule state info.
    public var info: Api.Schedule.V1.ScheduleInfo {
      get {_storage._info ?? Api.Schedule.V1.ScheduleInfo()}
      set {_uniqueStorage()._info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {_storage._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {_uniqueStorage()._info = nil}

    /// The memo and search attributes that the schedule was created with.
    public var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    public var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    public mutating func clearMemo() {_uniqueStorage()._memo = nil}

    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    /// This value can be passed back to UpdateSchedule to ensure that the
    /// schedule was not modified between a Describe and an Update, which could
    /// lead to lost updates and other confusion.
    public var conflictToken: Data {
      get {_storage._conflictToken}
      set {_uniqueStorage()._conflictToken = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateScheduleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the schedule to update.
    public var namespace: String = String()

    /// The id of the schedule to update.
    public var scheduleID: String = String()

    /// The new schedule. The four main fields of the schedule (spec, action,
    /// policies, state) are replaced completely by the values in this message.
    public var schedule: Api.Schedule.V1.Schedule {
      get {_schedule ?? Api.Schedule.V1.Schedule()}
      set {_schedule = newValue}
    }
    /// Returns true if `schedule` has been explicitly set.
    public var hasSchedule: Bool {self._schedule != nil}
    /// Clears the value of `schedule`. Subsequent reads from it will return its default value.
    public mutating func clearSchedule() {self._schedule = nil}

    /// This can be the value of conflict_token from a DescribeScheduleResponse,
    /// which will cause this request to fail if the schedule has been modified
    /// between the Describe and this Update.
    /// If missing, the schedule will be updated unconditionally.
    public var conflictToken: Data = Data()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// A unique identifier for this update request for idempotence. Typically UUIDv4.
    public var requestID: String = String()

    /// Schedule search attributes to be updated.
    /// Do not set this field if you do not want to update the search attributes.
    /// A non-null empty object will set the search attributes to an empty map.
    /// Note: you cannot only update the search attributes with `UpdateScheduleRequest`,
    /// you must also set the `schedule` field; otherwise, it will unset the schedule.
    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {self._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {self._searchAttributes = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _schedule: Api.Schedule.V1.Schedule? = nil
    fileprivate var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateScheduleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct PatchScheduleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the schedule to patch.
    public var namespace: String = String()

    /// The id of the schedule to patch.
    public var scheduleID: String = String()

    public var patch: Api.Schedule.V1.SchedulePatch {
      get {_patch ?? Api.Schedule.V1.SchedulePatch()}
      set {_patch = newValue}
    }
    /// Returns true if `patch` has been explicitly set.
    public var hasPatch: Bool {self._patch != nil}
    /// Clears the value of `patch`. Subsequent reads from it will return its default value.
    public mutating func clearPatch() {self._patch = nil}

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// A unique identifier for this update request for idempotence. Typically UUIDv4.
    public var requestID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _patch: Api.Schedule.V1.SchedulePatch? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PatchScheduleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListScheduleMatchingTimesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the schedule to query.
    public var namespace: String = String()

    /// The id of the schedule to query.
    public var scheduleID: String = String()

    /// Time range to query.
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    public var endTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_endTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTime = newValue}
    }
    /// Returns true if `endTime` has been explicitly set.
    public var hasEndTime: Bool {self._endTime != nil}
    /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
    public mutating func clearEndTime() {self._endTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListScheduleMatchingTimesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var startTime: [SwiftProtobuf.Google_Protobuf_Timestamp] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteScheduleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the schedule to delete.
    public var namespace: String = String()

    /// The id of the schedule to delete.
    public var scheduleID: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteScheduleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListSchedulesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to list schedules in.
    public var namespace: String = String()

    /// How many to return at once.
    public var maximumPageSize: Int32 = 0

    /// Token to get the next page of results.
    public var nextPageToken: Data = Data()

    /// Query to filter schedules.
    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListSchedulesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var schedules: [Api.Schedule.V1.ScheduleListEntry] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct UpdateWorkerBuildIdCompatibilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Must be set, the task queue to apply changes to. Because all workers on a given task queue
    /// must have the same set of workflow & activity implementations, there is no reason to specify
    /// a task queue type here.
    public var taskQueue: String = String()

    public var operation: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.OneOf_Operation? = nil

    /// A new build id. This operation will create a new set which will be the new overall
    /// default version for the queue, with this id as its only member. This new set is
    /// incompatible with all previous sets/versions.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: In makes perfect sense here. --)
    public var addNewBuildIDInNewDefaultSet: String {
      get {
        if case .addNewBuildIDInNewDefaultSet(let v)? = operation {return v}
        return String()
      }
      set {operation = .addNewBuildIDInNewDefaultSet(newValue)}
    }

    /// Adds a new id to an existing compatible set, see sub-message definition for more.
    public var addNewCompatibleBuildID: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion {
      get {
        if case .addNewCompatibleBuildID(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion()
      }
      set {operation = .addNewCompatibleBuildID(newValue)}
    }

    /// Promote an existing set to be the current default (if it isn't already) by targeting
    /// an existing build id within it. This field's value is the extant build id.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: Names are hard. --)
    public var promoteSetByBuildID: String {
      get {
        if case .promoteSetByBuildID(let v)? = operation {return v}
        return String()
      }
      set {operation = .promoteSetByBuildID(newValue)}
    }

    /// Promote an existing build id within some set to be the current default for that set.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: Within makes perfect sense here. --)
    public var promoteBuildIDWithinSet: String {
      get {
        if case .promoteBuildIDWithinSet(let v)? = operation {return v}
        return String()
      }
      set {operation = .promoteBuildIDWithinSet(newValue)}
    }

    /// Merge two existing sets together, thus declaring all build IDs in both sets compatible
    /// with one another. The primary set's default will become the default for the merged set.
    /// This is useful if you've accidentally declared a new ID as incompatible you meant to
    /// declare as compatible. The unusual case of incomplete replication during failover could
    /// also result in a split set, which this operation can repair.
    public var mergeSets: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets {
      get {
        if case .mergeSets(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets()
      }
      set {operation = .mergeSets(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Operation: Equatable, Sendable {
      /// A new build id. This operation will create a new set which will be the new overall
      /// default version for the queue, with this id as its only member. This new set is
      /// incompatible with all previous sets/versions.
      ///
      /// (-- api-linter: core::0140::prepositions=disabled
      ///     aip.dev/not-precedent: In makes perfect sense here. --)
      case addNewBuildIDInNewDefaultSet(String)
      /// Adds a new id to an existing compatible set, see sub-message definition for more.
      case addNewCompatibleBuildID(Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion)
      /// Promote an existing set to be the current default (if it isn't already) by targeting
      /// an existing build id within it. This field's value is the extant build id.
      ///
      /// (-- api-linter: core::0140::prepositions=disabled
      ///     aip.dev/not-precedent: Names are hard. --)
      case promoteSetByBuildID(String)
      /// Promote an existing build id within some set to be the current default for that set.
      ///
      /// (-- api-linter: core::0140::prepositions=disabled
      ///     aip.dev/not-precedent: Within makes perfect sense here. --)
      case promoteBuildIDWithinSet(String)
      /// Merge two existing sets together, thus declaring all build IDs in both sets compatible
      /// with one another. The primary set's default will become the default for the merged set.
      /// This is useful if you've accidentally declared a new ID as incompatible you meant to
      /// declare as compatible. The unusual case of incomplete replication during failover could
      /// also result in a split set, which this operation can repair.
      case mergeSets(Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets)

    }

    public struct AddNewCompatibleVersion: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A new id to be added to an existing compatible set.
      public var newBuildID: String = String()

      /// A build id which must already exist in the version sets known by the task queue. The new
      /// id will be stored in the set containing this id, marking it as compatible with
      /// the versions within.
      public var existingCompatibleBuildID: String = String()

      /// When set, establishes the compatible set being targeted as the overall default for the
      /// queue. If a different set was the current default, the targeted set will replace it as
      /// the new default.
      public var makeSetDefault: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct MergeSets: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// A build ID in the set whose default will become the merged set default
      public var primarySetBuildID: String = String()

      /// A build ID in the set which will be merged into the primary set
      public var secondarySetBuildID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct UpdateWorkerBuildIdCompatibilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct GetWorkerBuildIdCompatibilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Must be set, the task queue to interrogate about worker id compatibility.
    public var taskQueue: String = String()

    /// Limits how many compatible sets will be returned. Specify 1 to only return the current
    /// default major version set. 0 returns all sets.
    public var maxSets: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct GetWorkerBuildIdCompatibilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Major version sets, in order from oldest to newest. The last element of the list will always
    /// be the current default major version. IE: New workflows will target the most recent version
    /// in that version set.
    ///
    /// There may be fewer sets returned than exist, if the request chose to limit this response.
    public var majorVersionSets: [Api.Taskqueue.V1.CompatibleVersionSet] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// (-- api-linter: core::0134::request-mask-required=disabled
  ///     aip.dev/not-precedent: UpdateNamespace RPC doesn't follow Google API format. --)
  /// (-- api-linter: core::0134::request-resource-required=disabled
  ///     aip.dev/not-precedent: GetWorkerBuildIdCompatibilityRequest RPC doesn't follow Google API format. --)
  /// [cleanup-wv-pre-release]
  public struct UpdateWorkerVersioningRulesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var taskQueue: String = String()

    /// A valid conflict_token can be taken from the previous
    /// ListWorkerVersioningRulesResponse or UpdateWorkerVersioningRulesResponse.
    /// An invalid token will cause this request to fail, ensuring that if the rules
    /// for this Task Queue have been modified between the previous and current
    /// operation, the request will fail instead of causing an unpredictable mutation.
    public var conflictToken: Data = Data()

    public var operation: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.OneOf_Operation? = nil

    public var insertAssignmentRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule {
      get {
        if case .insertAssignmentRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule()
      }
      set {operation = .insertAssignmentRule(newValue)}
    }

    public var replaceAssignmentRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule {
      get {
        if case .replaceAssignmentRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule()
      }
      set {operation = .replaceAssignmentRule(newValue)}
    }

    public var deleteAssignmentRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule {
      get {
        if case .deleteAssignmentRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule()
      }
      set {operation = .deleteAssignmentRule(newValue)}
    }

    public var addCompatibleRedirectRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule {
      get {
        if case .addCompatibleRedirectRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule()
      }
      set {operation = .addCompatibleRedirectRule(newValue)}
    }

    public var replaceCompatibleRedirectRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule {
      get {
        if case .replaceCompatibleRedirectRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule()
      }
      set {operation = .replaceCompatibleRedirectRule(newValue)}
    }

    public var deleteCompatibleRedirectRule: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule {
      get {
        if case .deleteCompatibleRedirectRule(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule()
      }
      set {operation = .deleteCompatibleRedirectRule(newValue)}
    }

    public var commitBuildID: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId {
      get {
        if case .commitBuildID(let v)? = operation {return v}
        return Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId()
      }
      set {operation = .commitBuildID(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Operation: Equatable, Sendable {
      case insertAssignmentRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule)
      case replaceAssignmentRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule)
      case deleteAssignmentRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule)
      case addCompatibleRedirectRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule)
      case replaceCompatibleRedirectRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule)
      case deleteCompatibleRedirectRule(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule)
      case commitBuildID(Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId)

    }

    /// Inserts the rule to the list of assignment rules for this Task Queue.
    /// The rules are evaluated in order, starting from index 0. The first
    /// applicable rule will be applied and the rest will be ignored.
    public struct InsertBuildIdAssignmentRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Use this option to insert the rule in a particular index. By
      /// default, the new rule is inserted at the beginning of the list
      /// (index 0). If the given index is too larger the rule will be
      /// inserted at the end of the list.
      public var ruleIndex: Int32 = 0

      public var rule: Api.Taskqueue.V1.BuildIdAssignmentRule {
        get {_rule ?? Api.Taskqueue.V1.BuildIdAssignmentRule()}
        set {_rule = newValue}
      }
      /// Returns true if `rule` has been explicitly set.
      public var hasRule: Bool {self._rule != nil}
      /// Clears the value of `rule`. Subsequent reads from it will return its default value.
      public mutating func clearRule() {self._rule = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rule: Api.Taskqueue.V1.BuildIdAssignmentRule? = nil
    }

    /// Replaces the assignment rule at a given index.
    public struct ReplaceBuildIdAssignmentRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ruleIndex: Int32 = 0

      public var rule: Api.Taskqueue.V1.BuildIdAssignmentRule {
        get {_rule ?? Api.Taskqueue.V1.BuildIdAssignmentRule()}
        set {_rule = newValue}
      }
      /// Returns true if `rule` has been explicitly set.
      public var hasRule: Bool {self._rule != nil}
      /// Clears the value of `rule`. Subsequent reads from it will return its default value.
      public mutating func clearRule() {self._rule = nil}

      /// By default presence of one unconditional rule is enforced, otherwise
      /// the replace operation will be rejected. Set `force` to true to
      /// bypass this validation. An unconditional assignment rule:
      ///   - Has no hint filter
      ///   - Has no ramp
      public var force: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rule: Api.Taskqueue.V1.BuildIdAssignmentRule? = nil
    }

    public struct DeleteBuildIdAssignmentRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var ruleIndex: Int32 = 0

      /// By default presence of one unconditional rule is enforced, otherwise
      /// the delete operation will be rejected. Set `force` to true to
      /// bypass this validation. An unconditional assignment rule:
      ///   - Has no hint filter
      ///   - Has no ramp
      public var force: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// Adds the rule to the list of redirect rules for this Task Queue. There
    /// can be at most one redirect rule for each distinct Source Build ID.
    public struct AddCompatibleBuildIdRedirectRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule {
        get {_rule ?? Api.Taskqueue.V1.CompatibleBuildIdRedirectRule()}
        set {_rule = newValue}
      }
      /// Returns true if `rule` has been explicitly set.
      public var hasRule: Bool {self._rule != nil}
      /// Clears the value of `rule`. Subsequent reads from it will return its default value.
      public mutating func clearRule() {self._rule = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule? = nil
    }

    /// Replaces the routing rule with the given source Build ID.
    public struct ReplaceCompatibleBuildIdRedirectRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule {
        get {_rule ?? Api.Taskqueue.V1.CompatibleBuildIdRedirectRule()}
        set {_rule = newValue}
      }
      /// Returns true if `rule` has been explicitly set.
      public var hasRule: Bool {self._rule != nil}
      /// Clears the value of `rule`. Subsequent reads from it will return its default value.
      public mutating func clearRule() {self._rule = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rule: Api.Taskqueue.V1.CompatibleBuildIdRedirectRule? = nil
    }

    public struct DeleteCompatibleBuildIdRedirectRule: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var sourceBuildID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    /// This command is intended to be used to complete the rollout of a Build
    /// ID and cleanup unnecessary rules possibly created during a gradual
    /// rollout. Specifically, this command will make the following changes
    /// atomically:
    ///  1. Adds an assignment rule (with full ramp) for the target Build ID at
    ///     the end of the list.
    ///  2. Removes all previously added assignment rules to the given target
    ///     Build ID (if any).
    ///  3. Removes any fully-ramped assignment rule for other Build IDs.
    public struct CommitBuildId: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var targetBuildID: String = String()

      /// To prevent committing invalid Build IDs, we reject the request if no
      /// pollers has been seen recently for this Build ID. Use the `force`
      /// option to disable this validation.
      public var force: Bool = false

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct UpdateWorkerVersioningRulesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var assignmentRules: [Api.Taskqueue.V1.TimestampedBuildIdAssignmentRule] = []

    public var compatibleRedirectRules: [Api.Taskqueue.V1.TimestampedCompatibleBuildIdRedirectRule] = []

    /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
    /// ensure that the rules were not modified between the two updates, which
    /// could lead to lost updates and other confusion.
    public var conflictToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct GetWorkerVersioningRulesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var taskQueue: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  public struct GetWorkerVersioningRulesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var assignmentRules: [Api.Taskqueue.V1.TimestampedBuildIdAssignmentRule] = []

    public var compatibleRedirectRules: [Api.Taskqueue.V1.TimestampedCompatibleBuildIdRedirectRule] = []

    /// This value can be passed back to UpdateWorkerVersioningRulesRequest to
    /// ensure that the rules were not modified between this List and the Update,
    /// which could lead to lost updates and other confusion.
    public var conflictToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  /// Deprecated. Use `DescribeTaskQueue`.
  public struct GetWorkerTaskReachabilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Build ids to retrieve reachability for. An empty string will be interpreted as an unversioned worker.
    /// The number of build ids that can be queried in a single API call is limited.
    /// Open source users can adjust this limit by setting the server's dynamic config value for
    /// `limit.reachabilityQueryBuildIds` with the caveat that this call can strain the visibility store.
    public var buildIds: [String] = []

    /// Task queues to retrieve reachability for. Leave this empty to query for all task queues associated with given
    /// build ids in the namespace.
    /// Must specify at least one task queue if querying for an unversioned worker.
    /// The number of task queues that the server will fetch reachability information for is limited.
    /// See the `GetWorkerTaskReachabilityResponse` documentation for more information.
    public var taskQueues: [String] = []

    /// Type of reachability to query for.
    /// `TASK_REACHABILITY_NEW_WORKFLOWS` is always returned in the response.
    /// Use `TASK_REACHABILITY_EXISTING_WORKFLOWS` if your application needs to respond to queries on closed workflows.
    /// Otherwise, use `TASK_REACHABILITY_OPEN_WORKFLOWS`. Default is `TASK_REACHABILITY_EXISTING_WORKFLOWS` if left
    /// unspecified.
    /// See the TaskReachability docstring for information about each enum variant.
    public var reachability: Api.Enums.V1.TaskReachability = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release]
  /// Deprecated. Use `DescribeTaskQueue`.
  public struct GetWorkerTaskReachabilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Task reachability, broken down by build id and then task queue.
    /// When requesting a large number of task queues or all task queues associated with the given build ids in a
    /// namespace, all task queues will be listed in the response but some of them may not contain reachability
    /// information due to a server enforced limit. When reaching the limit, task queues that reachability information
    /// could not be retrieved for will be marked with a single TASK_REACHABILITY_UNSPECIFIED entry. The caller may issue
    /// another call to get the reachability for those task queues.
    ///
    /// Open source users can adjust this limit by setting the server's dynamic config value for
    /// `limit.reachabilityTaskQueueScan` with the caveat that this call can strain the visibility store.
    public var buildIDReachability: [Api.Taskqueue.V1.BuildIdReachability] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// (-- api-linter: core::0134=disabled
  ///     aip.dev/not-precedent: Update RPCs don't follow Google API format. --)
  public struct UpdateWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace name of the target Workflow.
    public var namespace: String = String()

    /// The target Workflow Id and (optionally) a specific Run Id thereof.
    /// (-- api-linter: core::0203::optional=disabled
    ///     aip.dev/not-precedent: false positive triggered by the word "optional" --)
    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    /// If set, this call will error if the most recent (if no Run Id is set on
    /// `workflow_execution`), or specified (if it is) Workflow Execution is not
    /// part of the same execution chain as this Id.
    public var firstExecutionRunID: String = String()

    /// Specifies client's intent to wait for Update results.
    /// NOTE: This field works together with API call timeout which is limited by
    /// server timeout (maximum wait time). If server timeout is expired before
    /// user specified timeout, API call returns even if specified stage is not reached.
    /// Actual reached stage will be included in the response.
    public var waitPolicy: Api.Update.V1.WaitPolicy {
      get {_waitPolicy ?? Api.Update.V1.WaitPolicy()}
      set {_waitPolicy = newValue}
    }
    /// Returns true if `waitPolicy` has been explicitly set.
    public var hasWaitPolicy: Bool {self._waitPolicy != nil}
    /// Clears the value of `waitPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearWaitPolicy() {self._waitPolicy = nil}

    /// The request information that will be delivered all the way down to the
    /// Workflow Execution.
    public var request: Api.Update.V1.Request {
      get {_request ?? Api.Update.V1.Request()}
      set {_request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {self._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {self._request = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _waitPolicy: Api.Update.V1.WaitPolicy? = nil
    fileprivate var _request: Api.Update.V1.Request? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Enough information for subsequent poll calls if needed. Never null.
    public var updateRef: Api.Update.V1.UpdateRef {
      get {_updateRef ?? Api.Update.V1.UpdateRef()}
      set {_updateRef = newValue}
    }
    /// Returns true if `updateRef` has been explicitly set.
    public var hasUpdateRef: Bool {self._updateRef != nil}
    /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateRef() {self._updateRef = nil}

    /// The outcome of the Update if and only if the Workflow Update
    /// has completed. If this response is being returned before the Update has
    /// completed then this field will not be set.
    public var outcome: Api.Update.V1.Outcome {
      get {_outcome ?? Api.Update.V1.Outcome()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    public var hasOutcome: Bool {self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    public mutating func clearOutcome() {self._outcome = nil}

    /// The most advanced lifecycle stage that the Update is known to have
    /// reached, where lifecycle stages are ordered
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    /// UNSPECIFIED will be returned if and only if the server's maximum wait
    /// time was reached before the Update reached the stage specified in the
    /// request WaitPolicy, and before the context deadline expired; clients may
    /// may then retry the call as needed.
    public var stage: Api.Enums.V1.UpdateWorkflowExecutionLifecycleStage = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _updateRef: Api.Update.V1.UpdateRef? = nil
    fileprivate var _outcome: Api.Update.V1.Outcome? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct StartBatchOperationRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace that contains the batch operation
    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    /// Visibility query defines the the group of workflow to apply the batch operation
    /// This field and `executions` are mutually exclusive
    public var visibilityQuery: String {
      get {_storage._visibilityQuery}
      set {_uniqueStorage()._visibilityQuery = newValue}
    }

    /// Job ID defines the unique ID for the batch job
    public var jobID: String {
      get {_storage._jobID}
      set {_uniqueStorage()._jobID = newValue}
    }

    /// Reason to perform the batch operation
    public var reason: String {
      get {_storage._reason}
      set {_uniqueStorage()._reason = newValue}
    }

    /// Executions to apply the batch operation
    /// This field and `visibility_query` are mutually exclusive
    public var executions: [Api.Common.V1.WorkflowExecution] {
      get {_storage._executions}
      set {_uniqueStorage()._executions = newValue}
    }

    /// Limit for the number of operations processed per second within this batch.
    /// Its purpose is to reduce the stress on the system caused by batch operations, which helps to prevent system
    /// overload and minimize potential delays in executing ongoing tasks for user workers.
    /// Note that when no explicit limit is provided, the server will operate according to its limit defined by the
    /// dynamic configuration key `worker.batcherRPS`. This also applies if the value in this field exceeds the
    /// server's configured limit.
    public var maxOperationsPerSecond: Float {
      get {_storage._maxOperationsPerSecond}
      set {_uniqueStorage()._maxOperationsPerSecond = newValue}
    }

    /// Operation input
    public var operation: OneOf_Operation? {
      get {return _storage._operation}
      set {_uniqueStorage()._operation = newValue}
    }

    public var terminationOperation: Api.Batch.V1.BatchOperationTermination {
      get {
        if case .terminationOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationTermination()
      }
      set {_uniqueStorage()._operation = .terminationOperation(newValue)}
    }

    public var signalOperation: Api.Batch.V1.BatchOperationSignal {
      get {
        if case .signalOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationSignal()
      }
      set {_uniqueStorage()._operation = .signalOperation(newValue)}
    }

    public var cancellationOperation: Api.Batch.V1.BatchOperationCancellation {
      get {
        if case .cancellationOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationCancellation()
      }
      set {_uniqueStorage()._operation = .cancellationOperation(newValue)}
    }

    public var deletionOperation: Api.Batch.V1.BatchOperationDeletion {
      get {
        if case .deletionOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationDeletion()
      }
      set {_uniqueStorage()._operation = .deletionOperation(newValue)}
    }

    public var resetOperation: Api.Batch.V1.BatchOperationReset {
      get {
        if case .resetOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationReset()
      }
      set {_uniqueStorage()._operation = .resetOperation(newValue)}
    }

    public var updateWorkflowOptionsOperation: Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions {
      get {
        if case .updateWorkflowOptionsOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions()
      }
      set {_uniqueStorage()._operation = .updateWorkflowOptionsOperation(newValue)}
    }

    public var unpauseActivitiesOperation: Api.Batch.V1.BatchOperationUnpauseActivities {
      get {
        if case .unpauseActivitiesOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationUnpauseActivities()
      }
      set {_uniqueStorage()._operation = .unpauseActivitiesOperation(newValue)}
    }

    public var resetActivitiesOperation: Api.Batch.V1.BatchOperationResetActivities {
      get {
        if case .resetActivitiesOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationResetActivities()
      }
      set {_uniqueStorage()._operation = .resetActivitiesOperation(newValue)}
    }

    public var updateActivityOptionsOperation: Api.Batch.V1.BatchOperationUpdateActivityOptions {
      get {
        if case .updateActivityOptionsOperation(let v)? = _storage._operation {return v}
        return Api.Batch.V1.BatchOperationUpdateActivityOptions()
      }
      set {_uniqueStorage()._operation = .updateActivityOptionsOperation(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Operation input
    public enum OneOf_Operation: Equatable, Sendable {
      case terminationOperation(Api.Batch.V1.BatchOperationTermination)
      case signalOperation(Api.Batch.V1.BatchOperationSignal)
      case cancellationOperation(Api.Batch.V1.BatchOperationCancellation)
      case deletionOperation(Api.Batch.V1.BatchOperationDeletion)
      case resetOperation(Api.Batch.V1.BatchOperationReset)
      case updateWorkflowOptionsOperation(Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions)
      case unpauseActivitiesOperation(Api.Batch.V1.BatchOperationUnpauseActivities)
      case resetActivitiesOperation(Api.Batch.V1.BatchOperationResetActivities)
      case updateActivityOptionsOperation(Api.Batch.V1.BatchOperationUpdateActivityOptions)

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct StartBatchOperationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct StopBatchOperationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace that contains the batch operation
    public var namespace: String = String()

    /// Batch job id
    public var jobID: String = String()

    /// Reason to stop a batch operation
    public var reason: String = String()

    /// Identity of the operator
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct StopBatchOperationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeBatchOperationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace that contains the batch operation
    public var namespace: String = String()

    /// Batch job id
    public var jobID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeBatchOperationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Batch operation type
    public var operationType: Api.Enums.V1.BatchOperationType = .unspecified

    /// Batch job ID
    public var jobID: String = String()

    /// Batch operation state
    public var state: Api.Enums.V1.BatchOperationState = .unspecified

    /// Batch operation start time
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// Batch operation close time
    public var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_closeTime = newValue}
    }
    /// Returns true if `closeTime` has been explicitly set.
    public var hasCloseTime: Bool {self._closeTime != nil}
    /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCloseTime() {self._closeTime = nil}

    /// Total operation count
    public var totalOperationCount: Int64 = 0

    /// Complete operation count
    public var completeOperationCount: Int64 = 0

    /// Failure operation count
    public var failureOperationCount: Int64 = 0

    /// Identity indicates the operator identity
    public var identity: String = String()

    /// Reason indicates the reason to stop a operation
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListBatchOperationsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace that contains the batch operation
    public var namespace: String = String()

    /// List page size
    public var pageSize: Int32 = 0

    /// Next page token
    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListBatchOperationsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// BatchOperationInfo contains the basic info about batch operation
    public var operationInfo: [Api.Batch.V1.BatchOperationInfo] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct PollWorkflowExecutionUpdateRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace of the Workflow Execution to which the Update was
    /// originally issued.
    public var namespace: String = String()

    /// The Update reference returned in the initial UpdateWorkflowExecutionResponse.
    public var updateRef: Api.Update.V1.UpdateRef {
      get {_updateRef ?? Api.Update.V1.UpdateRef()}
      set {_updateRef = newValue}
    }
    /// Returns true if `updateRef` has been explicitly set.
    public var hasUpdateRef: Bool {self._updateRef != nil}
    /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateRef() {self._updateRef = nil}

    /// The identity of the worker/client who is polling this Update outcome.
    public var identity: String = String()

    /// Specifies client's intent to wait for Update results.
    /// Omit to request a non-blocking poll.
    public var waitPolicy: Api.Update.V1.WaitPolicy {
      get {_waitPolicy ?? Api.Update.V1.WaitPolicy()}
      set {_waitPolicy = newValue}
    }
    /// Returns true if `waitPolicy` has been explicitly set.
    public var hasWaitPolicy: Bool {self._waitPolicy != nil}
    /// Clears the value of `waitPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearWaitPolicy() {self._waitPolicy = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _updateRef: Api.Update.V1.UpdateRef? = nil
    fileprivate var _waitPolicy: Api.Update.V1.WaitPolicy? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollWorkflowExecutionUpdateResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The outcome of the update if and only if the update has completed. If
    /// this response is being returned before the update has completed (e.g. due
    /// to the specification of a wait policy that only waits on
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED) then this field will
    /// not be set.
    public var outcome: Api.Update.V1.Outcome {
      get {_outcome ?? Api.Update.V1.Outcome()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    public var hasOutcome: Bool {self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    public mutating func clearOutcome() {self._outcome = nil}

    /// The most advanced lifecycle stage that the Update is known to have
    /// reached, where lifecycle stages are ordered
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ADMITTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_ACCEPTED <
    /// UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED.
    /// UNSPECIFIED will be returned if and only if the server's maximum wait
    /// time was reached before the Update reached the stage specified in the
    /// request WaitPolicy, and before the context deadline expired; clients may
    /// may then retry the call as needed.
    public var stage: Api.Enums.V1.UpdateWorkflowExecutionLifecycleStage = .unspecified

    /// Sufficient information to address this Update.
    public var updateRef: Api.Update.V1.UpdateRef {
      get {_updateRef ?? Api.Update.V1.UpdateRef()}
      set {_updateRef = newValue}
    }
    /// Returns true if `updateRef` has been explicitly set.
    public var hasUpdateRef: Bool {self._updateRef != nil}
    /// Clears the value of `updateRef`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateRef() {self._updateRef = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _outcome: Api.Update.V1.Outcome? = nil
    fileprivate var _updateRef: Api.Update.V1.UpdateRef? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollNexusTaskQueueRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {self._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {self._taskQueue = nil}

    /// Information about this worker's build identifier and if it is choosing to use the versioning
    /// feature. See the `WorkerVersionCapabilities` docstring for more.
    /// Deprecated. Replaced by deployment_options.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities {
      get {_workerVersionCapabilities ?? Api.Common.V1.WorkerVersionCapabilities()}
      set {_workerVersionCapabilities = newValue}
    }
    /// Returns true if `workerVersionCapabilities` has been explicitly set.
    public var hasWorkerVersionCapabilities: Bool {self._workerVersionCapabilities != nil}
    /// Clears the value of `workerVersionCapabilities`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerVersionCapabilities() {self._workerVersionCapabilities = nil}

    /// Worker deployment options that user has set in the worker.
    public var deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions {
      get {_deploymentOptions ?? Api.Deployment.V1.WorkerDeploymentOptions()}
      set {_deploymentOptions = newValue}
    }
    /// Returns true if `deploymentOptions` has been explicitly set.
    public var hasDeploymentOptions: Bool {self._deploymentOptions != nil}
    /// Clears the value of `deploymentOptions`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentOptions() {self._deploymentOptions = nil}

    /// Worker info to be sent to the server.
    public var workerHeartbeat: [Api.Worker.V1.WorkerHeartbeat] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    fileprivate var _workerVersionCapabilities: Api.Common.V1.WorkerVersionCapabilities? = nil
    fileprivate var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollNexusTaskQueueResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// An opaque unique identifier for this task for correlating a completion request the embedded request.
    public var taskToken: Data = Data()

    /// Embedded request as translated from the incoming frontend request.
    public var request: Api.Nexus.V1.Request {
      get {_request ?? Api.Nexus.V1.Request()}
      set {_request = newValue}
    }
    /// Returns true if `request` has been explicitly set.
    public var hasRequest: Bool {self._request != nil}
    /// Clears the value of `request`. Subsequent reads from it will return its default value.
    public mutating func clearRequest() {self._request = nil}

    /// Server-advised information the SDK may use to adjust its poller count.
    public var pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision {
      get {_pollerScalingDecision ?? Api.Taskqueue.V1.PollerScalingDecision()}
      set {_pollerScalingDecision = newValue}
    }
    /// Returns true if `pollerScalingDecision` has been explicitly set.
    public var hasPollerScalingDecision: Bool {self._pollerScalingDecision != nil}
    /// Clears the value of `pollerScalingDecision`. Subsequent reads from it will return its default value.
    public mutating func clearPollerScalingDecision() {self._pollerScalingDecision = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _request: Api.Nexus.V1.Request? = nil
    fileprivate var _pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondNexusTaskCompletedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// A unique identifier for this task as received via a poll response.
    public var taskToken: Data = Data()

    /// Embedded response to be translated into a frontend response.
    public var response: Api.Nexus.V1.Response {
      get {_response ?? Api.Nexus.V1.Response()}
      set {_response = newValue}
    }
    /// Returns true if `response` has been explicitly set.
    public var hasResponse: Bool {self._response != nil}
    /// Clears the value of `response`. Subsequent reads from it will return its default value.
    public mutating func clearResponse() {self._response = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _response: Api.Nexus.V1.Response? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondNexusTaskCompletedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondNexusTaskFailedRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// A unique identifier for this task.
    public var taskToken: Data = Data()

    /// The error the handler failed with.
    public var error: Api.Nexus.V1.HandlerError {
      get {_error ?? Api.Nexus.V1.HandlerError()}
      set {_error = newValue}
    }
    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool {self._error != nil}
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() {self._error = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _error: Api.Nexus.V1.HandlerError? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct RespondNexusTaskFailedResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ExecuteMultiOperationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// List of operations to execute within a single workflow.
    ///
    /// Preconditions:
    /// - The list of operations must not be empty.
    /// - The workflow ids must match across operations.
    /// - The only valid list of operations at this time is [StartWorkflow, UpdateWorkflow], in this order.
    ///
    /// Note that additional operation-specific restrictions have to be considered.
    public var operations: [Api.Workflowservice.V1.ExecuteMultiOperationRequest.Operation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Operation: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var operation: Api.Workflowservice.V1.ExecuteMultiOperationRequest.Operation.OneOf_Operation? = nil

      /// Additional restrictions:
      /// - setting `cron_schedule` is invalid
      /// - setting `request_eager_execution` is invalid
      /// - setting `workflow_start_delay` is invalid
      public var startWorkflow: Api.Workflowservice.V1.StartWorkflowExecutionRequest {
        get {
          if case .startWorkflow(let v)? = operation {return v}
          return Api.Workflowservice.V1.StartWorkflowExecutionRequest()
        }
        set {operation = .startWorkflow(newValue)}
      }

      /// Additional restrictions:
      /// - setting `first_execution_run_id` is invalid
      /// - setting `workflow_execution.run_id` is invalid
      public var updateWorkflow: Api.Workflowservice.V1.UpdateWorkflowExecutionRequest {
        get {
          if case .updateWorkflow(let v)? = operation {return v}
          return Api.Workflowservice.V1.UpdateWorkflowExecutionRequest()
        }
        set {operation = .updateWorkflow(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Operation: Equatable, Sendable {
        /// Additional restrictions:
        /// - setting `cron_schedule` is invalid
        /// - setting `request_eager_execution` is invalid
        /// - setting `workflow_start_delay` is invalid
        case startWorkflow(Api.Workflowservice.V1.StartWorkflowExecutionRequest)
        /// Additional restrictions:
        /// - setting `first_execution_run_id` is invalid
        /// - setting `workflow_execution.run_id` is invalid
        case updateWorkflow(Api.Workflowservice.V1.UpdateWorkflowExecutionRequest)

      }

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// IMPORTANT: For [StartWorkflow, UpdateWorkflow] combination ("Update-with-Start") when both
  ///   1. the workflow update for the requested update ID has already completed, and
  ///   2. the workflow for the requested workflow ID has already been closed,
  /// then you'll receive
  ///   - an update response containing the update's outcome, and
  ///   - a start response with a `status` field that reflects the workflow's current state.
  public struct ExecuteMultiOperationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var responses: [Api.Workflowservice.V1.ExecuteMultiOperationResponse.Response] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Response: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var response: Api.Workflowservice.V1.ExecuteMultiOperationResponse.Response.OneOf_Response? = nil

      public var startWorkflow: Api.Workflowservice.V1.StartWorkflowExecutionResponse {
        get {
          if case .startWorkflow(let v)? = response {return v}
          return Api.Workflowservice.V1.StartWorkflowExecutionResponse()
        }
        set {response = .startWorkflow(newValue)}
      }

      public var updateWorkflow: Api.Workflowservice.V1.UpdateWorkflowExecutionResponse {
        get {
          if case .updateWorkflow(let v)? = response {return v}
          return Api.Workflowservice.V1.UpdateWorkflowExecutionResponse()
        }
        set {response = .updateWorkflow(newValue)}
      }

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public enum OneOf_Response: Equatable, Sendable {
        case startWorkflow(Api.Workflowservice.V1.StartWorkflowExecutionResponse)
        case updateWorkflow(Api.Workflowservice.V1.UpdateWorkflowExecutionResponse)

      }

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationUpdateActivityOptions
  public struct UpdateActivityOptionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity
    public var namespace: String = String()

    /// Execution info of the workflow which scheduled this activity
    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// The identity of the client who initiated this request
    public var identity: String = String()

    /// Activity options. Partial updates are accepted and controlled by update_mask
    public var activityOptions: Api.Activity.V1.ActivityOptions {
      get {_activityOptions ?? Api.Activity.V1.ActivityOptions()}
      set {_activityOptions = newValue}
    }
    /// Returns true if `activityOptions` has been explicitly set.
    public var hasActivityOptions: Bool {self._activityOptions != nil}
    /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
    public mutating func clearActivityOptions() {self._activityOptions = nil}

    /// Controls which fields from `activity_options` will be applied
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool {self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() {self._updateMask = nil}

    /// either activity id, activity type or update_all must be provided
    public var activity: Api.Workflowservice.V1.UpdateActivityOptionsRequest.OneOf_Activity? = nil

    /// Only activity with this ID will be updated.
    public var id: String {
      get {
        if case .id(let v)? = activity {return v}
        return String()
      }
      set {activity = .id(newValue)}
    }

    /// Update all running activities of this type.
    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    /// Update all running activities.
    public var matchAll: Bool {
      get {
        if case .matchAll(let v)? = activity {return v}
        return false
      }
      set {activity = .matchAll(newValue)}
    }

    /// If set, the activity options will be restored to the default.
    /// Default options are then options activity was created with.
    /// They are part of the first SCHEDULE event.
    /// This flag cannot be combined with any other option; if you supply
    /// restore_original together with other options, the request will be rejected.
    public var restoreOriginal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// either activity id, activity type or update_all must be provided
    public enum OneOf_Activity: Equatable, Sendable {
      /// Only activity with this ID will be updated.
      case id(String)
      /// Update all running activities of this type.
      case type(String)
      /// Update all running activities.
      case matchAll(Bool)

    }

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _activityOptions: Api.Activity.V1.ActivityOptions? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateActivityOptionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Activity options after an update
    public var activityOptions: Api.Activity.V1.ActivityOptions {
      get {_activityOptions ?? Api.Activity.V1.ActivityOptions()}
      set {_activityOptions = newValue}
    }
    /// Returns true if `activityOptions` has been explicitly set.
    public var hasActivityOptions: Bool {self._activityOptions != nil}
    /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
    public mutating func clearActivityOptions() {self._activityOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _activityOptions: Api.Activity.V1.ActivityOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PauseActivityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity.
    public var namespace: String = String()

    /// Execution info of the workflow which scheduled this activity
    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// either activity id or activity type must be provided
    public var activity: Api.Workflowservice.V1.PauseActivityRequest.OneOf_Activity? = nil

    /// Only the activity with this ID will be paused.
    public var id: String {
      get {
        if case .id(let v)? = activity {return v}
        return String()
      }
      set {activity = .id(newValue)}
    }

    /// Pause all running activities of this type.
    /// Note: Experimental - the behavior of pause by activity type might change in a future release.
    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    /// Reason to pause the activity.
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// either activity id or activity type must be provided
    public enum OneOf_Activity: Equatable, Sendable {
      /// Only the activity with this ID will be paused.
      case id(String)
      /// Pause all running activities of this type.
      /// Note: Experimental - the behavior of pause by activity type might change in a future release.
      case type(String)

    }

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PauseActivityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct UnpauseActivityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity.
    public var namespace: String = String()

    /// Execution info of the workflow which scheduled this activity
    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// either activity id or activity type must be provided
    public var activity: Api.Workflowservice.V1.UnpauseActivityRequest.OneOf_Activity? = nil

    /// Only the activity with this ID will be unpaused.
    public var id: String {
      get {
        if case .id(let v)? = activity {return v}
        return String()
      }
      set {activity = .id(newValue)}
    }

    /// Unpause all running activities with of this type.
    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    /// Unpause all running activities.
    public var unpauseAll: Bool {
      get {
        if case .unpauseAll(let v)? = activity {return v}
        return false
      }
      set {activity = .unpauseAll(newValue)}
    }

    /// Providing this flag will also reset the number of attempts.
    public var resetAttempts: Bool = false

    /// Providing this flag will also reset the heartbeat details.
    public var resetHeartbeat: Bool = false

    /// If set, the activity will start at a random time within the specified jitter duration.
    public var jitter: SwiftProtobuf.Google_Protobuf_Duration {
      get {_jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_jitter = newValue}
    }
    /// Returns true if `jitter` has been explicitly set.
    public var hasJitter: Bool {self._jitter != nil}
    /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
    public mutating func clearJitter() {self._jitter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// either activity id or activity type must be provided
    public enum OneOf_Activity: Equatable, Sendable {
      /// Only the activity with this ID will be unpaused.
      case id(String)
      /// Unpause all running activities with of this type.
      case type(String)
      /// Unpause all running activities.
      case unpauseAll(Bool)

    }

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UnpauseActivityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// NOTE: keep in sync with temporal.api.batch.v1.BatchOperationResetActivities
  public struct ResetActivityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow which scheduled this activity.
    public var namespace: String = String()

    /// Execution info of the workflow which scheduled this activity
    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// either activity id, activity type or update_all must be provided
    public var activity: Api.Workflowservice.V1.ResetActivityRequest.OneOf_Activity? = nil

    /// Only activity with this ID will be reset.
    public var id: String {
      get {
        if case .id(let v)? = activity {return v}
        return String()
      }
      set {activity = .id(newValue)}
    }

    /// Reset all running activities with of this type.
    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    /// Reset all running activities.
    public var matchAll: Bool {
      get {
        if case .matchAll(let v)? = activity {return v}
        return false
      }
      set {activity = .matchAll(newValue)}
    }

    /// Indicates that activity should reset heartbeat details.
    /// This flag will be applied only to the new instance of the activity.
    public var resetHeartbeat: Bool = false

    /// If activity is paused, it will remain paused after reset
    public var keepPaused: Bool = false

    /// If set, and activity is in backoff, the activity will start at a random time within the specified jitter duration.
    /// (unless it is paused and keep_paused is set)
    public var jitter: SwiftProtobuf.Google_Protobuf_Duration {
      get {_jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_jitter = newValue}
    }
    /// Returns true if `jitter` has been explicitly set.
    public var hasJitter: Bool {self._jitter != nil}
    /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
    public mutating func clearJitter() {self._jitter = nil}

    /// If set, the activity options will be restored to the defaults.
    /// Default options are then options activity was created with.
    /// They are part of the first SCHEDULE event.
    public var restoreOriginalOptions: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// either activity id, activity type or update_all must be provided
    public enum OneOf_Activity: Equatable, Sendable {
      /// Only activity with this ID will be reset.
      case id(String)
      /// Reset all running activities with of this type.
      case type(String)
      /// Reset all running activities.
      case matchAll(Bool)

    }

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ResetActivityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Keep the parameters in sync with:
  ///   - temporal.api.batch.v1.BatchOperationUpdateWorkflowExecutionOptions.
  ///   - temporal.api.workflow.v1.PostResetOperation.UpdateWorkflowOptions.
  public struct UpdateWorkflowExecutionOptionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace name of the target Workflow.
    public var namespace: String = String()

    /// The target Workflow Id and (optionally) a specific Run Id thereof.
    /// (-- api-linter: core::0203::optional=disabled
    ///     aip.dev/not-precedent: false positive triggered by the word "optional" --)
    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    /// Workflow Execution options. Partial updates are accepted and controlled by update_mask.
    public var workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions {
      get {_workflowExecutionOptions ?? Api.Workflow.V1.WorkflowExecutionOptions()}
      set {_workflowExecutionOptions = newValue}
    }
    /// Returns true if `workflowExecutionOptions` has been explicitly set.
    public var hasWorkflowExecutionOptions: Bool {self._workflowExecutionOptions != nil}
    /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

    /// Controls which fields from `workflow_execution_options` will be applied.
    /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool {self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() {self._updateMask = nil}

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateWorkflowExecutionOptionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Workflow Execution options after update.
    public var workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions {
      get {_workflowExecutionOptions ?? Api.Workflow.V1.WorkflowExecutionOptions()}
      set {_workflowExecutionOptions = newValue}
    }
    /// Returns true if `workflowExecutionOptions` has been explicitly set.
    public var hasWorkflowExecutionOptions: Bool {self._workflowExecutionOptions != nil}
    /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct DescribeDeploymentRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct DescribeDeploymentResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deploymentInfo: Api.Deployment.V1.DeploymentInfo {
      get {_deploymentInfo ?? Api.Deployment.V1.DeploymentInfo()}
      set {_deploymentInfo = newValue}
    }
    /// Returns true if `deploymentInfo` has been explicitly set.
    public var hasDeploymentInfo: Bool {self._deploymentInfo != nil}
    /// Clears the value of `deploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentInfo() {self._deploymentInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentInfo: Api.Deployment.V1.DeploymentInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerDeploymentVersionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// Required.
    public var deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_deploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    public var hasDeploymentVersion: Bool {self._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

    /// Report stats for task queues which have been polled by this version.
    public var reportTaskQueueStats: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerDeploymentVersionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var workerDeploymentVersionInfo: Api.Deployment.V1.WorkerDeploymentVersionInfo {
      get {_workerDeploymentVersionInfo ?? Api.Deployment.V1.WorkerDeploymentVersionInfo()}
      set {_workerDeploymentVersionInfo = newValue}
    }
    /// Returns true if `workerDeploymentVersionInfo` has been explicitly set.
    public var hasWorkerDeploymentVersionInfo: Bool {self._workerDeploymentVersionInfo != nil}
    /// Clears the value of `workerDeploymentVersionInfo`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerDeploymentVersionInfo() {self._workerDeploymentVersionInfo = nil}

    /// All the Task Queues that have ever polled from this Deployment version.
    public var versionTaskQueues: [Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// (-- api-linter: core::0123::resource-annotation=disabled --)
    public struct VersionTaskQueue: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var type: Api.Enums.V1.TaskQueueType = .unspecified

      /// Only set if `report_task_queue_stats` is set on the request.
      public var stats: Api.Taskqueue.V1.TaskQueueStats {
        get {_stats ?? Api.Taskqueue.V1.TaskQueueStats()}
        set {_stats = newValue}
      }
      /// Returns true if `stats` has been explicitly set.
      public var hasStats: Bool {self._stats != nil}
      /// Clears the value of `stats`. Subsequent reads from it will return its default value.
      public mutating func clearStats() {self._stats = nil}

      /// Task queue stats breakdown by priority key. Only contains actively used priority keys.
      /// Only set if `report_task_queue_stats` is set to true in the request.
      /// (-- api-linter: core::0140::prepositions=disabled
      ///     aip.dev/not-precedent: "by" is used to clarify the key. --)
      public var statsByPriorityKey: Dictionary<Int32,Api.Taskqueue.V1.TaskQueueStats> = [:]

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _stats: Api.Taskqueue.V1.TaskQueueStats? = nil
    }

    public init() {}

    fileprivate var _workerDeploymentVersionInfo: Api.Deployment.V1.WorkerDeploymentVersionInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerDeploymentRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deploymentName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerDeploymentResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this read and a future write.
    public var conflictToken: Data = Data()

    public var workerDeploymentInfo: Api.Deployment.V1.WorkerDeploymentInfo {
      get {_workerDeploymentInfo ?? Api.Deployment.V1.WorkerDeploymentInfo()}
      set {_workerDeploymentInfo = newValue}
    }
    /// Returns true if `workerDeploymentInfo` has been explicitly set.
    public var hasWorkerDeploymentInfo: Bool {self._workerDeploymentInfo != nil}
    /// Clears the value of `workerDeploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerDeploymentInfo() {self._workerDeploymentInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workerDeploymentInfo: Api.Deployment.V1.WorkerDeploymentInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct ListDeploymentsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    /// Optional. Use to filter based on exact series name match.
    public var seriesName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct ListDeploymentsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nextPageToken: Data = Data()

    public var deployments: [Api.Deployment.V1.DeploymentListInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct SetCurrentDeploymentRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    /// Optional. Use to add or remove user-defined metadata entries. Metadata entries are exposed
    /// when describing a deployment. It is a good place for information such as operator name,
    /// links to internal deployment pipelines, etc.
    public var updateMetadata: Api.Deployment.V1.UpdateDeploymentMetadata {
      get {_updateMetadata ?? Api.Deployment.V1.UpdateDeploymentMetadata()}
      set {_updateMetadata = newValue}
    }
    /// Returns true if `updateMetadata` has been explicitly set.
    public var hasUpdateMetadata: Bool {self._updateMetadata != nil}
    /// Clears the value of `updateMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMetadata() {self._updateMetadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
    fileprivate var _updateMetadata: Api.Deployment.V1.UpdateDeploymentMetadata? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct SetCurrentDeploymentResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currentDeploymentInfo: Api.Deployment.V1.DeploymentInfo {
      get {_currentDeploymentInfo ?? Api.Deployment.V1.DeploymentInfo()}
      set {_currentDeploymentInfo = newValue}
    }
    /// Returns true if `currentDeploymentInfo` has been explicitly set.
    public var hasCurrentDeploymentInfo: Bool {self._currentDeploymentInfo != nil}
    /// Clears the value of `currentDeploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentDeploymentInfo() {self._currentDeploymentInfo = nil}

    /// Info of the deployment that was current before executing this operation.
    public var previousDeploymentInfo: Api.Deployment.V1.DeploymentInfo {
      get {_previousDeploymentInfo ?? Api.Deployment.V1.DeploymentInfo()}
      set {_previousDeploymentInfo = newValue}
    }
    /// Returns true if `previousDeploymentInfo` has been explicitly set.
    public var hasPreviousDeploymentInfo: Bool {self._previousDeploymentInfo != nil}
    /// Clears the value of `previousDeploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearPreviousDeploymentInfo() {self._previousDeploymentInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _currentDeploymentInfo: Api.Deployment.V1.DeploymentInfo? = nil
    fileprivate var _previousDeploymentInfo: Api.Deployment.V1.DeploymentInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// Set/unset the Current Version of a Worker Deployment.
  public struct SetWorkerDeploymentCurrentVersionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deploymentName: String = String()

    /// Deprecated. Use `build_id`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// The build id of the Version that you want to set as Current.
    /// Pass an empty value to set the Current Version to nil.
    /// A nil Current Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    public var buildID: String = String()

    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    public var conflictToken: Data = Data()

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    /// Optional. By default this request would be rejected if not all the expected Task Queues are
    /// being polled by the new Version, to protect against accidental removal of Task Queues, or
    /// worker health issues. Pass `true` here to bypass this protection.
    /// The set of expected Task Queues is the set of all the Task Queues that were ever poller by
    /// the existing Current Version of the Deployment, with the following exclusions:
    ///   - Task Queues that are not used anymore (inferred by having empty backlog and a task
    ///     add_rate of 0.)
    ///   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
    ///     having a different Current Version than the Current Version of this deployment.)
    /// WARNING: Do not set this flag unless you are sure that the missing task queue pollers are not
    /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
    /// pollers have not reached to the server yet. Only set this if you expect those pollers to
    /// never arrive.
    public var ignoreMissingTaskQueues: Bool = false

    /// Optional. By default this request will be rejected if no pollers have been seen for the proposed
    /// Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
    /// to possible timeouts. Pass `true` here to bypass this protection.
    public var allowNoPollers: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct SetWorkerDeploymentCurrentVersionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    public var conflictToken: Data = Data()

    /// Deprecated. Use `previous_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousVersion: String = String()

    /// The version that was current before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Current version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_previousDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_previousDeploymentVersion = newValue}
    }
    /// Returns true if `previousDeploymentVersion` has been explicitly set.
    public var hasPreviousDeploymentVersion: Bool {self._previousDeploymentVersion != nil}
    /// Clears the value of `previousDeploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearPreviousDeploymentVersion() {self._previousDeploymentVersion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _previousDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// Set/unset the Ramping Version of a Worker Deployment and its ramp percentage.
  public struct SetWorkerDeploymentRampingVersionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deploymentName: String = String()

    /// Deprecated. Use `build_id`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// The build id of the Version that you want to ramp traffic to.
    /// Pass an empty value to set the Ramping Version to nil.
    /// A nil Ramping Version represents all the unversioned workers (those with `UNVERSIONED` (or unspecified) `WorkerVersioningMode`.)
    public var buildID: String = String()

    /// Ramp percentage to set. Valid range: [0,100].
    public var percentage: Float = 0

    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    public var conflictToken: Data = Data()

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    /// Optional. By default this request would be rejected if not all the expected Task Queues are
    /// being polled by the new Version, to protect against accidental removal of Task Queues, or
    /// worker health issues. Pass `true` here to bypass this protection.
    /// The set of expected Task Queues equals to all the Task Queues ever polled from the existing
    /// Current Version of the Deployment, with the following exclusions:
    ///   - Task Queues that are not used anymore (inferred by having empty backlog and a task
    ///     add_rate of 0.)
    ///   - Task Queues that are moved to another Worker Deployment (inferred by the Task Queue
    ///     having a different Current Version than the Current Version of this deployment.)
    /// WARNING: Do not set this flag unless you are sure that the missing task queue poller are not
    /// needed. If the request is unexpectedly rejected due to missing pollers, then that means the
    /// pollers have not reached to the server yet. Only set this if you expect those pollers to
    /// never arrive.
    /// Note: this check only happens when the ramping version is about to change, not every time
    /// that the percentage changes. Also note that the check is against the deployment's Current
    /// Version, not the previous Ramping Version.
    public var ignoreMissingTaskQueues: Bool = false

    /// Optional. By default this request will be rejected if no pollers have been seen for the proposed
    /// Current Version, in order to protect users from routing tasks to pollers that do not exist, leading
    /// to possible timeouts. Pass `true` here to bypass this protection.
    public var allowNoPollers: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct SetWorkerDeploymentRampingVersionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    public var conflictToken: Data = Data()

    /// Deprecated. Use `previous_deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousVersion: String = String()

    /// The version that was ramping before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Ramping version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_previousDeploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_previousDeploymentVersion = newValue}
    }
    /// Returns true if `previousDeploymentVersion` has been explicitly set.
    public var hasPreviousDeploymentVersion: Bool {self._previousDeploymentVersion != nil}
    /// Clears the value of `previousDeploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearPreviousDeploymentVersion() {self._previousDeploymentVersion = nil}

    /// The ramping version percentage before executing this operation.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// Ramping version info before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousPercentage: Float = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _previousDeploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkerDeploymentsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkerDeploymentsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nextPageToken: Data = Data()

    /// The list of worker deployments.
    public var workerDeployments: [Api.Workflowservice.V1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// (-- api-linter: core::0123::resource-annotation=disabled --)
    /// A subset of WorkerDeploymentInfo
    public struct WorkerDeploymentSummary: @unchecked Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String {
        get {_storage._name}
        set {_uniqueStorage()._name = newValue}
      }

      public var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
        get {_storage._createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
        set {_uniqueStorage()._createTime = newValue}
      }
      /// Returns true if `createTime` has been explicitly set.
      public var hasCreateTime: Bool {_storage._createTime != nil}
      /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
      public mutating func clearCreateTime() {_uniqueStorage()._createTime = nil}

      public var routingConfig: Api.Deployment.V1.RoutingConfig {
        get {_storage._routingConfig ?? Api.Deployment.V1.RoutingConfig()}
        set {_uniqueStorage()._routingConfig = newValue}
      }
      /// Returns true if `routingConfig` has been explicitly set.
      public var hasRoutingConfig: Bool {_storage._routingConfig != nil}
      /// Clears the value of `routingConfig`. Subsequent reads from it will return its default value.
      public mutating func clearRoutingConfig() {_uniqueStorage()._routingConfig = nil}

      /// Summary of the version that was added most recently in the Worker Deployment.
      public var latestVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
        get {_storage._latestVersionSummary ?? Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
        set {_uniqueStorage()._latestVersionSummary = newValue}
      }
      /// Returns true if `latestVersionSummary` has been explicitly set.
      public var hasLatestVersionSummary: Bool {_storage._latestVersionSummary != nil}
      /// Clears the value of `latestVersionSummary`. Subsequent reads from it will return its default value.
      public mutating func clearLatestVersionSummary() {_uniqueStorage()._latestVersionSummary = nil}

      /// Summary of the current version of the Worker Deployment.
      public var currentVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
        get {_storage._currentVersionSummary ?? Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
        set {_uniqueStorage()._currentVersionSummary = newValue}
      }
      /// Returns true if `currentVersionSummary` has been explicitly set.
      public var hasCurrentVersionSummary: Bool {_storage._currentVersionSummary != nil}
      /// Clears the value of `currentVersionSummary`. Subsequent reads from it will return its default value.
      public mutating func clearCurrentVersionSummary() {_uniqueStorage()._currentVersionSummary = nil}

      /// Summary of the ramping version of the Worker Deployment.
      public var rampingVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary {
        get {_storage._rampingVersionSummary ?? Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary()}
        set {_uniqueStorage()._rampingVersionSummary = newValue}
      }
      /// Returns true if `rampingVersionSummary` has been explicitly set.
      public var hasRampingVersionSummary: Bool {_storage._rampingVersionSummary != nil}
      /// Clears the value of `rampingVersionSummary`. Subsequent reads from it will return its default value.
      public mutating func clearRampingVersionSummary() {_uniqueStorage()._rampingVersionSummary = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _storage = _StorageClass.defaultInstance
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Used for manual deletion of Versions. User can delete a Version only when all the
  /// following conditions are met:
  ///  - It is not the Current or Ramping Version of its Deployment.
  ///  - It has no active pollers (none of the task queues in the Version have pollers)
  ///  - It is not draining (see WorkerDeploymentVersionInfo.drainage_info). This condition
  ///    can be skipped by passing `skip-drainage=true`.
  public struct DeleteWorkerDeploymentVersionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// Required.
    public var deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_deploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    public var hasDeploymentVersion: Bool {self._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

    /// Pass to force deletion even if the Version is draining. In this case the open pinned
    /// workflows will be stuck until manually moved to another version by UpdateWorkflowExecutionOptions.
    public var skipDrainage: Bool = false

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkerDeploymentVersionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Deletes records of (an old) Deployment. A deployment can only be deleted if
  /// it has no Version in it.
  public struct DeleteWorkerDeploymentRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deploymentName: String = String()

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkerDeploymentResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Used to update the user-defined metadata of a Worker Deployment Version.
  public struct UpdateWorkerDeploymentVersionMetadataRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Deprecated. Use `deployment_version`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var version: String = String()

    /// Required.
    public var deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion {
      get {_deploymentVersion ?? Api.Deployment.V1.WorkerDeploymentVersion()}
      set {_deploymentVersion = newValue}
    }
    /// Returns true if `deploymentVersion` has been explicitly set.
    public var hasDeploymentVersion: Bool {self._deploymentVersion != nil}
    /// Clears the value of `deploymentVersion`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentVersion() {self._deploymentVersion = nil}

    public var upsertEntries: Dictionary<String,Api.Common.V1.Payload> = [:]

    /// List of keys to remove from the metadata.
    public var removeEntries: [String] = []

    /// Optional. The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentVersion: Api.Deployment.V1.WorkerDeploymentVersion? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateWorkerDeploymentVersionMetadataResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Full metadata after performing the update.
    public var metadata: Api.Deployment.V1.VersionMetadata {
      get {_metadata ?? Api.Deployment.V1.VersionMetadata()}
      set {_metadata = newValue}
    }
    /// Returns true if `metadata` has been explicitly set.
    public var hasMetadata: Bool {self._metadata != nil}
    /// Clears the value of `metadata`. Subsequent reads from it will return its default value.
    public mutating func clearMetadata() {self._metadata = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _metadata: Api.Deployment.V1.VersionMetadata? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// Update the ManagerIdentity of a Worker Deployment.
  public struct SetWorkerDeploymentManagerRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deploymentName: String = String()

    public var newManagerIdentity: Api.Workflowservice.V1.SetWorkerDeploymentManagerRequest.OneOf_NewManagerIdentity? = nil

    /// Arbitrary value for `manager_identity`.
    /// Empty will unset the field.
    public var managerIdentity: String {
      get {
        if case .managerIdentity(let v)? = newManagerIdentity {return v}
        return String()
      }
      set {newManagerIdentity = .managerIdentity(newValue)}
    }

    /// True will set `manager_identity` to `identity`.
    public var self_p: Bool {
      get {
        if case .self_p(let v)? = newManagerIdentity {return v}
        return false
      }
      set {newManagerIdentity = .self_p(newValue)}
    }

    /// Optional. This can be the value of conflict_token from a Describe, or another Worker
    /// Deployment API. Passing a non-nil conflict token will cause this request to fail if the
    /// Deployment's configuration has been modified between the API call that generated the
    /// token and this one.
    public var conflictToken: Data = Data()

    /// Required. The identity of the client who initiated this request.
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_NewManagerIdentity: Equatable, Sendable {
      /// Arbitrary value for `manager_identity`.
      /// Empty will unset the field.
      case managerIdentity(String)
      /// True will set `manager_identity` to `identity`.
      case self_p(Bool)

    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct SetWorkerDeploymentManagerResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// This value is returned so that it can be optionally passed to APIs
    /// that write to the Worker Deployment state to ensure that the state
    /// did not change between this API call and a future write.
    public var conflictToken: Data = Data()

    /// What the `manager_identity` field was before this change.
    /// Deprecated in favor of idempotency of the API. Use `DescribeWorkerDeployment` to get the
    /// manager identity before calling this API. By passing the `conflict_token` got from the
    /// `DescribeWorkerDeployment` call to this API you can ensure there is no interfering changes
    /// between the two calls.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var previousManagerIdentity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Returns the Current Deployment of a deployment series.
  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct GetCurrentDeploymentRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var seriesName: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct GetCurrentDeploymentResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var currentDeploymentInfo: Api.Deployment.V1.DeploymentInfo {
      get {_currentDeploymentInfo ?? Api.Deployment.V1.DeploymentInfo()}
      set {_currentDeploymentInfo = newValue}
    }
    /// Returns true if `currentDeploymentInfo` has been explicitly set.
    public var hasCurrentDeploymentInfo: Bool {self._currentDeploymentInfo != nil}
    /// Clears the value of `currentDeploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearCurrentDeploymentInfo() {self._currentDeploymentInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _currentDeploymentInfo: Api.Deployment.V1.DeploymentInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct GetDeploymentReachabilityRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var deployment: Api.Deployment.V1.Deployment {
      get {_deployment ?? Api.Deployment.V1.Deployment()}
      set {_deployment = newValue}
    }
    /// Returns true if `deployment` has been explicitly set.
    public var hasDeployment: Bool {self._deployment != nil}
    /// Clears the value of `deployment`. Subsequent reads from it will return its default value.
    public mutating func clearDeployment() {self._deployment = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deployment: Api.Deployment.V1.Deployment? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// [cleanup-wv-pre-release] Pre-release deployment APIs, clean up later
  public struct GetDeploymentReachabilityResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deploymentInfo: Api.Deployment.V1.DeploymentInfo {
      get {_deploymentInfo ?? Api.Deployment.V1.DeploymentInfo()}
      set {_deploymentInfo = newValue}
    }
    /// Returns true if `deploymentInfo` has been explicitly set.
    public var hasDeploymentInfo: Bool {self._deploymentInfo != nil}
    /// Clears the value of `deploymentInfo`. Subsequent reads from it will return its default value.
    public mutating func clearDeploymentInfo() {self._deploymentInfo = nil}

    public var reachability: Api.Enums.V1.DeploymentReachability = .unspecified

    /// Reachability level might come from server cache. This timestamp specifies when the value
    /// was actually calculated.
    public var lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastUpdateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastUpdateTime = newValue}
    }
    /// Returns true if `lastUpdateTime` has been explicitly set.
    public var hasLastUpdateTime: Bool {self._lastUpdateTime != nil}
    /// Clears the value of `lastUpdateTime`. Subsequent reads from it will return its default value.
    public mutating func clearLastUpdateTime() {self._lastUpdateTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _deploymentInfo: Api.Deployment.V1.DeploymentInfo? = nil
    fileprivate var _lastUpdateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct CreateWorkflowRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// The rule specification .
    public var spec: Api.Rules.V1.WorkflowRuleSpec {
      get {_spec ?? Api.Rules.V1.WorkflowRuleSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// If true, the rule will be applied to the currently running workflows via batch job.
    /// If not set , the rule will only be applied when triggering condition is satisfied.
    /// visibility_query in the rule will be used to select the workflows to apply the rule to.
    public var forceScan: Bool = false

    /// Used to de-dupe requests. Typically should be UUID.
    public var requestID: String = String()

    /// Identity of the actor who created the rule. Will be stored with the rule.
    public var identity: String = String()

    /// Rule description.Will be stored with the rule.
    public var description_p: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Rules.V1.WorkflowRuleSpec? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct CreateWorkflowRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Created rule.
    public var rule: Api.Rules.V1.WorkflowRule {
      get {_rule ?? Api.Rules.V1.WorkflowRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    public var hasRule: Bool {self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    public mutating func clearRule() {self._rule = nil}

    /// Batch Job ID if force-scan flag was provided. Otherwise empty.
    public var jobID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _rule: Api.Rules.V1.WorkflowRule? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkflowRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// User-specified ID of the rule to read. Unique within the namespace.
    public var ruleID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkflowRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The rule that was read.
    public var rule: Api.Rules.V1.WorkflowRule {
      get {_rule ?? Api.Rules.V1.WorkflowRule()}
      set {_rule = newValue}
    }
    /// Returns true if `rule` has been explicitly set.
    public var hasRule: Bool {self._rule != nil}
    /// Clears the value of `rule`. Subsequent reads from it will return its default value.
    public mutating func clearRule() {self._rule = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _rule: Api.Rules.V1.WorkflowRule? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkflowRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// ID of the rule to delete. Unique within the namespace.
    public var ruleID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteWorkflowRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkflowRulesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkflowRulesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var rules: [Api.Rules.V1.WorkflowRule] = []

    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct TriggerWorkflowRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Execution info of the workflow which scheduled this activity
    public var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    public var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    public mutating func clearExecution() {self._execution = nil}

    /// Either provide id of existing rule, or rule specification
    public var rule: Api.Workflowservice.V1.TriggerWorkflowRuleRequest.OneOf_Rule? = nil

    public var id: String {
      get {
        if case .id(let v)? = rule {return v}
        return String()
      }
      set {rule = .id(newValue)}
    }

    /// Note: Rule ID and expiration date are not used in the trigger request.
    public var spec: Api.Rules.V1.WorkflowRuleSpec {
      get {
        if case .spec(let v)? = rule {return v}
        return Api.Rules.V1.WorkflowRuleSpec()
      }
      set {rule = .spec(newValue)}
    }

    /// The identity of the client who initiated this request
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Either provide id of existing rule, or rule specification
    public enum OneOf_Rule: Equatable, Sendable {
      case id(String)
      /// Note: Rule ID and expiration date are not used in the trigger request.
      case spec(Api.Rules.V1.WorkflowRuleSpec)

    }

    public init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct TriggerWorkflowRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// True is the rule was applied, based on the rule conditions (predicate/visibility_query).
    public var applied: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordWorkerHeartbeatRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace this worker belongs to.
    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    public var workerHeartbeat: [Api.Worker.V1.WorkerHeartbeat] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RecordWorkerHeartbeatResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkersRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var pageSize: Int32 = 0

    public var nextPageToken: Data = Data()

    /// `query` in ListWorkers is used to filter workers based on worker status info.
    /// The following worker status attributes are expected are supported as part of the query:
    ///* WorkerInstanceKey
    ///* WorkerIdentity
    ///* HostName
    ///* TaskQueue
    ///* DeploymentName
    ///* BuildId
    ///* SdkName
    ///* SdkVersion
    ///* StartTime
    ///* LastHeartbeatTime
    ///* Status
    /// Currently metrics are not supported as a part of ListWorkers query.
    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListWorkersResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var workersInfo: [Api.Worker.V1.WorkerInfo] = []

    /// Next page token
    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateTaskQueueConfigRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var identity: String = String()

    /// Selects the task queue to update.
    public var taskQueue: String = String()

    public var taskQueueType: Api.Enums.V1.TaskQueueType = .unspecified

    /// Update to queue-wide rate limit.
    /// If not set, this configuration is unchanged.
    /// NOTE: A limit set by the worker is overriden; and restored again when reset.
    /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
    public var updateQueueRateLimit: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate {
      get {_updateQueueRateLimit ?? Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate()}
      set {_updateQueueRateLimit = newValue}
    }
    /// Returns true if `updateQueueRateLimit` has been explicitly set.
    public var hasUpdateQueueRateLimit: Bool {self._updateQueueRateLimit != nil}
    /// Clears the value of `updateQueueRateLimit`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateQueueRateLimit() {self._updateQueueRateLimit = nil}

    /// Update to the default fairness key rate limit.
    /// If not set, this configuration is unchanged.
    /// If the `rate_limit` field in the `RateLimitUpdate` is missing, remove the existing rate limit.
    public var updateFairnessKeyRateLimitDefault: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate {
      get {_updateFairnessKeyRateLimitDefault ?? Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate()}
      set {_updateFairnessKeyRateLimitDefault = newValue}
    }
    /// Returns true if `updateFairnessKeyRateLimitDefault` has been explicitly set.
    public var hasUpdateFairnessKeyRateLimitDefault: Bool {self._updateFairnessKeyRateLimitDefault != nil}
    /// Clears the value of `updateFairnessKeyRateLimitDefault`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateFairnessKeyRateLimitDefault() {self._updateFairnessKeyRateLimitDefault = nil}

    /// If set, overrides the fairness weight for each specified fairness key.
    /// Fairness keys not listed in this map will keep their existing overrides (if any).
    public var setFairnessWeightOverrides: Dictionary<String,Float> = [:]

    /// If set, removes any existing fairness weight overrides for each specified fairness key.
    /// Fairness weights for corresponding keys fall back to the values set during task creation (if any),
    /// or to the default weight of 1.0.
    public var unsetFairnessWeightOverrides: [String] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct RateLimitUpdate: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Rate Limit to be updated
      public var rateLimit: Api.Taskqueue.V1.RateLimit {
        get {_rateLimit ?? Api.Taskqueue.V1.RateLimit()}
        set {_rateLimit = newValue}
      }
      /// Returns true if `rateLimit` has been explicitly set.
      public var hasRateLimit: Bool {self._rateLimit != nil}
      /// Clears the value of `rateLimit`. Subsequent reads from it will return its default value.
      public mutating func clearRateLimit() {self._rateLimit = nil}

      /// Reason for why the rate limit was set.
      public var reason: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _rateLimit: Api.Taskqueue.V1.RateLimit? = nil
    }

    public init() {}

    fileprivate var _updateQueueRateLimit: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate? = nil
    fileprivate var _updateFairnessKeyRateLimitDefault: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateTaskQueueConfigResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var config: Api.Taskqueue.V1.TaskQueueConfig {
      get {_config ?? Api.Taskqueue.V1.TaskQueueConfig()}
      set {_config = newValue}
    }
    /// Returns true if `config` has been explicitly set.
    public var hasConfig: Bool {self._config != nil}
    /// Clears the value of `config`. Subsequent reads from it will return its default value.
    public mutating func clearConfig() {self._config = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _config: Api.Taskqueue.V1.TaskQueueConfig? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct FetchWorkerConfigRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace this worker belongs to.
    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// Reason for sending worker command, can be used for audit purpose.
    public var reason: String = String()

    /// Defines which workers should receive this command.
    /// only single worker is supported at this time.
    public var selector: Api.Common.V1.WorkerSelector {
      get {_selector ?? Api.Common.V1.WorkerSelector()}
      set {_selector = newValue}
    }
    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool {self._selector != nil}
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() {self._selector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _selector: Api.Common.V1.WorkerSelector? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct FetchWorkerConfigResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The worker configuration.
    public var workerConfig: Api.Sdk.V1.WorkerConfig {
      get {_workerConfig ?? Api.Sdk.V1.WorkerConfig()}
      set {_workerConfig = newValue}
    }
    /// Returns true if `workerConfig` has been explicitly set.
    public var hasWorkerConfig: Bool {self._workerConfig != nil}
    /// Clears the value of `workerConfig`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerConfig() {self._workerConfig = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workerConfig: Api.Sdk.V1.WorkerConfig? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateWorkerConfigRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace this worker belongs to.
    public var namespace: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// Reason for sending worker command, can be used for audit purpose.
    public var reason: String = String()

    /// Partial updates are accepted and controlled by update_mask.
    /// The worker configuration to set.
    public var workerConfig: Api.Sdk.V1.WorkerConfig {
      get {_workerConfig ?? Api.Sdk.V1.WorkerConfig()}
      set {_workerConfig = newValue}
    }
    /// Returns true if `workerConfig` has been explicitly set.
    public var hasWorkerConfig: Bool {self._workerConfig != nil}
    /// Clears the value of `workerConfig`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerConfig() {self._workerConfig = nil}

    /// Controls which fields from `worker_config` will be applied
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool {self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() {self._updateMask = nil}

    /// Defines which workers should receive this command.
    public var selector: Api.Common.V1.WorkerSelector {
      get {_selector ?? Api.Common.V1.WorkerSelector()}
      set {_selector = newValue}
    }
    /// Returns true if `selector` has been explicitly set.
    public var hasSelector: Bool {self._selector != nil}
    /// Clears the value of `selector`. Subsequent reads from it will return its default value.
    public mutating func clearSelector() {self._selector = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workerConfig: Api.Sdk.V1.WorkerConfig? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
    fileprivate var _selector: Api.Common.V1.WorkerSelector? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct UpdateWorkerConfigResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var response: Api.Workflowservice.V1.UpdateWorkerConfigResponse.OneOf_Response? = nil

    /// The worker configuration. Will be returned if the command was sent to a single worker.
    public var workerConfig: Api.Sdk.V1.WorkerConfig {
      get {
        if case .workerConfig(let v)? = response {return v}
        return Api.Sdk.V1.WorkerConfig()
      }
      set {response = .workerConfig(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Response: Equatable, Sendable {
      /// The worker configuration. Will be returned if the command was sent to a single worker.
      case workerConfig(Api.Sdk.V1.WorkerConfig)

    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace this worker belongs to.
    public var namespace: String = String()

    /// Worker instance key to describe.
    public var workerInstanceKey: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeWorkerResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var workerInfo: Api.Worker.V1.WorkerInfo {
      get {_workerInfo ?? Api.Worker.V1.WorkerInfo()}
      set {_workerInfo = newValue}
    }
    /// Returns true if `workerInfo` has been explicitly set.
    public var hasWorkerInfo: Bool {self._workerInfo != nil}
    /// Clears the value of `workerInfo`. Subsequent reads from it will return its default value.
    public mutating func clearWorkerInfo() {self._workerInfo = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workerInfo: Api.Worker.V1.WorkerInfo? = nil
  }
}
extension Api.Workflowservice.V1 {


  /// Request to pause a workflow execution.
  public struct PauseWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow to pause.
    public var namespace: String = String()

    /// ID of the workflow execution to be paused. Required.
    public var workflowID: String = String()

    /// Run ID of the workflow execution to be paused. Optional. If not provided, the current run of the workflow will be paused.
    public var runID: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// Reason to pause the workflow execution.
    public var reason: String = String()

    /// A unique identifier for this pause request for idempotence. Typically UUIDv4.
    public var requestID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Response to a successful PauseWorkflowExecution request.
  public struct PauseWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct UnpauseWorkflowExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Namespace of the workflow to unpause.
    public var namespace: String = String()

    /// ID of the workflow execution to be paused. Required.
    public var workflowID: String = String()

    /// Run ID of the workflow execution to be paused. Optional. If not provided, the current run of the workflow will be paused.
    public var runID: String = String()

    /// The identity of the client who initiated this request.
    public var identity: String = String()

    /// Reason to unpause the workflow execution.
    public var reason: String = String()

    /// A unique identifier for this unpause request for idempotence. Typically UUIDv4.
    public var requestID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  /// Response to a successful UnpauseWorkflowExecution request.
  public struct UnpauseWorkflowExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct StartActivityExecutionRequest: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    /// The identity of the client who initiated this request
    public var identity: String {
      get {_storage._identity}
      set {_uniqueStorage()._identity = newValue}
    }

    /// A unique identifier for this start request. Typically UUIDv4.
    public var requestID: String {
      get {_storage._requestID}
      set {_uniqueStorage()._requestID = newValue}
    }

    /// Identifier for this activity. Required. This identifier should be meaningful in the user's
    /// own system. It must be unique among activities in the same namespace, subject to the rules
    /// imposed by id_reuse_policy and id_conflict_policy.
    public var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    /// The type of the activity, a string that corresponds to a registered activity on a worker.
    public var activityType: Api.Common.V1.ActivityType {
      get {_storage._activityType ?? Api.Common.V1.ActivityType()}
      set {_uniqueStorage()._activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {_storage._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

    /// Task queue to schedule this activity on.
    public var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    public var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    public mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    /// Indicates how long the caller is willing to wait for an activity completion. Limits how long
    /// retries will be attempted. Either this or `start_to_close_timeout` must be specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    public var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits time an activity task can stay in a task queue before a worker picks it up. This
    /// timeout is always non retryable, as all a retry would achieve is to put it back into the same
    /// queue. Defaults to `schedule_to_close_timeout` if not specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    public var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time an activity is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be
    /// specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    public var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    public var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Maximum permitted time between successful worker heartbeats.
    public var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    public var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    public mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// The retry policy for the activity. Will never exceed `schedule_to_close_timeout`.
    public var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    public var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    public mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Serialized arguments to the activity. These are passed as arguments to the activity function.
    public var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Defines whether to allow re-using the activity id from a previously *closed* activity.
    /// The default policy is ACTIVITY_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    public var idReusePolicy: Api.Enums.V1.ActivityIdReusePolicy {
      get {_storage._idReusePolicy}
      set {_uniqueStorage()._idReusePolicy = newValue}
    }

    /// Defines how to resolve an activity id conflict with a *running* activity.
    /// The default policy is ACTIVITY_ID_CONFLICT_POLICY_FAIL.
    public var idConflictPolicy: Api.Enums.V1.ActivityIdConflictPolicy {
      get {_storage._idConflictPolicy}
      set {_uniqueStorage()._idConflictPolicy = newValue}
    }

    /// Search attributes for indexing.
    public var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    public var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    /// Header for context propagation and tracing purposes.
    public var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {_uniqueStorage()._header = nil}

    /// Metadata for use by user interfaces to display the fixed as-of-start summary and details of the activity.
    public var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    public var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    public mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// Priority metadata.
    public var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    public var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    public mutating func clearPriority() {_uniqueStorage()._priority = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Workflowservice.V1 {


  public struct StartActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The run ID of the activity that was started - or used (via ACTIVITY_ID_CONFLICT_POLICY_USE_EXISTING).
    public var runID: String = String()

    /// If true, a new activity was started.
    public var started: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeActivityExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var activityID: String = String()

    /// Activity run ID. If empty the request targets the latest run.
    public var runID: String = String()

    /// Include the input field in the response.
    public var includeInput: Bool = false

    /// Include the outcome (result/failure) in the response if the activity has completed.
    public var includeOutcome: Bool = false

    /// Token from a previous DescribeActivityExecutionResponse. If present, long-poll until activity
    /// state changes from the state encoded in this token. If absent, return current state immediately.
    /// If present, run_id must also be present.
    /// Note that activity state may change multiple times between requests, therefore it is not
    /// guaranteed that a client making a sequence of long-poll requests will see a complete
    /// sequence of state changes.
    public var longPollToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DescribeActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The run ID of the activity, useful when run_id was not specified in the request.
    public var runID: String = String()

    /// Information about the activity execution.
    public var info: Api.Activity.V1.ActivityExecutionInfo {
      get {_info ?? Api.Activity.V1.ActivityExecutionInfo()}
      set {_info = newValue}
    }
    /// Returns true if `info` has been explicitly set.
    public var hasInfo: Bool {self._info != nil}
    /// Clears the value of `info`. Subsequent reads from it will return its default value.
    public mutating func clearInfo() {self._info = nil}

    /// Serialized activity input, passed as arguments to the activity function.
    /// Only set if include_input was true in the request.
    public var input: Api.Common.V1.Payloads {
      get {_input ?? Api.Common.V1.Payloads()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {self._input = nil}

    /// Only set if the activity is completed and include_outcome was true in the request.
    public var outcome: Api.Activity.V1.ActivityExecutionOutcome {
      get {_outcome ?? Api.Activity.V1.ActivityExecutionOutcome()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    public var hasOutcome: Bool {self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    public mutating func clearOutcome() {self._outcome = nil}

    /// Token for follow-on long-poll requests. Absent only if the activity is complete.
    public var longPollToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _info: Api.Activity.V1.ActivityExecutionInfo? = nil
    fileprivate var _input: Api.Common.V1.Payloads? = nil
    fileprivate var _outcome: Api.Activity.V1.ActivityExecutionOutcome? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct PollActivityExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var activityID: String = String()

    /// Activity run ID. If empty the request targets the latest run.
    public var runID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct PollActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The run ID of the activity, useful when run_id was not specified in the request.
    public var runID: String = String()

    public var outcome: Api.Activity.V1.ActivityExecutionOutcome {
      get {_outcome ?? Api.Activity.V1.ActivityExecutionOutcome()}
      set {_outcome = newValue}
    }
    /// Returns true if `outcome` has been explicitly set.
    public var hasOutcome: Bool {self._outcome != nil}
    /// Clears the value of `outcome`. Subsequent reads from it will return its default value.
    public mutating func clearOutcome() {self._outcome = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _outcome: Api.Activity.V1.ActivityExecutionOutcome? = nil
  }
}
extension Api.Workflowservice.V1 {


  public struct ListActivityExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Max number of executions to return per page.
    public var pageSize: Int32 = 0

    /// Token returned in ListActivityExecutionsResponse.
    public var nextPageToken: Data = Data()

    /// Visibility query, see https://docs.temporal.io/list-filter for the syntax.
    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct ListActivityExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var executions: [Api.Activity.V1.ActivityExecutionListInfo] = []

    /// Token to use to fetch the next page. If empty, there is no next page.
    public var nextPageToken: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct CountActivityExecutionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    /// Visibility query, see https://docs.temporal.io/list-filter for the syntax.
    public var query: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct CountActivityExecutionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If `query` is not grouping by any field, the count is an approximate number
    /// of activities that match the query.
    /// If `query` is grouping by a field, the count is simply the sum of the counts
    /// of the groups returned in the response. This number can be smaller than the
    /// total number of activities matching the query.
    public var count: Int64 = 0

    /// Contains the groups if the request is grouping by a field.
    /// The list might not be complete, and the counts of each group is approximate.
    public var groups: [Api.Workflowservice.V1.CountActivityExecutionsResponse.AggregationGroup] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct AggregationGroup: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var groupValues: [Api.Common.V1.Payload] = []

      public var count: Int64 = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RequestCancelActivityExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var activityID: String = String()

    /// Activity run ID, targets the latest run if run_id is empty.
    public var runID: String = String()

    /// The identity of the worker/client.
    public var identity: String = String()

    /// Used to de-dupe cancellation requests.
    public var requestID: String = String()

    /// Reason for requesting the cancellation, recorded and available via the PollActivityExecution API.
    /// Not propagated to a worker if an activity attempt is currently running.
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct RequestCancelActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct TerminateActivityExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var activityID: String = String()

    /// Activity run ID, targets the latest run if run_id is empty.
    public var runID: String = String()

    /// The identity of the worker/client.
    public var identity: String = String()

    /// Used to de-dupe termination requests.
    public var requestID: String = String()

    /// Reason for requesting the termination, recorded in in the activity's result failure outcome.
    public var reason: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct TerminateActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteActivityExecutionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var activityID: String = String()

    /// Activity run ID, targets the latest run if run_id is empty.
    public var runID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Workflowservice.V1 {


  public struct DeleteActivityExecutionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.workflowservice.v1"

extension Api.Workflowservice.V1.RegisterNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}description\0\u{3}owner_email\0\u{3}workflow_execution_retention_period\0\u{1}clusters\0\u{3}active_cluster_name\0\u{1}data\0\u{3}security_token\0\u{3}is_global_namespace\0\u{3}history_archival_state\0\u{3}history_archival_uri\0\u{3}visibility_archival_state\0\u{3}visibility_archival_uri\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerEmail) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionRetentionPeriod) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.clusters) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.activeClusterName) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.data) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.securityToken) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.isGlobalNamespace) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.historyArchivalState) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.historyArchivalUri) }()
      case 12: try { try decoder.decodeSingularEnumField(value: &self.visibilityArchivalState) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.visibilityArchivalUri) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.ownerEmail.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerEmail, fieldNumber: 3)
    }
    try { if let v = self._workflowExecutionRetentionPeriod {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.clusters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.clusters, fieldNumber: 5)
    }
    if !self.activeClusterName.isEmpty {
      try visitor.visitSingularStringField(value: self.activeClusterName, fieldNumber: 6)
    }
    if !self.data.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.data, fieldNumber: 7)
    }
    if !self.securityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.securityToken, fieldNumber: 8)
    }
    if self.isGlobalNamespace != false {
      try visitor.visitSingularBoolField(value: self.isGlobalNamespace, fieldNumber: 9)
    }
    if self.historyArchivalState != .unspecified {
      try visitor.visitSingularEnumField(value: self.historyArchivalState, fieldNumber: 10)
    }
    if !self.historyArchivalUri.isEmpty {
      try visitor.visitSingularStringField(value: self.historyArchivalUri, fieldNumber: 11)
    }
    if self.visibilityArchivalState != .unspecified {
      try visitor.visitSingularEnumField(value: self.visibilityArchivalState, fieldNumber: 12)
    }
    if !self.visibilityArchivalUri.isEmpty {
      try visitor.visitSingularStringField(value: self.visibilityArchivalUri, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RegisterNamespaceRequest, rhs: Api.Workflowservice.V1.RegisterNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.ownerEmail != rhs.ownerEmail {return false}
    if lhs._workflowExecutionRetentionPeriod != rhs._workflowExecutionRetentionPeriod {return false}
    if lhs.clusters != rhs.clusters {return false}
    if lhs.activeClusterName != rhs.activeClusterName {return false}
    if lhs.data != rhs.data {return false}
    if lhs.securityToken != rhs.securityToken {return false}
    if lhs.isGlobalNamespace != rhs.isGlobalNamespace {return false}
    if lhs.historyArchivalState != rhs.historyArchivalState {return false}
    if lhs.historyArchivalUri != rhs.historyArchivalUri {return false}
    if lhs.visibilityArchivalState != rhs.visibilityArchivalState {return false}
    if lhs.visibilityArchivalUri != rhs.visibilityArchivalUri {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RegisterNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RegisterNamespaceResponse, rhs: Api.Workflowservice.V1.RegisterNamespaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListNamespacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNamespacesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}next_page_token\0\u{3}namespace_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._namespaceFilter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try { if let v = self._namespaceFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListNamespacesRequest, rhs: Api.Workflowservice.V1.ListNamespacesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._namespaceFilter != rhs._namespaceFilter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListNamespacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListNamespacesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespaces\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.namespaces) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaces, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListNamespacesResponse, rhs: Api.Workflowservice.V1.ListNamespacesResponse) -> Bool {
    if lhs.namespaces != rhs.namespaces {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeNamespaceRequest, rhs: Api.Workflowservice.V1.DescribeNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}namespace_info\0\u{1}config\0\u{3}replication_config\0\u{3}failover_version\0\u{3}is_global_namespace\0\u{3}failover_history\0")

  fileprivate class _StorageClass {
    var _namespaceInfo: Api.Namespace.V1.NamespaceInfo? = nil
    var _config: Api.Namespace.V1.NamespaceConfig? = nil
    var _replicationConfig: Api.Replication.V1.NamespaceReplicationConfig? = nil
    var _failoverVersion: Int64 = 0
    var _isGlobalNamespace: Bool = false
    var _failoverHistory: [Api.Replication.V1.FailoverStatus] = []

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespaceInfo = source._namespaceInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _failoverVersion = source._failoverVersion
      _isGlobalNamespace = source._isGlobalNamespace
      _failoverHistory = source._failoverHistory
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._failoverVersion) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isGlobalNamespace) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._failoverHistory) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._namespaceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._failoverVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failoverVersion, fieldNumber: 4)
      }
      if _storage._isGlobalNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._isGlobalNamespace, fieldNumber: 5)
      }
      if !_storage._failoverHistory.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._failoverHistory, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeNamespaceResponse, rhs: Api.Workflowservice.V1.DescribeNamespaceResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespaceInfo != rhs_storage._namespaceInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._failoverVersion != rhs_storage._failoverVersion {return false}
        if _storage._isGlobalNamespace != rhs_storage._isGlobalNamespace {return false}
        if _storage._failoverHistory != rhs_storage._failoverHistory {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}update_info\0\u{1}config\0\u{3}replication_config\0\u{3}security_token\0\u{3}delete_bad_binary\0\u{3}promote_namespace\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _updateInfo: Api.Namespace.V1.UpdateNamespaceInfo? = nil
    var _config: Api.Namespace.V1.NamespaceConfig? = nil
    var _replicationConfig: Api.Replication.V1.NamespaceReplicationConfig? = nil
    var _securityToken: String = String()
    var _deleteBadBinary: String = String()
    var _promoteNamespace: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _updateInfo = source._updateInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _securityToken = source._securityToken
      _deleteBadBinary = source._deleteBadBinary
      _promoteNamespace = source._promoteNamespace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._updateInfo) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._securityToken) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._deleteBadBinary) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._promoteNamespace) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      try { if let v = _storage._updateInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._securityToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._securityToken, fieldNumber: 5)
      }
      if !_storage._deleteBadBinary.isEmpty {
        try visitor.visitSingularStringField(value: _storage._deleteBadBinary, fieldNumber: 6)
      }
      if _storage._promoteNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._promoteNamespace, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateNamespaceRequest, rhs: Api.Workflowservice.V1.UpdateNamespaceRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._updateInfo != rhs_storage._updateInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._securityToken != rhs_storage._securityToken {return false}
        if _storage._deleteBadBinary != rhs_storage._deleteBadBinary {return false}
        if _storage._promoteNamespace != rhs_storage._promoteNamespace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}namespace_info\0\u{1}config\0\u{3}replication_config\0\u{3}failover_version\0\u{3}is_global_namespace\0")

  fileprivate class _StorageClass {
    var _namespaceInfo: Api.Namespace.V1.NamespaceInfo? = nil
    var _config: Api.Namespace.V1.NamespaceConfig? = nil
    var _replicationConfig: Api.Replication.V1.NamespaceReplicationConfig? = nil
    var _failoverVersion: Int64 = 0
    var _isGlobalNamespace: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespaceInfo = source._namespaceInfo
      _config = source._config
      _replicationConfig = source._replicationConfig
      _failoverVersion = source._failoverVersion
      _isGlobalNamespace = source._isGlobalNamespace
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._namespaceInfo) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._replicationConfig) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._failoverVersion) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isGlobalNamespace) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._namespaceInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._replicationConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._failoverVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failoverVersion, fieldNumber: 4)
      }
      if _storage._isGlobalNamespace != false {
        try visitor.visitSingularBoolField(value: _storage._isGlobalNamespace, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateNamespaceResponse, rhs: Api.Workflowservice.V1.UpdateNamespaceResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespaceInfo != rhs_storage._namespaceInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._replicationConfig != rhs_storage._replicationConfig {return false}
        if _storage._failoverVersion != rhs_storage._failoverVersion {return false}
        if _storage._isGlobalNamespace != rhs_storage._isGlobalNamespace {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeprecateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeprecateNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}security_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.securityToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.securityToken.isEmpty {
      try visitor.visitSingularStringField(value: self.securityToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeprecateNamespaceRequest, rhs: Api.Workflowservice.V1.DeprecateNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.securityToken != rhs.securityToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeprecateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeprecateNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeprecateNamespaceResponse, rhs: Api.Workflowservice.V1.DeprecateNamespaceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}identity\0\u{3}request_id\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}request_eager_execution\0\u{3}continued_failure\0\u{3}last_completion_result\0\u{3}workflow_start_delay\0\u{3}completion_callbacks\0\u{3}workflow_id_conflict_policy\0\u{3}user_metadata\0\u{1}links\0\u{3}versioning_override\0\u{3}on_conflict_options\0\u{1}priority\0\u{3}eager_worker_deployment_options\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _identity: String = String()
    var _requestID: String = String()
    var _workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy = .unspecified
    var _workflowIDConflictPolicy: Api.Enums.V1.WorkflowIdConflictPolicy = .unspecified
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _header: Api.Common.V1.Header? = nil
    var _requestEagerExecution: Bool = false
    var _continuedFailure: Api.Failure.V1.Failure? = nil
    var _lastCompletionResult: Api.Common.V1.Payloads? = nil
    var _workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _completionCallbacks: [Api.Common.V1.Callback] = []
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _links: [Api.Common.V1.Link] = []
    var _versioningOverride: Api.Workflow.V1.VersioningOverride? = nil
    var _onConflictOptions: Api.Workflow.V1.OnConflictOptions? = nil
    var _priority: Api.Common.V1.Priority? = nil
    var _eagerWorkerDeploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _identity = source._identity
      _requestID = source._requestID
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _workflowIDConflictPolicy = source._workflowIDConflictPolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _requestEagerExecution = source._requestEagerExecution
      _continuedFailure = source._continuedFailure
      _lastCompletionResult = source._lastCompletionResult
      _workflowStartDelay = source._workflowStartDelay
      _completionCallbacks = source._completionCallbacks
      _userMetadata = source._userMetadata
      _links = source._links
      _versioningOverride = source._versioningOverride
      _onConflictOptions = source._onConflictOptions
      _priority = source._priority
      _eagerWorkerDeploymentOptions = source._eagerWorkerDeploymentOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._requestEagerExecution) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._continuedFailure) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._workflowStartDelay) }()
        case 21: try { try decoder.decodeRepeatedMessageField(value: &_storage._completionCallbacks) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDConflictPolicy) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._onConflictOptions) }()
        case 27: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 28: try { try decoder.decodeSingularMessageField(value: &_storage._eagerWorkerDeploymentOptions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 9)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 13)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._requestEagerExecution != false {
        try visitor.visitSingularBoolField(value: _storage._requestEagerExecution, fieldNumber: 17)
      }
      try { if let v = _storage._continuedFailure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._workflowStartDelay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if !_storage._completionCallbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._completionCallbacks, fieldNumber: 21)
      }
      if _storage._workflowIDConflictPolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDConflictPolicy, fieldNumber: 22)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 24)
      }
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._onConflictOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      } }()
      try { if let v = _storage._eagerWorkerDeploymentOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.StartWorkflowExecutionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._workflowIDConflictPolicy != rhs_storage._workflowIDConflictPolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._requestEagerExecution != rhs_storage._requestEagerExecution {return false}
        if _storage._continuedFailure != rhs_storage._continuedFailure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._workflowStartDelay != rhs_storage._workflowStartDelay {return false}
        if _storage._completionCallbacks != rhs_storage._completionCallbacks {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._onConflictOptions != rhs_storage._onConflictOptions {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._eagerWorkerDeploymentOptions != rhs_storage._eagerWorkerDeploymentOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{3}eager_workflow_task\0\u{1}started\0\u{1}link\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._eagerWorkflowTask) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._link) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try { if let v = self._eagerWorkflowTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 3)
    }
    try { if let v = self._link {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.status != .unspecified {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.StartWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.started != rhs.started {return false}
    if lhs.status != rhs.status {return false}
    if lhs._eagerWorkflowTask != rhs._eagerWorkflowTask {return false}
    if lhs._link != rhs._link {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkflowExecutionHistoryRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}wait_new_event\0\u{3}history_event_filter_type\0\u{3}skip_archival\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.waitNewEvent) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.historyEventFilterType) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.skipArchival) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 3)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    if self.waitNewEvent != false {
      try visitor.visitSingularBoolField(value: self.waitNewEvent, fieldNumber: 5)
    }
    if self.historyEventFilterType != .unspecified {
      try visitor.visitSingularEnumField(value: self.historyEventFilterType, fieldNumber: 6)
    }
    if self.skipArchival != false {
      try visitor.visitSingularBoolField(value: self.skipArchival, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryRequest, rhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.waitNewEvent != rhs.waitNewEvent {return false}
    if lhs.historyEventFilterType != rhs.historyEventFilterType {return false}
    if lhs.skipArchival != rhs.skipArchival {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkflowExecutionHistoryResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}history\0\u{3}raw_history\0\u{3}next_page_token\0\u{1}archived\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rawHistory) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.archived) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.rawHistory.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawHistory, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if self.archived != false {
      try visitor.visitSingularBoolField(value: self.archived, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryResponse, rhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryResponse) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.rawHistory != rhs.rawHistory {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.archived != rhs.archived {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryReverseRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}maximum_page_size\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 3)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseRequest, rhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkflowExecutionHistoryReverseResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}history\0\u{4}\u{2}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseResponse, rhs: Api.Workflowservice.V1.GetWorkflowExecutionHistoryReverseResponse) -> Bool {
    if lhs._history != rhs._history {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollWorkflowTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollWorkflowTaskQueueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{1}identity\0\u{3}binary_checksum\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 4)
    }
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollWorkflowTaskQueueRequest, rhs: Api.Workflowservice.V1.PollWorkflowTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollWorkflowTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollWorkflowTaskQueueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}previous_started_event_id\0\u{3}started_event_id\0\u{1}attempt\0\u{3}backlog_count_hint\0\u{1}history\0\u{3}next_page_token\0\u{1}query\0\u{3}workflow_execution_task_queue\0\u{3}scheduled_time\0\u{3}started_time\0\u{1}queries\0\u{1}messages\0\u{3}poller_scaling_decision\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _previousStartedEventID: Int64 = 0
    var _startedEventID: Int64 = 0
    var _attempt: Int32 = 0
    var _backlogCountHint: Int64 = 0
    var _history: Api.History.V1.History? = nil
    var _nextPageToken: Data = Data()
    var _query: Api.Query.V1.WorkflowQuery? = nil
    var _workflowExecutionTaskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _queries: Dictionary<String,Api.Query.V1.WorkflowQuery> = [:]
    var _messages: [Api.`Protocol`.V1.Message] = []
    var _pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _workflowExecution = source._workflowExecution
      _workflowType = source._workflowType
      _previousStartedEventID = source._previousStartedEventID
      _startedEventID = source._startedEventID
      _attempt = source._attempt
      _backlogCountHint = source._backlogCountHint
      _history = source._history
      _nextPageToken = source._nextPageToken
      _query = source._query
      _workflowExecutionTaskQueue = source._workflowExecutionTaskQueue
      _scheduledTime = source._scheduledTime
      _startedTime = source._startedTime
      _queries = source._queries
      _messages = source._messages
      _pollerScalingDecision = source._pollerScalingDecision
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularInt64Field(value: &_storage._previousStartedEventID) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._startedEventID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._backlogCountHint) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._history) }()
        case 9: try { try decoder.decodeSingularBytesField(value: &_storage._nextPageToken) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._query) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTaskQueue) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 14: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Query.V1.WorkflowQuery>.self, value: &_storage._queries) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._messages) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._pollerScalingDecision) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if _storage._previousStartedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._previousStartedEventID, fieldNumber: 4)
      }
      if _storage._startedEventID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._startedEventID, fieldNumber: 5)
      }
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 6)
      }
      if _storage._backlogCountHint != 0 {
        try visitor.visitSingularInt64Field(value: _storage._backlogCountHint, fieldNumber: 7)
      }
      try { if let v = _storage._history {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._nextPageToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._nextPageToken, fieldNumber: 9)
      }
      try { if let v = _storage._query {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._workflowExecutionTaskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._queries.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Query.V1.WorkflowQuery>.self, value: _storage._queries, fieldNumber: 14)
      }
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 15)
      }
      try { if let v = _storage._pollerScalingDecision {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse, rhs: Api.Workflowservice.V1.PollWorkflowTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._previousStartedEventID != rhs_storage._previousStartedEventID {return false}
        if _storage._startedEventID != rhs_storage._startedEventID {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._backlogCountHint != rhs_storage._backlogCountHint {return false}
        if _storage._history != rhs_storage._history {return false}
        if _storage._nextPageToken != rhs_storage._nextPageToken {return false}
        if _storage._query != rhs_storage._query {return false}
        if _storage._workflowExecutionTaskQueue != rhs_storage._workflowExecutionTaskQueue {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._queries != rhs_storage._queries {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._pollerScalingDecision != rhs_storage._pollerScalingDecision {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskCompletedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}commands\0\u{1}identity\0\u{3}sticky_attributes\0\u{3}return_new_workflow_task\0\u{3}force_create_new_workflow_task\0\u{3}binary_checksum\0\u{3}query_results\0\u{1}namespace\0\u{3}worker_version_stamp\0\u{1}messages\0\u{3}sdk_metadata\0\u{3}metering_metadata\0\u{1}capabilities\0\u{1}deployment\0\u{3}versioning_behavior\0\u{3}deployment_options\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _commands: [Api.Command.V1.Command] = []
    var _identity: String = String()
    var _stickyAttributes: Api.Taskqueue.V1.StickyExecutionAttributes? = nil
    var _returnNewWorkflowTask: Bool = false
    var _forceCreateNewWorkflowTask: Bool = false
    var _binaryChecksum: String = String()
    var _queryResults: Dictionary<String,Api.Query.V1.WorkflowQueryResult> = [:]
    var _namespace: String = String()
    var _workerVersionStamp: Api.Common.V1.WorkerVersionStamp? = nil
    var _messages: [Api.`Protocol`.V1.Message] = []
    var _sdkMetadata: Api.Sdk.V1.WorkflowTaskCompletedMetadata? = nil
    var _meteringMetadata: Api.Common.V1.MeteringMetadata? = nil
    var _capabilities: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities? = nil
    var _deployment: Api.Deployment.V1.Deployment? = nil
    var _versioningBehavior: Api.Enums.V1.VersioningBehavior = .unspecified
    var _deploymentOptions: Api.Deployment.V1.WorkerDeploymentOptions? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _commands = source._commands
      _identity = source._identity
      _stickyAttributes = source._stickyAttributes
      _returnNewWorkflowTask = source._returnNewWorkflowTask
      _forceCreateNewWorkflowTask = source._forceCreateNewWorkflowTask
      _binaryChecksum = source._binaryChecksum
      _queryResults = source._queryResults
      _namespace = source._namespace
      _workerVersionStamp = source._workerVersionStamp
      _messages = source._messages
      _sdkMetadata = source._sdkMetadata
      _meteringMetadata = source._meteringMetadata
      _capabilities = source._capabilities
      _deployment = source._deployment
      _versioningBehavior = source._versioningBehavior
      _deploymentOptions = source._deploymentOptions
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._commands) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._stickyAttributes) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._returnNewWorkflowTask) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._forceCreateNewWorkflowTask) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._binaryChecksum) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Query.V1.WorkflowQueryResult>.self, value: &_storage._queryResults) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._workerVersionStamp) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._messages) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._sdkMetadata) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._meteringMetadata) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._capabilities) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._deployment) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._versioningBehavior) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._deploymentOptions) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      if !_storage._commands.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._commands, fieldNumber: 2)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 3)
      }
      try { if let v = _storage._stickyAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._returnNewWorkflowTask != false {
        try visitor.visitSingularBoolField(value: _storage._returnNewWorkflowTask, fieldNumber: 5)
      }
      if _storage._forceCreateNewWorkflowTask != false {
        try visitor.visitSingularBoolField(value: _storage._forceCreateNewWorkflowTask, fieldNumber: 6)
      }
      if !_storage._binaryChecksum.isEmpty {
        try visitor.visitSingularStringField(value: _storage._binaryChecksum, fieldNumber: 7)
      }
      if !_storage._queryResults.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Query.V1.WorkflowQueryResult>.self, value: _storage._queryResults, fieldNumber: 8)
      }
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 9)
      }
      try { if let v = _storage._workerVersionStamp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._messages.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messages, fieldNumber: 11)
      }
      try { if let v = _storage._sdkMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._meteringMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._deployment {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._versioningBehavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._versioningBehavior, fieldNumber: 16)
      }
      try { if let v = _storage._deploymentOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest, rhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._commands != rhs_storage._commands {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._stickyAttributes != rhs_storage._stickyAttributes {return false}
        if _storage._returnNewWorkflowTask != rhs_storage._returnNewWorkflowTask {return false}
        if _storage._forceCreateNewWorkflowTask != rhs_storage._forceCreateNewWorkflowTask {return false}
        if _storage._binaryChecksum != rhs_storage._binaryChecksum {return false}
        if _storage._queryResults != rhs_storage._queryResults {return false}
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workerVersionStamp != rhs_storage._workerVersionStamp {return false}
        if _storage._messages != rhs_storage._messages {return false}
        if _storage._sdkMetadata != rhs_storage._sdkMetadata {return false}
        if _storage._meteringMetadata != rhs_storage._meteringMetadata {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._deployment != rhs_storage._deployment {return false}
        if _storage._versioningBehavior != rhs_storage._versioningBehavior {return false}
        if _storage._deploymentOptions != rhs_storage._deploymentOptions {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.protoMessageName + ".Capabilities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}discard_speculative_workflow_task_with_events\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.discardSpeculativeWorkflowTaskWithEvents) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.discardSpeculativeWorkflowTaskWithEvents != false {
      try visitor.visitSingularBoolField(value: self.discardSpeculativeWorkflowTaskWithEvents, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities, rhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedRequest.Capabilities) -> Bool {
    if lhs.discardSpeculativeWorkflowTaskWithEvents != rhs.discardSpeculativeWorkflowTaskWithEvents {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondWorkflowTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskCompletedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_task\0\u{3}activity_tasks\0\u{3}reset_history_event_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowTask) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.activityTasks) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.resetHistoryEventID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowTask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.activityTasks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityTasks, fieldNumber: 2)
    }
    if self.resetHistoryEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.resetHistoryEventID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedResponse, rhs: Api.Workflowservice.V1.RespondWorkflowTaskCompletedResponse) -> Bool {
    if lhs._workflowTask != rhs._workflowTask {return false}
    if lhs.activityTasks != rhs.activityTasks {return false}
    if lhs.resetHistoryEventID != rhs.resetHistoryEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondWorkflowTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskFailedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}cause\0\u{1}failure\0\u{1}identity\0\u{3}binary_checksum\0\u{1}namespace\0\u{1}messages\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.binaryChecksum) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 2)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.binaryChecksum.isEmpty {
      try visitor.visitSingularStringField(value: self.binaryChecksum, fieldNumber: 5)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 6)
    }
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 7)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondWorkflowTaskFailedRequest, rhs: Api.Workflowservice.V1.RespondWorkflowTaskFailedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.binaryChecksum != rhs.binaryChecksum {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.messages != rhs.messages {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondWorkflowTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondWorkflowTaskFailedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondWorkflowTaskFailedResponse, rhs: Api.Workflowservice.V1.RespondWorkflowTaskFailedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollActivityTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollActivityTaskQueueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{1}identity\0\u{3}task_queue_metadata\0\u{3}worker_version_capabilities\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._taskQueueMetadata) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._taskQueueMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollActivityTaskQueueRequest, rhs: Api.Workflowservice.V1.PollActivityTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._taskQueueMetadata != rhs._taskQueueMetadata {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollActivityTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollActivityTaskQueueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}workflow_namespace\0\u{3}workflow_type\0\u{3}workflow_execution\0\u{3}activity_type\0\u{3}activity_id\0\u{1}header\0\u{1}input\0\u{3}heartbeat_details\0\u{3}scheduled_time\0\u{3}current_attempt_scheduled_time\0\u{3}started_time\0\u{1}attempt\0\u{3}schedule_to_close_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}poller_scaling_decision\0\u{1}priority\0\u{3}activity_run_id\0")

  fileprivate class _StorageClass {
    var _taskToken: Data = Data()
    var _workflowNamespace: String = String()
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    var _activityType: Api.Common.V1.ActivityType? = nil
    var _activityID: String = String()
    var _header: Api.Common.V1.Header? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _heartbeatDetails: Api.Common.V1.Payloads? = nil
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: Int32 = 0
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _pollerScalingDecision: Api.Taskqueue.V1.PollerScalingDecision? = nil
    var _priority: Api.Common.V1.Priority? = nil
    var _activityRunID: String = String()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _taskToken = source._taskToken
      _workflowNamespace = source._workflowNamespace
      _workflowType = source._workflowType
      _workflowExecution = source._workflowExecution
      _activityType = source._activityType
      _activityID = source._activityID
      _header = source._header
      _input = source._input
      _heartbeatDetails = source._heartbeatDetails
      _scheduledTime = source._scheduledTime
      _currentAttemptScheduledTime = source._currentAttemptScheduledTime
      _startedTime = source._startedTime
      _attempt = source._attempt
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _pollerScalingDecision = source._pollerScalingDecision
      _priority = source._priority
      _activityRunID = source._activityRunID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._taskToken) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowNamespace) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatDetails) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._currentAttemptScheduledTime) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 13: try { try decoder.decodeSingularInt32Field(value: &_storage._attempt) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._pollerScalingDecision) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._activityRunID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._taskToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._taskToken, fieldNumber: 1)
      }
      if !_storage._workflowNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowNamespace, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 6)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._heartbeatDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._currentAttemptScheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularInt32Field(value: _storage._attempt, fieldNumber: 13)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._pollerScalingDecision {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      if !_storage._activityRunID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityRunID, fieldNumber: 20)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollActivityTaskQueueResponse, rhs: Api.Workflowservice.V1.PollActivityTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._taskToken != rhs_storage._taskToken {return false}
        if _storage._workflowNamespace != rhs_storage._workflowNamespace {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._currentAttemptScheduledTime != rhs_storage._currentAttemptScheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._pollerScalingDecision != rhs_storage._pollerScalingDecision {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._activityRunID != rhs_storage._activityRunID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordActivityTaskHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}details\0\u{1}identity\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatRequest, rhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordActivityTaskHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cancel_requested\0\u{3}activity_paused\0\u{3}activity_reset\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.activityPaused) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityReset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 1)
    }
    if self.activityPaused != false {
      try visitor.visitSingularBoolField(value: self.activityPaused, fieldNumber: 2)
    }
    if self.activityReset != false {
      try visitor.visitSingularBoolField(value: self.activityReset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatResponse, rhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatResponse) -> Bool {
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs.activityPaused != rhs.activityPaused {return false}
    if lhs.activityReset != rhs.activityReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatByIdRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}details\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdRequest, rhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordActivityTaskHeartbeatByIdResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}cancel_requested\0\u{3}activity_paused\0\u{3}activity_reset\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.cancelRequested) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.activityPaused) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityReset) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cancelRequested != false {
      try visitor.visitSingularBoolField(value: self.cancelRequested, fieldNumber: 1)
    }
    if self.activityPaused != false {
      try visitor.visitSingularBoolField(value: self.activityPaused, fieldNumber: 2)
    }
    if self.activityReset != false {
      try visitor.visitSingularBoolField(value: self.activityReset, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdResponse, rhs: Api.Workflowservice.V1.RecordActivityTaskHeartbeatByIdResponse) -> Bool {
    if lhs.cancelRequested != rhs.cancelRequested {return false}
    if lhs.activityPaused != rhs.activityPaused {return false}
    if lhs.activityReset != rhs.activityReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}result\0\u{1}identity\0\u{1}namespace\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCompletedRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskCompletedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._result != rhs._result {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCompletedResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCompletedByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedByIdRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}result\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCompletedByIdRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskCompletedByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._result != rhs._result {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCompletedByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCompletedByIdResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCompletedByIdResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskCompletedByIdResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}failure\0\u{1}identity\0\u{1}namespace\0\u{3}last_heartbeat_details\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskFailedRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskFailedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskFailedResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskFailedResponse) -> Bool {
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskFailedByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedByIdRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}failure\0\u{1}identity\0\u{3}last_heartbeat_details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskFailedByIdRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskFailedByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskFailedByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskFailedByIdResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failures\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.failures) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.failures.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.failures, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskFailedByIdResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskFailedByIdResponse) -> Bool {
    if lhs.failures != rhs.failures {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCanceledRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}details\0\u{1}identity\0\u{1}namespace\0\u{3}worker_version\0\u{1}deployment\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerVersion) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try { if let v = self._workerVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCanceledRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskCanceledRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workerVersion != rhs._workerVersion {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCanceledResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCanceledResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskCanceledResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCanceledByIdRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledByIdRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{3}activity_id\0\u{1}details\0\u{1}identity\0\u{3}deployment_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 4)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCanceledByIdRequest, rhs: Api.Workflowservice.V1.RespondActivityTaskCanceledByIdRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondActivityTaskCanceledByIdResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondActivityTaskCanceledByIdResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondActivityTaskCanceledByIdResponse, rhs: Api.Workflowservice.V1.RespondActivityTaskCanceledByIdResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RequestCancelWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCancelWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}identity\0\u{3}request_id\0\u{3}first_execution_run_id\0\u{1}reason\0\u{1}links\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RequestCancelWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.RequestCancelWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RequestCancelWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCancelWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RequestCancelWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.RequestCancelWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SignalWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}signal_name\0\u{1}input\0\u{1}identity\0\u{3}request_id\0\u{1}control\0\u{1}header\0\u{2}\u{2}links\0\u{c}\u{9}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 7)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SignalWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.SignalWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.control != rhs.control {return false}
    if lhs._header != rhs._header {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SignalWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SignalWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.SignalWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SignalWithStartWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalWithStartWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{1}identity\0\u{3}request_id\0\u{3}workflow_id_reuse_policy\0\u{3}signal_name\0\u{3}signal_input\0\u{1}control\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}memo\0\u{3}search_attributes\0\u{1}header\0\u{3}workflow_start_delay\0\u{4}\u{2}workflow_id_conflict_policy\0\u{3}user_metadata\0\u{1}links\0\u{3}versioning_override\0\u{1}priority\0\u{c}\u{15}\u{1}")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _identity: String = String()
    var _requestID: String = String()
    var _workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy = .unspecified
    var _workflowIDConflictPolicy: Api.Enums.V1.WorkflowIdConflictPolicy = .unspecified
    var _signalName: String = String()
    var _signalInput: Api.Common.V1.Payloads? = nil
    var _control: String = String()
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _header: Api.Common.V1.Header? = nil
    var _workflowStartDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _links: [Api.Common.V1.Link] = []
    var _versioningOverride: Api.Workflow.V1.VersioningOverride? = nil
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _identity = source._identity
      _requestID = source._requestID
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _workflowIDConflictPolicy = source._workflowIDConflictPolicy
      _signalName = source._signalName
      _signalInput = source._signalInput
      _control = source._control
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _header = source._header
      _workflowStartDelay = source._workflowStartDelay
      _userMetadata = source._userMetadata
      _links = source._links
      _versioningOverride = source._versioningOverride
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._signalName) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._signalInput) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._control) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._workflowStartDelay) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDConflictPolicy) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 24: try { try decoder.decodeRepeatedMessageField(value: &_storage._links) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._versioningOverride) }()
        case 26: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 9)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      if !_storage._signalName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._signalName, fieldNumber: 12)
      }
      try { if let v = _storage._signalInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if !_storage._control.isEmpty {
        try visitor.visitSingularStringField(value: _storage._control, fieldNumber: 14)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 16)
      }
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._workflowStartDelay {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
      if _storage._workflowIDConflictPolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDConflictPolicy, fieldNumber: 22)
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      if !_storage._links.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._links, fieldNumber: 24)
      }
      try { if let v = _storage._versioningOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SignalWithStartWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.SignalWithStartWorkflowExecutionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._workflowIDConflictPolicy != rhs_storage._workflowIDConflictPolicy {return false}
        if _storage._signalName != rhs_storage._signalName {return false}
        if _storage._signalInput != rhs_storage._signalInput {return false}
        if _storage._control != rhs_storage._control {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._workflowStartDelay != rhs_storage._workflowStartDelay {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._links != rhs_storage._links {return false}
        if _storage._versioningOverride != rhs_storage._versioningOverride {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SignalWithStartWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignalWithStartWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}started\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SignalWithStartWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.SignalWithStartWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.started != rhs.started {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}reason\0\u{3}workflow_task_finish_event_id\0\u{3}request_id\0\u{3}reset_reapply_type\0\u{3}reset_reapply_exclude_types\0\u{3}post_reset_operations\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.workflowTaskFinishEventID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.resetReapplyType) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.resetReapplyExcludeTypes) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.postResetOperations) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if self.workflowTaskFinishEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.workflowTaskFinishEventID, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    if self.resetReapplyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetReapplyType, fieldNumber: 6)
    }
    if !self.resetReapplyExcludeTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.resetReapplyExcludeTypes, fieldNumber: 7)
    }
    if !self.postResetOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postResetOperations, fieldNumber: 8)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.ResetWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.workflowTaskFinishEventID != rhs.workflowTaskFinishEventID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resetReapplyType != rhs.resetReapplyType {return false}
    if lhs.resetReapplyExcludeTypes != rhs.resetReapplyExcludeTypes {return false}
    if lhs.postResetOperations != rhs.postResetOperations {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.ResetWorkflowExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TerminateWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminateWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{1}reason\0\u{1}details\0\u{1}identity\0\u{3}first_execution_run_id\0\u{1}links\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 6)
    }
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TerminateWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.TerminateWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TerminateWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminateWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TerminateWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.TerminateWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.DeleteWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.DeleteWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListOpenWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOpenWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}start_time_filter\0\u{3}execution_filter\0\u{3}type_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTimeFilter) }()
      case 5: try {
        var v: Api.Filter.V1.WorkflowExecutionFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .executionFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .executionFilter(v)
        }
      }()
      case 6: try {
        var v: Api.Filter.V1.WorkflowTypeFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .typeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .typeFilter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try { if let v = self._startTimeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.filters {
    case .executionFilter?: try {
      guard case .executionFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .typeFilter?: try {
      guard case .typeFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListOpenWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.ListOpenWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._startTimeFilter != rhs._startTimeFilter {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListOpenWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListOpenWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListOpenWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.ListOpenWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListClosedWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClosedWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{3}start_time_filter\0\u{3}execution_filter\0\u{3}type_filter\0\u{3}status_filter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTimeFilter) }()
      case 5: try {
        var v: Api.Filter.V1.WorkflowExecutionFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .executionFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .executionFilter(v)
        }
      }()
      case 6: try {
        var v: Api.Filter.V1.WorkflowTypeFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .typeFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .typeFilter(v)
        }
      }()
      case 7: try {
        var v: Api.Filter.V1.StatusFilter?
        var hadOneofValue = false
        if let current = self.filters {
          hadOneofValue = true
          if case .statusFilter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filters = .statusFilter(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try { if let v = self._startTimeFilter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    switch self.filters {
    case .executionFilter?: try {
      guard case .executionFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .typeFilter?: try {
      guard case .typeFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .statusFilter?: try {
      guard case .statusFilter(let v)? = self.filters else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListClosedWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.ListClosedWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs._startTimeFilter != rhs._startTimeFilter {return false}
    if lhs.filters != rhs.filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListClosedWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListClosedWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListClosedWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.ListClosedWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.ListWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.ListWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListArchivedWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListArchivedWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListArchivedWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.ListArchivedWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListArchivedWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListArchivedWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListArchivedWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.ListArchivedWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ScanWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScanWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ScanWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.ScanWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ScanWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ScanWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ScanWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.ScanWorkflowExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountWorkflowExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountWorkflowExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountWorkflowExecutionsRequest, rhs: Api.Workflowservice.V1.CountWorkflowExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountWorkflowExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountWorkflowExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}groups\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountWorkflowExecutionsResponse, rhs: Api.Workflowservice.V1.CountWorkflowExecutionsResponse) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountWorkflowExecutionsResponse.AggregationGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.CountWorkflowExecutionsResponse.protoMessageName + ".AggregationGroup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_values\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupValues, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountWorkflowExecutionsResponse.AggregationGroup, rhs: Api.Workflowservice.V1.CountWorkflowExecutionsResponse.AggregationGroup) -> Bool {
    if lhs.groupValues != rhs.groupValues {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetSearchAttributesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSearchAttributesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetSearchAttributesRequest, rhs: Api.Workflowservice.V1.GetSearchAttributesRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetSearchAttributesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSearchAttributesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}keys\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: &self.keys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keys.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufEnumMap<SwiftProtobuf.ProtobufString,Api.Enums.V1.IndexedValueType>.self, value: self.keys, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetSearchAttributesResponse, rhs: Api.Workflowservice.V1.GetSearchAttributesResponse) -> Bool {
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondQueryTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondQueryTaskCompletedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{3}completed_type\0\u{3}query_result\0\u{3}error_message\0\u{2}\u{2}namespace\0\u{1}failure\0\u{1}cause\0\u{c}\u{5}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.completedType) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.completedType != .unspecified {
      try visitor.visitSingularEnumField(value: self.completedType, fieldNumber: 2)
    }
    try { if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 4)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 6)
    }
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.cause != .unspecified {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondQueryTaskCompletedRequest, rhs: Api.Workflowservice.V1.RespondQueryTaskCompletedRequest) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.completedType != rhs.completedType {return false}
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondQueryTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondQueryTaskCompletedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondQueryTaskCompletedResponse, rhs: Api.Workflowservice.V1.RespondQueryTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetStickyTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetStickyTaskQueueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetStickyTaskQueueRequest, rhs: Api.Workflowservice.V1.ResetStickyTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetStickyTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetStickyTaskQueueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetStickyTaskQueueResponse, rhs: Api.Workflowservice.V1.ResetStickyTaskQueueResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ShutdownWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShutdownWorkerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}sticky_task_queue\0\u{1}identity\0\u{1}reason\0\u{3}worker_heartbeat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.stickyTaskQueue) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._workerHeartbeat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.stickyTaskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.stickyTaskQueue, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 4)
    }
    try { if let v = self._workerHeartbeat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ShutdownWorkerRequest, rhs: Api.Workflowservice.V1.ShutdownWorkerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.stickyTaskQueue != rhs.stickyTaskQueue {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._workerHeartbeat != rhs._workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ShutdownWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ShutdownWorkerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ShutdownWorkerResponse, rhs: Api.Workflowservice.V1.ShutdownWorkerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.QueryWorkflowRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWorkflowRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}query\0\u{3}query_reject_condition\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._query) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.queryRejectCondition) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._query {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.queryRejectCondition != .unspecified {
      try visitor.visitSingularEnumField(value: self.queryRejectCondition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.QueryWorkflowRequest, rhs: Api.Workflowservice.V1.QueryWorkflowRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs._query != rhs._query {return false}
    if lhs.queryRejectCondition != rhs.queryRejectCondition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.QueryWorkflowResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".QueryWorkflowResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}query_result\0\u{3}query_rejected\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._queryResult) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._queryRejected) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._queryResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._queryRejected {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.QueryWorkflowResponse, rhs: Api.Workflowservice.V1.QueryWorkflowResponse) -> Bool {
    if lhs._queryResult != rhs._queryResult {return false}
    if lhs._queryRejected != rhs._queryRejected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.DescribeWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}execution_config\0\u{3}workflow_execution_info\0\u{3}pending_activities\0\u{3}pending_children\0\u{3}pending_workflow_task\0\u{1}callbacks\0\u{3}pending_nexus_operations\0\u{3}workflow_extended_info\0")

  fileprivate class _StorageClass {
    var _executionConfig: Api.Workflow.V1.WorkflowExecutionConfig? = nil
    var _workflowExecutionInfo: Api.Workflow.V1.WorkflowExecutionInfo? = nil
    var _pendingActivities: [Api.Workflow.V1.PendingActivityInfo] = []
    var _pendingChildren: [Api.Workflow.V1.PendingChildExecutionInfo] = []
    var _pendingWorkflowTask: Api.Workflow.V1.PendingWorkflowTaskInfo? = nil
    var _callbacks: [Api.Workflow.V1.CallbackInfo] = []
    var _pendingNexusOperations: [Api.Workflow.V1.PendingNexusOperationInfo] = []
    var _workflowExtendedInfo: Api.Workflow.V1.WorkflowExecutionExtendedInfo? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _executionConfig = source._executionConfig
      _workflowExecutionInfo = source._workflowExecutionInfo
      _pendingActivities = source._pendingActivities
      _pendingChildren = source._pendingChildren
      _pendingWorkflowTask = source._pendingWorkflowTask
      _callbacks = source._callbacks
      _pendingNexusOperations = source._pendingNexusOperations
      _workflowExtendedInfo = source._workflowExtendedInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._executionConfig) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionInfo) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingActivities) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingChildren) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._pendingWorkflowTask) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._callbacks) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._pendingNexusOperations) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExtendedInfo) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._executionConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._workflowExecutionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._pendingActivities.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingActivities, fieldNumber: 3)
      }
      if !_storage._pendingChildren.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingChildren, fieldNumber: 4)
      }
      try { if let v = _storage._pendingWorkflowTask {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if !_storage._callbacks.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._callbacks, fieldNumber: 6)
      }
      if !_storage._pendingNexusOperations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pendingNexusOperations, fieldNumber: 7)
      }
      try { if let v = _storage._workflowExtendedInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.DescribeWorkflowExecutionResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._executionConfig != rhs_storage._executionConfig {return false}
        if _storage._workflowExecutionInfo != rhs_storage._workflowExecutionInfo {return false}
        if _storage._pendingActivities != rhs_storage._pendingActivities {return false}
        if _storage._pendingChildren != rhs_storage._pendingChildren {return false}
        if _storage._pendingWorkflowTask != rhs_storage._pendingWorkflowTask {return false}
        if _storage._callbacks != rhs_storage._callbacks {return false}
        if _storage._pendingNexusOperations != rhs_storage._pendingNexusOperations {return false}
        if _storage._workflowExtendedInfo != rhs_storage._workflowExtendedInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeTaskQueueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}task_queue_type\0\u{3}include_task_queue_status\0\u{3}api_mode\0\u{1}versions\0\u{3}task_queue_types\0\u{3}report_stats\0\u{3}report_pollers\0\u{3}report_task_reachability\0\u{3}report_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.taskQueueType) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeTaskQueueStatus) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.apiMode) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._versions) }()
      case 7: try { try decoder.decodeRepeatedEnumField(value: &self.taskQueueTypes) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.reportStats) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.reportPollers) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.reportTaskReachability) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.reportConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.taskQueueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskQueueType, fieldNumber: 3)
    }
    if self.includeTaskQueueStatus != false {
      try visitor.visitSingularBoolField(value: self.includeTaskQueueStatus, fieldNumber: 4)
    }
    if self.apiMode != .unspecified {
      try visitor.visitSingularEnumField(value: self.apiMode, fieldNumber: 5)
    }
    try { if let v = self._versions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.taskQueueTypes.isEmpty {
      try visitor.visitPackedEnumField(value: self.taskQueueTypes, fieldNumber: 7)
    }
    if self.reportStats != false {
      try visitor.visitSingularBoolField(value: self.reportStats, fieldNumber: 8)
    }
    if self.reportPollers != false {
      try visitor.visitSingularBoolField(value: self.reportPollers, fieldNumber: 9)
    }
    if self.reportTaskReachability != false {
      try visitor.visitSingularBoolField(value: self.reportTaskReachability, fieldNumber: 10)
    }
    if self.reportConfig != false {
      try visitor.visitSingularBoolField(value: self.reportConfig, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeTaskQueueRequest, rhs: Api.Workflowservice.V1.DescribeTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.taskQueueType != rhs.taskQueueType {return false}
    if lhs.reportStats != rhs.reportStats {return false}
    if lhs.reportConfig != rhs.reportConfig {return false}
    if lhs.includeTaskQueueStatus != rhs.includeTaskQueueStatus {return false}
    if lhs.apiMode != rhs.apiMode {return false}
    if lhs._versions != rhs._versions {return false}
    if lhs.taskQueueTypes != rhs.taskQueueTypes {return false}
    if lhs.reportPollers != rhs.reportPollers {return false}
    if lhs.reportTaskReachability != rhs.reportTaskReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeTaskQueueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pollers\0\u{3}task_queue_status\0\u{3}versions_info\0\u{3}versioning_info\0\u{1}stats\0\u{1}config\0\u{3}effective_rate_limit\0\u{3}stats_by_priority_key\0")

  fileprivate class _StorageClass {
    var _pollers: [Api.Taskqueue.V1.PollerInfo] = []
    var _stats: Api.Taskqueue.V1.TaskQueueStats? = nil
    var _statsByPriorityKey: Dictionary<Int32,Api.Taskqueue.V1.TaskQueueStats> = [:]
    var _versioningInfo: Api.Taskqueue.V1.TaskQueueVersioningInfo? = nil
    var _config: Api.Taskqueue.V1.TaskQueueConfig? = nil
    var _effectiveRateLimit: Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit? = nil
    var _taskQueueStatus: Api.Taskqueue.V1.TaskQueueStatus? = nil
    var _versionsInfo: Dictionary<String,Api.Taskqueue.V1.TaskQueueVersionInfo> = [:]

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _pollers = source._pollers
      _stats = source._stats
      _statsByPriorityKey = source._statsByPriorityKey
      _versioningInfo = source._versioningInfo
      _config = source._config
      _effectiveRateLimit = source._effectiveRateLimit
      _taskQueueStatus = source._taskQueueStatus
      _versionsInfo = source._versionsInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeRepeatedMessageField(value: &_storage._pollers) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueueStatus) }()
        case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Taskqueue.V1.TaskQueueVersionInfo>.self, value: &_storage._versionsInfo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._versioningInfo) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stats) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._config) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._effectiveRateLimit) }()
        case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueStats>.self, value: &_storage._statsByPriorityKey) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._pollers.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._pollers, fieldNumber: 1)
      }
      try { if let v = _storage._taskQueueStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._versionsInfo.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Taskqueue.V1.TaskQueueVersionInfo>.self, value: _storage._versionsInfo, fieldNumber: 3)
      }
      try { if let v = _storage._versioningInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._stats {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._config {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._effectiveRateLimit {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._statsByPriorityKey.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueStats>.self, value: _storage._statsByPriorityKey, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeTaskQueueResponse, rhs: Api.Workflowservice.V1.DescribeTaskQueueResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._pollers != rhs_storage._pollers {return false}
        if _storage._stats != rhs_storage._stats {return false}
        if _storage._statsByPriorityKey != rhs_storage._statsByPriorityKey {return false}
        if _storage._versioningInfo != rhs_storage._versioningInfo {return false}
        if _storage._config != rhs_storage._config {return false}
        if _storage._effectiveRateLimit != rhs_storage._effectiveRateLimit {return false}
        if _storage._taskQueueStatus != rhs_storage._taskQueueStatus {return false}
        if _storage._versionsInfo != rhs_storage._versionsInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.DescribeTaskQueueResponse.protoMessageName + ".EffectiveRateLimit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}requests_per_second\0\u{3}rate_limit_source\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.requestsPerSecond) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.rateLimitSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestsPerSecond.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.requestsPerSecond, fieldNumber: 1)
    }
    if self.rateLimitSource != .unspecified {
      try visitor.visitSingularEnumField(value: self.rateLimitSource, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit, rhs: Api.Workflowservice.V1.DescribeTaskQueueResponse.EffectiveRateLimit) -> Bool {
    if lhs.requestsPerSecond != rhs.requestsPerSecond {return false}
    if lhs.rateLimitSource != rhs.rateLimitSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetClusterInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClusterInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetClusterInfoRequest, rhs: Api.Workflowservice.V1.GetClusterInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetClusterInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetClusterInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}supported_clients\0\u{3}server_version\0\u{3}cluster_id\0\u{3}version_info\0\u{3}cluster_name\0\u{3}history_shard_count\0\u{3}persistence_store\0\u{3}visibility_store\0\u{3}initial_failover_version\0\u{3}failover_version_increment\0")

  fileprivate class _StorageClass {
    var _supportedClients: Dictionary<String,String> = [:]
    var _serverVersion: String = String()
    var _clusterID: String = String()
    var _versionInfo: Api.Version.V1.VersionInfo? = nil
    var _clusterName: String = String()
    var _historyShardCount: Int32 = 0
    var _persistenceStore: String = String()
    var _visibilityStore: String = String()
    var _initialFailoverVersion: Int64 = 0
    var _failoverVersionIncrement: Int64 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _supportedClients = source._supportedClients
      _serverVersion = source._serverVersion
      _clusterID = source._clusterID
      _versionInfo = source._versionInfo
      _clusterName = source._clusterName
      _historyShardCount = source._historyShardCount
      _persistenceStore = source._persistenceStore
      _visibilityStore = source._visibilityStore
      _initialFailoverVersion = source._initialFailoverVersion
      _failoverVersionIncrement = source._failoverVersionIncrement
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._supportedClients) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._serverVersion) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._clusterID) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._versionInfo) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._clusterName) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._historyShardCount) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._persistenceStore) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._visibilityStore) }()
        case 9: try { try decoder.decodeSingularInt64Field(value: &_storage._initialFailoverVersion) }()
        case 10: try { try decoder.decodeSingularInt64Field(value: &_storage._failoverVersionIncrement) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._supportedClients.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._supportedClients, fieldNumber: 1)
      }
      if !_storage._serverVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._serverVersion, fieldNumber: 2)
      }
      if !_storage._clusterID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterID, fieldNumber: 3)
      }
      try { if let v = _storage._versionInfo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._clusterName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clusterName, fieldNumber: 5)
      }
      if _storage._historyShardCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._historyShardCount, fieldNumber: 6)
      }
      if !_storage._persistenceStore.isEmpty {
        try visitor.visitSingularStringField(value: _storage._persistenceStore, fieldNumber: 7)
      }
      if !_storage._visibilityStore.isEmpty {
        try visitor.visitSingularStringField(value: _storage._visibilityStore, fieldNumber: 8)
      }
      if _storage._initialFailoverVersion != 0 {
        try visitor.visitSingularInt64Field(value: _storage._initialFailoverVersion, fieldNumber: 9)
      }
      if _storage._failoverVersionIncrement != 0 {
        try visitor.visitSingularInt64Field(value: _storage._failoverVersionIncrement, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetClusterInfoResponse, rhs: Api.Workflowservice.V1.GetClusterInfoResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._supportedClients != rhs_storage._supportedClients {return false}
        if _storage._serverVersion != rhs_storage._serverVersion {return false}
        if _storage._clusterID != rhs_storage._clusterID {return false}
        if _storage._versionInfo != rhs_storage._versionInfo {return false}
        if _storage._clusterName != rhs_storage._clusterName {return false}
        if _storage._historyShardCount != rhs_storage._historyShardCount {return false}
        if _storage._persistenceStore != rhs_storage._persistenceStore {return false}
        if _storage._visibilityStore != rhs_storage._visibilityStore {return false}
        if _storage._initialFailoverVersion != rhs_storage._initialFailoverVersion {return false}
        if _storage._failoverVersionIncrement != rhs_storage._failoverVersionIncrement {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetSystemInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSystemInfoRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetSystemInfoRequest, rhs: Api.Workflowservice.V1.GetSystemInfoRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetSystemInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetSystemInfoResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}server_version\0\u{1}capabilities\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serverVersion) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._capabilities) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serverVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.serverVersion, fieldNumber: 1)
    }
    try { if let v = self._capabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetSystemInfoResponse, rhs: Api.Workflowservice.V1.GetSystemInfoResponse) -> Bool {
    if lhs.serverVersion != rhs.serverVersion {return false}
    if lhs._capabilities != rhs._capabilities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.GetSystemInfoResponse.protoMessageName + ".Capabilities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}signal_and_query_header\0\u{3}internal_error_differentiation\0\u{3}activity_failure_include_heartbeat\0\u{3}supports_schedules\0\u{3}encoded_failure_attributes\0\u{3}build_id_based_versioning\0\u{3}upsert_memo\0\u{3}eager_workflow_start\0\u{3}sdk_metadata\0\u{3}count_group_by_execution_status\0\u{1}nexus\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.signalAndQueryHeader) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.internalErrorDifferentiation) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activityFailureIncludeHeartbeat) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.supportsSchedules) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.encodedFailureAttributes) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.buildIDBasedVersioning) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.upsertMemo) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.eagerWorkflowStart) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.sdkMetadata) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.countGroupByExecutionStatus) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.nexus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.signalAndQueryHeader != false {
      try visitor.visitSingularBoolField(value: self.signalAndQueryHeader, fieldNumber: 1)
    }
    if self.internalErrorDifferentiation != false {
      try visitor.visitSingularBoolField(value: self.internalErrorDifferentiation, fieldNumber: 2)
    }
    if self.activityFailureIncludeHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.activityFailureIncludeHeartbeat, fieldNumber: 3)
    }
    if self.supportsSchedules != false {
      try visitor.visitSingularBoolField(value: self.supportsSchedules, fieldNumber: 4)
    }
    if self.encodedFailureAttributes != false {
      try visitor.visitSingularBoolField(value: self.encodedFailureAttributes, fieldNumber: 5)
    }
    if self.buildIDBasedVersioning != false {
      try visitor.visitSingularBoolField(value: self.buildIDBasedVersioning, fieldNumber: 6)
    }
    if self.upsertMemo != false {
      try visitor.visitSingularBoolField(value: self.upsertMemo, fieldNumber: 7)
    }
    if self.eagerWorkflowStart != false {
      try visitor.visitSingularBoolField(value: self.eagerWorkflowStart, fieldNumber: 8)
    }
    if self.sdkMetadata != false {
      try visitor.visitSingularBoolField(value: self.sdkMetadata, fieldNumber: 9)
    }
    if self.countGroupByExecutionStatus != false {
      try visitor.visitSingularBoolField(value: self.countGroupByExecutionStatus, fieldNumber: 10)
    }
    if self.nexus != false {
      try visitor.visitSingularBoolField(value: self.nexus, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities, rhs: Api.Workflowservice.V1.GetSystemInfoResponse.Capabilities) -> Bool {
    if lhs.signalAndQueryHeader != rhs.signalAndQueryHeader {return false}
    if lhs.internalErrorDifferentiation != rhs.internalErrorDifferentiation {return false}
    if lhs.activityFailureIncludeHeartbeat != rhs.activityFailureIncludeHeartbeat {return false}
    if lhs.supportsSchedules != rhs.supportsSchedules {return false}
    if lhs.encodedFailureAttributes != rhs.encodedFailureAttributes {return false}
    if lhs.buildIDBasedVersioning != rhs.buildIDBasedVersioning {return false}
    if lhs.upsertMemo != rhs.upsertMemo {return false}
    if lhs.eagerWorkflowStart != rhs.eagerWorkflowStart {return false}
    if lhs.sdkMetadata != rhs.sdkMetadata {return false}
    if lhs.countGroupByExecutionStatus != rhs.countGroupByExecutionStatus {return false}
    if lhs.nexus != rhs.nexus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListTaskQueuePartitionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTaskQueuePartitionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListTaskQueuePartitionsRequest, rhs: Api.Workflowservice.V1.ListTaskQueuePartitionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListTaskQueuePartitionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTaskQueuePartitionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_task_queue_partitions\0\u{3}workflow_task_queue_partitions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.activityTaskQueuePartitions) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workflowTaskQueuePartitions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.activityTaskQueuePartitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.activityTaskQueuePartitions, fieldNumber: 1)
    }
    if !self.workflowTaskQueuePartitions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workflowTaskQueuePartitions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListTaskQueuePartitionsResponse, rhs: Api.Workflowservice.V1.ListTaskQueuePartitionsResponse) -> Bool {
    if lhs.activityTaskQueuePartitions != rhs.activityTaskQueuePartitions {return false}
    if lhs.workflowTaskQueuePartitions != rhs.workflowTaskQueuePartitions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CreateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}schedule\0\u{3}initial_patch\0\u{1}identity\0\u{3}request_id\0\u{1}memo\0\u{3}search_attributes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._initialPatch) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._memo) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._initialPatch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try { if let v = self._memo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CreateScheduleRequest, rhs: Api.Workflowservice.V1.CreateScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs._initialPatch != rhs._initialPatch {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._memo != rhs._memo {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CreateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CreateScheduleResponse, rhs: Api.Workflowservice.V1.CreateScheduleResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeScheduleRequest, rhs: Api.Workflowservice.V1.DescribeScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schedule\0\u{1}info\0\u{1}memo\0\u{3}search_attributes\0\u{3}conflict_token\0")

  fileprivate class _StorageClass {
    var _schedule: Api.Schedule.V1.Schedule? = nil
    var _info: Api.Schedule.V1.ScheduleInfo? = nil
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _conflictToken: Data = Data()

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _schedule = source._schedule
      _info = source._info
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _conflictToken = source._conflictToken
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._schedule) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._info) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 5: try { try decoder.decodeSingularBytesField(value: &_storage._conflictToken) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._schedule {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._info {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._conflictToken.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._conflictToken, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeScheduleResponse, rhs: Api.Workflowservice.V1.DescribeScheduleResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._schedule != rhs_storage._schedule {return false}
        if _storage._info != rhs_storage._info {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._conflictToken != rhs_storage._conflictToken {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}schedule\0\u{3}conflict_token\0\u{1}identity\0\u{3}request_id\0\u{3}search_attributes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._schedule) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._schedule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateScheduleRequest, rhs: Api.Workflowservice.V1.UpdateScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._schedule != rhs._schedule {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateScheduleResponse, rhs: Api.Workflowservice.V1.UpdateScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PatchScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}patch\0\u{1}identity\0\u{3}request_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._patch) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._patch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PatchScheduleRequest, rhs: Api.Workflowservice.V1.PatchScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._patch != rhs._patch {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PatchScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PatchScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PatchScheduleResponse, rhs: Api.Workflowservice.V1.PatchScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListScheduleMatchingTimesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListScheduleMatchingTimesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{3}start_time\0\u{3}end_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListScheduleMatchingTimesRequest, rhs: Api.Workflowservice.V1.ListScheduleMatchingTimesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListScheduleMatchingTimesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListScheduleMatchingTimesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.startTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.startTime.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.startTime, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListScheduleMatchingTimesResponse, rhs: Api.Workflowservice.V1.ListScheduleMatchingTimesResponse) -> Bool {
    if lhs.startTime != rhs.startTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteScheduleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteScheduleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}schedule_id\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.scheduleID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.scheduleID.isEmpty {
      try visitor.visitSingularStringField(value: self.scheduleID, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteScheduleRequest, rhs: Api.Workflowservice.V1.DeleteScheduleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.scheduleID != rhs.scheduleID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteScheduleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteScheduleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteScheduleResponse, rhs: Api.Workflowservice.V1.DeleteScheduleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListSchedulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSchedulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}maximum_page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maximumPageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.maximumPageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.maximumPageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListSchedulesRequest, rhs: Api.Workflowservice.V1.ListSchedulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.maximumPageSize != rhs.maximumPageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListSchedulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListSchedulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}schedules\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.schedules) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.schedules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.schedules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListSchedulesResponse, rhs: Api.Workflowservice.V1.ListSchedulesResponse) -> Bool {
    if lhs.schedules != rhs.schedules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerBuildIdCompatibilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}add_new_build_id_in_new_default_set\0\u{3}add_new_compatible_build_id\0\u{3}promote_set_by_build_id\0\u{3}promote_build_id_within_set\0\u{3}merge_sets\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .addNewBuildIDInNewDefaultSet(v)
        }
      }()
      case 4: try {
        var v: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addNewCompatibleBuildID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addNewCompatibleBuildID(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .promoteSetByBuildID(v)
        }
      }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .promoteBuildIDWithinSet(v)
        }
      }()
      case 7: try {
        var v: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .mergeSets(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .mergeSets(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    switch self.operation {
    case .addNewBuildIDInNewDefaultSet?: try {
      guard case .addNewBuildIDInNewDefaultSet(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .addNewCompatibleBuildID?: try {
      guard case .addNewCompatibleBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .promoteSetByBuildID?: try {
      guard case .promoteSetByBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .promoteBuildIDWithinSet?: try {
      guard case .promoteBuildIDWithinSet(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .mergeSets?: try {
      guard case .mergeSets(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest, rhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.protoMessageName + ".AddNewCompatibleVersion"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}new_build_id\0\u{3}existing_compatible_build_id\0\u{3}make_set_default\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.newBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.existingCompatibleBuildID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.makeSetDefault) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.newBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.newBuildID, fieldNumber: 1)
    }
    if !self.existingCompatibleBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.existingCompatibleBuildID, fieldNumber: 2)
    }
    if self.makeSetDefault != false {
      try visitor.visitSingularBoolField(value: self.makeSetDefault, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion, rhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.AddNewCompatibleVersion) -> Bool {
    if lhs.newBuildID != rhs.newBuildID {return false}
    if lhs.existingCompatibleBuildID != rhs.existingCompatibleBuildID {return false}
    if lhs.makeSetDefault != rhs.makeSetDefault {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.protoMessageName + ".MergeSets"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}primary_set_build_id\0\u{3}secondary_set_build_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.primarySetBuildID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secondarySetBuildID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.primarySetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.primarySetBuildID, fieldNumber: 1)
    }
    if !self.secondarySetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.secondarySetBuildID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets, rhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityRequest.MergeSets) -> Bool {
    if lhs.primarySetBuildID != rhs.primarySetBuildID {return false}
    if lhs.secondarySetBuildID != rhs.secondarySetBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerBuildIdCompatibilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{b}version_set_id\0\u{c}\u{1}\u{1}")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityResponse, rhs: Api.Workflowservice.V1.UpdateWorkerBuildIdCompatibilityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerBuildIdCompatibilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}max_sets\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.maxSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    if self.maxSets != 0 {
      try visitor.visitSingularInt32Field(value: self.maxSets, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityRequest, rhs: Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.maxSets != rhs.maxSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerBuildIdCompatibilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}major_version_sets\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.majorVersionSets) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.majorVersionSets.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.majorVersionSets, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityResponse, rhs: Api.Workflowservice.V1.GetWorkerBuildIdCompatibilityResponse) -> Bool {
    if lhs.majorVersionSets != rhs.majorVersionSets {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerVersioningRulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0\u{3}conflict_token\0\u{3}insert_assignment_rule\0\u{3}replace_assignment_rule\0\u{3}delete_assignment_rule\0\u{3}add_compatible_redirect_rule\0\u{3}replace_compatible_redirect_rule\0\u{3}delete_compatible_redirect_rule\0\u{3}commit_build_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 4: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .insertAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .insertAssignmentRule(v)
        }
      }()
      case 5: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replaceAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replaceAssignmentRule(v)
        }
      }()
      case 6: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteAssignmentRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteAssignmentRule(v)
        }
      }()
      case 7: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .addCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .addCompatibleRedirectRule(v)
        }
      }()
      case 8: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .replaceCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .replaceCompatibleRedirectRule(v)
        }
      }()
      case 9: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .deleteCompatibleRedirectRule(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .deleteCompatibleRedirectRule(v)
        }
      }()
      case 10: try {
        var v: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .commitBuildID(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .commitBuildID(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    switch self.operation {
    case .insertAssignmentRule?: try {
      guard case .insertAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .replaceAssignmentRule?: try {
      guard case .replaceAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .deleteAssignmentRule?: try {
      guard case .deleteAssignmentRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .addCompatibleRedirectRule?: try {
      guard case .addCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .replaceCompatibleRedirectRule?: try {
      guard case .replaceCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .deleteCompatibleRedirectRule?: try {
      guard case .deleteCompatibleRedirectRule(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .commitBuildID?: try {
      guard case .commitBuildID(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".InsertBuildIdAssignmentRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.InsertBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".ReplaceBuildIdAssignmentRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}rule\0\u{1}force\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs._rule != rhs._rule {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".DeleteBuildIdAssignmentRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rule_index\0\u{1}force\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.ruleIndex) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.ruleIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.ruleIndex, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteBuildIdAssignmentRule) -> Bool {
    if lhs.ruleIndex != rhs.ruleIndex {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".AddCompatibleBuildIdRedirectRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.AddCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".ReplaceCompatibleBuildIdRedirectRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.ReplaceCompatibleBuildIdRedirectRule) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".DeleteCompatibleBuildIdRedirectRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}source_build_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourceBuildID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourceBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceBuildID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.DeleteCompatibleBuildIdRedirectRule) -> Bool {
    if lhs.sourceBuildID != rhs.sourceBuildID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.protoMessageName + ".CommitBuildId"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}target_build_id\0\u{1}force\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.targetBuildID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.targetBuildID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetBuildID, fieldNumber: 1)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesRequest.CommitBuildId) -> Bool {
    if lhs.targetBuildID != rhs.targetBuildID {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerVersioningRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerVersioningRulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}assignment_rules\0\u{3}compatible_redirect_rules\0\u{3}conflict_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignmentRules) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.compatibleRedirectRules) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignmentRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignmentRules, fieldNumber: 1)
    }
    if !self.compatibleRedirectRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compatibleRedirectRules, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesResponse, rhs: Api.Workflowservice.V1.UpdateWorkerVersioningRulesResponse) -> Bool {
    if lhs.assignmentRules != rhs.assignmentRules {return false}
    if lhs.compatibleRedirectRules != rhs.compatibleRedirectRules {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerVersioningRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerVersioningRulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}task_queue\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerVersioningRulesRequest, rhs: Api.Workflowservice.V1.GetWorkerVersioningRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerVersioningRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerVersioningRulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}assignment_rules\0\u{3}compatible_redirect_rules\0\u{3}conflict_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.assignmentRules) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.compatibleRedirectRules) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.assignmentRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.assignmentRules, fieldNumber: 1)
    }
    if !self.compatibleRedirectRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.compatibleRedirectRules, fieldNumber: 2)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerVersioningRulesResponse, rhs: Api.Workflowservice.V1.GetWorkerVersioningRulesResponse) -> Bool {
    if lhs.assignmentRules != rhs.assignmentRules {return false}
    if lhs.compatibleRedirectRules != rhs.compatibleRedirectRules {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerTaskReachabilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerTaskReachabilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}build_ids\0\u{3}task_queues\0\u{1}reachability\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.buildIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.taskQueues) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.reachability) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.buildIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.buildIds, fieldNumber: 2)
    }
    if !self.taskQueues.isEmpty {
      try visitor.visitRepeatedStringField(value: self.taskQueues, fieldNumber: 3)
    }
    if self.reachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.reachability, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerTaskReachabilityRequest, rhs: Api.Workflowservice.V1.GetWorkerTaskReachabilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.buildIds != rhs.buildIds {return false}
    if lhs.taskQueues != rhs.taskQueues {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetWorkerTaskReachabilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetWorkerTaskReachabilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}build_id_reachability\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.buildIDReachability) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.buildIDReachability.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.buildIDReachability, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetWorkerTaskReachabilityResponse, rhs: Api.Workflowservice.V1.GetWorkerTaskReachabilityResponse) -> Bool {
    if lhs.buildIDReachability != rhs.buildIDReachability {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}first_execution_run_id\0\u{3}wait_policy\0\u{1}request\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firstExecutionRunID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waitPolicy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.firstExecutionRunID.isEmpty {
      try visitor.visitSingularStringField(value: self.firstExecutionRunID, fieldNumber: 3)
    }
    try { if let v = self._waitPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.UpdateWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs.firstExecutionRunID != rhs.firstExecutionRunID {return false}
    if lhs._waitPolicy != rhs._waitPolicy {return false}
    if lhs._request != rhs._request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}update_ref\0\u{1}outcome\0\u{1}stage\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.UpdateWorkflowExecutionResponse) -> Bool {
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartBatchOperationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}visibility_query\0\u{3}job_id\0\u{1}reason\0\u{1}executions\0\u{3}max_operations_per_second\0\u{4}\u{4}termination_operation\0\u{3}signal_operation\0\u{3}cancellation_operation\0\u{3}deletion_operation\0\u{3}reset_operation\0\u{3}update_workflow_options_operation\0\u{3}unpause_activities_operation\0\u{3}reset_activities_operation\0\u{3}update_activity_options_operation\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _visibilityQuery: String = String()
    var _jobID: String = String()
    var _reason: String = String()
    var _executions: [Api.Common.V1.WorkflowExecution] = []
    var _maxOperationsPerSecond: Float = 0
    var _operation: Api.Workflowservice.V1.StartBatchOperationRequest.OneOf_Operation?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _visibilityQuery = source._visibilityQuery
      _jobID = source._jobID
      _reason = source._reason
      _executions = source._executions
      _maxOperationsPerSecond = source._maxOperationsPerSecond
      _operation = source._operation
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._visibilityQuery) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._jobID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._reason) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._executions) }()
        case 6: try { try decoder.decodeSingularFloatField(value: &_storage._maxOperationsPerSecond) }()
        case 10: try {
          var v: Api.Batch.V1.BatchOperationTermination?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .terminationOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .terminationOperation(v)
          }
        }()
        case 11: try {
          var v: Api.Batch.V1.BatchOperationSignal?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .signalOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .signalOperation(v)
          }
        }()
        case 12: try {
          var v: Api.Batch.V1.BatchOperationCancellation?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .cancellationOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .cancellationOperation(v)
          }
        }()
        case 13: try {
          var v: Api.Batch.V1.BatchOperationDeletion?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .deletionOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .deletionOperation(v)
          }
        }()
        case 14: try {
          var v: Api.Batch.V1.BatchOperationReset?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .resetOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .resetOperation(v)
          }
        }()
        case 15: try {
          var v: Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .updateWorkflowOptionsOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .updateWorkflowOptionsOperation(v)
          }
        }()
        case 16: try {
          var v: Api.Batch.V1.BatchOperationUnpauseActivities?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .unpauseActivitiesOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .unpauseActivitiesOperation(v)
          }
        }()
        case 17: try {
          var v: Api.Batch.V1.BatchOperationResetActivities?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .resetActivitiesOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .resetActivitiesOperation(v)
          }
        }()
        case 18: try {
          var v: Api.Batch.V1.BatchOperationUpdateActivityOptions?
          var hadOneofValue = false
          if let current = _storage._operation {
            hadOneofValue = true
            if case .updateActivityOptionsOperation(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._operation = .updateActivityOptionsOperation(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._visibilityQuery.isEmpty {
        try visitor.visitSingularStringField(value: _storage._visibilityQuery, fieldNumber: 2)
      }
      if !_storage._jobID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._jobID, fieldNumber: 3)
      }
      if !_storage._reason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reason, fieldNumber: 4)
      }
      if !_storage._executions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._executions, fieldNumber: 5)
      }
      if _storage._maxOperationsPerSecond.bitPattern != 0 {
        try visitor.visitSingularFloatField(value: _storage._maxOperationsPerSecond, fieldNumber: 6)
      }
      switch _storage._operation {
      case .terminationOperation?: try {
        guard case .terminationOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .signalOperation?: try {
        guard case .signalOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .cancellationOperation?: try {
        guard case .cancellationOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .deletionOperation?: try {
        guard case .deletionOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .resetOperation?: try {
        guard case .resetOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .updateWorkflowOptionsOperation?: try {
        guard case .updateWorkflowOptionsOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .unpauseActivitiesOperation?: try {
        guard case .unpauseActivitiesOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .resetActivitiesOperation?: try {
        guard case .resetActivitiesOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .updateActivityOptionsOperation?: try {
        guard case .updateActivityOptionsOperation(let v)? = _storage._operation else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartBatchOperationRequest, rhs: Api.Workflowservice.V1.StartBatchOperationRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._visibilityQuery != rhs_storage._visibilityQuery {return false}
        if _storage._jobID != rhs_storage._jobID {return false}
        if _storage._reason != rhs_storage._reason {return false}
        if _storage._executions != rhs_storage._executions {return false}
        if _storage._maxOperationsPerSecond != rhs_storage._maxOperationsPerSecond {return false}
        if _storage._operation != rhs_storage._operation {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartBatchOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartBatchOperationResponse, rhs: Api.Workflowservice.V1.StartBatchOperationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StopBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopBatchOperationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}job_id\0\u{1}reason\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StopBatchOperationRequest, rhs: Api.Workflowservice.V1.StopBatchOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StopBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StopBatchOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StopBatchOperationResponse, rhs: Api.Workflowservice.V1.StopBatchOperationResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeBatchOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeBatchOperationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}job_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeBatchOperationRequest, rhs: Api.Workflowservice.V1.DescribeBatchOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeBatchOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeBatchOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_type\0\u{3}job_id\0\u{1}state\0\u{3}start_time\0\u{3}close_time\0\u{3}total_operation_count\0\u{3}complete_operation_count\0\u{3}failure_operation_count\0\u{1}identity\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.operationType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.totalOperationCount) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.completeOperationCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.failureOperationCount) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.operationType != .unspecified {
      try visitor.visitSingularEnumField(value: self.operationType, fieldNumber: 1)
    }
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.totalOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.totalOperationCount, fieldNumber: 6)
    }
    if self.completeOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.completeOperationCount, fieldNumber: 7)
    }
    if self.failureOperationCount != 0 {
      try visitor.visitSingularInt64Field(value: self.failureOperationCount, fieldNumber: 8)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 9)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeBatchOperationResponse, rhs: Api.Workflowservice.V1.DescribeBatchOperationResponse) -> Bool {
    if lhs.operationType != rhs.operationType {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs.totalOperationCount != rhs.totalOperationCount {return false}
    if lhs.completeOperationCount != rhs.completeOperationCount {return false}
    if lhs.failureOperationCount != rhs.failureOperationCount {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListBatchOperationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBatchOperationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListBatchOperationsRequest, rhs: Api.Workflowservice.V1.ListBatchOperationsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListBatchOperationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListBatchOperationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}operation_info\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.operationInfo) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.operationInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operationInfo, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListBatchOperationsResponse, rhs: Api.Workflowservice.V1.ListBatchOperationsResponse) -> Bool {
    if lhs.operationInfo != rhs.operationInfo {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollWorkflowExecutionUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollWorkflowExecutionUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}update_ref\0\u{1}identity\0\u{3}wait_policy\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._waitPolicy) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._waitPolicy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollWorkflowExecutionUpdateRequest, rhs: Api.Workflowservice.V1.PollWorkflowExecutionUpdateRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._waitPolicy != rhs._waitPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollWorkflowExecutionUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollWorkflowExecutionUpdateResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}outcome\0\u{1}stage\0\u{3}update_ref\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.stage) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateRef) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.stage != .unspecified {
      try visitor.visitSingularEnumField(value: self.stage, fieldNumber: 2)
    }
    try { if let v = self._updateRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollWorkflowExecutionUpdateResponse, rhs: Api.Workflowservice.V1.PollWorkflowExecutionUpdateResponse) -> Bool {
    if lhs._outcome != rhs._outcome {return false}
    if lhs.stage != rhs.stage {return false}
    if lhs._updateRef != rhs._updateRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollNexusTaskQueueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollNexusTaskQueueRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_queue\0\u{3}worker_version_capabilities\0\u{4}\u{2}deployment_options\0\u{3}worker_heartbeat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._taskQueue) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerVersionCapabilities) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._deploymentOptions) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.workerHeartbeat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    try { if let v = self._taskQueue {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._workerVersionCapabilities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deploymentOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.workerHeartbeat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerHeartbeat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollNexusTaskQueueRequest, rhs: Api.Workflowservice.V1.PollNexusTaskQueueRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._taskQueue != rhs._taskQueue {return false}
    if lhs._workerVersionCapabilities != rhs._workerVersionCapabilities {return false}
    if lhs._deploymentOptions != rhs._deploymentOptions {return false}
    if lhs.workerHeartbeat != rhs.workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollNexusTaskQueueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollNexusTaskQueueResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}request\0\u{3}poller_scaling_decision\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._request) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pollerScalingDecision) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    try { if let v = self._request {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._pollerScalingDecision {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollNexusTaskQueueResponse, rhs: Api.Workflowservice.V1.PollNexusTaskQueueResponse) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._request != rhs._request {return false}
    if lhs._pollerScalingDecision != rhs._pollerScalingDecision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondNexusTaskCompletedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskCompletedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_token\0\u{1}response\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._response) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 3)
    }
    try { if let v = self._response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondNexusTaskCompletedRequest, rhs: Api.Workflowservice.V1.RespondNexusTaskCompletedRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._response != rhs._response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondNexusTaskCompletedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskCompletedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondNexusTaskCompletedResponse, rhs: Api.Workflowservice.V1.RespondNexusTaskCompletedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondNexusTaskFailedRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskFailedRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_token\0\u{1}error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 3)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondNexusTaskFailedRequest, rhs: Api.Workflowservice.V1.RespondNexusTaskFailedRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs._error != rhs._error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RespondNexusTaskFailedResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RespondNexusTaskFailedResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RespondNexusTaskFailedResponse, rhs: Api.Workflowservice.V1.RespondNexusTaskFailedResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ExecuteMultiOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteMultiOperationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}operations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ExecuteMultiOperationRequest, rhs: Api.Workflowservice.V1.ExecuteMultiOperationRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ExecuteMultiOperationRequest.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.ExecuteMultiOperationRequest.protoMessageName + ".Operation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_workflow\0\u{3}update_workflow\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Workflowservice.V1.StartWorkflowExecutionRequest?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .startWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .startWorkflow(v)
        }
      }()
      case 2: try {
        var v: Api.Workflowservice.V1.UpdateWorkflowExecutionRequest?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .updateWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .updateWorkflow(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .startWorkflow?: try {
      guard case .startWorkflow(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflow?: try {
      guard case .updateWorkflow(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ExecuteMultiOperationRequest.Operation, rhs: Api.Workflowservice.V1.ExecuteMultiOperationRequest.Operation) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ExecuteMultiOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExecuteMultiOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responses\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.responses) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.responses, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ExecuteMultiOperationResponse, rhs: Api.Workflowservice.V1.ExecuteMultiOperationResponse) -> Bool {
    if lhs.responses != rhs.responses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ExecuteMultiOperationResponse.Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.ExecuteMultiOperationResponse.protoMessageName + ".Response"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_workflow\0\u{3}update_workflow\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Workflowservice.V1.StartWorkflowExecutionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .startWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .startWorkflow(v)
        }
      }()
      case 2: try {
        var v: Api.Workflowservice.V1.UpdateWorkflowExecutionResponse?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .updateWorkflow(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .updateWorkflow(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .startWorkflow?: try {
      guard case .startWorkflow(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .updateWorkflow?: try {
      guard case .updateWorkflow(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ExecuteMultiOperationResponse.Response, rhs: Api.Workflowservice.V1.ExecuteMultiOperationResponse.Response) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateActivityOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActivityOptionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{3}activity_options\0\u{3}update_mask\0\u{1}id\0\u{1}type\0\u{3}restore_original\0\u{3}match_all\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 7: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginal) }()
      case 9: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }()
    default: break
    }
    if self.restoreOriginal != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginal, fieldNumber: 8)
    }
    try { if case .matchAll(let v)? = self.activity {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateActivityOptionsRequest, rhs: Api.Workflowservice.V1.UpdateActivityOptionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.restoreOriginal != rhs.restoreOriginal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateActivityOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateActivityOptionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateActivityOptionsResponse, rhs: Api.Workflowservice.V1.UpdateActivityOptionsResponse) -> Bool {
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PauseActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PauseActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PauseActivityRequest, rhs: Api.Workflowservice.V1.PauseActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PauseActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PauseActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PauseActivityResponse, rhs: Api.Workflowservice.V1.PauseActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UnpauseActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpauseActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{3}unpause_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{1}jitter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .unpauseAll(v)
        }
      }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .unpauseAll?: try {
      guard case .unpauseAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 7)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 8)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UnpauseActivityRequest, rhs: Api.Workflowservice.V1.UnpauseActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UnpauseActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpauseActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UnpauseActivityResponse, rhs: Api.Workflowservice.V1.UnpauseActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}type\0\u{3}reset_heartbeat\0\u{3}keep_paused\0\u{1}jitter\0\u{3}restore_original_options\0\u{3}match_all\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .id(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.keepPaused) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginalOptions) }()
      case 10: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.activity {
    case .id?: try {
      guard case .id(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    default: break
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 6)
    }
    if self.keepPaused != false {
      try visitor.visitSingularBoolField(value: self.keepPaused, fieldNumber: 7)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if self.restoreOriginalOptions != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginalOptions, fieldNumber: 9)
    }
    try { if case .matchAll(let v)? = self.activity {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetActivityRequest, rhs: Api.Workflowservice.V1.ResetActivityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs.keepPaused != rhs.keepPaused {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.restoreOriginalOptions != rhs.restoreOriginalOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ResetActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ResetActivityResponse, rhs: Api.Workflowservice.V1.ResetActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionOptionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_execution_options\0\u{3}update_mask\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsRequest, rhs: Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkflowExecutionOptionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_execution_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsResponse, rhs: Api.Workflowservice.V1.UpdateWorkflowExecutionOptionsResponse) -> Bool {
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeDeploymentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeDeploymentRequest, rhs: Api.Workflowservice.V1.DescribeDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeDeploymentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deployment_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deploymentInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeDeploymentResponse, rhs: Api.Workflowservice.V1.DescribeDeploymentResponse) -> Bool {
    if lhs._deploymentInfo != rhs._deploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerDeploymentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentVersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}deployment_version\0\u{3}report_task_queue_stats\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reportTaskQueueStats) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.reportTaskQueueStats != false {
      try visitor.visitSingularBoolField(value: self.reportTaskQueueStats, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionRequest, rhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.reportTaskQueueStats != rhs.reportTaskQueueStats {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentVersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_deployment_version_info\0\u{3}version_task_queues\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerDeploymentVersionInfo) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.versionTaskQueues) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerDeploymentVersionInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.versionTaskQueues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.versionTaskQueues, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse, rhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse) -> Bool {
    if lhs._workerDeploymentVersionInfo != rhs._workerDeploymentVersionInfo {return false}
    if lhs.versionTaskQueues != rhs.versionTaskQueues {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse.protoMessageName + ".VersionTaskQueue"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}type\0\u{1}stats\0\u{3}stats_by_priority_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._stats) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueStats>.self, value: &self.statsByPriorityKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.type != .unspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._stats {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.statsByPriorityKey.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,Api.Taskqueue.V1.TaskQueueStats>.self, value: self.statsByPriorityKey, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue, rhs: Api.Workflowservice.V1.DescribeWorkerDeploymentVersionResponse.VersionTaskQueue) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.type != rhs.type {return false}
    if lhs._stats != rhs._stats {return false}
    if lhs.statsByPriorityKey != rhs.statsByPriorityKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerDeploymentRequest, rhs: Api.Workflowservice.V1.DescribeWorkerDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerDeploymentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}worker_deployment_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workerDeploymentInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    try { if let v = self._workerDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerDeploymentResponse, rhs: Api.Workflowservice.V1.DescribeWorkerDeploymentResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs._workerDeploymentInfo != rhs._workerDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeploymentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{3}series_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.seriesName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.seriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesName, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListDeploymentsRequest, rhs: Api.Workflowservice.V1.ListDeploymentsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.seriesName != rhs.seriesName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListDeploymentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{1}deployments\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.deployments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.deployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListDeploymentsResponse, rhs: Api.Workflowservice.V1.ListDeploymentsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.deployments != rhs.deployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetCurrentDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCurrentDeploymentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0\u{1}identity\0\u{3}update_metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateMetadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._updateMetadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetCurrentDeploymentRequest, rhs: Api.Workflowservice.V1.SetCurrentDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._updateMetadata != rhs._updateMetadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetCurrentDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetCurrentDeploymentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_deployment_info\0\u{3}previous_deployment_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentInfo) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._previousDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetCurrentDeploymentResponse, rhs: Api.Workflowservice.V1.SetCurrentDeploymentResponse) -> Bool {
    if lhs._currentDeploymentInfo != rhs._currentDeploymentInfo {return false}
    if lhs._previousDeploymentInfo != rhs._previousDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentCurrentVersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}version\0\u{3}conflict_token\0\u{1}identity\0\u{3}ignore_missing_task_queues\0\u{3}build_id\0\u{4}\u{2}allow_no_pollers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.ignoreMissingTaskQueues) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.allowNoPollers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if self.ignoreMissingTaskQueues != false {
      try visitor.visitSingularBoolField(value: self.ignoreMissingTaskQueues, fieldNumber: 6)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 7)
    }
    if self.allowNoPollers != false {
      try visitor.visitSingularBoolField(value: self.allowNoPollers, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionRequest, rhs: Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ignoreMissingTaskQueues != rhs.ignoreMissingTaskQueues {return false}
    if lhs.allowNoPollers != rhs.allowNoPollers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentCurrentVersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}previous_version\0\u{3}previous_deployment_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.previousVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    if !self.previousVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.previousVersion, fieldNumber: 2)
    }
    try { if let v = self._previousDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionResponse, rhs: Api.Workflowservice.V1.SetWorkerDeploymentCurrentVersionResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.previousVersion != rhs.previousVersion {return false}
    if lhs._previousDeploymentVersion != rhs._previousDeploymentVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentRampingVersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}version\0\u{1}percentage\0\u{3}conflict_token\0\u{1}identity\0\u{3}ignore_missing_task_queues\0\u{3}build_id\0\u{4}\u{2}allow_no_pollers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.percentage) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.ignoreMissingTaskQueues) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.buildID) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.allowNoPollers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if self.percentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.percentage, fieldNumber: 4)
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 5)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    if self.ignoreMissingTaskQueues != false {
      try visitor.visitSingularBoolField(value: self.ignoreMissingTaskQueues, fieldNumber: 7)
    }
    if !self.buildID.isEmpty {
      try visitor.visitSingularStringField(value: self.buildID, fieldNumber: 8)
    }
    if self.allowNoPollers != false {
      try visitor.visitSingularBoolField(value: self.allowNoPollers, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionRequest, rhs: Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.version != rhs.version {return false}
    if lhs.buildID != rhs.buildID {return false}
    if lhs.percentage != rhs.percentage {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.ignoreMissingTaskQueues != rhs.ignoreMissingTaskQueues {return false}
    if lhs.allowNoPollers != rhs.allowNoPollers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentRampingVersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}previous_version\0\u{3}previous_percentage\0\u{3}previous_deployment_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.previousVersion) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.previousPercentage) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._previousDeploymentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    if !self.previousVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.previousVersion, fieldNumber: 2)
    }
    if self.previousPercentage.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.previousPercentage, fieldNumber: 3)
    }
    try { if let v = self._previousDeploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionResponse, rhs: Api.Workflowservice.V1.SetWorkerDeploymentRampingVersionResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.previousVersion != rhs.previousVersion {return false}
    if lhs._previousDeploymentVersion != rhs._previousDeploymentVersion {return false}
    if lhs.previousPercentage != rhs.previousPercentage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkerDeploymentsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkerDeploymentsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkerDeploymentsRequest, rhs: Api.Workflowservice.V1.ListWorkerDeploymentsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkerDeploymentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkerDeploymentsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}next_page_token\0\u{3}worker_deployments\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.workerDeployments) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 1)
    }
    if !self.workerDeployments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerDeployments, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkerDeploymentsResponse, rhs: Api.Workflowservice.V1.ListWorkerDeploymentsResponse) -> Bool {
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.workerDeployments != rhs.workerDeployments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.ListWorkerDeploymentsResponse.protoMessageName + ".WorkerDeploymentSummary"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{3}create_time\0\u{3}routing_config\0\u{3}latest_version_summary\0\u{3}current_version_summary\0\u{3}ramping_version_summary\0")

  fileprivate class _StorageClass {
    var _name: String = String()
    var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _routingConfig: Api.Deployment.V1.RoutingConfig? = nil
    var _latestVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil
    var _currentVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil
    var _rampingVersionSummary: Api.Deployment.V1.WorkerDeploymentInfo.WorkerDeploymentVersionSummary? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _name = source._name
      _createTime = source._createTime
      _routingConfig = source._routingConfig
      _latestVersionSummary = source._latestVersionSummary
      _currentVersionSummary = source._currentVersionSummary
      _rampingVersionSummary = source._rampingVersionSummary
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._createTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._routingConfig) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._latestVersionSummary) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._currentVersionSummary) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._rampingVersionSummary) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 1)
      }
      try { if let v = _storage._createTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._routingConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._latestVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._currentVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._rampingVersionSummary {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary, rhs: Api.Workflowservice.V1.ListWorkerDeploymentsResponse.WorkerDeploymentSummary) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._name != rhs_storage._name {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._routingConfig != rhs_storage._routingConfig {return false}
        if _storage._latestVersionSummary != rhs_storage._latestVersionSummary {return false}
        if _storage._currentVersionSummary != rhs_storage._currentVersionSummary {return false}
        if _storage._rampingVersionSummary != rhs_storage._rampingVersionSummary {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkerDeploymentVersionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentVersionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}skip_drainage\0\u{1}identity\0\u{3}deployment_version\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.skipDrainage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if self.skipDrainage != false {
      try visitor.visitSingularBoolField(value: self.skipDrainage, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkerDeploymentVersionRequest, rhs: Api.Workflowservice.V1.DeleteWorkerDeploymentVersionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.skipDrainage != rhs.skipDrainage {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkerDeploymentVersionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentVersionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkerDeploymentVersionResponse, rhs: Api.Workflowservice.V1.DeleteWorkerDeploymentVersionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkerDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkerDeploymentRequest, rhs: Api.Workflowservice.V1.DeleteWorkerDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkerDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkerDeploymentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkerDeploymentResponse, rhs: Api.Workflowservice.V1.DeleteWorkerDeploymentResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerDeploymentVersionMetadataRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}version\0\u{3}upsert_entries\0\u{3}remove_entries\0\u{3}deployment_version\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &self.upsertEntries) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.removeEntries) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deploymentVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 2)
    }
    if !self.upsertEntries.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: self.upsertEntries, fieldNumber: 3)
    }
    if !self.removeEntries.isEmpty {
      try visitor.visitRepeatedStringField(value: self.removeEntries, fieldNumber: 4)
    }
    try { if let v = self._deploymentVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataRequest, rhs: Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.version != rhs.version {return false}
    if lhs._deploymentVersion != rhs._deploymentVersion {return false}
    if lhs.upsertEntries != rhs.upsertEntries {return false}
    if lhs.removeEntries != rhs.removeEntries {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerDeploymentVersionMetadataResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}metadata\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._metadata) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._metadata {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataResponse, rhs: Api.Workflowservice.V1.UpdateWorkerDeploymentVersionMetadataResponse) -> Bool {
    if lhs._metadata != rhs._metadata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentManagerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentManagerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}deployment_name\0\u{3}manager_identity\0\u{1}self\0\u{3}conflict_token\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deploymentName) }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.newManagerIdentity != nil {try decoder.handleConflictingOneOf()}
          self.newManagerIdentity = .managerIdentity(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.newManagerIdentity != nil {try decoder.handleConflictingOneOf()}
          self.newManagerIdentity = .self_p(v)
        }
      }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.deploymentName.isEmpty {
      try visitor.visitSingularStringField(value: self.deploymentName, fieldNumber: 2)
    }
    switch self.newManagerIdentity {
    case .managerIdentity?: try {
      guard case .managerIdentity(let v)? = self.newManagerIdentity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case .self_p?: try {
      guard case .self_p(let v)? = self.newManagerIdentity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 5)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentManagerRequest, rhs: Api.Workflowservice.V1.SetWorkerDeploymentManagerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.deploymentName != rhs.deploymentName {return false}
    if lhs.newManagerIdentity != rhs.newManagerIdentity {return false}
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.SetWorkerDeploymentManagerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetWorkerDeploymentManagerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}conflict_token\0\u{3}previous_manager_identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.conflictToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.previousManagerIdentity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conflictToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.conflictToken, fieldNumber: 1)
    }
    if !self.previousManagerIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.previousManagerIdentity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.SetWorkerDeploymentManagerResponse, rhs: Api.Workflowservice.V1.SetWorkerDeploymentManagerResponse) -> Bool {
    if lhs.conflictToken != rhs.conflictToken {return false}
    if lhs.previousManagerIdentity != rhs.previousManagerIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetCurrentDeploymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCurrentDeploymentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}series_name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.seriesName) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.seriesName.isEmpty {
      try visitor.visitSingularStringField(value: self.seriesName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetCurrentDeploymentRequest, rhs: Api.Workflowservice.V1.GetCurrentDeploymentRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.seriesName != rhs.seriesName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetCurrentDeploymentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetCurrentDeploymentResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}current_deployment_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._currentDeploymentInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._currentDeploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetCurrentDeploymentResponse, rhs: Api.Workflowservice.V1.GetCurrentDeploymentResponse) -> Bool {
    if lhs._currentDeploymentInfo != rhs._currentDeploymentInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetDeploymentReachabilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentReachabilityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}deployment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._deployment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._deployment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetDeploymentReachabilityRequest, rhs: Api.Workflowservice.V1.GetDeploymentReachabilityRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._deployment != rhs._deployment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.GetDeploymentReachabilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetDeploymentReachabilityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}deployment_info\0\u{1}reachability\0\u{3}last_update_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deploymentInfo) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reachability) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._lastUpdateTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deploymentInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.reachability != .unspecified {
      try visitor.visitSingularEnumField(value: self.reachability, fieldNumber: 2)
    }
    try { if let v = self._lastUpdateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.GetDeploymentReachabilityResponse, rhs: Api.Workflowservice.V1.GetDeploymentReachabilityResponse) -> Bool {
    if lhs._deploymentInfo != rhs._deploymentInfo {return false}
    if lhs.reachability != rhs.reachability {return false}
    if lhs._lastUpdateTime != rhs._lastUpdateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CreateWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkflowRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}force_scan\0\u{3}request_id\0\u{1}identity\0\u{1}description\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.forceScan) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.forceScan != false {
      try visitor.visitSingularBoolField(value: self.forceScan, fieldNumber: 3)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 4)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CreateWorkflowRuleRequest, rhs: Api.Workflowservice.V1.CreateWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.forceScan != rhs.forceScan {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CreateWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateWorkflowRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0\u{3}job_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CreateWorkflowRuleResponse, rhs: Api.Workflowservice.V1.CreateWorkflowRuleResponse) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}rule_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkflowRuleRequest, rhs: Api.Workflowservice.V1.DescribeWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkflowRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkflowRuleResponse, rhs: Api.Workflowservice.V1.DescribeWorkflowRuleResponse) -> Bool {
    if lhs._rule != rhs._rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}rule_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ruleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.ruleID.isEmpty {
      try visitor.visitSingularStringField(value: self.ruleID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkflowRuleRequest, rhs: Api.Workflowservice.V1.DeleteWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.ruleID != rhs.ruleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteWorkflowRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteWorkflowRuleResponse, rhs: Api.Workflowservice.V1.DeleteWorkflowRuleResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkflowRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowRulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkflowRulesRequest, rhs: Api.Workflowservice.V1.ListWorkflowRulesRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkflowRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkflowRulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}rules\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkflowRulesResponse, rhs: Api.Workflowservice.V1.ListWorkflowRulesResponse) -> Bool {
    if lhs.rules != rhs.rules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TriggerWorkflowRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TriggerWorkflowRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{1}identity\0\u{1}id\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.rule != nil {try decoder.handleConflictingOneOf()}
          self.rule = .id(v)
        }
      }()
      case 5: try {
        var v: Api.Rules.V1.WorkflowRuleSpec?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .spec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .spec(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    switch self.rule {
    case .id?: try {
      guard case .id(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case .spec?: try {
      guard case .spec(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TriggerWorkflowRuleRequest, rhs: Api.Workflowservice.V1.TriggerWorkflowRuleRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TriggerWorkflowRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TriggerWorkflowRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}applied\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.applied) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.applied != false {
      try visitor.visitSingularBoolField(value: self.applied, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TriggerWorkflowRuleResponse, rhs: Api.Workflowservice.V1.TriggerWorkflowRuleResponse) -> Bool {
    if lhs.applied != rhs.applied {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordWorkerHeartbeatRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordWorkerHeartbeatRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}worker_heartbeat\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.workerHeartbeat) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.workerHeartbeat.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workerHeartbeat, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordWorkerHeartbeatRequest, rhs: Api.Workflowservice.V1.RecordWorkerHeartbeatRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.workerHeartbeat != rhs.workerHeartbeat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RecordWorkerHeartbeatResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RecordWorkerHeartbeatResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RecordWorkerHeartbeatResponse, rhs: Api.Workflowservice.V1.RecordWorkerHeartbeatResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkersRequest, rhs: Api.Workflowservice.V1.ListWorkersRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListWorkersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListWorkersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workers_info\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.workersInfo) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.workersInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.workersInfo, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListWorkersResponse, rhs: Api.Workflowservice.V1.ListWorkersResponse) -> Bool {
    if lhs.workersInfo != rhs.workersInfo {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateTaskQueueConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTaskQueueConfigRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}task_queue\0\u{3}task_queue_type\0\u{3}update_queue_rate_limit\0\u{3}update_fairness_key_rate_limit_default\0\u{3}set_fairness_weight_overrides\0\u{3}unset_fairness_weight_overrides\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.taskQueue) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.taskQueueType) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateQueueRateLimit) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._updateFairnessKeyRateLimitDefault) }()
      case 7: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: &self.setFairnessWeightOverrides) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.unsetFairnessWeightOverrides) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.taskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.taskQueue, fieldNumber: 3)
    }
    if self.taskQueueType != .unspecified {
      try visitor.visitSingularEnumField(value: self.taskQueueType, fieldNumber: 4)
    }
    try { if let v = self._updateQueueRateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._updateFairnessKeyRateLimitDefault {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.setFairnessWeightOverrides.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufFloat>.self, value: self.setFairnessWeightOverrides, fieldNumber: 7)
    }
    if !self.unsetFairnessWeightOverrides.isEmpty {
      try visitor.visitRepeatedStringField(value: self.unsetFairnessWeightOverrides, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest, rhs: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.taskQueue != rhs.taskQueue {return false}
    if lhs.taskQueueType != rhs.taskQueueType {return false}
    if lhs._updateQueueRateLimit != rhs._updateQueueRateLimit {return false}
    if lhs._updateFairnessKeyRateLimitDefault != rhs._updateFairnessKeyRateLimitDefault {return false}
    if lhs.setFairnessWeightOverrides != rhs.setFairnessWeightOverrides {return false}
    if lhs.unsetFairnessWeightOverrides != rhs.unsetFairnessWeightOverrides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.protoMessageName + ".RateLimitUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}rate_limit\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._rateLimit) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._rateLimit {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate, rhs: Api.Workflowservice.V1.UpdateTaskQueueConfigRequest.RateLimitUpdate) -> Bool {
    if lhs._rateLimit != rhs._rateLimit {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateTaskQueueConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateTaskQueueConfigResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._config) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._config {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateTaskQueueConfigResponse, rhs: Api.Workflowservice.V1.UpdateTaskQueueConfigResponse) -> Bool {
    if lhs._config != rhs._config {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.FetchWorkerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchWorkerConfigRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{1}reason\0\u{2}\u{3}selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.FetchWorkerConfigRequest, rhs: Api.Workflowservice.V1.FetchWorkerConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.FetchWorkerConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FetchWorkerConfigResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerConfig) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.FetchWorkerConfigResponse, rhs: Api.Workflowservice.V1.FetchWorkerConfigResponse) -> Bool {
    if lhs._workerConfig != rhs._workerConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerConfigRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerConfigRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{1}reason\0\u{3}worker_config\0\u{3}update_mask\0\u{1}selector\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._workerConfig) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._selector) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 3)
    }
    try { if let v = self._workerConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._selector {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerConfigRequest, rhs: Api.Workflowservice.V1.UpdateWorkerConfigRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs._workerConfig != rhs._workerConfig {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._selector != rhs._selector {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UpdateWorkerConfigResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateWorkerConfigResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_config\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Sdk.V1.WorkerConfig?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .workerConfig(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .workerConfig(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .workerConfig(let v)? = self.response {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UpdateWorkerConfigResponse, rhs: Api.Workflowservice.V1.UpdateWorkerConfigResponse) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}worker_instance_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workerInstanceKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workerInstanceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.workerInstanceKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerRequest, rhs: Api.Workflowservice.V1.DescribeWorkerRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workerInstanceKey != rhs.workerInstanceKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeWorkerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeWorkerResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}worker_info\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._workerInfo) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._workerInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeWorkerResponse, rhs: Api.Workflowservice.V1.DescribeWorkerResponse) -> Bool {
    if lhs._workerInfo != rhs._workerInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PauseWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PauseWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{1}identity\0\u{1}reason\0\u{3}request_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PauseWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.PauseWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PauseWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PauseWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PauseWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.PauseWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UnpauseWorkflowExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpauseWorkflowExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{1}identity\0\u{1}reason\0\u{3}request_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 5)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UnpauseWorkflowExecutionRequest, rhs: Api.Workflowservice.V1.UnpauseWorkflowExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.UnpauseWorkflowExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UnpauseWorkflowExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.UnpauseWorkflowExecutionResponse, rhs: Api.Workflowservice.V1.UnpauseWorkflowExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}identity\0\u{3}request_id\0\u{3}activity_id\0\u{3}activity_type\0\u{3}task_queue\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{1}input\0\u{3}id_reuse_policy\0\u{3}id_conflict_policy\0\u{3}search_attributes\0\u{1}header\0\u{3}user_metadata\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _identity: String = String()
    var _requestID: String = String()
    var _activityID: String = String()
    var _activityType: Api.Common.V1.ActivityType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _idReusePolicy: Api.Enums.V1.ActivityIdReusePolicy = .unspecified
    var _idConflictPolicy: Api.Enums.V1.ActivityIdConflictPolicy = .unspecified
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _header: Api.Common.V1.Header? = nil
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _identity = source._identity
      _requestID = source._requestID
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _input = source._input
      _idReusePolicy = source._idReusePolicy
      _idConflictPolicy = source._idConflictPolicy
      _searchAttributes = source._searchAttributes
      _header = source._header
      _userMetadata = source._userMetadata
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._requestID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._idReusePolicy) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._idConflictPolicy) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 2)
      }
      if !_storage._requestID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestID, fieldNumber: 3)
      }
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 4)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if _storage._idReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._idReusePolicy, fieldNumber: 13)
      }
      if _storage._idConflictPolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._idConflictPolicy, fieldNumber: 14)
      }
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartActivityExecutionRequest, rhs: Api.Workflowservice.V1.StartActivityExecutionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._requestID != rhs_storage._requestID {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._idReusePolicy != rhs_storage._idReusePolicy {return false}
        if _storage._idConflictPolicy != rhs_storage._idConflictPolicy {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.StartActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}started\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.started) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    if self.started != false {
      try visitor.visitSingularBoolField(value: self.started, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.StartActivityExecutionResponse, rhs: Api.Workflowservice.V1.StartActivityExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs.started != rhs.started {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}activity_id\0\u{3}run_id\0\u{3}include_input\0\u{3}include_outcome\0\u{3}long_poll_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.includeInput) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.includeOutcome) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.longPollToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if self.includeInput != false {
      try visitor.visitSingularBoolField(value: self.includeInput, fieldNumber: 4)
    }
    if self.includeOutcome != false {
      try visitor.visitSingularBoolField(value: self.includeOutcome, fieldNumber: 5)
    }
    if !self.longPollToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.longPollToken, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeActivityExecutionRequest, rhs: Api.Workflowservice.V1.DescribeActivityExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.includeInput != rhs.includeInput {return false}
    if lhs.includeOutcome != rhs.includeOutcome {return false}
    if lhs.longPollToken != rhs.longPollToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DescribeActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DescribeActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}info\0\u{1}input\0\u{1}outcome\0\u{3}long_poll_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.longPollToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.longPollToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.longPollToken, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DescribeActivityExecutionResponse, rhs: Api.Workflowservice.V1.DescribeActivityExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs._info != rhs._info {return false}
    if lhs._input != rhs._input {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.longPollToken != rhs.longPollToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}activity_id\0\u{3}run_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollActivityExecutionRequest, rhs: Api.Workflowservice.V1.PollActivityExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.PollActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PollActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}run_id\0\u{1}outcome\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outcome) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 1)
    }
    try { if let v = self._outcome {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.PollActivityExecutionResponse, rhs: Api.Workflowservice.V1.PollActivityExecutionResponse) -> Bool {
    if lhs.runID != rhs.runID {return false}
    if lhs._outcome != rhs._outcome {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListActivityExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActivityExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}next_page_token\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 3)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListActivityExecutionsRequest, rhs: Api.Workflowservice.V1.ListActivityExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.ListActivityExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListActivityExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}executions\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.executions) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.executions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.executions, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.ListActivityExecutionsResponse, rhs: Api.Workflowservice.V1.ListActivityExecutionsResponse) -> Bool {
    if lhs.executions != rhs.executions {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountActivityExecutionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountActivityExecutionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}query\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.query) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.query.isEmpty {
      try visitor.visitSingularStringField(value: self.query, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountActivityExecutionsRequest, rhs: Api.Workflowservice.V1.CountActivityExecutionsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.query != rhs.query {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountActivityExecutionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CountActivityExecutionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0\u{1}groups\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 1)
    }
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountActivityExecutionsResponse, rhs: Api.Workflowservice.V1.CountActivityExecutionsResponse) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.groups != rhs.groups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.CountActivityExecutionsResponse.AggregationGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Workflowservice.V1.CountActivityExecutionsResponse.protoMessageName + ".AggregationGroup"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_values\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groupValues) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupValues.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groupValues, fieldNumber: 1)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.CountActivityExecutionsResponse.AggregationGroup, rhs: Api.Workflowservice.V1.CountActivityExecutionsResponse.AggregationGroup) -> Bool {
    if lhs.groupValues != rhs.groupValues {return false}
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RequestCancelActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCancelActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}activity_id\0\u{3}run_id\0\u{1}identity\0\u{3}request_id\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RequestCancelActivityExecutionRequest, rhs: Api.Workflowservice.V1.RequestCancelActivityExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.RequestCancelActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RequestCancelActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.RequestCancelActivityExecutionResponse, rhs: Api.Workflowservice.V1.RequestCancelActivityExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TerminateActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminateActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}activity_id\0\u{3}run_id\0\u{1}identity\0\u{3}request_id\0\u{1}reason\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TerminateActivityExecutionRequest, rhs: Api.Workflowservice.V1.TerminateActivityExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.TerminateActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminateActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.TerminateActivityExecutionResponse, rhs: Api.Workflowservice.V1.TerminateActivityExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteActivityExecutionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteActivityExecutionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}activity_id\0\u{3}run_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteActivityExecutionRequest, rhs: Api.Workflowservice.V1.DeleteActivityExecutionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Workflowservice.V1.DeleteActivityExecutionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteActivityExecutionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Workflowservice.V1.DeleteActivityExecutionResponse, rhs: Api.Workflowservice.V1.DeleteActivityExecutionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
