// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/failed_cause.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Enums.V1 {


  /// Workflow tasks can fail for various reasons. Note that some of these reasons can only originate
  /// from the server, and some of them can only originate from the SDK/worker.
  package enum WorkflowTaskFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Between starting and completing the workflow task (with a workflow completion command), some
    /// new command (like a signal) was processed into workflow history. The outstanding task will be
    /// failed with this reason, and a worker must pick up a new task.
    case unhandledCommand // = 1
    case badScheduleActivityAttributes // = 2
    case badRequestCancelActivityAttributes // = 3
    case badStartTimerAttributes // = 4
    case badCancelTimerAttributes // = 5
    case badRecordMarkerAttributes // = 6
    case badCompleteWorkflowExecutionAttributes // = 7
    case badFailWorkflowExecutionAttributes // = 8
    case badCancelWorkflowExecutionAttributes // = 9
    case badRequestCancelExternalWorkflowExecutionAttributes // = 10
    case badContinueAsNewAttributes // = 11
    case startTimerDuplicateID // = 12

    /// The worker wishes to fail the task and have the next one be generated on a normal, not sticky
    /// queue. Generally workers should prefer to use the explicit `ResetStickyTaskQueue` RPC call.
    case resetStickyTaskQueue // = 13
    case workflowWorkerUnhandledFailure // = 14
    case badSignalWorkflowExecutionAttributes // = 15
    case badStartChildExecutionAttributes // = 16
    case forceCloseCommand // = 17
    case failoverCloseCommand // = 18
    case badSignalInputSize // = 19
    case resetWorkflow // = 20
    case badBinary // = 21
    case scheduleActivityDuplicateID // = 22
    case badSearchAttributes // = 23

    /// The worker encountered a mismatch while replaying history between what was expected, and
    /// what the workflow code actually did.
    case nonDeterministicError // = 24
    case badModifyWorkflowPropertiesAttributes // = 25

    /// We send the below error codes to users when their requests would violate a size constraint
    /// of their workflow. We do this to ensure that the state of their workflow does not become too
    /// large because that can cause severe performance degradation. You can modify the thresholds for
    /// each of these errors within your dynamic config.
    ///
    /// Spawning a new child workflow would cause this workflow to exceed its limit of pending child
    /// workflows.
    case pendingChildWorkflowsLimitExceeded // = 26

    /// Starting a new activity would cause this workflow to exceed its limit of pending activities
    /// that we track.
    case pendingActivitiesLimitExceeded // = 27

    /// A workflow has a buffer of signals that have not yet reached their destination. We return this
    /// error when sending a new signal would exceed the capacity of this buffer.
    case pendingSignalsLimitExceeded // = 28

    /// Similarly, we have a buffer of pending requests to cancel other workflows. We return this error
    /// when our capacity for pending cancel requests is already reached.
    case pendingRequestCancelLimitExceeded // = 29

    /// Workflow execution update message (update.Acceptance, update.Rejection, or update.Response)
    /// has wrong format, or missing required fields.
    case badUpdateWorkflowExecutionMessage // = 30

    /// Similar to WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND, but for updates.
    case unhandledUpdate // = 31

    /// A workflow task completed with an invalid ScheduleNexusOperation command.
    case badScheduleNexusOperationAttributes // = 32

    /// A workflow task completed requesting to schedule a Nexus Operation exceeding the server configured limit.
    case pendingNexusOperationsLimitExceeded // = 33

    /// A workflow task completed with an invalid RequestCancelNexusOperation command.
    case badRequestCancelNexusOperationAttributes // = 34

    /// A workflow task completed requesting a feature that's disabled on the server (either system wide or - typically -
    /// for the workflow's namespace).
    /// Check the workflow task failure message for more information.
    case featureDisabled // = 35

    /// A workflow task failed because a grpc message was too large.
    case grpcMessageTooLarge // = 36

    /// A workflow task failed because payloads were too large.
    case payloadsTooLarge // = 37
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .unhandledCommand
      case 2: self = .badScheduleActivityAttributes
      case 3: self = .badRequestCancelActivityAttributes
      case 4: self = .badStartTimerAttributes
      case 5: self = .badCancelTimerAttributes
      case 6: self = .badRecordMarkerAttributes
      case 7: self = .badCompleteWorkflowExecutionAttributes
      case 8: self = .badFailWorkflowExecutionAttributes
      case 9: self = .badCancelWorkflowExecutionAttributes
      case 10: self = .badRequestCancelExternalWorkflowExecutionAttributes
      case 11: self = .badContinueAsNewAttributes
      case 12: self = .startTimerDuplicateID
      case 13: self = .resetStickyTaskQueue
      case 14: self = .workflowWorkerUnhandledFailure
      case 15: self = .badSignalWorkflowExecutionAttributes
      case 16: self = .badStartChildExecutionAttributes
      case 17: self = .forceCloseCommand
      case 18: self = .failoverCloseCommand
      case 19: self = .badSignalInputSize
      case 20: self = .resetWorkflow
      case 21: self = .badBinary
      case 22: self = .scheduleActivityDuplicateID
      case 23: self = .badSearchAttributes
      case 24: self = .nonDeterministicError
      case 25: self = .badModifyWorkflowPropertiesAttributes
      case 26: self = .pendingChildWorkflowsLimitExceeded
      case 27: self = .pendingActivitiesLimitExceeded
      case 28: self = .pendingSignalsLimitExceeded
      case 29: self = .pendingRequestCancelLimitExceeded
      case 30: self = .badUpdateWorkflowExecutionMessage
      case 31: self = .unhandledUpdate
      case 32: self = .badScheduleNexusOperationAttributes
      case 33: self = .pendingNexusOperationsLimitExceeded
      case 34: self = .badRequestCancelNexusOperationAttributes
      case 35: self = .featureDisabled
      case 36: self = .grpcMessageTooLarge
      case 37: self = .payloadsTooLarge
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .unhandledCommand: return 1
      case .badScheduleActivityAttributes: return 2
      case .badRequestCancelActivityAttributes: return 3
      case .badStartTimerAttributes: return 4
      case .badCancelTimerAttributes: return 5
      case .badRecordMarkerAttributes: return 6
      case .badCompleteWorkflowExecutionAttributes: return 7
      case .badFailWorkflowExecutionAttributes: return 8
      case .badCancelWorkflowExecutionAttributes: return 9
      case .badRequestCancelExternalWorkflowExecutionAttributes: return 10
      case .badContinueAsNewAttributes: return 11
      case .startTimerDuplicateID: return 12
      case .resetStickyTaskQueue: return 13
      case .workflowWorkerUnhandledFailure: return 14
      case .badSignalWorkflowExecutionAttributes: return 15
      case .badStartChildExecutionAttributes: return 16
      case .forceCloseCommand: return 17
      case .failoverCloseCommand: return 18
      case .badSignalInputSize: return 19
      case .resetWorkflow: return 20
      case .badBinary: return 21
      case .scheduleActivityDuplicateID: return 22
      case .badSearchAttributes: return 23
      case .nonDeterministicError: return 24
      case .badModifyWorkflowPropertiesAttributes: return 25
      case .pendingChildWorkflowsLimitExceeded: return 26
      case .pendingActivitiesLimitExceeded: return 27
      case .pendingSignalsLimitExceeded: return 28
      case .pendingRequestCancelLimitExceeded: return 29
      case .badUpdateWorkflowExecutionMessage: return 30
      case .unhandledUpdate: return 31
      case .badScheduleNexusOperationAttributes: return 32
      case .pendingNexusOperationsLimitExceeded: return 33
      case .badRequestCancelNexusOperationAttributes: return 34
      case .featureDisabled: return 35
      case .grpcMessageTooLarge: return 36
      case .payloadsTooLarge: return 37
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkflowTaskFailedCause] = [
      .unspecified,
      .unhandledCommand,
      .badScheduleActivityAttributes,
      .badRequestCancelActivityAttributes,
      .badStartTimerAttributes,
      .badCancelTimerAttributes,
      .badRecordMarkerAttributes,
      .badCompleteWorkflowExecutionAttributes,
      .badFailWorkflowExecutionAttributes,
      .badCancelWorkflowExecutionAttributes,
      .badRequestCancelExternalWorkflowExecutionAttributes,
      .badContinueAsNewAttributes,
      .startTimerDuplicateID,
      .resetStickyTaskQueue,
      .workflowWorkerUnhandledFailure,
      .badSignalWorkflowExecutionAttributes,
      .badStartChildExecutionAttributes,
      .forceCloseCommand,
      .failoverCloseCommand,
      .badSignalInputSize,
      .resetWorkflow,
      .badBinary,
      .scheduleActivityDuplicateID,
      .badSearchAttributes,
      .nonDeterministicError,
      .badModifyWorkflowPropertiesAttributes,
      .pendingChildWorkflowsLimitExceeded,
      .pendingActivitiesLimitExceeded,
      .pendingSignalsLimitExceeded,
      .pendingRequestCancelLimitExceeded,
      .badUpdateWorkflowExecutionMessage,
      .unhandledUpdate,
      .badScheduleNexusOperationAttributes,
      .pendingNexusOperationsLimitExceeded,
      .badRequestCancelNexusOperationAttributes,
      .featureDisabled,
      .grpcMessageTooLarge,
      .payloadsTooLarge,
    ]

  }
}
extension Api.Enums.V1 {


  package enum StartChildWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case workflowAlreadyExists // = 1
    case namespaceNotFound // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .workflowAlreadyExists
      case 2: self = .namespaceNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .workflowAlreadyExists: return 1
      case .namespaceNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.StartChildWorkflowExecutionFailedCause] = [
      .unspecified,
      .workflowAlreadyExists,
      .namespaceNotFound,
    ]

  }
}
extension Api.Enums.V1 {


  package enum CancelExternalWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case externalWorkflowExecutionNotFound // = 1
    case namespaceNotFound // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .externalWorkflowExecutionNotFound
      case 2: self = .namespaceNotFound
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .externalWorkflowExecutionNotFound: return 1
      case .namespaceNotFound: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.CancelExternalWorkflowExecutionFailedCause] = [
      .unspecified,
      .externalWorkflowExecutionNotFound,
      .namespaceNotFound,
    ]

  }
}
extension Api.Enums.V1 {


  package enum SignalExternalWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case externalWorkflowExecutionNotFound // = 1
    case namespaceNotFound // = 2

    /// Signal count limit is per workflow and controlled by server dynamic config "history.maximumSignalsPerExecution"
    case signalCountLimitExceeded // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .externalWorkflowExecutionNotFound
      case 2: self = .namespaceNotFound
      case 3: self = .signalCountLimitExceeded
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .externalWorkflowExecutionNotFound: return 1
      case .namespaceNotFound: return 2
      case .signalCountLimitExceeded: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.SignalExternalWorkflowExecutionFailedCause] = [
      .unspecified,
      .externalWorkflowExecutionNotFound,
      .namespaceNotFound,
      .signalCountLimitExceeded,
    ]

  }
}
extension Api.Enums.V1 {


  package enum ResourceExhaustedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Caller exceeds request per second limit.
    case rpsLimit // = 1

    /// Caller exceeds max concurrent request limit.
    case concurrentLimit // = 2

    /// System overloaded.
    case systemOverloaded // = 3

    /// Namespace exceeds persistence rate limit.
    case persistenceLimit // = 4

    /// Workflow is busy
    case busyWorkflow // = 5

    /// Caller exceeds action per second limit.
    case apsLimit // = 6

    /// Persistence storage limit exceeded.
    case persistenceStorageLimit // = 7

    /// Circuit breaker is open/half-open.
    case circuitBreakerOpen // = 8

    /// Namespace exceeds operations rate limit.
    case opsLimit // = 9

    /// Limits related to Worker Deployments are reached.
    case workerDeploymentLimits // = 10
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .rpsLimit
      case 2: self = .concurrentLimit
      case 3: self = .systemOverloaded
      case 4: self = .persistenceLimit
      case 5: self = .busyWorkflow
      case 6: self = .apsLimit
      case 7: self = .persistenceStorageLimit
      case 8: self = .circuitBreakerOpen
      case 9: self = .opsLimit
      case 10: self = .workerDeploymentLimits
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .rpsLimit: return 1
      case .concurrentLimit: return 2
      case .systemOverloaded: return 3
      case .persistenceLimit: return 4
      case .busyWorkflow: return 5
      case .apsLimit: return 6
      case .persistenceStorageLimit: return 7
      case .circuitBreakerOpen: return 8
      case .opsLimit: return 9
      case .workerDeploymentLimits: return 10
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ResourceExhaustedCause] = [
      .unspecified,
      .rpsLimit,
      .concurrentLimit,
      .systemOverloaded,
      .persistenceLimit,
      .busyWorkflow,
      .apsLimit,
      .persistenceStorageLimit,
      .circuitBreakerOpen,
      .opsLimit,
      .workerDeploymentLimits,
    ]

  }
}
extension Api.Enums.V1 {


  package enum ResourceExhaustedScope: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Exhausted resource is a system-level resource.
    case namespace // = 1

    /// Exhausted resource is a namespace-level resource.
    case system // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .namespace
      case 2: self = .system
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .namespace: return 1
      case .system: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ResourceExhaustedScope] = [
      .unspecified,
      .namespace,
      .system,
    ]

  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Api.Enums.V1.WorkflowTaskFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_TASK_FAILED_CAUSE_UNSPECIFIED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_ACTIVITY_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_ACTIVITY_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_START_TIMER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_TIMER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_RECORD_MARKER_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_COMPLETE_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_FAIL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CANCEL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_CONTINUE_AS_NEW_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_START_TIMER_DUPLICATE_ID\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_RESET_STICKY_TASK_QUEUE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_WORKFLOW_WORKER_UNHANDLED_FAILURE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_WORKFLOW_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_START_CHILD_EXECUTION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FORCE_CLOSE_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FAILOVER_CLOSE_COMMAND\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SIGNAL_INPUT_SIZE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_RESET_WORKFLOW\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_BINARY\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_SCHEDULE_ACTIVITY_DUPLICATE_ID\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SEARCH_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_NON_DETERMINISTIC_ERROR\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_MODIFY_WORKFLOW_PROPERTIES_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_CHILD_WORKFLOWS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_ACTIVITIES_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_SIGNALS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_REQUEST_CANCEL_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_UPDATE_WORKFLOW_EXECUTION_MESSAGE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_UNHANDLED_UPDATE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_SCHEDULE_NEXUS_OPERATION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PENDING_NEXUS_OPERATIONS_LIMIT_EXCEEDED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_BAD_REQUEST_CANCEL_NEXUS_OPERATION_ATTRIBUTES\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_FEATURE_DISABLED\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_GRPC_MESSAGE_TOO_LARGE\0\u{1}WORKFLOW_TASK_FAILED_CAUSE_PAYLOADS_TOO_LARGE\0")
}

extension Api.Enums.V1.StartChildWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0")
}

extension Api.Enums.V1.CancelExternalWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND\0\u{1}CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0")
}

extension Api.Enums.V1.SignalExternalWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_EXTERNAL_WORKFLOW_EXECUTION_NOT_FOUND\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_NAMESPACE_NOT_FOUND\0\u{1}SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED_CAUSE_SIGNAL_COUNT_LIMIT_EXCEEDED\0")
}

extension Api.Enums.V1.ResourceExhaustedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RESOURCE_EXHAUSTED_CAUSE_UNSPECIFIED\0\u{1}RESOURCE_EXHAUSTED_CAUSE_RPS_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_CONCURRENT_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_SYSTEM_OVERLOADED\0\u{1}RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_BUSY_WORKFLOW\0\u{1}RESOURCE_EXHAUSTED_CAUSE_APS_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_PERSISTENCE_STORAGE_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_CIRCUIT_BREAKER_OPEN\0\u{1}RESOURCE_EXHAUSTED_CAUSE_OPS_LIMIT\0\u{1}RESOURCE_EXHAUSTED_CAUSE_WORKER_DEPLOYMENT_LIMITS\0")
}

extension Api.Enums.V1.ResourceExhaustedScope: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RESOURCE_EXHAUSTED_SCOPE_UNSPECIFIED\0\u{1}RESOURCE_EXHAUSTED_SCOPE_NAMESPACE\0\u{1}RESOURCE_EXHAUSTED_SCOPE_SYSTEM\0")
}
