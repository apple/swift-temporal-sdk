// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/child_workflow/child_workflow.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Coresdk.ChildWorkflow {


  /// Used by the service to determine the fate of a child workflow
  /// in case its parent is closed.
  package enum ParentClosePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Let's the server set the default.
    case unspecified // = 0

    /// Terminate means terminating the child workflow.
    case terminate // = 1

    /// Abandon means not doing anything on the child workflow.
    case abandon // = 2

    /// Cancel means requesting cancellation on the child workflow.
    case requestCancel // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .terminate
      case 2: self = .abandon
      case 3: self = .requestCancel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .terminate: return 1
      case .abandon: return 2
      case .requestCancel: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.ChildWorkflow.ParentClosePolicy] = [
      .unspecified,
      .terminate,
      .abandon,
      .requestCancel,
    ]

  }
}
extension Coresdk.ChildWorkflow {


  /// Possible causes of failure to start a child workflow
  package enum StartChildWorkflowExecutionFailedCause: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case workflowAlreadyExists // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .workflowAlreadyExists
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .workflowAlreadyExists: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.ChildWorkflow.StartChildWorkflowExecutionFailedCause] = [
      .unspecified,
      .workflowAlreadyExists,
    ]

  }
}
extension Coresdk.ChildWorkflow {


  /// Controls at which point to report back to lang when a child workflow is cancelled
  package enum ChildWorkflowCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Do not request cancellation of the child workflow if already scheduled
    case abandon // = 0

    /// Initiate a cancellation request and immediately report cancellation to the parent.
    case tryCancel // = 1

    /// Wait for child cancellation completion.
    case waitCancellationCompleted // = 2

    /// Request cancellation of the child and wait for confirmation that the request was received.
    case waitCancellationRequested // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .abandon
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .abandon
      case 1: self = .tryCancel
      case 2: self = .waitCancellationCompleted
      case 3: self = .waitCancellationRequested
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .abandon: return 0
      case .tryCancel: return 1
      case .waitCancellationCompleted: return 2
      case .waitCancellationRequested: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.ChildWorkflow.ChildWorkflowCancellationType] = [
      .abandon,
      .tryCancel,
      .waitCancellationCompleted,
      .waitCancellationRequested,
    ]

  }
}
extension Coresdk.ChildWorkflow {


  /// Used by core to resolve child workflow executions.
  package struct ChildWorkflowResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var status: Coresdk.ChildWorkflow.ChildWorkflowResult.OneOf_Status? = nil

    package var completed: Coresdk.ChildWorkflow.Success {
      get {
        if case .completed(let v)? = status {return v}
        return Coresdk.ChildWorkflow.Success()
      }
      set {status = .completed(newValue)}
    }

    package var failed: Coresdk.ChildWorkflow.Failure {
      get {
        if case .failed(let v)? = status {return v}
        return Coresdk.ChildWorkflow.Failure()
      }
      set {status = .failed(newValue)}
    }

    package var cancelled: Coresdk.ChildWorkflow.Cancellation {
      get {
        if case .cancelled(let v)? = status {return v}
        return Coresdk.ChildWorkflow.Cancellation()
      }
      set {status = .cancelled(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Status: Equatable, Sendable {
      case completed(Coresdk.ChildWorkflow.Success)
      case failed(Coresdk.ChildWorkflow.Failure)
      case cancelled(Coresdk.ChildWorkflow.Cancellation)

    }

    package init() {}
  }
}
extension Coresdk.ChildWorkflow {


  /// Used in ChildWorkflowResult to report successful completion.
  package struct Success: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var result: Api.Common.V1.Payload {
      get {_result ?? Api.Common.V1.Payload()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    package var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    package mutating func clearResult() {self._result = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _result: Api.Common.V1.Payload? = nil
  }
}
extension Coresdk.ChildWorkflow {


  /// Used in ChildWorkflowResult to report non successful outcomes such as
  /// application failures, timeouts, terminations, and cancellations.
  package struct Failure: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Coresdk.ChildWorkflow {


  /// Used in ChildWorkflowResult to report cancellation.
  /// Failure should be ChildWorkflowFailure with a CanceledFailure cause.
  package struct Cancellation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.child_workflow"

extension Coresdk.ChildWorkflow.ParentClosePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARENT_CLOSE_POLICY_UNSPECIFIED\0\u{1}PARENT_CLOSE_POLICY_TERMINATE\0\u{1}PARENT_CLOSE_POLICY_ABANDON\0\u{1}PARENT_CLOSE_POLICY_REQUEST_CANCEL\0")
}

extension Coresdk.ChildWorkflow.StartChildWorkflowExecutionFailedCause: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_UNSPECIFIED\0\u{1}START_CHILD_WORKFLOW_EXECUTION_FAILED_CAUSE_WORKFLOW_ALREADY_EXISTS\0")
}

extension Coresdk.ChildWorkflow.ChildWorkflowCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ABANDON\0\u{1}TRY_CANCEL\0\u{1}WAIT_CANCELLATION_COMPLETED\0\u{1}WAIT_CANCELLATION_REQUESTED\0")
}

extension Coresdk.ChildWorkflow.ChildWorkflowResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ChildWorkflowResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Coresdk.ChildWorkflow.Success?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Coresdk.ChildWorkflow.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Coresdk.ChildWorkflow.Cancellation?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ChildWorkflow.ChildWorkflowResult, rhs: Coresdk.ChildWorkflow.ChildWorkflowResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ChildWorkflow.Success: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Success"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ChildWorkflow.Success, rhs: Coresdk.ChildWorkflow.Success) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ChildWorkflow.Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Failure"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ChildWorkflow.Failure, rhs: Coresdk.ChildWorkflow.Failure) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ChildWorkflow.Cancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancellation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ChildWorkflow.Cancellation, rhs: Coresdk.ChildWorkflow.Cancellation) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
