// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/workflow.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Enums.V1 {


  /// Defines whether to allow re-using a workflow id from a previously *closed* workflow.
  /// If the request is denied, the server returns a `WorkflowExecutionAlreadyStartedFailure` error.
  ///
  /// See `WorkflowIdConflictPolicy` for handling workflow id duplication with a *running* workflow.
  package enum WorkflowIdReusePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Allow starting a workflow execution using the same workflow id.
    case allowDuplicate // = 1

    /// Allow starting a workflow execution using the same workflow id, only when the last
    /// execution's final state is one of [terminated, cancelled, timed out, failed].
    case allowDuplicateFailedOnly // = 2

    /// Do not permit re-use of the workflow id for this workflow. Future start workflow requests
    /// could potentially change the policy, allowing re-use of the workflow id.
    case rejectDuplicate // = 3

    /// Terminate the current Workflow if one is already running; otherwise allow reusing the
    /// Workflow ID. When using this option, `WorkflowIdConflictPolicy` must be left unspecified.
    ///
    /// Deprecated. Instead, set `WorkflowIdReusePolicy` to `ALLOW_DUPLICATE` and
    /// `WorkflowIdConflictPolicy` to `TERMINATE_EXISTING`. Note that `WorkflowIdConflictPolicy`
    /// requires Temporal Server v1.24.0 or later.
    ///
    /// NOTE: This enum value was marked as deprecated in the .proto file
    case terminateIfRunning // = 4
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .allowDuplicate
      case 2: self = .allowDuplicateFailedOnly
      case 3: self = .rejectDuplicate
      case 4: self = .terminateIfRunning
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .allowDuplicate: return 1
      case .allowDuplicateFailedOnly: return 2
      case .rejectDuplicate: return 3
      case .terminateIfRunning: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkflowIdReusePolicy] = [
      .unspecified,
      .allowDuplicate,
      .allowDuplicateFailedOnly,
      .rejectDuplicate,
      .terminateIfRunning,
    ]

  }
}
extension Api.Enums.V1 {


  /// Defines what to do when trying to start a workflow with the same workflow id as a *running* workflow.
  /// Note that it is *never* valid to have two actively running instances of the same workflow id.
  ///
  /// See `WorkflowIdReusePolicy` for handling workflow id duplication with a *closed* workflow.
  package enum WorkflowIdConflictPolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Don't start a new workflow; instead return `WorkflowExecutionAlreadyStartedFailure`.
    case fail // = 1

    /// Don't start a new workflow; instead return a workflow handle for the running workflow.
    case useExisting // = 2

    /// Terminate the running workflow before starting a new one.
    case terminateExisting // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .fail
      case 2: self = .useExisting
      case 3: self = .terminateExisting
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .fail: return 1
      case .useExisting: return 2
      case .terminateExisting: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkflowIdConflictPolicy] = [
      .unspecified,
      .fail,
      .useExisting,
      .terminateExisting,
    ]

  }
}
extension Api.Enums.V1 {


  /// Defines how child workflows will react to their parent completing
  package enum ParentClosePolicy: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// The child workflow will also terminate
    case terminate // = 1

    /// The child workflow will do nothing
    case abandon // = 2

    /// Cancellation will be requested of the child workflow
    case requestCancel // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .terminate
      case 2: self = .abandon
      case 3: self = .requestCancel
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .terminate: return 1
      case .abandon: return 2
      case .requestCancel: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ParentClosePolicy] = [
      .unspecified,
      .terminate,
      .abandon,
      .requestCancel,
    ]

  }
}
extension Api.Enums.V1 {


  package enum ContinueAsNewInitiator: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// The workflow itself requested to continue as new
    case workflow // = 1

    /// The workflow continued as new because it is retrying
    case retry // = 2

    /// The workflow continued as new because cron has triggered a new execution
    case cronSchedule // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .workflow
      case 2: self = .retry
      case 3: self = .cronSchedule
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .workflow: return 1
      case .retry: return 2
      case .cronSchedule: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ContinueAsNewInitiator] = [
      .unspecified,
      .workflow,
      .retry,
      .cronSchedule,
    ]

  }
}
extension Api.Enums.V1 {


  /// (-- api-linter: core::0216::synonyms=disabled
  ///     aip.dev/not-precedent: There is WorkflowExecutionState already in another package. --)
  package enum WorkflowExecutionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Value 1 is hardcoded in SQL persistence.
    case running // = 1
    case completed // = 2
    case failed // = 3
    case canceled // = 4
    case terminated // = 5
    case continuedAsNew // = 6
    case timedOut // = 7
    case paused // = 8
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .running
      case 2: self = .completed
      case 3: self = .failed
      case 4: self = .canceled
      case 5: self = .terminated
      case 6: self = .continuedAsNew
      case 7: self = .timedOut
      case 8: self = .paused
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .running: return 1
      case .completed: return 2
      case .failed: return 3
      case .canceled: return 4
      case .terminated: return 5
      case .continuedAsNew: return 6
      case .timedOut: return 7
      case .paused: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.WorkflowExecutionStatus] = [
      .unspecified,
      .running,
      .completed,
      .failed,
      .canceled,
      .terminated,
      .continuedAsNew,
      .timedOut,
      .paused,
    ]

  }
}
extension Api.Enums.V1 {


  package enum PendingActivityState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case scheduled // = 1
    case started // = 2
    case cancelRequested // = 3

    /// PAUSED means activity is paused on the server, and is not running in the worker
    case paused // = 4

    /// PAUSE_REQUESTED means activity is currently running on the worker, but paused on the server
    case pauseRequested // = 5
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .scheduled
      case 2: self = .started
      case 3: self = .cancelRequested
      case 4: self = .paused
      case 5: self = .pauseRequested
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .scheduled: return 1
      case .started: return 2
      case .cancelRequested: return 3
      case .paused: return 4
      case .pauseRequested: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.PendingActivityState] = [
      .unspecified,
      .scheduled,
      .started,
      .cancelRequested,
      .paused,
      .pauseRequested,
    ]

  }
}
extension Api.Enums.V1 {


  package enum PendingWorkflowTaskState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case scheduled // = 1
    case started // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .scheduled
      case 2: self = .started
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .scheduled: return 1
      case .started: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.PendingWorkflowTaskState] = [
      .unspecified,
      .scheduled,
      .started,
    ]

  }
}
extension Api.Enums.V1 {


  package enum HistoryEventFilterType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case allEvent // = 1
    case closeEvent // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .allEvent
      case 2: self = .closeEvent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .allEvent: return 1
      case .closeEvent: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.HistoryEventFilterType] = [
      .unspecified,
      .allEvent,
      .closeEvent,
    ]

  }
}
extension Api.Enums.V1 {


  package enum RetryState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case inProgress // = 1
    case nonRetryableFailure // = 2
    case timeout // = 3
    case maximumAttemptsReached // = 4
    case retryPolicyNotSet // = 5
    case internalServerError // = 6
    case cancelRequested // = 7
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inProgress
      case 2: self = .nonRetryableFailure
      case 3: self = .timeout
      case 4: self = .maximumAttemptsReached
      case 5: self = .retryPolicyNotSet
      case 6: self = .internalServerError
      case 7: self = .cancelRequested
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inProgress: return 1
      case .nonRetryableFailure: return 2
      case .timeout: return 3
      case .maximumAttemptsReached: return 4
      case .retryPolicyNotSet: return 5
      case .internalServerError: return 6
      case .cancelRequested: return 7
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.RetryState] = [
      .unspecified,
      .inProgress,
      .nonRetryableFailure,
      .timeout,
      .maximumAttemptsReached,
      .retryPolicyNotSet,
      .internalServerError,
      .cancelRequested,
    ]

  }
}
extension Api.Enums.V1 {


  package enum TimeoutType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0
    case startToClose // = 1
    case scheduleToStart // = 2
    case scheduleToClose // = 3
    case heartbeat // = 4
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .startToClose
      case 2: self = .scheduleToStart
      case 3: self = .scheduleToClose
      case 4: self = .heartbeat
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .startToClose: return 1
      case .scheduleToStart: return 2
      case .scheduleToClose: return 3
      case .heartbeat: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.TimeoutType] = [
      .unspecified,
      .startToClose,
      .scheduleToStart,
      .scheduleToClose,
      .heartbeat,
    ]

  }
}
extension Api.Enums.V1 {


  /// Versioning Behavior specifies if and how a workflow execution moves between Worker Deployment
  /// Versions. The Versioning Behavior of a workflow execution is typically specified by the worker
  /// who completes the first task of the execution, but is also overridable manually for new and
  /// existing workflows (see VersioningOverride).
  /// Experimental. Worker Deployments are experimental and might significantly change in the future.
  package enum VersioningBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Workflow execution does not have a Versioning Behavior and is called Unversioned. This is the
    /// legacy behavior. An Unversioned workflow's task can go to any Unversioned worker (see
    /// `WorkerVersioningMode`.)
    /// User needs to use Patching to keep the new code compatible with prior versions when dealing
    /// with Unversioned workflows.
    case unspecified // = 0

    /// Workflow will start on its Target Version and then will be pinned to that same Deployment
    /// Version until completion (the Version that this Workflow is pinned to is specified in
    /// `versioning_info.version` and is the Pinned Version of the Workflow).
    ///
    /// The workflow's Target Version is the Current Version of its Task Queue, or, if the
    /// Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
    /// Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
    /// Ramping group depends on its Workflow ID and and the Ramp Percentage.
    ///
    /// This behavior eliminates most of compatibility concerns users face when changing their code.
    /// Patching is not needed when pinned workflows code change.
    /// Can be overridden explicitly via `UpdateWorkflowExecutionOptions` API to move the
    /// execution to another Deployment Version.
    /// Activities of `PINNED` workflows are sent to the same Deployment Version. Exception to this
    /// would be when the activity Task Queue workers are not present in the workflow's Deployment
    /// Version, in which case the activity will be sent to the Current Deployment Version of its own
    /// task queue.
    case pinned // = 1

    /// Workflow will automatically move to its Target Version when the next workflow task is dispatched.
    ///
    /// The workflow's Target Version is the Current Version of its Task Queue, or, if the
    /// Task Queue has a Ramping Version with non-zero Ramp Percentage `P`, the workflow's Target
    /// Version has a P% chance of being the Ramping Version. Whether a workflow falls into the
    /// Ramping group depends on its Workflow ID and and the Ramp Percentage.
    ///
    /// AutoUpgrade behavior is suitable for long-running workflows as it allows them to move to the
    /// latest Deployment Version, but the user still needs to use Patching to keep the new code
    /// compatible with prior versions for changed workflow types.
    /// Activities of `AUTO_UPGRADE` workflows are sent to the Deployment Version of the workflow
    /// execution (as specified in versioning_info.version based on the last completed
    /// workflow task). Exception to this would be when the activity Task Queue workers are not
    /// present in the workflow's Deployment Version, in which case, the activity will be sent to a
    /// different Deployment Version according to the Current or Ramping Deployment Version of its own
    /// Task Queue.
    /// Workflows stuck on a backlogged activity will still auto-upgrade if their Target Version
    /// changes, without having to wait for the backlogged activity to complete on the old Version.
    case autoUpgrade // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .pinned
      case 2: self = .autoUpgrade
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .pinned: return 1
      case .autoUpgrade: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.VersioningBehavior] = [
      .unspecified,
      .pinned,
      .autoUpgrade,
    ]

  }
}
extension Api.Enums.V1 {


  /// Experimental. Defines the versioning behavior to be used by the first task of a new workflow run in a continue-as-new chain.
  package enum ContinueAsNewVersioningBehavior: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Start the new run with AutoUpgrade behavior. Use the Target Version of the workflow's task queue at
    /// start-time, as AutoUpgrade workflows do. After the first workflow task completes, use whatever
    /// Versioning Behavior the workflow is annotated with in the workflow code.
    ///
    /// Note that if the previous workflow had a Pinned override, that override will be inherited by the
    /// new workflow run regardless of the ContinueAsNewVersioningBehavior specified in the continue-as-new
    /// command. If a Pinned override is inherited by the new run, and the new run starts with AutoUpgrade
    /// behavior, the base version of the new run will be the Target Version as described above, but the
    /// effective version will be whatever is specified by the Versioning Override until the override is removed.
    case autoUpgrade // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .autoUpgrade
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .autoUpgrade: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.ContinueAsNewVersioningBehavior] = [
      .unspecified,
      .autoUpgrade,
    ]

  }
}
extension Api.Enums.V1 {


  /// SuggestContinueAsNewReason specifies why SuggestContinueAsNew is true.
  package enum SuggestContinueAsNewReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Workflow History size is getting too large.
    case historySizeTooLarge // = 1

    /// Workflow History event count is getting too large.
    case tooManyHistoryEvents // = 2

    /// Workflow's count of completed plus in-flight updates is too large.
    case tooManyUpdates // = 3

    /// Workflow's Target Worker Deployment Version is different from its
    /// Current Version and the workflow is versioned.
    case targetWorkerDeploymentVersionChanged // = 4
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .historySizeTooLarge
      case 2: self = .tooManyHistoryEvents
      case 3: self = .tooManyUpdates
      case 4: self = .targetWorkerDeploymentVersionChanged
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .historySizeTooLarge: return 1
      case .tooManyHistoryEvents: return 2
      case .tooManyUpdates: return 3
      case .targetWorkerDeploymentVersionChanged: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.SuggestContinueAsNewReason] = [
      .unspecified,
      .historySizeTooLarge,
      .tooManyHistoryEvents,
      .tooManyUpdates,
      .targetWorkerDeploymentVersionChanged,
    ]

  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Api.Enums.V1.WorkflowIdReusePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED\0\u{1}WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE\0\u{1}WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE_FAILED_ONLY\0\u{1}WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE\0\u{1}WORKFLOW_ID_REUSE_POLICY_TERMINATE_IF_RUNNING\0")
}

extension Api.Enums.V1.WorkflowIdConflictPolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_FAIL\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_USE_EXISTING\0\u{1}WORKFLOW_ID_CONFLICT_POLICY_TERMINATE_EXISTING\0")
}

extension Api.Enums.V1.ParentClosePolicy: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PARENT_CLOSE_POLICY_UNSPECIFIED\0\u{1}PARENT_CLOSE_POLICY_TERMINATE\0\u{1}PARENT_CLOSE_POLICY_ABANDON\0\u{1}PARENT_CLOSE_POLICY_REQUEST_CANCEL\0")
}

extension Api.Enums.V1.ContinueAsNewInitiator: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONTINUE_AS_NEW_INITIATOR_UNSPECIFIED\0\u{1}CONTINUE_AS_NEW_INITIATOR_WORKFLOW\0\u{1}CONTINUE_AS_NEW_INITIATOR_RETRY\0\u{1}CONTINUE_AS_NEW_INITIATOR_CRON_SCHEDULE\0")
}

extension Api.Enums.V1.WorkflowExecutionStatus: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WORKFLOW_EXECUTION_STATUS_UNSPECIFIED\0\u{1}WORKFLOW_EXECUTION_STATUS_RUNNING\0\u{1}WORKFLOW_EXECUTION_STATUS_COMPLETED\0\u{1}WORKFLOW_EXECUTION_STATUS_FAILED\0\u{1}WORKFLOW_EXECUTION_STATUS_CANCELED\0\u{1}WORKFLOW_EXECUTION_STATUS_TERMINATED\0\u{1}WORKFLOW_EXECUTION_STATUS_CONTINUED_AS_NEW\0\u{1}WORKFLOW_EXECUTION_STATUS_TIMED_OUT\0\u{1}WORKFLOW_EXECUTION_STATUS_PAUSED\0")
}

extension Api.Enums.V1.PendingActivityState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PENDING_ACTIVITY_STATE_UNSPECIFIED\0\u{1}PENDING_ACTIVITY_STATE_SCHEDULED\0\u{1}PENDING_ACTIVITY_STATE_STARTED\0\u{1}PENDING_ACTIVITY_STATE_CANCEL_REQUESTED\0\u{1}PENDING_ACTIVITY_STATE_PAUSED\0\u{1}PENDING_ACTIVITY_STATE_PAUSE_REQUESTED\0")
}

extension Api.Enums.V1.PendingWorkflowTaskState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PENDING_WORKFLOW_TASK_STATE_UNSPECIFIED\0\u{1}PENDING_WORKFLOW_TASK_STATE_SCHEDULED\0\u{1}PENDING_WORKFLOW_TASK_STATE_STARTED\0")
}

extension Api.Enums.V1.HistoryEventFilterType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0HISTORY_EVENT_FILTER_TYPE_UNSPECIFIED\0\u{1}HISTORY_EVENT_FILTER_TYPE_ALL_EVENT\0\u{1}HISTORY_EVENT_FILTER_TYPE_CLOSE_EVENT\0")
}

extension Api.Enums.V1.RetryState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RETRY_STATE_UNSPECIFIED\0\u{1}RETRY_STATE_IN_PROGRESS\0\u{1}RETRY_STATE_NON_RETRYABLE_FAILURE\0\u{1}RETRY_STATE_TIMEOUT\0\u{1}RETRY_STATE_MAXIMUM_ATTEMPTS_REACHED\0\u{1}RETRY_STATE_RETRY_POLICY_NOT_SET\0\u{1}RETRY_STATE_INTERNAL_SERVER_ERROR\0\u{1}RETRY_STATE_CANCEL_REQUESTED\0")
}

extension Api.Enums.V1.TimeoutType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TIMEOUT_TYPE_UNSPECIFIED\0\u{1}TIMEOUT_TYPE_START_TO_CLOSE\0\u{1}TIMEOUT_TYPE_SCHEDULE_TO_START\0\u{1}TIMEOUT_TYPE_SCHEDULE_TO_CLOSE\0\u{1}TIMEOUT_TYPE_HEARTBEAT\0")
}

extension Api.Enums.V1.VersioningBehavior: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VERSIONING_BEHAVIOR_UNSPECIFIED\0\u{1}VERSIONING_BEHAVIOR_PINNED\0\u{1}VERSIONING_BEHAVIOR_AUTO_UPGRADE\0")
}

extension Api.Enums.V1.ContinueAsNewVersioningBehavior: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_UNSPECIFIED\0\u{1}CONTINUE_AS_NEW_VERSIONING_BEHAVIOR_AUTO_UPGRADE\0")
}

extension Api.Enums.V1.SuggestContinueAsNewReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SUGGEST_CONTINUE_AS_NEW_REASON_UNSPECIFIED\0\u{1}SUGGEST_CONTINUE_AS_NEW_REASON_HISTORY_SIZE_TOO_LARGE\0\u{1}SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_HISTORY_EVENTS\0\u{1}SUGGEST_CONTINUE_AS_NEW_REASON_TOO_MANY_UPDATES\0\u{1}SUGGEST_CONTINUE_AS_NEW_REASON_TARGET_WORKER_DEPLOYMENT_VERSION_CHANGED\0")
}
