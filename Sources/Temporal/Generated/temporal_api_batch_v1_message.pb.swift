// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/batch/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Batch.V1 {


  public struct BatchOperationInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Batch job ID
    public var jobID: String = String()

    /// Batch operation state
    public var state: Api.Enums.V1.BatchOperationState = .unspecified

    /// Batch operation start time
    public var startTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_startTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTime = newValue}
    }
    /// Returns true if `startTime` has been explicitly set.
    public var hasStartTime: Bool {self._startTime != nil}
    /// Clears the value of `startTime`. Subsequent reads from it will return its default value.
    public mutating func clearStartTime() {self._startTime = nil}

    /// Batch operation close time
    public var closeTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_closeTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_closeTime = newValue}
    }
    /// Returns true if `closeTime` has been explicitly set.
    public var hasCloseTime: Bool {self._closeTime != nil}
    /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
    public mutating func clearCloseTime() {self._closeTime = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _closeTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationTermination sends terminate requests to batch workflows.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.TerminateWorkflowExecutionRequest.
  /// Ignore first_execution_run_id because this is used for single workflow operation.
  public struct BatchOperationTermination: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Serialized value(s) to provide to the termination event
    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationSignal sends signals to batch workflows.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.SignalWorkflowExecutionRequest.
  public struct BatchOperationSignal: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The workflow author-defined name of the signal to send to the workflow
    public var signal: String = String()

    /// Serialized value(s) to provide with the signal
    public var input: Api.Common.V1.Payloads {
      get {_input ?? Api.Common.V1.Payloads()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    public var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    public mutating func clearInput() {self._input = nil}

    /// Headers that are passed with the signal to the processing workflow.
    /// These can include things like auth or tracing tokens.
    public var header: Api.Common.V1.Header {
      get {_header ?? Api.Common.V1.Header()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    public var hasHeader: Bool {self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    public mutating func clearHeader() {self._header = nil}

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _input: Api.Common.V1.Payloads? = nil
    fileprivate var _header: Api.Common.V1.Header? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationCancellation sends cancel requests to batch workflows.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.RequestCancelWorkflowExecutionRequest.
  /// Ignore first_execution_run_id because this is used for single workflow operation.
  public struct BatchOperationCancellation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Batch.V1 {


  /// BatchOperationDeletion sends deletion requests to batch workflows.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.DeleteWorkflowExecutionRequest.
  public struct BatchOperationDeletion: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client
    public var identity: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Batch.V1 {


  /// BatchOperationReset sends reset requests to batch workflows.
  /// Keep the parameter in sync with temporal.api.workflowservice.v1.ResetWorkflowExecutionRequest.
  public struct BatchOperationReset: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    /// Describes what to reset to and how. If set, `reset_type` and `reset_reapply_type` are ignored.
    public var options: Api.Common.V1.ResetOptions {
      get {_options ?? Api.Common.V1.ResetOptions()}
      set {_options = newValue}
    }
    /// Returns true if `options` has been explicitly set.
    public var hasOptions: Bool {self._options != nil}
    /// Clears the value of `options`. Subsequent reads from it will return its default value.
    public mutating func clearOptions() {self._options = nil}

    /// Deprecated. Use `options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var resetType: Api.Enums.V1.ResetType = .unspecified

    /// Deprecated. Use `options`.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var resetReapplyType: Api.Enums.V1.ResetReapplyType = .unspecified

    /// Operations to perform after the workflow has been reset. These operations will be applied
    /// to the *new* run of the workflow execution in the order they are provided.
    /// All operations are applied to the workflow before the first new workflow task is generated
    public var postResetOperations: [Api.Workflow.V1.PostResetOperation] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _options: Api.Common.V1.ResetOptions? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationUpdateWorkflowExecutionOptions sends UpdateWorkflowExecutionOptions requests to batch workflows.
  /// Keep the parameters in sync with temporal.api.workflowservice.v1.UpdateWorkflowExecutionOptionsRequest.
  public struct BatchOperationUpdateWorkflowExecutionOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    /// Update Workflow options that were originally specified via StartWorkflowExecution. Partial updates are accepted and controlled by update_mask.
    public var workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions {
      get {_workflowExecutionOptions ?? Api.Workflow.V1.WorkflowExecutionOptions()}
      set {_workflowExecutionOptions = newValue}
    }
    /// Returns true if `workflowExecutionOptions` has been explicitly set.
    public var hasWorkflowExecutionOptions: Bool {self._workflowExecutionOptions != nil}
    /// Clears the value of `workflowExecutionOptions`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecutionOptions() {self._workflowExecutionOptions = nil}

    /// Controls which fields from `workflow_execution_options` will be applied.
    /// To unset a field, set it to null and use the update mask to indicate that it should be mutated.
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool {self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() {self._updateMask = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecutionOptions: Api.Workflow.V1.WorkflowExecutionOptions? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationUnpauseActivities sends unpause requests to batch workflows.
  public struct BatchOperationUnpauseActivities: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    /// The activity to unpause. If match_all is set to true, all activities will be unpaused.
    public var activity: Api.Batch.V1.BatchOperationUnpauseActivities.OneOf_Activity? = nil

    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    public var matchAll: Bool {
      get {
        if case .matchAll(let v)? = activity {return v}
        return false
      }
      set {activity = .matchAll(newValue)}
    }

    /// Setting this flag will also reset the number of attempts.
    public var resetAttempts: Bool = false

    /// Setting this flag will also reset the heartbeat details.
    public var resetHeartbeat: Bool = false

    /// If set, the activity will start at a random time within the specified jitter
    /// duration, introducing variability to the start time.
    public var jitter: SwiftProtobuf.Google_Protobuf_Duration {
      get {_jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_jitter = newValue}
    }
    /// Returns true if `jitter` has been explicitly set.
    public var hasJitter: Bool {self._jitter != nil}
    /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
    public mutating func clearJitter() {self._jitter = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The activity to unpause. If match_all is set to true, all activities will be unpaused.
    public enum OneOf_Activity: Equatable, Sendable {
      case type(String)
      case matchAll(Bool)

    }

    public init() {}

    fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationTriggerWorkflowRule sends TriggerWorkflowRule requests to batch workflows.
  public struct BatchOperationTriggerWorkflowRule: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    public var rule: Api.Batch.V1.BatchOperationTriggerWorkflowRule.OneOf_Rule? = nil

    /// ID of existing rule.
    public var id: String {
      get {
        if case .id(let v)? = rule {return v}
        return String()
      }
      set {rule = .id(newValue)}
    }

    /// Rule specification to be applied to the workflow without creating a new rule.
    public var spec: Api.Rules.V1.WorkflowRuleSpec {
      get {
        if case .spec(let v)? = rule {return v}
        return Api.Rules.V1.WorkflowRuleSpec()
      }
      set {rule = .spec(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Rule: Equatable, Sendable {
      /// ID of existing rule.
      case id(String)
      /// Rule specification to be applied to the workflow without creating a new rule.
      case spec(Api.Rules.V1.WorkflowRuleSpec)

    }

    public init() {}
  }
}
extension Api.Batch.V1 {


  /// BatchOperationResetActivities sends activity reset requests in a batch.
  /// NOTE: keep in sync with temporal.api.workflowservice.v1.ResetActivityRequest
  public struct BatchOperationResetActivities: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    /// The activities to reset. If match_all is set to true, all activities will be reset.
    public var activity: Api.Batch.V1.BatchOperationResetActivities.OneOf_Activity? = nil

    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    public var matchAll: Bool {
      get {
        if case .matchAll(let v)? = activity {return v}
        return false
      }
      set {activity = .matchAll(newValue)}
    }

    /// Setting this flag will also reset the number of attempts.
    public var resetAttempts: Bool = false

    /// Setting this flag will also reset the heartbeat details.
    public var resetHeartbeat: Bool = false

    /// If activity is paused, it will remain paused after reset
    public var keepPaused: Bool = false

    /// If set, the activity will start at a random time within the specified jitter
    /// duration, introducing variability to the start time.
    public var jitter: SwiftProtobuf.Google_Protobuf_Duration {
      get {_jitter ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_jitter = newValue}
    }
    /// Returns true if `jitter` has been explicitly set.
    public var hasJitter: Bool {self._jitter != nil}
    /// Clears the value of `jitter`. Subsequent reads from it will return its default value.
    public mutating func clearJitter() {self._jitter = nil}

    /// If set, the activity options will be restored to the defaults.
    /// Default options are then options activity was created with.
    /// They are part of the first ActivityTaskScheduled event.
    public var restoreOriginalOptions: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The activities to reset. If match_all is set to true, all activities will be reset.
    public enum OneOf_Activity: Equatable, Sendable {
      case type(String)
      case matchAll(Bool)

    }

    public init() {}

    fileprivate var _jitter: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Batch.V1 {


  /// BatchOperationUpdateActivityOptions sends an update-activity-options requests in a batch.
  /// NOTE: keep in sync with temporal.api.workflowservice.v1.UpdateActivityRequest
  public struct BatchOperationUpdateActivityOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The identity of the worker/client.
    public var identity: String = String()

    /// The activity to update. If match_all is set to true, all activities will be updated.
    public var activity: Api.Batch.V1.BatchOperationUpdateActivityOptions.OneOf_Activity? = nil

    public var type: String {
      get {
        if case .type(let v)? = activity {return v}
        return String()
      }
      set {activity = .type(newValue)}
    }

    public var matchAll: Bool {
      get {
        if case .matchAll(let v)? = activity {return v}
        return false
      }
      set {activity = .matchAll(newValue)}
    }

    /// Update Activity options. Partial updates are accepted and controlled by update_mask.
    public var activityOptions: Api.Activity.V1.ActivityOptions {
      get {_activityOptions ?? Api.Activity.V1.ActivityOptions()}
      set {_activityOptions = newValue}
    }
    /// Returns true if `activityOptions` has been explicitly set.
    public var hasActivityOptions: Bool {self._activityOptions != nil}
    /// Clears the value of `activityOptions`. Subsequent reads from it will return its default value.
    public mutating func clearActivityOptions() {self._activityOptions = nil}

    /// Controls which fields from `activity_options` will be applied
    public var updateMask: SwiftProtobuf.Google_Protobuf_FieldMask {
      get {_updateMask ?? SwiftProtobuf.Google_Protobuf_FieldMask()}
      set {_updateMask = newValue}
    }
    /// Returns true if `updateMask` has been explicitly set.
    public var hasUpdateMask: Bool {self._updateMask != nil}
    /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
    public mutating func clearUpdateMask() {self._updateMask = nil}

    /// If set, the activity options will be restored to the default.
    /// Default options are then options activity was created with.
    /// They are part of the first ActivityTaskScheduled event.
    /// This flag cannot be combined with any other option; if you supply
    /// restore_original together with other options, the request will be rejected.
    public var restoreOriginal: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The activity to update. If match_all is set to true, all activities will be updated.
    public enum OneOf_Activity: Equatable, Sendable {
      case type(String)
      case matchAll(Bool)

    }

    public init() {}

    fileprivate var _activityOptions: Api.Activity.V1.ActivityOptions? = nil
    fileprivate var _updateMask: SwiftProtobuf.Google_Protobuf_FieldMask? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.batch.v1"

extension Api.Batch.V1.BatchOperationInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}job_id\0\u{1}state\0\u{3}start_time\0\u{3}close_time\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 2)
    }
    try { if let v = self._startTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationInfo, rhs: Api.Batch.V1.BatchOperationInfo) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.state != rhs.state {return false}
    if lhs._startTime != rhs._startTime {return false}
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationTermination: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationTermination"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationTermination, rhs: Api.Batch.V1.BatchOperationTermination) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationSignal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationSignal"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}signal\0\u{1}input\0\u{1}header\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.signal) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.signal.isEmpty {
      try visitor.visitSingularStringField(value: self.signal, fieldNumber: 1)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationSignal, rhs: Api.Batch.V1.BatchOperationSignal) -> Bool {
    if lhs.signal != rhs.signal {return false}
    if lhs._input != rhs._input {return false}
    if lhs._header != rhs._header {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationCancellation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationCancellation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationCancellation, rhs: Api.Batch.V1.BatchOperationCancellation) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationDeletion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationDeletion"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationDeletion, rhs: Api.Batch.V1.BatchOperationDeletion) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationReset: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationReset"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}reset_type\0\u{3}reset_reapply_type\0\u{1}identity\0\u{1}options\0\u{3}post_reset_operations\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.resetType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.resetReapplyType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._options) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.postResetOperations) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.resetType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetType, fieldNumber: 1)
    }
    if self.resetReapplyType != .unspecified {
      try visitor.visitSingularEnumField(value: self.resetReapplyType, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._options {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.postResetOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.postResetOperations, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationReset, rhs: Api.Batch.V1.BatchOperationReset) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs._options != rhs._options {return false}
    if lhs.resetType != rhs.resetType {return false}
    if lhs.resetReapplyType != rhs.resetReapplyType {return false}
    if lhs.postResetOperations != rhs.postResetOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationUpdateWorkflowExecutionOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{3}workflow_execution_options\0\u{3}update_mask\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecutionOptions) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    try { if let v = self._workflowExecutionOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions, rhs: Api.Batch.V1.BatchOperationUpdateWorkflowExecutionOptions) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs._workflowExecutionOptions != rhs._workflowExecutionOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationUnpauseActivities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationUnpauseActivities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{1}jitter\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 4)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 5)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationUnpauseActivities, rhs: Api.Batch.V1.BatchOperationUnpauseActivities) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationTriggerWorkflowRule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationTriggerWorkflowRule"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}id\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.rule != nil {try decoder.handleConflictingOneOf()}
          self.rule = .id(v)
        }
      }()
      case 3: try {
        var v: Api.Rules.V1.WorkflowRuleSpec?
        var hadOneofValue = false
        if let current = self.rule {
          hadOneofValue = true
          if case .spec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.rule = .spec(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.rule {
    case .id?: try {
      guard case .id(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .spec?: try {
      guard case .spec(let v)? = self.rule else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationTriggerWorkflowRule, rhs: Api.Batch.V1.BatchOperationTriggerWorkflowRule) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.rule != rhs.rule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationResetActivities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationResetActivities"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}reset_attempts\0\u{3}reset_heartbeat\0\u{3}keep_paused\0\u{1}jitter\0\u{3}restore_original_options\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.resetAttempts) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.resetHeartbeat) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.keepPaused) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._jitter) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginalOptions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    if self.resetAttempts != false {
      try visitor.visitSingularBoolField(value: self.resetAttempts, fieldNumber: 4)
    }
    if self.resetHeartbeat != false {
      try visitor.visitSingularBoolField(value: self.resetHeartbeat, fieldNumber: 5)
    }
    if self.keepPaused != false {
      try visitor.visitSingularBoolField(value: self.keepPaused, fieldNumber: 6)
    }
    try { if let v = self._jitter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.restoreOriginalOptions != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginalOptions, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationResetActivities, rhs: Api.Batch.V1.BatchOperationResetActivities) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs.resetAttempts != rhs.resetAttempts {return false}
    if lhs.resetHeartbeat != rhs.resetHeartbeat {return false}
    if lhs.keepPaused != rhs.keepPaused {return false}
    if lhs._jitter != rhs._jitter {return false}
    if lhs.restoreOriginalOptions != rhs.restoreOriginalOptions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Batch.V1.BatchOperationUpdateActivityOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BatchOperationUpdateActivityOptions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identity\0\u{1}type\0\u{3}match_all\0\u{3}activity_options\0\u{3}update_mask\0\u{3}restore_original\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .type(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.activity != nil {try decoder.handleConflictingOneOf()}
          self.activity = .matchAll(v)
        }
      }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityOptions) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.restoreOriginal) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 1)
    }
    switch self.activity {
    case .type?: try {
      guard case .type(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case .matchAll?: try {
      guard case .matchAll(let v)? = self.activity else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try { if let v = self._activityOptions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.restoreOriginal != false {
      try visitor.visitSingularBoolField(value: self.restoreOriginal, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Batch.V1.BatchOperationUpdateActivityOptions, rhs: Api.Batch.V1.BatchOperationUpdateActivityOptions) -> Bool {
    if lhs.identity != rhs.identity {return false}
    if lhs.activity != rhs.activity {return false}
    if lhs._activityOptions != rhs._activityOptions {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs.restoreOriginal != rhs.restoreOriginal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
