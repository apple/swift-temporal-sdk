// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/identity/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Cloud.Identity.V1 {


  package enum OwnerType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// The owner is a user.
    case user // = 1

    /// The owner is a service account.
    case serviceAccount // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .user
      case 2: self = .serviceAccount
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .user: return 1
      case .serviceAccount: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Cloud.Identity.V1.OwnerType] = [
      .unspecified,
      .user,
      .serviceAccount,
    ]

  }
}
extension Api.Cloud.Identity.V1 {


  package struct AccountAccess: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The role on the account, should be one of [owner, admin, developer, financeadmin, read, metricsread]
    /// owner - gives full access to the account, including users, namespaces, and billing
    /// admin - gives full access the account, including users and namespaces
    /// developer - gives access to create namespaces on the account
    /// financeadmin - gives read only access and write access for billing
    /// read - gives read only access to the account
    /// metricsread - gives read only access to all namespace metrics
    /// Deprecated: Not supported after v0.3.0 api version. Use role instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var roleDeprecated: String = String()

    /// The role on the account.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=role_deprecated
    package var role: Api.Cloud.Identity.V1.AccountAccess.Role = .unspecified

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum Role: SwiftProtobuf.Enum, Swift.CaseIterable {
      package typealias RawValue = Int
      case unspecified // = 0

      /// Gives full access to the account, including users, namespaces, and billing.
      case owner // = 1

      /// Gives full access to the account, including users and namespaces.
      case admin // = 2

      /// Gives access to create namespaces on the account.
      case developer // = 3

      /// Gives read only access and write access for billing.
      case financeAdmin // = 4

      /// Gives read only access to the account.
      case read // = 5

      /// Gives read only access to the account metrics.
      case metricsRead // = 6
      case UNRECOGNIZED(Int)

      package init() {
        self = .unspecified
      }

      package init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .owner
        case 2: self = .admin
        case 3: self = .developer
        case 4: self = .financeAdmin
        case 5: self = .read
        case 6: self = .metricsRead
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      package var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .owner: return 1
        case .admin: return 2
        case .developer: return 3
        case .financeAdmin: return 4
        case .read: return 5
        case .metricsRead: return 6
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      package static let allCases: [Api.Cloud.Identity.V1.AccountAccess.Role] = [
        .unspecified,
        .owner,
        .admin,
        .developer,
        .financeAdmin,
        .read,
        .metricsRead,
      ]

    }

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct NamespaceAccess: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The permission to the namespace, should be one of [admin, write, read]
    /// admin - gives full access to the namespace, including assigning namespace access to other users
    /// write - gives write access to the namespace configuration and workflows within the namespace
    /// read - gives read only access to the namespace configuration and workflows within the namespace
    /// Deprecated: Not supported after v0.3.0 api version. Use permission instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var permissionDeprecated: String = String()

    /// The permission to the namespace.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=permission_deprecated
    package var permission: Api.Cloud.Identity.V1.NamespaceAccess.Permission = .unspecified

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum Permission: SwiftProtobuf.Enum, Swift.CaseIterable {
      package typealias RawValue = Int
      case unspecified // = 0

      /// Gives full access to the namespace, including assigning namespace access to other users.
      case admin // = 1

      /// Gives write access to the namespace configuration and workflows within the namespace.
      case write // = 2

      /// Gives read only access to the namespace configuration and workflows within the namespace.
      case read // = 3
      case UNRECOGNIZED(Int)

      package init() {
        self = .unspecified
      }

      package init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .unspecified
        case 1: self = .admin
        case 2: self = .write
        case 3: self = .read
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      package var rawValue: Int {
        switch self {
        case .unspecified: return 0
        case .admin: return 1
        case .write: return 2
        case .read: return 3
        case .UNRECOGNIZED(let i): return i
        }
      }

      // The compiler won't synthesize support with the UNRECOGNIZED case.
      package static let allCases: [Api.Cloud.Identity.V1.NamespaceAccess.Permission] = [
        .unspecified,
        .admin,
        .write,
        .read,
      ]

    }

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct Access: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account access
    package var accountAccess: Api.Cloud.Identity.V1.AccountAccess {
      get {_accountAccess ?? Api.Cloud.Identity.V1.AccountAccess()}
      set {_accountAccess = newValue}
    }
    /// Returns true if `accountAccess` has been explicitly set.
    package var hasAccountAccess: Bool {self._accountAccess != nil}
    /// Clears the value of `accountAccess`. Subsequent reads from it will return its default value.
    package mutating func clearAccountAccess() {self._accountAccess = nil}

    /// The map of namespace accesses
    /// The key is the namespace name and the value is the access to the namespace
    package var namespaceAccesses: Dictionary<String,Api.Cloud.Identity.V1.NamespaceAccess> = [:]

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _accountAccess: Api.Cloud.Identity.V1.AccountAccess? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct NamespaceScopedAccess: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace the service account is assigned to - immutable.
    package var namespace: String = String()

    /// The namespace access assigned to the service account - mutable.
    package var access: Api.Cloud.Identity.V1.NamespaceAccess {
      get {_access ?? Api.Cloud.Identity.V1.NamespaceAccess()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    package var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    package mutating func clearAccess() {self._access = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.NamespaceAccess? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct UserSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The email address associated to the user
    package var email: String = String()

    /// The access to assigned to the user
    package var access: Api.Cloud.Identity.V1.Access {
      get {_access ?? Api.Cloud.Identity.V1.Access()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    package var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    package mutating func clearAccess() {self._access = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.Access? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct Invitation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The date and time when the user was created
    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {self._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {self._createdTime = nil}

    /// The date and time when the invitation expires or has expired
    package var expiredTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_expiredTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiredTime = newValue}
    }
    /// Returns true if `expiredTime` has been explicitly set.
    package var hasExpiredTime: Bool {self._expiredTime != nil}
    /// Clears the value of `expiredTime`. Subsequent reads from it will return its default value.
    package mutating func clearExpiredTime() {self._expiredTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _expiredTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct User: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user
    package var id: String {
      get {_storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// The current version of the user specification
    /// The next update operation will have to include this version
    package var resourceVersion: String {
      get {_storage._resourceVersion}
      set {_uniqueStorage()._resourceVersion = newValue}
    }

    /// The user specification
    package var spec: Api.Cloud.Identity.V1.UserSpec {
      get {_storage._spec ?? Api.Cloud.Identity.V1.UserSpec()}
      set {_uniqueStorage()._spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    package var hasSpec: Bool {_storage._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    package mutating func clearSpec() {_uniqueStorage()._spec = nil}

    /// The current state of the user
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var stateDeprecated: String {
      get {_storage._stateDeprecated}
      set {_uniqueStorage()._stateDeprecated = newValue}
    }

    /// The current state of the user.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    package var state: Api.Cloud.Resource.V1.ResourceState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The id of the async operation that is creating/updating/deleting the user, if any
    package var asyncOperationID: String {
      get {_storage._asyncOperationID}
      set {_uniqueStorage()._asyncOperationID = newValue}
    }

    /// The details of the open invitation sent to the user, if any
    package var invitation: Api.Cloud.Identity.V1.Invitation {
      get {_storage._invitation ?? Api.Cloud.Identity.V1.Invitation()}
      set {_uniqueStorage()._invitation = newValue}
    }
    /// Returns true if `invitation` has been explicitly set.
    package var hasInvitation: Bool {_storage._invitation != nil}
    /// Clears the value of `invitation`. Subsequent reads from it will return its default value.
    package mutating func clearInvitation() {_uniqueStorage()._invitation = nil}

    /// The date and time when the user was created
    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {_storage._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

    /// The date and time when the user was last modified
    /// Will not be set if the user has never been modified
    package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    package var hasLastModifiedTime: Bool {_storage._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Cloud.Identity.V1 {


  package struct GoogleGroupSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The email address of the Google group.
    /// The email address is immutable. Once set during creation, it cannot be changed.
    package var emailAddress: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct SCIMGroupSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id used in the upstream identity provider.
    package var idpID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct CloudGroupSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct UserGroupSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The display name of the group.
    package var displayName: String = String()

    /// The access assigned to the group.
    package var access: Api.Cloud.Identity.V1.Access {
      get {_access ?? Api.Cloud.Identity.V1.Access()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    package var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    package mutating func clearAccess() {self._access = nil}

    package var groupType: Api.Cloud.Identity.V1.UserGroupSpec.OneOf_GroupType? = nil

    /// The specification of the google group that this group is associated with.
    package var googleGroup: Api.Cloud.Identity.V1.GoogleGroupSpec {
      get {
        if case .googleGroup(let v)? = groupType {return v}
        return Api.Cloud.Identity.V1.GoogleGroupSpec()
      }
      set {groupType = .googleGroup(newValue)}
    }

    /// The specification of the SCIM group that this group is associated with.
    /// SCIM groups cannot be created or deleted directly, but their access can be managed.
    package var scimGroup: Api.Cloud.Identity.V1.SCIMGroupSpec {
      get {
        if case .scimGroup(let v)? = groupType {return v}
        return Api.Cloud.Identity.V1.SCIMGroupSpec()
      }
      set {groupType = .scimGroup(newValue)}
    }

    /// The specification for a Cloud group. Cloud groups can manage members using
    /// the add and remove member APIs.
    package var cloudGroup: Api.Cloud.Identity.V1.CloudGroupSpec {
      get {
        if case .cloudGroup(let v)? = groupType {return v}
        return Api.Cloud.Identity.V1.CloudGroupSpec()
      }
      set {groupType = .cloudGroup(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_GroupType: Equatable, Sendable {
      /// The specification of the google group that this group is associated with.
      case googleGroup(Api.Cloud.Identity.V1.GoogleGroupSpec)
      /// The specification of the SCIM group that this group is associated with.
      /// SCIM groups cannot be created or deleted directly, but their access can be managed.
      case scimGroup(Api.Cloud.Identity.V1.SCIMGroupSpec)
      /// The specification for a Cloud group. Cloud groups can manage members using
      /// the add and remove member APIs.
      case cloudGroup(Api.Cloud.Identity.V1.CloudGroupSpec)

    }

    package init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.Access? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct UserGroup: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group
    package var id: String = String()

    /// The current version of the group specification
    /// The next update operation will have to include this version
    package var resourceVersion: String = String()

    /// The group specification
    package var spec: Api.Cloud.Identity.V1.UserGroupSpec {
      get {_spec ?? Api.Cloud.Identity.V1.UserGroupSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    package var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    package mutating func clearSpec() {self._spec = nil}

    /// The current state of the group.
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var stateDeprecated: String = String()

    /// The current state of the group.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    package var state: Api.Cloud.Resource.V1.ResourceState = .unspecified

    /// The id of the async operation that is creating/updating/deleting the group, if any
    package var asyncOperationID: String = String()

    /// The date and time when the group was created
    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {self._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {self._createdTime = nil}

    /// The date and time when the group was last modified
    /// Will not be set if the group has never been modified
    package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    package var hasLastModifiedTime: Bool {self._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastModifiedTime() {self._lastModifiedTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.UserGroupSpec? = nil
    fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct UserGroupMemberId: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var memberType: Api.Cloud.Identity.V1.UserGroupMemberId.OneOf_MemberType? = nil

    package var userID: String {
      get {
        if case .userID(let v)? = memberType {return v}
        return String()
      }
      set {memberType = .userID(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_MemberType: Equatable, Sendable {
      case userID(String)

    }

    package init() {}
  }
}
extension Api.Cloud.Identity.V1 {


  package struct UserGroupMember: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var memberID: Api.Cloud.Identity.V1.UserGroupMemberId {
      get {_memberID ?? Api.Cloud.Identity.V1.UserGroupMemberId()}
      set {_memberID = newValue}
    }
    /// Returns true if `memberID` has been explicitly set.
    package var hasMemberID: Bool {self._memberID != nil}
    /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
    package mutating func clearMemberID() {self._memberID = nil}

    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {self._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {self._createdTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _memberID: Api.Cloud.Identity.V1.UserGroupMemberId? = nil
    fileprivate var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct ServiceAccount: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the service account.
    package var id: String {
      get {_storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// The current version of the service account specification.
    /// The next update operation will have to include this version.
    package var resourceVersion: String {
      get {_storage._resourceVersion}
      set {_uniqueStorage()._resourceVersion = newValue}
    }

    /// The service account specification.
    package var spec: Api.Cloud.Identity.V1.ServiceAccountSpec {
      get {_storage._spec ?? Api.Cloud.Identity.V1.ServiceAccountSpec()}
      set {_uniqueStorage()._spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    package var hasSpec: Bool {_storage._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    package mutating func clearSpec() {_uniqueStorage()._spec = nil}

    /// The current state of the service account.
    /// Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var stateDeprecated: String {
      get {_storage._stateDeprecated}
      set {_uniqueStorage()._stateDeprecated = newValue}
    }

    /// The current state of the service account.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    package var state: Api.Cloud.Resource.V1.ResourceState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The id of the async operation that is creating/updating/deleting the service account, if any.
    package var asyncOperationID: String {
      get {_storage._asyncOperationID}
      set {_uniqueStorage()._asyncOperationID = newValue}
    }

    /// The date and time when the service account was created.
    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {_storage._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

    /// The date and time when the service account was last modified
    /// Will not be set if the service account has never been modified.
    package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    package var hasLastModifiedTime: Bool {_storage._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Cloud.Identity.V1 {


  package struct ServiceAccountSpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The name associated with the service account.
    /// The name is mutable, but must be unique across all your active service accounts.
    package var name: String = String()

    /// Note: one of `Access` or `NamespaceScopedAccess` must be provided, but not both.
    /// The access assigned to the service account.
    /// If set, creates an account scoped service account.
    /// The access is mutable.
    package var access: Api.Cloud.Identity.V1.Access {
      get {_access ?? Api.Cloud.Identity.V1.Access()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    package var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    package mutating func clearAccess() {self._access = nil}

    /// The namespace scoped access assigned to the service account.
    /// If set, creates a namespace scoped service account (limited to a single namespace).
    /// The namespace scoped access is partially mutable.
    /// Refer to `NamespaceScopedAccess` for details.
    package var namespaceScopedAccess: Api.Cloud.Identity.V1.NamespaceScopedAccess {
      get {_namespaceScopedAccess ?? Api.Cloud.Identity.V1.NamespaceScopedAccess()}
      set {_namespaceScopedAccess = newValue}
    }
    /// Returns true if `namespaceScopedAccess` has been explicitly set.
    package var hasNamespaceScopedAccess: Bool {self._namespaceScopedAccess != nil}
    /// Clears the value of `namespaceScopedAccess`. Subsequent reads from it will return its default value.
    package mutating func clearNamespaceScopedAccess() {self._namespaceScopedAccess = nil}

    /// The description associated with the service account - optional.
    /// The description is mutable.
    package var description_p: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.Access? = nil
    fileprivate var _namespaceScopedAccess: Api.Cloud.Identity.V1.NamespaceScopedAccess? = nil
  }
}
extension Api.Cloud.Identity.V1 {


  package struct ApiKey: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the API Key.
    package var id: String {
      get {_storage._id}
      set {_uniqueStorage()._id = newValue}
    }

    /// The current version of the API key specification.
    /// The next update operation will have to include this version.
    package var resourceVersion: String {
      get {_storage._resourceVersion}
      set {_uniqueStorage()._resourceVersion = newValue}
    }

    /// The API key specification.
    package var spec: Api.Cloud.Identity.V1.ApiKeySpec {
      get {_storage._spec ?? Api.Cloud.Identity.V1.ApiKeySpec()}
      set {_uniqueStorage()._spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    package var hasSpec: Bool {_storage._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    package mutating func clearSpec() {_uniqueStorage()._spec = nil}

    /// The current state of the API key.
    /// Possible values: activating, activationfailed, active, updating, updatefailed, deleting, deletefailed, deleted, suspending, suspendfailed, suspended.
    /// For any failed state, reach out to Temporal Cloud support for remediation.
    /// Deprecated: Not supported after v0.3.0 api version. Use state instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var stateDeprecated: String {
      get {_storage._stateDeprecated}
      set {_uniqueStorage()._stateDeprecated = newValue}
    }

    /// The current state of the API key.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=state_deprecated
    package var state: Api.Cloud.Resource.V1.ResourceState {
      get {_storage._state}
      set {_uniqueStorage()._state = newValue}
    }

    /// The id of the async operation that is creating/updating/deleting the API key, if any.
    package var asyncOperationID: String {
      get {_storage._asyncOperationID}
      set {_uniqueStorage()._asyncOperationID = newValue}
    }

    /// The date and time when the API key was created.
    package var createdTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._createdTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._createdTime = newValue}
    }
    /// Returns true if `createdTime` has been explicitly set.
    package var hasCreatedTime: Bool {_storage._createdTime != nil}
    /// Clears the value of `createdTime`. Subsequent reads from it will return its default value.
    package mutating func clearCreatedTime() {_uniqueStorage()._createdTime = nil}

    /// The date and time when the API key was last modified.
    /// Will not be set if the API key has never been modified.
    package var lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._lastModifiedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._lastModifiedTime = newValue}
    }
    /// Returns true if `lastModifiedTime` has been explicitly set.
    package var hasLastModifiedTime: Bool {_storage._lastModifiedTime != nil}
    /// Clears the value of `lastModifiedTime`. Subsequent reads from it will return its default value.
    package mutating func clearLastModifiedTime() {_uniqueStorage()._lastModifiedTime = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Cloud.Identity.V1 {


  package struct ApiKeySpec: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the owner to create the API key for.
    /// The owner id is immutable. Once set during creation, it cannot be changed.
    /// The owner id is the id of the user when the owner type is user.
    /// The owner id is the id of the service account when the owner type is service account.
    package var ownerID: String = String()

    /// The type of the owner to create the API key for.
    /// The owner type is immutable. Once set during creation, it cannot be changed.
    /// Possible values: user, service-account.
    /// Deprecated: Not supported after v0.3.0 api version. Use owner_type instead.
    /// temporal:versioning:max_version=v0.3.0
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var ownerTypeDeprecated: String = String()

    /// The type of the owner to create the API key for.
    /// temporal:versioning:min_version=v0.3.0
    /// temporal:enums:replaces=owner_type_deprecated
    package var ownerType: Api.Cloud.Identity.V1.OwnerType = .unspecified

    /// The display name of the API key.
    package var displayName: String = String()

    /// The description of the API key.
    package var description_p: String = String()

    /// The expiry time of the API key.
    package var expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_expiryTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_expiryTime = newValue}
    }
    /// Returns true if `expiryTime` has been explicitly set.
    package var hasExpiryTime: Bool {self._expiryTime != nil}
    /// Clears the value of `expiryTime`. Subsequent reads from it will return its default value.
    package mutating func clearExpiryTime() {self._expiryTime = nil}

    /// True if the API key is disabled.
    package var disabled: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _expiryTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.identity.v1"

extension Api.Cloud.Identity.V1.OwnerType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0OWNER_TYPE_UNSPECIFIED\0\u{1}OWNER_TYPE_USER\0\u{1}OWNER_TYPE_SERVICE_ACCOUNT\0")
}

extension Api.Cloud.Identity.V1.AccountAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".AccountAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}role_deprecated\0\u{1}role\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.roleDeprecated) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.role) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.roleDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.roleDeprecated, fieldNumber: 1)
    }
    if self.role != .unspecified {
      try visitor.visitSingularEnumField(value: self.role, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.AccountAccess, rhs: Api.Cloud.Identity.V1.AccountAccess) -> Bool {
    if lhs.roleDeprecated != rhs.roleDeprecated {return false}
    if lhs.role != rhs.role {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.AccountAccess.Role: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ROLE_UNSPECIFIED\0\u{1}ROLE_OWNER\0\u{1}ROLE_ADMIN\0\u{1}ROLE_DEVELOPER\0\u{1}ROLE_FINANCE_ADMIN\0\u{1}ROLE_READ\0\u{1}ROLE_METRICS_READ\0")
}

extension Api.Cloud.Identity.V1.NamespaceAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}permission_deprecated\0\u{1}permission\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.permissionDeprecated) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.permission) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.permissionDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.permissionDeprecated, fieldNumber: 1)
    }
    if self.permission != .unspecified {
      try visitor.visitSingularEnumField(value: self.permission, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.NamespaceAccess, rhs: Api.Cloud.Identity.V1.NamespaceAccess) -> Bool {
    if lhs.permissionDeprecated != rhs.permissionDeprecated {return false}
    if lhs.permission != rhs.permission {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.NamespaceAccess.Permission: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PERMISSION_UNSPECIFIED\0\u{1}PERMISSION_ADMIN\0\u{1}PERMISSION_WRITE\0\u{1}PERMISSION_READ\0")
}

extension Api.Cloud.Identity.V1.Access: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Access"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}account_access\0\u{3}namespace_accesses\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._accountAccess) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Cloud.Identity.V1.NamespaceAccess>.self, value: &self.namespaceAccesses) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountAccess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.namespaceAccesses.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Cloud.Identity.V1.NamespaceAccess>.self, value: self.namespaceAccesses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.Access, rhs: Api.Cloud.Identity.V1.Access) -> Bool {
    if lhs._accountAccess != rhs._accountAccess {return false}
    if lhs.namespaceAccesses != rhs.namespaceAccesses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.NamespaceScopedAccess: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NamespaceScopedAccess"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.NamespaceScopedAccess, rhs: Api.Cloud.Identity.V1.NamespaceScopedAccess) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._access != rhs._access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.UserSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}email\0\u{1}access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.UserSpec, rhs: Api.Cloud.Identity.V1.UserSpec) -> Bool {
    if lhs.email != rhs.email {return false}
    if lhs._access != rhs._access {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.Invitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Invitation"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}created_time\0\u{3}expired_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._expiredTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._expiredTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.Invitation, rhs: Api.Cloud.Identity.V1.Invitation) -> Bool {
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs._expiredTime != rhs._expiredTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".User"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{1}invitation\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Api.Cloud.Identity.V1.UserSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Api.Cloud.Resource.V1.ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _invitation: Api.Cloud.Identity.V1.Invitation? = nil
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _invitation = source._invitation
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._invitation) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._invitation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 9)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.User, rhs: Api.Cloud.Identity.V1.User) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._invitation != rhs_storage._invitation {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.GoogleGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".GoogleGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}email_address\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.GoogleGroupSpec, rhs: Api.Cloud.Identity.V1.GoogleGroupSpec) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.SCIMGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SCIMGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}idp_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idpID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idpID.isEmpty {
      try visitor.visitSingularStringField(value: self.idpID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.SCIMGroupSpec, rhs: Api.Cloud.Identity.V1.SCIMGroupSpec) -> Bool {
    if lhs.idpID != rhs.idpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.CloudGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CloudGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.CloudGroupSpec, rhs: Api.Cloud.Identity.V1.CloudGroupSpec) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.UserGroupSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}display_name\0\u{1}access\0\u{3}google_group\0\u{3}scim_group\0\u{3}cloud_group\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 3: try {
        var v: Api.Cloud.Identity.V1.GoogleGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .googleGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .googleGroup(v)
        }
      }()
      case 4: try {
        var v: Api.Cloud.Identity.V1.SCIMGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .scimGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .scimGroup(v)
        }
      }()
      case 5: try {
        var v: Api.Cloud.Identity.V1.CloudGroupSpec?
        var hadOneofValue = false
        if let current = self.groupType {
          hadOneofValue = true
          if case .cloudGroup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.groupType = .cloudGroup(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    switch self.groupType {
    case .googleGroup?: try {
      guard case .googleGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .scimGroup?: try {
      guard case .scimGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .cloudGroup?: try {
      guard case .cloudGroup(let v)? = self.groupType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.UserGroupSpec, rhs: Api.Cloud.Identity.V1.UserGroupSpec) -> Bool {
    if lhs.displayName != rhs.displayName {return false}
    if lhs._access != rhs._access {return false}
    if lhs.groupType != rhs.groupType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.UserGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroup"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.stateDeprecated) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedTime) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.stateDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.stateDeprecated, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lastModifiedTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.state != .unspecified {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.UserGroup, rhs: Api.Cloud.Identity.V1.UserGroup) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.stateDeprecated != rhs.stateDeprecated {return false}
    if lhs.state != rhs.state {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs._lastModifiedTime != rhs._lastModifiedTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.UserGroupMemberId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupMemberId"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.memberType != nil {try decoder.handleConflictingOneOf()}
          self.memberType = .userID(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .userID(let v)? = self.memberType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.UserGroupMemberId, rhs: Api.Cloud.Identity.V1.UserGroupMemberId) -> Bool {
    if lhs.memberType != rhs.memberType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.UserGroupMember: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UserGroupMember"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}member_id\0\u{3}created_time\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdTime) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._createdTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.UserGroupMember, rhs: Api.Cloud.Identity.V1.UserGroupMember) -> Bool {
    if lhs._memberID != rhs._memberID {return false}
    if lhs._createdTime != rhs._createdTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.ServiceAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ServiceAccount"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Api.Cloud.Identity.V1.ServiceAccountSpec? = nil
    var _stateDeprecated: String = String()
    var _state: Api.Cloud.Resource.V1.ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.ServiceAccount, rhs: Api.Cloud.Identity.V1.ServiceAccount) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.ServiceAccountSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ServiceAccountSpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0\u{1}access\0\u{1}description\0\u{3}namespace_scoped_access\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._namespaceScopedAccess) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try { if let v = self._namespaceScopedAccess {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.ServiceAccountSpec, rhs: Api.Cloud.Identity.V1.ServiceAccountSpec) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs._access != rhs._access {return false}
    if lhs._namespaceScopedAccess != rhs._namespaceScopedAccess {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.ApiKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApiKey"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}resource_version\0\u{1}spec\0\u{3}state_deprecated\0\u{3}async_operation_id\0\u{3}created_time\0\u{3}last_modified_time\0\u{1}state\0")

  fileprivate class _StorageClass {
    var _id: String = String()
    var _resourceVersion: String = String()
    var _spec: Api.Cloud.Identity.V1.ApiKeySpec? = nil
    var _stateDeprecated: String = String()
    var _state: Api.Cloud.Resource.V1.ResourceState = .unspecified
    var _asyncOperationID: String = String()
    var _createdTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _lastModifiedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _resourceVersion = source._resourceVersion
      _spec = source._spec
      _stateDeprecated = source._stateDeprecated
      _state = source._state
      _asyncOperationID = source._asyncOperationID
      _createdTime = source._createdTime
      _lastModifiedTime = source._lastModifiedTime
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._resourceVersion) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._spec) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._stateDeprecated) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._asyncOperationID) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._createdTime) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._lastModifiedTime) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._id.isEmpty {
        try visitor.visitSingularStringField(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._resourceVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._resourceVersion, fieldNumber: 2)
      }
      try { if let v = _storage._spec {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._stateDeprecated.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stateDeprecated, fieldNumber: 4)
      }
      if !_storage._asyncOperationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._asyncOperationID, fieldNumber: 5)
      }
      try { if let v = _storage._createdTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lastModifiedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._state != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.ApiKey, rhs: Api.Cloud.Identity.V1.ApiKey) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._resourceVersion != rhs_storage._resourceVersion {return false}
        if _storage._spec != rhs_storage._spec {return false}
        if _storage._stateDeprecated != rhs_storage._stateDeprecated {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._asyncOperationID != rhs_storage._asyncOperationID {return false}
        if _storage._createdTime != rhs_storage._createdTime {return false}
        if _storage._lastModifiedTime != rhs_storage._lastModifiedTime {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Identity.V1.ApiKeySpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ApiKeySpec"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}owner_id\0\u{3}owner_type_deprecated\0\u{3}display_name\0\u{1}description\0\u{3}expiry_time\0\u{1}disabled\0\u{3}owner_type\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ownerTypeDeprecated) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._expiryTime) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.disabled) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.ownerType) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 1)
    }
    if !self.ownerTypeDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerTypeDeprecated, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    try { if let v = self._expiryTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 6)
    }
    if self.ownerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.ownerType, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Cloud.Identity.V1.ApiKeySpec, rhs: Api.Cloud.Identity.V1.ApiKeySpec) -> Bool {
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerTypeDeprecated != rhs.ownerTypeDeprecated {return false}
    if lhs.ownerType != rhs.ownerType {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._expiryTime != rhs._expiryTime {return false}
    if lhs.disabled != rhs.disabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
