// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/nexus/nexus.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Coresdk.Nexus {


  package enum NexusTaskCancelReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// The nexus task is known to have timed out
    case timedOut // = 0

    /// The worker is shutting down
    case workerShutdown // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .timedOut
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .timedOut
      case 1: self = .workerShutdown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .timedOut: return 0
      case .workerShutdown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.Nexus.NexusTaskCancelReason] = [
      .timedOut,
      .workerShutdown,
    ]

  }
}
extension Coresdk.Nexus {


  /// Controls at which point to report back to lang when a nexus operation is cancelled
  package enum NexusOperationCancellationType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Wait for operation cancellation completion. Default.
    case waitCancellationCompleted // = 0

    /// Do not request cancellation of the nexus operation if already scheduled
    case abandon // = 1

    /// Initiate a cancellation request for the Nexus operation and immediately report cancellation
    /// to the caller. Note that it doesn't guarantee that cancellation is delivered to the operation if calling workflow exits before the delivery is done.
    /// If you want to ensure that cancellation is delivered to the operation, use WAIT_CANCELLATION_REQUESTED.
    case tryCancel // = 2

    /// Request cancellation of the operation and wait for confirmation that the request was received.
    case waitCancellationRequested // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .waitCancellationCompleted
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .waitCancellationCompleted
      case 1: self = .abandon
      case 2: self = .tryCancel
      case 3: self = .waitCancellationRequested
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .waitCancellationCompleted: return 0
      case .abandon: return 1
      case .tryCancel: return 2
      case .waitCancellationRequested: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.Nexus.NexusOperationCancellationType] = [
      .waitCancellationCompleted,
      .abandon,
      .tryCancel,
      .waitCancellationRequested,
    ]

  }
}
extension Coresdk.Nexus {


  /// Used by core to resolve nexus operations.
  package struct NexusOperationResult: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var status: Coresdk.Nexus.NexusOperationResult.OneOf_Status? = nil

    package var completed: Api.Common.V1.Payload {
      get {
        if case .completed(let v)? = status {return v}
        return Api.Common.V1.Payload()
      }
      set {status = .completed(newValue)}
    }

    package var failed: Api.Failure.V1.Failure {
      get {
        if case .failed(let v)? = status {return v}
        return Api.Failure.V1.Failure()
      }
      set {status = .failed(newValue)}
    }

    package var cancelled: Api.Failure.V1.Failure {
      get {
        if case .cancelled(let v)? = status {return v}
        return Api.Failure.V1.Failure()
      }
      set {status = .cancelled(newValue)}
    }

    package var timedOut: Api.Failure.V1.Failure {
      get {
        if case .timedOut(let v)? = status {return v}
        return Api.Failure.V1.Failure()
      }
      set {status = .timedOut(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Status: Equatable, Sendable {
      case completed(Api.Common.V1.Payload)
      case failed(Api.Failure.V1.Failure)
      case cancelled(Api.Failure.V1.Failure)
      case timedOut(Api.Failure.V1.Failure)

    }

    package init() {}
  }
}
extension Coresdk.Nexus {


  /// A response to a Nexus task
  package struct NexusTaskCompletion: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The unique identifier for this task provided in the poll response
    package var taskToken: Data = Data()

    package var status: Coresdk.Nexus.NexusTaskCompletion.OneOf_Status? = nil

    /// The handler completed (successfully or not). Note that the response kind must match the
    /// request kind (start or cancel).
    package var completed: Api.Nexus.V1.Response {
      get {
        if case .completed(let v)? = status {return v}
        return Api.Nexus.V1.Response()
      }
      set {status = .completed(newValue)}
    }

    /// The handler could not complete the request for some reason.
    package var error: Api.Nexus.V1.HandlerError {
      get {
        if case .error(let v)? = status {return v}
        return Api.Nexus.V1.HandlerError()
      }
      set {status = .error(newValue)}
    }

    /// The lang SDK acknowledges that it is responding to a `CancelNexusTask` and thus the
    /// response is irrelevant. This is not the only way to respond to a cancel, the other
    /// variants can still be used, but this variant should be used when the handler was aborted
    /// by cancellation.
    package var ackCancel: Bool {
      get {
        if case .ackCancel(let v)? = status {return v}
        return false
      }
      set {status = .ackCancel(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Status: Equatable, Sendable {
      /// The handler completed (successfully or not). Note that the response kind must match the
      /// request kind (start or cancel).
      case completed(Api.Nexus.V1.Response)
      /// The handler could not complete the request for some reason.
      case error(Api.Nexus.V1.HandlerError)
      /// The lang SDK acknowledges that it is responding to a `CancelNexusTask` and thus the
      /// response is irrelevant. This is not the only way to respond to a cancel, the other
      /// variants can still be used, but this variant should be used when the handler was aborted
      /// by cancellation.
      case ackCancel(Bool)

    }

    package init() {}
  }
}
extension Coresdk.Nexus {


  package struct NexusTask: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var variant: OneOf_Variant? {
      get {return _storage._variant}
      set {_uniqueStorage()._variant = newValue}
    }

    /// A nexus task from server
    package var task: Api.Workflowservice.V1.PollNexusTaskQueueResponse {
      get {
        if case .task(let v)? = _storage._variant {return v}
        return Api.Workflowservice.V1.PollNexusTaskQueueResponse()
      }
      set {_uniqueStorage()._variant = .task(newValue)}
    }

    /// A request by Core to notify an in-progress operation handler that it should cancel. This
    /// is distinct from a `CancelOperationRequest` from the server, which results from the user
    /// requesting the cancellation of an operation. Handling this variant should result in
    /// something like cancelling a cancellation token given to the user's operation handler.
    ///
    /// These do not count as a separate task for the purposes of completing all issued tasks,
    /// but rather count as a sort of modification to the already-issued task which is being
    /// cancelled.
    ///
    /// EX: Core knows the nexus operation has timed out, and it does not make sense for the
    /// user's operation handler to continue doing work.
    package var cancelTask: Coresdk.Nexus.CancelNexusTask {
      get {
        if case .cancelTask(let v)? = _storage._variant {return v}
        return Coresdk.Nexus.CancelNexusTask()
      }
      set {_uniqueStorage()._variant = .cancelTask(newValue)}
    }

    /// The deadline for this request, parsed from the "Request-Timeout" header.
    /// Only set when variant is `task` and the header was present with a valid value.
    /// Represented as an absolute timestamp.
    package var requestDeadline: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._requestDeadline ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._requestDeadline = newValue}
    }
    /// Returns true if `requestDeadline` has been explicitly set.
    package var hasRequestDeadline: Bool {_storage._requestDeadline != nil}
    /// Clears the value of `requestDeadline`. Subsequent reads from it will return its default value.
    package mutating func clearRequestDeadline() {_uniqueStorage()._requestDeadline = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Variant: Equatable, Sendable {
      /// A nexus task from server
      case task(Api.Workflowservice.V1.PollNexusTaskQueueResponse)
      /// A request by Core to notify an in-progress operation handler that it should cancel. This
      /// is distinct from a `CancelOperationRequest` from the server, which results from the user
      /// requesting the cancellation of an operation. Handling this variant should result in
      /// something like cancelling a cancellation token given to the user's operation handler.
      ///
      /// These do not count as a separate task for the purposes of completing all issued tasks,
      /// but rather count as a sort of modification to the already-issued task which is being
      /// cancelled.
      ///
      /// EX: Core knows the nexus operation has timed out, and it does not make sense for the
      /// user's operation handler to continue doing work.
      case cancelTask(Coresdk.Nexus.CancelNexusTask)

    }

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.Nexus {


  package struct CancelNexusTask: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The task token from the PollNexusTaskQueueResponse
    package var taskToken: Data = Data()

    /// Why Core is asking for this operation to be cancelled
    package var reason: Coresdk.Nexus.NexusTaskCancelReason = .timedOut

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.nexus"

extension Coresdk.Nexus.NexusTaskCancelReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TIMED_OUT\0\u{1}WORKER_SHUTDOWN\0")
}

extension Coresdk.Nexus.NexusOperationCancellationType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0WAIT_CANCELLATION_COMPLETED\0\u{1}ABANDON\0\u{1}TRY_CANCEL\0\u{1}WAIT_CANCELLATION_REQUESTED\0")
}

extension Coresdk.Nexus.NexusOperationResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusOperationResult"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}completed\0\u{1}failed\0\u{1}cancelled\0\u{3}timed_out\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Api.Common.V1.Payload?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 2: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .failed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .failed(v)
        }
      }()
      case 3: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .cancelled(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .cancelled(v)
        }
      }()
      case 4: try {
        var v: Api.Failure.V1.Failure?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .timedOut(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .timedOut(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .failed?: try {
      guard case .failed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .cancelled?: try {
      guard case .cancelled(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .timedOut?: try {
      guard case .timedOut(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.Nexus.NexusOperationResult, rhs: Coresdk.Nexus.NexusOperationResult) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.Nexus.NexusTaskCompletion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusTaskCompletion"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}completed\0\u{1}error\0\u{3}ack_cancel\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try {
        var v: Api.Nexus.V1.Response?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .completed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .completed(v)
        }
      }()
      case 3: try {
        var v: Api.Nexus.V1.HandlerError?
        var hadOneofValue = false
        if let current = self.status {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.status = .error(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.status != nil {try decoder.handleConflictingOneOf()}
          self.status = .ackCancel(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    switch self.status {
    case .completed?: try {
      guard case .completed(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .error?: try {
      guard case .error(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .ackCancel?: try {
      guard case .ackCancel(let v)? = self.status else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.Nexus.NexusTaskCompletion, rhs: Coresdk.Nexus.NexusTaskCompletion) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.Nexus.NexusTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".NexusTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}task\0\u{3}cancel_task\0\u{3}request_deadline\0")

  fileprivate class _StorageClass {
    var _variant: Coresdk.Nexus.NexusTask.OneOf_Variant?
    var _requestDeadline: SwiftProtobuf.Google_Protobuf_Timestamp? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _variant = source._variant
      _requestDeadline = source._requestDeadline
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try {
          var v: Api.Workflowservice.V1.PollNexusTaskQueueResponse?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .task(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .task(v)
          }
        }()
        case 2: try {
          var v: Coresdk.Nexus.CancelNexusTask?
          var hadOneofValue = false
          if let current = _storage._variant {
            hadOneofValue = true
            if case .cancelTask(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._variant = .cancelTask(v)
          }
        }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._requestDeadline) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      switch _storage._variant {
      case .task?: try {
        guard case .task(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }()
      case .cancelTask?: try {
        guard case .cancelTask(let v)? = _storage._variant else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case nil: break
      }
      try { if let v = _storage._requestDeadline {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.Nexus.NexusTask, rhs: Coresdk.Nexus.NexusTask) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._variant != rhs_storage._variant {return false}
        if _storage._requestDeadline != rhs_storage._requestDeadline {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.Nexus.CancelNexusTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelNexusTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    if self.reason != .timedOut {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.Nexus.CancelNexusTask, rhs: Coresdk.Nexus.CancelNexusTask) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
