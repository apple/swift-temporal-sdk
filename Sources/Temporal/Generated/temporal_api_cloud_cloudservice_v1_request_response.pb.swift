// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/cloud/cloudservice/v1/request_response.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUsersRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    /// Filter users by email address - optional.
    public var email: String = String()

    /// Filter users by the namespace they have access to - optional.
    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUsersResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of users in ascending ids order
    public var users: [Api.Cloud.Identity.V1.User] = []

    /// The next page's token
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user to get
    public var userID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The user
    public var user: Api.Cloud.Identity.V1.User {
      get {_user ?? Api.Cloud.Identity.V1.User()}
      set {_user = newValue}
    }
    /// Returns true if `user` has been explicitly set.
    public var hasUser: Bool {self._user != nil}
    /// Clears the value of `user`. Subsequent reads from it will return its default value.
    public mutating func clearUser() {self._user = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _user: Api.Cloud.Identity.V1.User? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateUserRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The spec for the user to invite
    public var spec: Api.Cloud.Identity.V1.UserSpec {
      get {_spec ?? Api.Cloud.Identity.V1.UserSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation - optional
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.UserSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateUserResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user that was invited
    public var userID: String = String()

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateUserRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user to update
    public var userID: String = String()

    /// The new user specification
    public var spec: Api.Cloud.Identity.V1.UserSpec {
      get {_spec ?? Api.Cloud.Identity.V1.UserSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the user for which this update is intended for
    /// The latest version can be found in the GetUser operation response
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.UserSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateUserResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteUserRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the user to delete
    public var userID: String = String()

    /// The version of the user for which this delete is intended for
    /// The latest version can be found in the GetUser operation response
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteUserResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetUserNamespaceAccessRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to set permissions for
    public var namespace: String = String()

    /// The id of the user to set permissions for
    public var userID: String = String()

    /// The namespace access to assign the user
    public var access: Api.Cloud.Identity.V1.NamespaceAccess {
      get {_access ?? Api.Cloud.Identity.V1.NamespaceAccess()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    public var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    public mutating func clearAccess() {self._access = nil}

    /// The version of the user for which this update is intended for
    /// The latest version can be found in the GetUser operation response
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.NamespaceAccess? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetUserNamespaceAccessResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetAsyncOperationRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the async operation to get
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetAsyncOperationResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace specification.
    public var spec: Api.Cloud.Namespace.V1.NamespaceSpec {
      get {_spec ?? Api.Cloud.Namespace.V1.NamespaceSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    /// The tags to add to the namespace.
    /// Note: This field can be set by global admins or account owners only.
    public var tags: Dictionary<String,String> = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Namespace.V1.NamespaceSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace that was created.
    public var namespace: String = String()

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespacesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve.
    /// Cannot exceed 1000.
    /// Optional, defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response.
    /// Optional, defaults to empty.
    public var pageToken: String = String()

    /// Filter namespaces by their name.
    /// Optional, defaults to empty.
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespacesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of namespaces in ascending name order.
    public var namespaces: [Api.Cloud.Namespace.V1.Namespace] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to get.
    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace.
    public var namespace: Api.Cloud.Namespace.V1.Namespace {
      get {_namespace ?? Api.Cloud.Namespace.V1.Namespace()}
      set {_namespace = newValue}
    }
    /// Returns true if `namespace` has been explicitly set.
    public var hasNamespace: Bool {self._namespace != nil}
    /// Clears the value of `namespace`. Subsequent reads from it will return its default value.
    public mutating func clearNamespace() {self._namespace = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _namespace: Api.Cloud.Namespace.V1.Namespace? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to update.
    public var namespace: String = String()

    /// The new namespace specification.
    public var spec: Api.Cloud.Namespace.V1.NamespaceSpec {
      get {_spec ?? Api.Cloud.Namespace.V1.NamespaceSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the namespace for which this update is intended for.
    /// The latest version can be found in the namespace status.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Namespace.V1.NamespaceSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct RenameCustomSearchAttributeRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to rename the custom search attribute for.
    public var namespace: String = String()

    /// The existing name of the custom search attribute to be renamed.
    public var existingCustomSearchAttributeName: String = String()

    /// The new name of the custom search attribute.
    public var newCustomSearchAttributeName: String = String()

    /// The version of the namespace for which this update is intended for.
    /// The latest version can be found in the namespace status.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct RenameCustomSearchAttributeResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to delete.
    public var namespace: String = String()

    /// The version of the namespace for which this delete is intended for.
    /// The latest version can be found in the namespace status.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct FailoverNamespaceRegionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to failover.
    public var namespace: String = String()

    /// The id of the region to failover to.
    /// Must be a region that the namespace is currently available in.
    public var region: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct FailoverNamespaceRegionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct AddNamespaceRegionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to add the region to.
    public var namespace: String = String()

    /// The id of the standby region to add to the namespace.
    /// The GetRegions API can be used to get the list of valid region ids.
    /// Example: "aws-us-west-2".
    public var region: String = String()

    /// The version of the namespace for which this add region operation is intended for.
    /// The latest version can be found in the GetNamespace operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct AddNamespaceRegionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceRegionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to delete a region.
    public var namespace: String = String()

    /// The id of the standby region to be deleted.
    /// The GetRegions API can be used to get the list of valid region ids.
    /// Example: "aws-us-west-2".
    public var region: String = String()

    /// The version of the namespace for which this delete region operation is intended for.
    /// The latest version can be found in the GetNamespace operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceRegionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetRegionsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetRegionsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The temporal cloud regions.
    public var regions: [Api.Cloud.Region.V1.Region] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetRegionRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the region to get.
    public var region: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetRegionResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The temporal cloud region.
    public var region: Api.Cloud.Region.V1.Region {
      get {_region ?? Api.Cloud.Region.V1.Region()}
      set {_region = newValue}
    }
    /// Returns true if `region` has been explicitly set.
    public var hasRegion: Bool {self._region != nil}
    /// Clears the value of `region`. Subsequent reads from it will return its default value.
    public mutating func clearRegion() {self._region = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _region: Api.Cloud.Region.V1.Region? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetApiKeysRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    /// Filter api keys by owner id - optional.
    public var ownerID: String = String()

    /// Filter api keys by owner type - optional.
    /// Possible values: user, service-account
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var ownerTypeDeprecated: String = String()

    /// Filter api keys by owner type - optional.
    /// temporal:enums:replaces=owner_type_deprecated
    public var ownerType: Api.Cloud.Identity.V1.OwnerType = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetApiKeysResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of api keys in ascending id order.
    public var apiKeys: [Api.Cloud.Identity.V1.ApiKey] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetApiKeyRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the api key to get.
    public var keyID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetApiKeyResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The api key.
    public var apiKey: Api.Cloud.Identity.V1.ApiKey {
      get {_apiKey ?? Api.Cloud.Identity.V1.ApiKey()}
      set {_apiKey = newValue}
    }
    /// Returns true if `apiKey` has been explicitly set.
    public var hasApiKey: Bool {self._apiKey != nil}
    /// Clears the value of `apiKey`. Subsequent reads from it will return its default value.
    public mutating func clearApiKey() {self._apiKey = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _apiKey: Api.Cloud.Identity.V1.ApiKey? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateApiKeyRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The spec for the api key to create.
    /// Create api key only supports service-account owner type for now.
    public var spec: Api.Cloud.Identity.V1.ApiKeySpec {
      get {_spec ?? Api.Cloud.Identity.V1.ApiKeySpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.ApiKeySpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateApiKeyResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the api key created.
    public var keyID: String = String()

    /// The token of the api key created.
    /// This is a secret and should be stored securely.
    /// It will not be retrievable after this response.
    public var token: String = String()

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateApiKeyRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the api key to update.
    public var keyID: String = String()

    /// The new api key specification.
    public var spec: Api.Cloud.Identity.V1.ApiKeySpec {
      get {_spec ?? Api.Cloud.Identity.V1.ApiKeySpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the api key for which this update is intended for.
    /// The latest version can be found in the GetApiKey operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.ApiKeySpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateApiKeyResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteApiKeyRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the api key to delete.
    public var keyID: String = String()

    /// The version of the api key for which this delete is intended for.
    /// The latest version can be found in the GetApiKey operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteApiKeyResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNexusEndpointsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    /// optional, treated as an AND if specified
    public var targetNamespaceID: String = String()

    /// optional, treated as an AND if specified
    public var targetTaskQueue: String = String()

    /// Filter endpoints by their name - optional, treated as an AND if specified. Specifying this will result in zero or one results.
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNexusEndpointsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of endpoints in ascending id order.
    public var endpoints: [Api.Cloud.Nexus.V1.Endpoint] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the nexus endpoint to get.
    public var endpointID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The nexus endpoint.
    public var endpoint: Api.Cloud.Nexus.V1.Endpoint {
      get {_endpoint ?? Api.Cloud.Nexus.V1.Endpoint()}
      set {_endpoint = newValue}
    }
    /// Returns true if `endpoint` has been explicitly set.
    public var hasEndpoint: Bool {self._endpoint != nil}
    /// Clears the value of `endpoint`. Subsequent reads from it will return its default value.
    public mutating func clearEndpoint() {self._endpoint = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _endpoint: Api.Cloud.Nexus.V1.Endpoint? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The spec for the nexus endpoint.
    public var spec: Api.Cloud.Nexus.V1.EndpointSpec {
      get {_spec ?? Api.Cloud.Nexus.V1.EndpointSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Nexus.V1.EndpointSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the endpoint that was created.
    public var endpointID: String = String()

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the nexus endpoint to update.
    public var endpointID: String = String()

    /// The updated nexus endpoint specification.
    public var spec: Api.Cloud.Nexus.V1.EndpointSpec {
      get {_spec ?? Api.Cloud.Nexus.V1.EndpointSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the nexus endpoint for which this update is intended for.
    /// The latest version can be found in the GetNexusEndpoint operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Nexus.V1.EndpointSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNexusEndpointRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the nexus endpoint to delete.
    public var endpointID: String = String()

    /// The version of the endpoint for which this delete is intended for.
    /// The latest version can be found in the GetNexusEndpoint operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNexusEndpointResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    /// Filter groups by the namespace they have access to - optional.
    public var namespace: String = String()

    /// Filter groups by the display name - optional.
    public var displayName: String = String()

    /// Filter groups by the google group specification - optional.
    public var googleGroup: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter {
      get {_googleGroup ?? Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter()}
      set {_googleGroup = newValue}
    }
    /// Returns true if `googleGroup` has been explicitly set.
    public var hasGoogleGroup: Bool {self._googleGroup != nil}
    /// Clears the value of `googleGroup`. Subsequent reads from it will return its default value.
    public mutating func clearGoogleGroup() {self._googleGroup = nil}

    /// Filter groups by the SCIM group specification - optional.
    public var scimGroup: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter {
      get {_scimGroup ?? Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter()}
      set {_scimGroup = newValue}
    }
    /// Returns true if `scimGroup` has been explicitly set.
    public var hasScimGroup: Bool {self._scimGroup != nil}
    /// Clears the value of `scimGroup`. Subsequent reads from it will return its default value.
    public mutating func clearScimGroup() {self._scimGroup = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct GoogleGroupFilter: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Filter groups by the google group email - optional.
      public var emailAddress: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct SCIMGroupFilter: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Filter groups by the SCIM IDP id - optional.
      public var idpID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _googleGroup: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter? = nil
    fileprivate var _scimGroup: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of groups in ascending name order.
    public var groups: [Api.Cloud.Identity.V1.UserGroup] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group to get.
    public var groupID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The group.
    public var group: Api.Cloud.Identity.V1.UserGroup {
      get {_group ?? Api.Cloud.Identity.V1.UserGroup()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    public var hasGroup: Bool {self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    public mutating func clearGroup() {self._group = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _group: Api.Cloud.Identity.V1.UserGroup? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateUserGroupRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The spec for the group to create.
    public var spec: Api.Cloud.Identity.V1.UserGroupSpec {
      get {_spec ?? Api.Cloud.Identity.V1.UserGroupSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.UserGroupSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateUserGroupResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group that was created.
    public var groupID: String = String()

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateUserGroupRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group to update.
    public var groupID: String = String()

    /// The new group specification.
    public var spec: Api.Cloud.Identity.V1.UserGroupSpec {
      get {_spec ?? Api.Cloud.Identity.V1.UserGroupSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the group for which this update is intended for.
    /// The latest version can be found in the GetGroup operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.UserGroupSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateUserGroupResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteUserGroupRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group to delete.
    public var groupID: String = String()

    /// The version of the group for which this delete is intended for.
    /// The latest version can be found in the GetGroup operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteUserGroupResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetUserGroupNamespaceAccessRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to set permissions for.
    public var namespace: String = String()

    /// The id of the group to set permissions for.
    public var groupID: String = String()

    /// The namespace access to assign the group. If left empty, the group will be removed from the namespace access.
    public var access: Api.Cloud.Identity.V1.NamespaceAccess {
      get {_access ?? Api.Cloud.Identity.V1.NamespaceAccess()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    public var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    public mutating func clearAccess() {self._access = nil}

    /// The version of the group for which this update is intended for.
    /// The latest version can be found in the GetGroup operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.NamespaceAccess? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetUserGroupNamespaceAccessResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct AddUserGroupMemberRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group to add the member for.
    public var groupID: String = String()

    /// The member id to add to the group.
    public var memberID: Api.Cloud.Identity.V1.UserGroupMemberId {
      get {_memberID ?? Api.Cloud.Identity.V1.UserGroupMemberId()}
      set {_memberID = newValue}
    }
    /// Returns true if `memberID` has been explicitly set.
    public var hasMemberID: Bool {self._memberID != nil}
    /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
    public mutating func clearMemberID() {self._memberID = nil}

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _memberID: Api.Cloud.Identity.V1.UserGroupMemberId? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct AddUserGroupMemberResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct RemoveUserGroupMemberRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the group to add the member for.
    public var groupID: String = String()

    /// The member id to add to the group.
    public var memberID: Api.Cloud.Identity.V1.UserGroupMemberId {
      get {_memberID ?? Api.Cloud.Identity.V1.UserGroupMemberId()}
      set {_memberID = newValue}
    }
    /// Returns true if `memberID` has been explicitly set.
    public var hasMemberID: Bool {self._memberID != nil}
    /// Clears the value of `memberID`. Subsequent reads from it will return its default value.
    public mutating func clearMemberID() {self._memberID = nil}

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _memberID: Api.Cloud.Identity.V1.UserGroupMemberId? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct RemoveUserGroupMemberResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupMembersRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    /// The group id to list members of.
    public var groupID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUserGroupMembersResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of group members
    public var members: [Api.Cloud.Identity.V1.UserGroupMember] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateServiceAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The spec of the service account to create.
    public var spec: Api.Cloud.Identity.V1.ServiceAccountSpec {
      get {_spec ?? Api.Cloud.Identity.V1.ServiceAccountSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.ServiceAccountSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateServiceAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the created service account.
    public var serviceAccountID: String = String()

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetServiceAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID of the service account to retrieve.
    public var serviceAccountID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetServiceAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The service account retrieved.
    public var serviceAccount: Api.Cloud.Identity.V1.ServiceAccount {
      get {_serviceAccount ?? Api.Cloud.Identity.V1.ServiceAccount()}
      set {_serviceAccount = newValue}
    }
    /// Returns true if `serviceAccount` has been explicitly set.
    public var hasServiceAccount: Bool {self._serviceAccount != nil}
    /// Clears the value of `serviceAccount`. Subsequent reads from it will return its default value.
    public mutating func clearServiceAccount() {self._serviceAccount = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _serviceAccount: Api.Cloud.Identity.V1.ServiceAccount? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetServiceAccountsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve - optional.
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetServiceAccountsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of service accounts in ascending ID order.
    public var serviceAccount: [Api.Cloud.Identity.V1.ServiceAccount] = []

    /// The next page token, set if there is another page.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateServiceAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the service account to update.
    public var serviceAccountID: String = String()

    /// The new service account specification.
    public var spec: Api.Cloud.Identity.V1.ServiceAccountSpec {
      get {_spec ?? Api.Cloud.Identity.V1.ServiceAccountSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the service account for which this update is intended for.
    /// The latest version can be found in the GetServiceAccount response.
    public var resourceVersion: String = String()

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Identity.V1.ServiceAccountSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateServiceAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetServiceAccountNamespaceAccessRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the service account to update.
    public var serviceAccountID: String = String()

    /// The namespace to set permissions for.
    public var namespace: String = String()

    /// The namespace access to assign the service account.
    public var access: Api.Cloud.Identity.V1.NamespaceAccess {
      get {_access ?? Api.Cloud.Identity.V1.NamespaceAccess()}
      set {_access = newValue}
    }
    /// Returns true if `access` has been explicitly set.
    public var hasAccess: Bool {self._access != nil}
    /// Clears the value of `access`. Subsequent reads from it will return its default value.
    public mutating func clearAccess() {self._access = nil}

    /// The version of the service account for which this update is intended for.
    /// The latest version can be found in the GetServiceAccount response.
    public var resourceVersion: String = String()

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _access: Api.Cloud.Identity.V1.NamespaceAccess? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct SetServiceAccountNamespaceAccessResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteServiceAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the service account to delete;
    public var serviceAccountID: String = String()

    /// The version of the service account for which this update is intended for.
    /// The latest version can be found in the GetServiceAccount response.
    public var resourceVersion: String = String()

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteServiceAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUsageRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Filter for UTC time >= - optional.
    /// Defaults to: start of the current month.
    /// Must be: within the last 90 days from the current date.
    /// Must be: midnight UTC time.
    public var startTimeInclusive: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_startTimeInclusive ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_startTimeInclusive = newValue}
    }
    /// Returns true if `startTimeInclusive` has been explicitly set.
    public var hasStartTimeInclusive: Bool {self._startTimeInclusive != nil}
    /// Clears the value of `startTimeInclusive`. Subsequent reads from it will return its default value.
    public mutating func clearStartTimeInclusive() {self._startTimeInclusive = nil}

    /// Filter for UTC time < - optional.
    /// Defaults to: start of the next UTC day.
    /// Must be: within the last 90 days from the current date.
    /// Must be: midnight UTC time.
    public var endTimeExclusive: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_endTimeExclusive ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_endTimeExclusive = newValue}
    }
    /// Returns true if `endTimeExclusive` has been explicitly set.
    public var hasEndTimeExclusive: Bool {self._endTimeExclusive != nil}
    /// Clears the value of `endTimeExclusive`. Subsequent reads from it will return its default value.
    public mutating func clearEndTimeExclusive() {self._endTimeExclusive = nil}

    /// The requested size of the page to retrieve - optional.
    /// Each count corresponds to a single object - per day per namespace
    /// Cannot exceed 1000. Defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _startTimeInclusive: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    fileprivate var _endTimeExclusive: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetUsageResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of data based on granularity (per Day for now)
    /// Ordered by: time range in ascending order
    public var summaries: [Api.Cloud.Usage.V1.Summary] = []

    /// The next page's token.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The account.
    public var account: Api.Cloud.Account.V1.Account {
      get {_account ?? Api.Cloud.Account.V1.Account()}
      set {_account = newValue}
    }
    /// Returns true if `account` has been explicitly set.
    public var hasAccount: Bool {self._account != nil}
    /// Clears the value of `account`. Subsequent reads from it will return its default value.
    public mutating func clearAccount() {self._account = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _account: Api.Cloud.Account.V1.Account? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateAccountRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The updated account specification to apply.
    public var spec: Api.Cloud.Account.V1.AccountSpec {
      get {_spec ?? Api.Cloud.Account.V1.AccountSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the account for which this update is intended for.
    /// The latest version can be found in the GetAccount operation response.
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Account.V1.AccountSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateAccountResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNamespaceExportSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace under which the sink is configured.
    public var namespace: String = String()

    /// The specification for the export sink.
    public var spec: Api.Cloud.Namespace.V1.ExportSinkSpec {
      get {_spec ?? Api.Cloud.Namespace.V1.ExportSinkSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// Optional. The ID to use for this async operation.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Namespace.V1.ExportSinkSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateNamespaceExportSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceExportSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to which the sink belongs.
    public var namespace: String = String()

    /// The name of the sink to retrieve.
    public var name: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceExportSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The export sink retrieved.
    public var sink: Api.Cloud.Namespace.V1.ExportSink {
      get {_sink ?? Api.Cloud.Namespace.V1.ExportSink()}
      set {_sink = newValue}
    }
    /// Returns true if `sink` has been explicitly set.
    public var hasSink: Bool {self._sink != nil}
    /// Clears the value of `sink`. Subsequent reads from it will return its default value.
    public mutating func clearSink() {self._sink = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _sink: Api.Cloud.Namespace.V1.ExportSink? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceExportSinksRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to which the sinks belong.
    public var namespace: String = String()

    /// The requested size of the page to retrieve. Cannot exceed 1000.
    /// Defaults to 100 if not specified.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response - optional.
    public var pageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetNamespaceExportSinksResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The list of export sinks retrieved.
    public var sinks: [Api.Cloud.Namespace.V1.ExportSink] = []

    /// The next page token, set if there is another page.
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceExportSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to which the sink belongs.
    public var namespace: String = String()

    /// The updated export sink specification.
    public var spec: Api.Cloud.Namespace.V1.ExportSinkSpec {
      get {_spec ?? Api.Cloud.Namespace.V1.ExportSinkSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The version of the sink to update. The latest version can be
    /// retrieved using the GetNamespaceExportSink call.
    public var resourceVersion: String = String()

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Namespace.V1.ExportSinkSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceExportSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceExportSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to which the sink belongs.
    public var namespace: String = String()

    /// The name of the sink to delete.
    public var name: String = String()

    /// The version of the sink to delete. The latest version can be
    /// retrieved using the GetNamespaceExportSink call.
    public var resourceVersion: String = String()

    /// The ID to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteNamespaceExportSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct ValidateNamespaceExportSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to which the sink belongs.
    public var namespace: String = String()

    /// The export sink specification to validate.
    public var spec: Api.Cloud.Namespace.V1.ExportSinkSpec {
      get {_spec ?? Api.Cloud.Namespace.V1.ExportSinkSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Namespace.V1.ExportSinkSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct ValidateNamespaceExportSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceTagsRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace to set tags for.
    public var namespace: String = String()

    /// A list of tags to add or update.
    /// If a key of an existing tag is added, the tag's value is updated.
    /// At least one of tags_to_upsert or tags_to_remove must be specified.
    public var tagsToUpsert: Dictionary<String,String> = [:]

    /// A list of tag keys to remove.
    /// If a tag key doesn't exist, it is silently ignored.
    /// At least one of tags_to_upsert or tags_to_remove must be specified.
    public var tagsToRemove: [String] = []

    /// The id to use for this async operation - optional.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct UpdateNamespaceTagsResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation.
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateConnectivityRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The connectivity rule specification.
    public var spec: Api.Cloud.Connectivityrule.V1.ConnectivityRuleSpec {
      get {_spec ?? Api.Cloud.Connectivityrule.V1.ConnectivityRuleSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Connectivityrule.V1.ConnectivityRuleSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct CreateConnectivityRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the connectivity rule that was created.
    public var connectivityRuleID: String = String()

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetConnectivityRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The id of the connectivity rule to get.
    public var connectivityRuleID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetConnectivityRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var connectivityRule: Api.Cloud.Connectivityrule.V1.ConnectivityRule {
      get {_connectivityRule ?? Api.Cloud.Connectivityrule.V1.ConnectivityRule()}
      set {_connectivityRule = newValue}
    }
    /// Returns true if `connectivityRule` has been explicitly set.
    public var hasConnectivityRule: Bool {self._connectivityRule != nil}
    /// Clears the value of `connectivityRule`. Subsequent reads from it will return its default value.
    public mutating func clearConnectivityRule() {self._connectivityRule = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _connectivityRule: Api.Cloud.Connectivityrule.V1.ConnectivityRule? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetConnectivityRulesRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The requested size of the page to retrieve.
    /// Optional, defaults to 100.
    public var pageSize: Int32 = 0

    /// The page token if this is continuing from another response.
    /// Optional, defaults to empty.
    public var pageToken: String = String()

    /// Filter connectivity rule by the namespace id.
    public var namespace: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct GetConnectivityRulesResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// connectivity_rules returned
    public var connectivityRules: [Api.Cloud.Connectivityrule.V1.ConnectivityRule] = []

    /// The next page token
    public var nextPageToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteConnectivityRuleRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The ID of the connectivity rule that need be deleted, required.
    public var connectivityRuleID: String = String()

    /// The resource version which should be the same from the the db, required
    /// The latest version can be found in the GetConnectivityRule operation response
    public var resourceVersion: String = String()

    /// The id to use for this async operation.
    /// Optional, if not provided a random id will be generated.
    public var asyncOperationID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct DeleteConnectivityRuleResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The async operation
    public var asyncOperation: Api.Cloud.Operation.V1.AsyncOperation {
      get {_asyncOperation ?? Api.Cloud.Operation.V1.AsyncOperation()}
      set {_asyncOperation = newValue}
    }
    /// Returns true if `asyncOperation` has been explicitly set.
    public var hasAsyncOperation: Bool {self._asyncOperation != nil}
    /// Clears the value of `asyncOperation`. Subsequent reads from it will return its default value.
    public mutating func clearAsyncOperation() {self._asyncOperation = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _asyncOperation: Api.Cloud.Operation.V1.AsyncOperation? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct ValidateAccountAuditLogSinkRequest: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The audit log sink spec that will be validated
    public var spec: Api.Cloud.Account.V1.AuditLogSinkSpec {
      get {_spec ?? Api.Cloud.Account.V1.AuditLogSinkSpec()}
      set {_spec = newValue}
    }
    /// Returns true if `spec` has been explicitly set.
    public var hasSpec: Bool {self._spec != nil}
    /// Clears the value of `spec`. Subsequent reads from it will return its default value.
    public mutating func clearSpec() {self._spec = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _spec: Api.Cloud.Account.V1.AuditLogSinkSpec? = nil
  }
}
extension Api.Cloud.Cloudservice.V1 {


  public struct ValidateAccountAuditLogSinkResponse: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.cloud.cloudservice.v1"

extension Api.Cloud.Cloudservice.V1.GetUsersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}email\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.email) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.email.isEmpty {
      try visitor.visitSingularStringField(value: self.email, fieldNumber: 3)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUsersRequest, rhs: Api.Cloud.Cloudservice.V1.GetUsersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.email != rhs.email {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUsersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}users\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.users) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.users.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.users, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUsersResponse, rhs: Api.Cloud.Cloudservice.V1.GetUsersResponse) -> Bool {
    if lhs.users != rhs.users {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserRequest, rhs: Api.Cloud.Cloudservice.V1.GetUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}user\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserResponse, rhs: Api.Cloud.Cloudservice.V1.GetUserResponse) -> Bool {
    if lhs._user != rhs._user {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateUserRequest, rhs: Api.Cloud.Cloudservice.V1.CreateUserRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateUserResponse, rhs: Api.Cloud.Cloudservice.V1.CreateUserResponse) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateUserRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateUserResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateUserResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteUserRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}user_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteUserRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteUserRequest) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteUserResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteUserResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteUserResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetUserNamespaceAccessRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}user_id\0\u{1}access\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 2)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessRequest, rhs: Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.userID != rhs.userID {return false}
    if lhs._access != rhs._access {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetUserNamespaceAccessResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessResponse, rhs: Api.Cloud.Cloudservice.V1.SetUserNamespaceAccessResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetAsyncOperationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAsyncOperationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetAsyncOperationRequest, rhs: Api.Cloud.Cloudservice.V1.GetAsyncOperationRequest) -> Bool {
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetAsyncOperationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAsyncOperationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetAsyncOperationResponse, rhs: Api.Cloud.Cloudservice.V1.GetAsyncOperationResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}spec\0\u{3}async_operation_id\0\u{1}tags\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tags) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    if !self.tags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNamespaceRequest, rhs: Api.Cloud.Cloudservice.V1.CreateNamespaceRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNamespaceResponse, rhs: Api.Cloud.Cloudservice.V1.CreateNamespaceResponse) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespacesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespacesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespacesRequest, rhs: Api.Cloud.Cloudservice.V1.GetNamespacesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespacesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespacesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespaces\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.namespaces) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespaces.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.namespaces, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespacesResponse, rhs: Api.Cloud.Cloudservice.V1.GetNamespacesResponse) -> Bool {
    if lhs.namespaces != rhs.namespaces {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceRequest, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._namespace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceResponse, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceResponse) -> Bool {
    if lhs._namespace != rhs._namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameCustomSearchAttributeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}existing_custom_search_attribute_name\0\u{3}new_custom_search_attribute_name\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.existingCustomSearchAttributeName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.newCustomSearchAttributeName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.existingCustomSearchAttributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.existingCustomSearchAttributeName, fieldNumber: 2)
    }
    if !self.newCustomSearchAttributeName.isEmpty {
      try visitor.visitSingularStringField(value: self.newCustomSearchAttributeName, fieldNumber: 3)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeRequest, rhs: Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.existingCustomSearchAttributeName != rhs.existingCustomSearchAttributeName {return false}
    if lhs.newCustomSearchAttributeName != rhs.newCustomSearchAttributeName {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RenameCustomSearchAttributeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeResponse, rhs: Api.Cloud.Cloudservice.V1.RenameCustomSearchAttributeResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailoverNamespaceRegionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionRequest, rhs: Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".FailoverNamespaceRegionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionResponse, rhs: Api.Cloud.Cloudservice.V1.FailoverNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.AddNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNamespaceRegionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.AddNamespaceRegionRequest, rhs: Api.Cloud.Cloudservice.V1.AddNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.AddNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddNamespaceRegionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.AddNamespaceRegionResponse, rhs: Api.Cloud.Cloudservice.V1.AddNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRegionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}region\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.region != rhs.region {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceRegionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceRegionResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetRegionsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRegionsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetRegionsRequest, rhs: Api.Cloud.Cloudservice.V1.GetRegionsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetRegionsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRegionsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}regions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.regions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.regions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetRegionsResponse, rhs: Api.Cloud.Cloudservice.V1.GetRegionsResponse) -> Bool {
    if lhs.regions != rhs.regions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetRegionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRegionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.region) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetRegionRequest, rhs: Api.Cloud.Cloudservice.V1.GetRegionRequest) -> Bool {
    if lhs.region != rhs.region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetRegionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetRegionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}region\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._region) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._region {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetRegionResponse, rhs: Api.Cloud.Cloudservice.V1.GetRegionResponse) -> Bool {
    if lhs._region != rhs._region {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetApiKeysRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApiKeysRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}owner_id\0\u{3}owner_type_deprecated\0\u{3}owner_type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ownerID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.ownerTypeDeprecated) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.ownerType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.ownerID.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerID, fieldNumber: 3)
    }
    if !self.ownerTypeDeprecated.isEmpty {
      try visitor.visitSingularStringField(value: self.ownerTypeDeprecated, fieldNumber: 4)
    }
    if self.ownerType != .unspecified {
      try visitor.visitSingularEnumField(value: self.ownerType, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetApiKeysRequest, rhs: Api.Cloud.Cloudservice.V1.GetApiKeysRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.ownerID != rhs.ownerID {return false}
    if lhs.ownerTypeDeprecated != rhs.ownerTypeDeprecated {return false}
    if lhs.ownerType != rhs.ownerType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetApiKeysResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApiKeysResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}api_keys\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.apiKeys) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.apiKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.apiKeys, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetApiKeysResponse, rhs: Api.Cloud.Cloudservice.V1.GetApiKeysResponse) -> Bool {
    if lhs.apiKeys != rhs.apiKeys {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApiKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetApiKeyRequest, rhs: Api.Cloud.Cloudservice.V1.GetApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetApiKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}api_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._apiKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._apiKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetApiKeyResponse, rhs: Api.Cloud.Cloudservice.V1.GetApiKeyResponse) -> Bool {
    if lhs._apiKey != rhs._apiKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateApiKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateApiKeyRequest, rhs: Api.Cloud.Cloudservice.V1.CreateApiKeyRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateApiKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{1}token\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.token) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.token.isEmpty {
      try visitor.visitSingularStringField(value: self.token, fieldNumber: 2)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateApiKeyResponse, rhs: Api.Cloud.Cloudservice.V1.CreateApiKeyResponse) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.token != rhs.token {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateApiKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateApiKeyRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateApiKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateApiKeyResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateApiKeyResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteApiKeyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteApiKeyRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}key_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteApiKeyRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteApiKeyRequest) -> Bool {
    if lhs.keyID != rhs.keyID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteApiKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteApiKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteApiKeyResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteApiKeyResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNexusEndpointsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}target_namespace_id\0\u{3}target_task_queue\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.targetNamespaceID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.targetTaskQueue) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.targetNamespaceID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetNamespaceID, fieldNumber: 3)
    }
    if !self.targetTaskQueue.isEmpty {
      try visitor.visitSingularStringField(value: self.targetTaskQueue, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointsRequest, rhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.targetNamespaceID != rhs.targetNamespaceID {return false}
    if lhs.targetTaskQueue != rhs.targetTaskQueue {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNexusEndpointsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoints\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.endpoints) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.endpoints, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointsResponse, rhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointsResponse) -> Bool {
    if lhs.endpoints != rhs.endpoints {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointRequest, rhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._endpoint) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._endpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointResponse, rhs: Api.Cloud.Cloudservice.V1.GetNexusEndpointResponse) -> Bool {
    if lhs._endpoint != rhs._endpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNexusEndpointRequest, rhs: Api.Cloud.Cloudservice.V1.CreateNexusEndpointRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNexusEndpointResponse, rhs: Api.Cloud.Cloudservice.V1.CreateNexusEndpointResponse) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNexusEndpointRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNexusEndpointResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateNexusEndpointResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNexusEndpointRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}endpoint_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.endpointID.isEmpty {
      try visitor.visitSingularStringField(value: self.endpointID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNexusEndpointRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteNexusEndpointRequest) -> Bool {
    if lhs.endpointID != rhs.endpointID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNexusEndpointResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNexusEndpointResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNexusEndpointResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteNexusEndpointResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}namespace\0\u{3}display_name\0\u{3}google_group\0\u{3}scim_group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._googleGroup) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._scimGroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    try { if let v = self._googleGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._scimGroup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._googleGroup != rhs._googleGroup {return false}
    if lhs._scimGroup != rhs._scimGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.protoMessageName + ".GoogleGroupFilter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}email_address\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emailAddress) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emailAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.emailAddress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.GoogleGroupFilter) -> Bool {
    if lhs.emailAddress != rhs.emailAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.protoMessageName + ".SCIMGroupFilter"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}idp_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.idpID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.idpID.isEmpty {
      try visitor.visitSingularStringField(value: self.idpID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupsRequest.SCIMGroupFilter) -> Bool {
    if lhs.idpID != rhs.idpID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}groups\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.groups) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.groups, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupsResponse, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupsResponse) -> Bool {
    if lhs.groups != rhs.groups {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupRequest, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}group\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupResponse, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupResponse) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateUserGroupRequest, rhs: Api.Cloud.Cloudservice.V1.CreateUserGroupRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateUserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateUserGroupResponse, rhs: Api.Cloud.Cloudservice.V1.CreateUserGroupResponse) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateUserGroupRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateUserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateUserGroupResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateUserGroupResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteUserGroupRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserGroupRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteUserGroupRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteUserGroupRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteUserGroupResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteUserGroupResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteUserGroupResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteUserGroupResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetUserGroupNamespaceAccessRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}group_id\0\u{1}access\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 2)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessRequest, rhs: Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs._access != rhs._access {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetUserGroupNamespaceAccessResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessResponse, rhs: Api.Cloud.Cloudservice.V1.SetUserGroupNamespaceAccessResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.AddUserGroupMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddUserGroupMemberRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}member_id\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.AddUserGroupMemberRequest, rhs: Api.Cloud.Cloudservice.V1.AddUserGroupMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.AddUserGroupMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddUserGroupMemberResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.AddUserGroupMemberResponse, rhs: Api.Cloud.Cloudservice.V1.AddUserGroupMemberResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveUserGroupMemberRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}group_id\0\u{3}member_id\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._memberID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 1)
    }
    try { if let v = self._memberID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberRequest, rhs: Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberRequest) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs._memberID != rhs._memberID {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RemoveUserGroupMemberResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberResponse, rhs: Api.Cloud.Cloudservice.V1.RemoveUserGroupMemberResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupMembersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupMembersRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{3}group_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupMembersRequest, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupMembersRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUserGroupMembersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUserGroupMembersResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}members\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.members) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUserGroupMembersResponse, rhs: Api.Cloud.Cloudservice.V1.GetUserGroupMembersResponse) -> Bool {
    if lhs.members != rhs.members {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateServiceAccountRequest, rhs: Api.Cloud.Cloudservice.V1.CreateServiceAccountRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateServiceAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateServiceAccountResponse, rhs: Api.Cloud.Cloudservice.V1.CreateServiceAccountResponse) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetServiceAccountRequest, rhs: Api.Cloud.Cloudservice.V1.GetServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._serviceAccount) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._serviceAccount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetServiceAccountResponse, rhs: Api.Cloud.Cloudservice.V1.GetServiceAccountResponse) -> Bool {
    if lhs._serviceAccount != rhs._serviceAccount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetServiceAccountsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetServiceAccountsRequest, rhs: Api.Cloud.Cloudservice.V1.GetServiceAccountsRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetServiceAccountsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetServiceAccountsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.serviceAccount) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.serviceAccount, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetServiceAccountsResponse, rhs: Api.Cloud.Cloudservice.V1.GetServiceAccountsResponse) -> Bool {
    if lhs.serviceAccount != rhs.serviceAccount {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateServiceAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateServiceAccountRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateServiceAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateServiceAccountResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateServiceAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetServiceAccountNamespaceAccessRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{1}namespace\0\u{1}access\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._access) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 2)
    }
    try { if let v = self._access {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 4)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessRequest, rhs: Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs._access != rhs._access {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SetServiceAccountNamespaceAccessResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessResponse, rhs: Api.Cloud.Cloudservice.V1.SetServiceAccountNamespaceAccessResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteServiceAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}service_account_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceAccountID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceAccountID.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceAccountID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteServiceAccountRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteServiceAccountRequest) -> Bool {
    if lhs.serviceAccountID != rhs.serviceAccountID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteServiceAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteServiceAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteServiceAccountResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteServiceAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUsageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}start_time_inclusive\0\u{3}end_time_exclusive\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._startTimeInclusive) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTimeExclusive) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startTimeInclusive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTimeExclusive {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 3)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUsageRequest, rhs: Api.Cloud.Cloudservice.V1.GetUsageRequest) -> Bool {
    if lhs._startTimeInclusive != rhs._startTimeInclusive {return false}
    if lhs._endTimeExclusive != rhs._endTimeExclusive {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetUsageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetUsageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}summaries\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.summaries) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.summaries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.summaries, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetUsageResponse, rhs: Api.Cloud.Cloudservice.V1.GetUsageResponse) -> Bool {
    if lhs.summaries != rhs.summaries {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetAccountRequest, rhs: Api.Cloud.Cloudservice.V1.GetAccountRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._account) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetAccountResponse, rhs: Api.Cloud.Cloudservice.V1.GetAccountResponse) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateAccountRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAccountRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateAccountRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateAccountRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateAccountResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateAccountResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateAccountResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateAccountResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNamespaceExportSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkRequest, rhs: Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateNamespaceExportSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkResponse, rhs: Api.Cloud.Cloudservice.V1.CreateNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}name\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkRequest, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sink\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sink) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sink {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkResponse, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinkResponse) -> Bool {
    if lhs._sink != rhs._sink {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinksRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}page_size\0\u{3}page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 2)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksRequest, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetNamespaceExportSinksResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sinks\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sinks) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sinks, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksResponse, rhs: Api.Cloud.Cloudservice.V1.GetNamespaceExportSinksResponse) -> Bool {
    if lhs.sinks != rhs.sinks {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceExportSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceExportSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceExportSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}name\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.name != rhs.name {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteNamespaceExportSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteNamespaceExportSinkResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateNamespaceExportSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkRequest, rhs: Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateNamespaceExportSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkResponse, rhs: Api.Cloud.Cloudservice.V1.ValidateNamespaceExportSinkResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceTagsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}tags_to_upsert\0\u{3}tags_to_remove\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.tagsToUpsert) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.tagsToRemove) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.tagsToUpsert.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.tagsToUpsert, fieldNumber: 2)
    }
    if !self.tagsToRemove.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tagsToRemove, fieldNumber: 3)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsRequest, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsRequest) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.tagsToUpsert != rhs.tagsToUpsert {return false}
    if lhs.tagsToRemove != rhs.tagsToRemove {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateNamespaceTagsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsResponse, rhs: Api.Cloud.Cloudservice.V1.UpdateNamespaceTagsResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectivityRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateConnectivityRuleRequest, rhs: Api.Cloud.Cloudservice.V1.CreateConnectivityRuleRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.CreateConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CreateConnectivityRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.CreateConnectivityRuleResponse, rhs: Api.Cloud.Cloudservice.V1.CreateConnectivityRuleResponse) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectivityRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetConnectivityRuleRequest, rhs: Api.Cloud.Cloudservice.V1.GetConnectivityRuleRequest) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectivityRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._connectivityRule) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._connectivityRule {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetConnectivityRuleResponse, rhs: Api.Cloud.Cloudservice.V1.GetConnectivityRuleResponse) -> Bool {
    if lhs._connectivityRule != rhs._connectivityRule {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetConnectivityRulesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectivityRulesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}page_size\0\u{3}page_token\0\u{1}namespace\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.pageSize) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.pageToken) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pageSize != 0 {
      try visitor.visitSingularInt32Field(value: self.pageSize, fieldNumber: 1)
    }
    if !self.pageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.pageToken, fieldNumber: 2)
    }
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetConnectivityRulesRequest, rhs: Api.Cloud.Cloudservice.V1.GetConnectivityRulesRequest) -> Bool {
    if lhs.pageSize != rhs.pageSize {return false}
    if lhs.pageToken != rhs.pageToken {return false}
    if lhs.namespace != rhs.namespace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.GetConnectivityRulesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConnectivityRulesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rules\0\u{3}next_page_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.connectivityRules) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.connectivityRules, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.GetConnectivityRulesResponse, rhs: Api.Cloud.Cloudservice.V1.GetConnectivityRulesResponse) -> Bool {
    if lhs.connectivityRules != rhs.connectivityRules {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConnectivityRuleRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}connectivity_rule_id\0\u{3}resource_version\0\u{3}async_operation_id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.connectivityRuleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resourceVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.asyncOperationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.connectivityRuleID.isEmpty {
      try visitor.visitSingularStringField(value: self.connectivityRuleID, fieldNumber: 1)
    }
    if !self.resourceVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.resourceVersion, fieldNumber: 2)
    }
    if !self.asyncOperationID.isEmpty {
      try visitor.visitSingularStringField(value: self.asyncOperationID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleRequest, rhs: Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleRequest) -> Bool {
    if lhs.connectivityRuleID != rhs.connectivityRuleID {return false}
    if lhs.resourceVersion != rhs.resourceVersion {return false}
    if lhs.asyncOperationID != rhs.asyncOperationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConnectivityRuleResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}async_operation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._asyncOperation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._asyncOperation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleResponse, rhs: Api.Cloud.Cloudservice.V1.DeleteConnectivityRuleResponse) -> Bool {
    if lhs._asyncOperation != rhs._asyncOperation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateAccountAuditLogSinkRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}spec\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._spec) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkRequest, rhs: Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkRequest) -> Bool {
    if lhs._spec != rhs._spec {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ValidateAccountAuditLogSinkResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkResponse, rhs: Api.Cloud.Cloudservice.V1.ValidateAccountAuditLogSinkResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
