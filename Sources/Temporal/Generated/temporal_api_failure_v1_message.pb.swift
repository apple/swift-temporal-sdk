// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/failure/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Failure.V1 {


  public struct ApplicationFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: String = String()

    public var nonRetryable: Bool = false

    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    /// next_retry_delay can be used by the client to override the activity
    /// retry interval calculated by the retry policy. Retry attempts will
    /// still be subject to the maximum retries limit and total time limit
    /// defined by the policy.
    public var nextRetryDelay: SwiftProtobuf.Google_Protobuf_Duration {
      get {_nextRetryDelay ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_nextRetryDelay = newValue}
    }
    /// Returns true if `nextRetryDelay` has been explicitly set.
    public var hasNextRetryDelay: Bool {self._nextRetryDelay != nil}
    /// Clears the value of `nextRetryDelay`. Subsequent reads from it will return its default value.
    public mutating func clearNextRetryDelay() {self._nextRetryDelay = nil}

    public var category: Api.Enums.V1.ApplicationErrorCategory = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
    fileprivate var _nextRetryDelay: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Failure.V1 {


  public struct TimeoutFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timeoutType: Api.Enums.V1.TimeoutType = .unspecified

    public var lastHeartbeatDetails: Api.Common.V1.Payloads {
      get {_lastHeartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_lastHeartbeatDetails = newValue}
    }
    /// Returns true if `lastHeartbeatDetails` has been explicitly set.
    public var hasLastHeartbeatDetails: Bool {self._lastHeartbeatDetails != nil}
    /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _lastHeartbeatDetails: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Failure.V1 {


  public struct CanceledFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    public var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    public mutating func clearDetails() {self._details = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Failure.V1 {


  public struct TerminatedFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Failure.V1 {


  public struct ServerFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var nonRetryable: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Failure.V1 {


  public struct ResetWorkflowFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lastHeartbeatDetails: Api.Common.V1.Payloads {
      get {_lastHeartbeatDetails ?? Api.Common.V1.Payloads()}
      set {_lastHeartbeatDetails = newValue}
    }
    /// Returns true if `lastHeartbeatDetails` has been explicitly set.
    public var hasLastHeartbeatDetails: Bool {self._lastHeartbeatDetails != nil}
    /// Clears the value of `lastHeartbeatDetails`. Subsequent reads from it will return its default value.
    public mutating func clearLastHeartbeatDetails() {self._lastHeartbeatDetails = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _lastHeartbeatDetails: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Failure.V1 {


  public struct ActivityFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var scheduledEventID: Int64 = 0

    public var startedEventID: Int64 = 0

    public var identity: String = String()

    public var activityType: Api.Common.V1.ActivityType {
      get {_activityType ?? Api.Common.V1.ActivityType()}
      set {_activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    public var hasActivityType: Bool {self._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    public mutating func clearActivityType() {self._activityType = nil}

    public var activityID: String = String()

    public var retryState: Api.Enums.V1.RetryState = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _activityType: Api.Common.V1.ActivityType? = nil
  }
}
extension Api.Failure.V1 {


  public struct ChildWorkflowExecutionFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var namespace: String = String()

    public var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    public var hasWorkflowExecution: Bool {self._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowExecution() {self._workflowExecution = nil}

    public var workflowType: Api.Common.V1.WorkflowType {
      get {_workflowType ?? Api.Common.V1.WorkflowType()}
      set {_workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    public var hasWorkflowType: Bool {self._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    public mutating func clearWorkflowType() {self._workflowType = nil}

    public var initiatedEventID: Int64 = 0

    public var startedEventID: Int64 = 0

    public var retryState: Api.Enums.V1.RetryState = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _workflowType: Api.Common.V1.WorkflowType? = nil
  }
}
extension Api.Failure.V1 {


  public struct NexusOperationFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The NexusOperationScheduled event ID.
    public var scheduledEventID: Int64 = 0

    /// Endpoint name.
    public var endpoint: String = String()

    /// Service name.
    public var service: String = String()

    /// Operation name.
    public var operation: String = String()

    /// Operation ID - may be empty if the operation completed synchronously.
    ///
    /// Deprecated. Renamed to operation_token.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    public var operationID: String = String()

    /// Operation token - may be empty if the operation completed synchronously.
    public var operationToken: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Failure.V1 {


  public struct NexusHandlerFailureInfo: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The Nexus error type as defined in the spec:
    /// https://github.com/nexus-rpc/api/blob/main/SPEC.md#predefined-handler-errors.
    public var type: String = String()

    /// Retry behavior, defaults to the retry behavior of the error type as defined in the spec.
    public var retryBehavior: Api.Enums.V1.NexusHandlerErrorRetryBehavior = .unspecified

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}
extension Api.Failure.V1 {


  public struct Failure: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var message: String {
      get {_storage._message}
      set {_uniqueStorage()._message = newValue}
    }

    /// The source this Failure originated in, e.g. TypeScriptSDK / JavaSDK
    /// In some SDKs this is used to rehydrate the stack trace into an exception object.
    public var source: String {
      get {_storage._source}
      set {_uniqueStorage()._source = newValue}
    }

    public var stackTrace: String {
      get {_storage._stackTrace}
      set {_uniqueStorage()._stackTrace = newValue}
    }

    /// Alternative way to supply `message` and `stack_trace` and possibly other attributes, used for encryption of
    /// errors originating in user code which might contain sensitive information.
    /// The `encoded_attributes` Payload could represent any serializable object, e.g. JSON object or a `Failure` proto
    /// message.
    ///
    /// SDK authors:
    /// - The SDK should provide a default `encodeFailureAttributes` and `decodeFailureAttributes` implementation that:
    ///   - Uses a JSON object to represent `{ message, stack_trace }`.
    ///   - Overwrites the original message with "Encoded failure" to indicate that more information could be extracted.
    ///   - Overwrites the original stack_trace with an empty string.
    ///   - The resulting JSON object is converted to Payload using the default PayloadConverter and should be processed
    ///     by the user-provided PayloadCodec
    ///
    /// - If there's demand, we could allow overriding the default SDK implementation to encode other opaque Failure attributes.
    /// (-- api-linter: core::0203::optional=disabled --)
    public var encodedAttributes: Api.Common.V1.Payload {
      get {_storage._encodedAttributes ?? Api.Common.V1.Payload()}
      set {_uniqueStorage()._encodedAttributes = newValue}
    }
    /// Returns true if `encodedAttributes` has been explicitly set.
    public var hasEncodedAttributes: Bool {_storage._encodedAttributes != nil}
    /// Clears the value of `encodedAttributes`. Subsequent reads from it will return its default value.
    public mutating func clearEncodedAttributes() {_uniqueStorage()._encodedAttributes = nil}

    public var cause: Api.Failure.V1.Failure {
      get {_storage._cause ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._cause = newValue}
    }
    /// Returns true if `cause` has been explicitly set.
    public var hasCause: Bool {_storage._cause != nil}
    /// Clears the value of `cause`. Subsequent reads from it will return its default value.
    public mutating func clearCause() {_uniqueStorage()._cause = nil}

    public var failureInfo: OneOf_FailureInfo? {
      get {return _storage._failureInfo}
      set {_uniqueStorage()._failureInfo = newValue}
    }

    public var applicationFailureInfo: Api.Failure.V1.ApplicationFailureInfo {
      get {
        if case .applicationFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.ApplicationFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .applicationFailureInfo(newValue)}
    }

    public var timeoutFailureInfo: Api.Failure.V1.TimeoutFailureInfo {
      get {
        if case .timeoutFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.TimeoutFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .timeoutFailureInfo(newValue)}
    }

    public var canceledFailureInfo: Api.Failure.V1.CanceledFailureInfo {
      get {
        if case .canceledFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.CanceledFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .canceledFailureInfo(newValue)}
    }

    public var terminatedFailureInfo: Api.Failure.V1.TerminatedFailureInfo {
      get {
        if case .terminatedFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.TerminatedFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .terminatedFailureInfo(newValue)}
    }

    public var serverFailureInfo: Api.Failure.V1.ServerFailureInfo {
      get {
        if case .serverFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.ServerFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .serverFailureInfo(newValue)}
    }

    public var resetWorkflowFailureInfo: Api.Failure.V1.ResetWorkflowFailureInfo {
      get {
        if case .resetWorkflowFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.ResetWorkflowFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .resetWorkflowFailureInfo(newValue)}
    }

    public var activityFailureInfo: Api.Failure.V1.ActivityFailureInfo {
      get {
        if case .activityFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.ActivityFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .activityFailureInfo(newValue)}
    }

    public var childWorkflowExecutionFailureInfo: Api.Failure.V1.ChildWorkflowExecutionFailureInfo {
      get {
        if case .childWorkflowExecutionFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.ChildWorkflowExecutionFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .childWorkflowExecutionFailureInfo(newValue)}
    }

    public var nexusOperationExecutionFailureInfo: Api.Failure.V1.NexusOperationFailureInfo {
      get {
        if case .nexusOperationExecutionFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.NexusOperationFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .nexusOperationExecutionFailureInfo(newValue)}
    }

    public var nexusHandlerFailureInfo: Api.Failure.V1.NexusHandlerFailureInfo {
      get {
        if case .nexusHandlerFailureInfo(let v)? = _storage._failureInfo {return v}
        return Api.Failure.V1.NexusHandlerFailureInfo()
      }
      set {_uniqueStorage()._failureInfo = .nexusHandlerFailureInfo(newValue)}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_FailureInfo: Equatable, Sendable {
      case applicationFailureInfo(Api.Failure.V1.ApplicationFailureInfo)
      case timeoutFailureInfo(Api.Failure.V1.TimeoutFailureInfo)
      case canceledFailureInfo(Api.Failure.V1.CanceledFailureInfo)
      case terminatedFailureInfo(Api.Failure.V1.TerminatedFailureInfo)
      case serverFailureInfo(Api.Failure.V1.ServerFailureInfo)
      case resetWorkflowFailureInfo(Api.Failure.V1.ResetWorkflowFailureInfo)
      case activityFailureInfo(Api.Failure.V1.ActivityFailureInfo)
      case childWorkflowExecutionFailureInfo(Api.Failure.V1.ChildWorkflowExecutionFailureInfo)
      case nexusOperationExecutionFailureInfo(Api.Failure.V1.NexusOperationFailureInfo)
      case nexusHandlerFailureInfo(Api.Failure.V1.NexusHandlerFailureInfo)

    }

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Failure.V1 {


  public struct MultiOperationExecutionAborted: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.failure.v1"

extension Api.Failure.V1.ApplicationFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ApplicationFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}non_retryable\0\u{1}details\0\u{3}next_retry_delay\0\u{1}category\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.nonRetryable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._nextRetryDelay) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.category) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.nonRetryable != false {
      try visitor.visitSingularBoolField(value: self.nonRetryable, fieldNumber: 2)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._nextRetryDelay {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if self.category != .unspecified {
      try visitor.visitSingularEnumField(value: self.category, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.ApplicationFailureInfo, rhs: Api.Failure.V1.ApplicationFailureInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.nonRetryable != rhs.nonRetryable {return false}
    if lhs._details != rhs._details {return false}
    if lhs._nextRetryDelay != rhs._nextRetryDelay {return false}
    if lhs.category != rhs.category {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.TimeoutFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TimeoutFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timeout_type\0\u{3}last_heartbeat_details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.timeoutType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timeoutType != .unspecified {
      try visitor.visitSingularEnumField(value: self.timeoutType, fieldNumber: 1)
    }
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.TimeoutFailureInfo, rhs: Api.Failure.V1.TimeoutFailureInfo) -> Bool {
    if lhs.timeoutType != rhs.timeoutType {return false}
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.CanceledFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CanceledFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.CanceledFailureInfo, rhs: Api.Failure.V1.CanceledFailureInfo) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.TerminatedFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TerminatedFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.TerminatedFailureInfo, rhs: Api.Failure.V1.TerminatedFailureInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.ServerFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ServerFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}non_retryable\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.nonRetryable) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonRetryable != false {
      try visitor.visitSingularBoolField(value: self.nonRetryable, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.ServerFailureInfo, rhs: Api.Failure.V1.ServerFailureInfo) -> Bool {
    if lhs.nonRetryable != rhs.nonRetryable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.ResetWorkflowFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResetWorkflowFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}last_heartbeat_details\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._lastHeartbeatDetails) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._lastHeartbeatDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.ResetWorkflowFailureInfo, rhs: Api.Failure.V1.ResetWorkflowFailureInfo) -> Bool {
    if lhs._lastHeartbeatDetails != rhs._lastHeartbeatDetails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.ActivityFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ActivityFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{3}started_event_id\0\u{1}identity\0\u{3}activity_type\0\u{3}activity_id\0\u{3}retry_state\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.identity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._activityType) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.activityID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 2)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 3)
    }
    try { if let v = self._activityType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.activityID.isEmpty {
      try visitor.visitSingularStringField(value: self.activityID, fieldNumber: 5)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.ActivityFailureInfo, rhs: Api.Failure.V1.ActivityFailureInfo) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs._activityType != rhs._activityType {return false}
    if lhs.activityID != rhs.activityID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.ChildWorkflowExecutionFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChildWorkflowExecutionFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_execution\0\u{3}workflow_type\0\u{3}initiated_event_id\0\u{3}started_event_id\0\u{3}retry_state\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._workflowExecution) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._workflowType) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.initiatedEventID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.startedEventID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.retryState) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._workflowExecution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._workflowType {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.initiatedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.initiatedEventID, fieldNumber: 4)
    }
    if self.startedEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.startedEventID, fieldNumber: 5)
    }
    if self.retryState != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.ChildWorkflowExecutionFailureInfo, rhs: Api.Failure.V1.ChildWorkflowExecutionFailureInfo) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._workflowExecution != rhs._workflowExecution {return false}
    if lhs._workflowType != rhs._workflowType {return false}
    if lhs.initiatedEventID != rhs.initiatedEventID {return false}
    if lhs.startedEventID != rhs.startedEventID {return false}
    if lhs.retryState != rhs.retryState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.NexusOperationFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NexusOperationFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{3}operation_id\0\u{3}operation_token\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.operationID) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.operationToken) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 2)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 3)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 4)
    }
    if !self.operationID.isEmpty {
      try visitor.visitSingularStringField(value: self.operationID, fieldNumber: 5)
    }
    if !self.operationToken.isEmpty {
      try visitor.visitSingularStringField(value: self.operationToken, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.NexusOperationFailureInfo, rhs: Api.Failure.V1.NexusOperationFailureInfo) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs.operationID != rhs.operationID {return false}
    if lhs.operationToken != rhs.operationToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.NexusHandlerFailureInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NexusHandlerFailureInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}retry_behavior\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.retryBehavior) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if self.retryBehavior != .unspecified {
      try visitor.visitSingularEnumField(value: self.retryBehavior, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.NexusHandlerFailureInfo, rhs: Api.Failure.V1.NexusHandlerFailureInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.retryBehavior != rhs.retryBehavior {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.Failure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Failure"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}message\0\u{1}source\0\u{3}stack_trace\0\u{1}cause\0\u{3}application_failure_info\0\u{3}timeout_failure_info\0\u{3}canceled_failure_info\0\u{3}terminated_failure_info\0\u{3}server_failure_info\0\u{3}reset_workflow_failure_info\0\u{3}activity_failure_info\0\u{3}child_workflow_execution_failure_info\0\u{3}nexus_operation_execution_failure_info\0\u{3}nexus_handler_failure_info\0\u{4}\u{6}encoded_attributes\0")

  fileprivate class _StorageClass {
    var _message: String = String()
    var _source: String = String()
    var _stackTrace: String = String()
    var _encodedAttributes: Api.Common.V1.Payload? = nil
    var _cause: Api.Failure.V1.Failure? = nil
    var _failureInfo: Api.Failure.V1.Failure.OneOf_FailureInfo?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _message = source._message
      _source = source._source
      _stackTrace = source._stackTrace
      _encodedAttributes = source._encodedAttributes
      _cause = source._cause
      _failureInfo = source._failureInfo
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._message) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._source) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._stackTrace) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._cause) }()
        case 5: try {
          var v: Api.Failure.V1.ApplicationFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .applicationFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .applicationFailureInfo(v)
          }
        }()
        case 6: try {
          var v: Api.Failure.V1.TimeoutFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .timeoutFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .timeoutFailureInfo(v)
          }
        }()
        case 7: try {
          var v: Api.Failure.V1.CanceledFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .canceledFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .canceledFailureInfo(v)
          }
        }()
        case 8: try {
          var v: Api.Failure.V1.TerminatedFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .terminatedFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .terminatedFailureInfo(v)
          }
        }()
        case 9: try {
          var v: Api.Failure.V1.ServerFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .serverFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .serverFailureInfo(v)
          }
        }()
        case 10: try {
          var v: Api.Failure.V1.ResetWorkflowFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .resetWorkflowFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .resetWorkflowFailureInfo(v)
          }
        }()
        case 11: try {
          var v: Api.Failure.V1.ActivityFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .activityFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .activityFailureInfo(v)
          }
        }()
        case 12: try {
          var v: Api.Failure.V1.ChildWorkflowExecutionFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .childWorkflowExecutionFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .childWorkflowExecutionFailureInfo(v)
          }
        }()
        case 13: try {
          var v: Api.Failure.V1.NexusOperationFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .nexusOperationExecutionFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .nexusOperationExecutionFailureInfo(v)
          }
        }()
        case 14: try {
          var v: Api.Failure.V1.NexusHandlerFailureInfo?
          var hadOneofValue = false
          if let current = _storage._failureInfo {
            hadOneofValue = true
            if case .nexusHandlerFailureInfo(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._failureInfo = .nexusHandlerFailureInfo(v)
          }
        }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._encodedAttributes) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._message.isEmpty {
        try visitor.visitSingularStringField(value: _storage._message, fieldNumber: 1)
      }
      if !_storage._source.isEmpty {
        try visitor.visitSingularStringField(value: _storage._source, fieldNumber: 2)
      }
      if !_storage._stackTrace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._stackTrace, fieldNumber: 3)
      }
      try { if let v = _storage._cause {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      switch _storage._failureInfo {
      case .applicationFailureInfo?: try {
        guard case .applicationFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .timeoutFailureInfo?: try {
        guard case .timeoutFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .canceledFailureInfo?: try {
        guard case .canceledFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .terminatedFailureInfo?: try {
        guard case .terminatedFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .serverFailureInfo?: try {
        guard case .serverFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .resetWorkflowFailureInfo?: try {
        guard case .resetWorkflowFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .activityFailureInfo?: try {
        guard case .activityFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .childWorkflowExecutionFailureInfo?: try {
        guard case .childWorkflowExecutionFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .nexusOperationExecutionFailureInfo?: try {
        guard case .nexusOperationExecutionFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .nexusHandlerFailureInfo?: try {
        guard case .nexusHandlerFailureInfo(let v)? = _storage._failureInfo else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case nil: break
      }
      try { if let v = _storage._encodedAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.Failure, rhs: Api.Failure.V1.Failure) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._message != rhs_storage._message {return false}
        if _storage._source != rhs_storage._source {return false}
        if _storage._stackTrace != rhs_storage._stackTrace {return false}
        if _storage._encodedAttributes != rhs_storage._encodedAttributes {return false}
        if _storage._cause != rhs_storage._cause {return false}
        if _storage._failureInfo != rhs_storage._failureInfo {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Failure.V1.MultiOperationExecutionAborted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MultiOperationExecutionAborted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api.Failure.V1.MultiOperationExecutionAborted, rhs: Api.Failure.V1.MultiOperationExecutionAborted) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
