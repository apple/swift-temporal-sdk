// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/enums/v1/task_queue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Enums.V1 {


  package enum TaskQueueKind: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Tasks from any non workflow task may be unspecified.
    ///
    /// Task queue kind is used to differentiate whether a workflow task queue is sticky or 
    /// normal. If a task is not a workflow task, Task queue kind will sometimes be 
    /// unspecified.
    case unspecified // = 0

    /// Tasks from a normal workflow task queue always include complete workflow history
    ///
    /// The task queue specified by the user is always a normal task queue. There can be as many
    /// workers as desired for a single normal task queue. All those workers may pick up tasks from
    /// that queue.
    case normal // = 1

    /// A sticky queue only includes new history since the last workflow task, and they are
    /// per-worker.
    ///
    /// Sticky queues are created dynamically by each worker during their start up. They only exist
    /// for the lifetime of the worker process. Tasks in a sticky task queue are only available to
    /// the worker that created the sticky queue.
    ///
    /// Sticky queues are only for workflow tasks. There are no sticky task queues for activities.
    case sticky // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .normal
      case 2: self = .sticky
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .normal: return 1
      case .sticky: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.TaskQueueKind] = [
      .unspecified,
      .normal,
      .sticky,
    ]

  }
}
extension Api.Enums.V1 {


  package enum TaskQueueType: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Workflow type of task queue.
    case workflow // = 1

    /// Activity type of task queue.
    case activity // = 2

    /// Task queue type for dispatching Nexus requests.
    case nexus // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .workflow
      case 2: self = .activity
      case 3: self = .nexus
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .workflow: return 1
      case .activity: return 2
      case .nexus: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.TaskQueueType] = [
      .unspecified,
      .workflow,
      .activity,
      .nexus,
    ]

  }
}
extension Api.Enums.V1 {


  /// Specifies which category of tasks may reach a worker on a versioned task queue.
  /// Used both in a reachability query and its response.
  /// Deprecated.
  package enum TaskReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// There's a possiblity for a worker to receive new workflow tasks. Workers should *not* be retired.
    case newWorkflows // = 1

    /// There's a possiblity for a worker to receive existing workflow and activity tasks from existing workflows. Workers
    /// should *not* be retired.
    /// This enum value does not distinguish between open and closed workflows.
    case existingWorkflows // = 2

    /// There's a possiblity for a worker to receive existing workflow and activity tasks from open workflows. Workers
    /// should *not* be retired.
    case openWorkflows // = 3

    /// There's a possiblity for a worker to receive existing workflow tasks from closed workflows. Workers may be
    /// retired dependending on application requirements. For example, if there's no need to query closed workflows.
    case closedWorkflows // = 4
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .newWorkflows
      case 2: self = .existingWorkflows
      case 3: self = .openWorkflows
      case 4: self = .closedWorkflows
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .newWorkflows: return 1
      case .existingWorkflows: return 2
      case .openWorkflows: return 3
      case .closedWorkflows: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.TaskReachability] = [
      .unspecified,
      .newWorkflows,
      .existingWorkflows,
      .openWorkflows,
      .closedWorkflows,
    ]

  }
}
extension Api.Enums.V1 {


  /// Specifies which category of tasks may reach a versioned worker of a certain Build ID.
  ///
  /// Task Reachability is eventually consistent; there may be a delay (up to few minutes) until it
  /// converges to the most accurate value but it is designed in a way to take the more conservative
  /// side until it converges. For example REACHABLE is more conservative than CLOSED_WORKFLOWS_ONLY.
  ///
  /// Note: future activities who inherit their workflow's Build ID but not its Task Queue will not be
  /// accounted for reachability as server cannot know if they'll happen as they do not use
  /// assignment rules of their Task Queue. Same goes for Child Workflows or Continue-As-New Workflows
  /// who inherit the parent/previous workflow's Build ID but not its Task Queue. In those cases, make
  /// sure to query reachability for the parent/previous workflow's Task Queue as well.
  package enum BuildIdTaskReachability: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Task reachability is not reported
    case unspecified // = 0

    /// Build ID may be used by new workflows or activities (base on versioning rules), or there MAY
    /// be open workflows or backlogged activities assigned to it.
    case reachable // = 1

    /// Build ID does not have open workflows and is not reachable by new workflows,
    /// but MAY have closed workflows within the namespace retention period.
    /// Not applicable to activity-only task queues.
    case closedWorkflowsOnly // = 2

    /// Build ID is not used for new executions, nor it has been used by any existing execution
    /// within the retention period.
    case unreachable // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .reachable
      case 2: self = .closedWorkflowsOnly
      case 3: self = .unreachable
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .reachable: return 1
      case .closedWorkflowsOnly: return 2
      case .unreachable: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.BuildIdTaskReachability] = [
      .unspecified,
      .reachable,
      .closedWorkflowsOnly,
      .unreachable,
    ]

  }
}
extension Api.Enums.V1 {


  package enum DescribeTaskQueueMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// Unspecified means legacy behavior.
    case unspecified // = 0

    /// Enhanced mode reports aggregated results for all partitions, supports Build IDs, and reports richer info.
    case enhanced // = 1
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .enhanced
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .enhanced: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.DescribeTaskQueueMode] = [
      .unspecified,
      .enhanced,
    ]

  }
}
extension Api.Enums.V1 {


  /// Source for the effective rate limit.
  package enum RateLimitSource: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// The value was set by the API.
    case api // = 1

    /// The value was set by a worker.
    case worker // = 2

    /// The value was set as the system default.
    case system // = 3
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .api
      case 2: self = .worker
      case 3: self = .system
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .api: return 1
      case .worker: return 2
      case .system: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.RateLimitSource] = [
      .unspecified,
      .api,
      .worker,
      .system,
    ]

  }
}
extension Api.Enums.V1 {


  /// Indicates whether a change to the Routing Config has been
  /// propagated to all relevant Task Queues and their partitions.
  package enum RoutingConfigUpdateState: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int
    case unspecified // = 0

    /// Update to the RoutingConfig is currently in progress.
    case inProgress // = 1

    /// Update to the RoutingConfig has completed successfully.
    case completed // = 2
    case UNRECOGNIZED(Int)

    package init() {
      self = .unspecified
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .inProgress
      case 2: self = .completed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .inProgress: return 1
      case .completed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Api.Enums.V1.RoutingConfigUpdateState] = [
      .unspecified,
      .inProgress,
      .completed,
    ]

  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Api.Enums.V1.TaskQueueKind: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_QUEUE_KIND_UNSPECIFIED\0\u{1}TASK_QUEUE_KIND_NORMAL\0\u{1}TASK_QUEUE_KIND_STICKY\0")
}

extension Api.Enums.V1.TaskQueueType: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_QUEUE_TYPE_UNSPECIFIED\0\u{1}TASK_QUEUE_TYPE_WORKFLOW\0\u{1}TASK_QUEUE_TYPE_ACTIVITY\0\u{1}TASK_QUEUE_TYPE_NEXUS\0")
}

extension Api.Enums.V1.TaskReachability: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0TASK_REACHABILITY_UNSPECIFIED\0\u{1}TASK_REACHABILITY_NEW_WORKFLOWS\0\u{1}TASK_REACHABILITY_EXISTING_WORKFLOWS\0\u{1}TASK_REACHABILITY_OPEN_WORKFLOWS\0\u{1}TASK_REACHABILITY_CLOSED_WORKFLOWS\0")
}

extension Api.Enums.V1.BuildIdTaskReachability: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BUILD_ID_TASK_REACHABILITY_UNSPECIFIED\0\u{1}BUILD_ID_TASK_REACHABILITY_REACHABLE\0\u{1}BUILD_ID_TASK_REACHABILITY_CLOSED_WORKFLOWS_ONLY\0\u{1}BUILD_ID_TASK_REACHABILITY_UNREACHABLE\0")
}

extension Api.Enums.V1.DescribeTaskQueueMode: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0DESCRIBE_TASK_QUEUE_MODE_UNSPECIFIED\0\u{1}DESCRIBE_TASK_QUEUE_MODE_ENHANCED\0")
}

extension Api.Enums.V1.RateLimitSource: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RATE_LIMIT_SOURCE_UNSPECIFIED\0\u{1}RATE_LIMIT_SOURCE_API\0\u{1}RATE_LIMIT_SOURCE_WORKER\0\u{1}RATE_LIMIT_SOURCE_SYSTEM\0")
}

extension Api.Enums.V1.RoutingConfigUpdateState: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ROUTING_CONFIG_UPDATE_STATE_UNSPECIFIED\0\u{1}ROUTING_CONFIG_UPDATE_STATE_IN_PROGRESS\0\u{1}ROUTING_CONFIG_UPDATE_STATE_COMPLETED\0")
}
