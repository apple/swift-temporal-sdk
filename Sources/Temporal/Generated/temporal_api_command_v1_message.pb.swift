// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/api/command/v1/message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Api.Command.V1 {


  package struct ScheduleActivityTaskCommandAttributes: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    package var activityType: Api.Common.V1.ActivityType {
      get {_storage._activityType ?? Api.Common.V1.ActivityType()}
      set {_uniqueStorage()._activityType = newValue}
    }
    /// Returns true if `activityType` has been explicitly set.
    package var hasActivityType: Bool {_storage._activityType != nil}
    /// Clears the value of `activityType`. Subsequent reads from it will return its default value.
    package mutating func clearActivityType() {_uniqueStorage()._activityType = nil}

    package var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    package var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    package var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {_uniqueStorage()._header = nil}

    package var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Indicates how long the caller is willing to wait for activity completion. The "schedule" time
    /// is when the activity is initially scheduled, not when the most recent retry is scheduled.
    /// Limits how long retries will be attempted. Either this or `start_to_close_timeout` must be
    /// specified. When not specified, defaults to the workflow execution timeout.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Limits the time an activity task can stay in a task queue before a worker picks it up. The
    /// "schedule" time is when the most recent retry is scheduled. This timeout should usually not
    /// be set: it's useful in specific scenarios like worker-specific task queues. This timeout is
    /// always non retryable, as all a retry would achieve is to put it back into the same queue.
    /// Defaults to `schedule_to_close_timeout` or workflow execution timeout if that is not
    /// specified. More info:
    /// https://docs.temporal.io/docs/content/what-is-a-schedule-to-start-timeout/
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {_storage._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {_uniqueStorage()._scheduleToStartTimeout = nil}

    /// Maximum time an activity is allowed to execute after being picked up by a worker. This
    /// timeout is always retryable. Either this or `schedule_to_close_timeout` must be specified.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// Maximum permitted time between successful worker heartbeats.
    package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    package var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// Activities are provided by a default retry policy which is controlled through the service's
    /// dynamic configuration. Retries will be attempted until `schedule_to_close_timeout` has
    /// elapsed. To disable retries set retry_policy.maximum_attempts to 1.
    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Request to start the activity directly bypassing matching service and worker polling
    /// The slot for executing the activity should be reserved when setting this field to true.
    package var requestEagerExecution: Bool {
      get {_storage._requestEagerExecution}
      set {_uniqueStorage()._requestEagerExecution = newValue}
    }

    /// If this is set, the activity would be assigned to the Build ID of the workflow. Otherwise,
    /// Assignment rules of the activity's Task Queue will be used to determine the Build ID.
    package var useWorkflowBuildID: Bool {
      get {_storage._useWorkflowBuildID}
      set {_uniqueStorage()._useWorkflowBuildID = newValue}
    }

    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    package var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    package var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    package mutating func clearPriority() {_uniqueStorage()._priority = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Command.V1 {


  package struct RequestCancelActivityTaskCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The `ACTIVITY_TASK_SCHEDULED` event id for the activity being cancelled.
    package var scheduledEventID: Int64 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Command.V1 {


  package struct StartTimerCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// An id for the timer, currently live timers must have different ids. Typically autogenerated
    /// by the SDK.
    package var timerID: String = String()

    /// How long until the timer fires, producing a `TIMER_FIRED` event.
    ///
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_startToFireTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startToFireTimeout = newValue}
    }
    /// Returns true if `startToFireTimeout` has been explicitly set.
    package var hasStartToFireTimeout: Bool {self._startToFireTimeout != nil}
    /// Clears the value of `startToFireTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToFireTimeout() {self._startToFireTimeout = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _startToFireTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Command.V1 {


  package struct CompleteWorkflowExecutionCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var result: Api.Common.V1.Payloads {
      get {_result ?? Api.Common.V1.Payloads()}
      set {_result = newValue}
    }
    /// Returns true if `result` has been explicitly set.
    package var hasResult: Bool {self._result != nil}
    /// Clears the value of `result`. Subsequent reads from it will return its default value.
    package mutating func clearResult() {self._result = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _result: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Command.V1 {


  package struct FailWorkflowExecutionCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Api.Command.V1 {


  package struct CancelTimerCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The same timer id from the start timer command
    package var timerID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Command.V1 {


  package struct CancelWorkflowExecutionCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var details: Api.Common.V1.Payloads {
      get {_details ?? Api.Common.V1.Payloads()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    package var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    package mutating func clearDetails() {self._details = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _details: Api.Common.V1.Payloads? = nil
  }
}
extension Api.Command.V1 {


  package struct RequestCancelExternalWorkflowExecutionCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var namespace: String = String()

    package var workflowID: String = String()

    package var runID: String = String()

    /// Deprecated.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var control: String = String()

    /// Set this to true if the workflow being cancelled is a child of the workflow originating this
    /// command. The request will be rejected if it is set to true and the target workflow is *not*
    /// a child of the requesting workflow.
    package var childWorkflowOnly: Bool = false

    /// Reason for requesting the cancellation
    package var reason: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Command.V1 {


  package struct SignalExternalWorkflowExecutionCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var namespace: String = String()

    package var execution: Api.Common.V1.WorkflowExecution {
      get {_execution ?? Api.Common.V1.WorkflowExecution()}
      set {_execution = newValue}
    }
    /// Returns true if `execution` has been explicitly set.
    package var hasExecution: Bool {self._execution != nil}
    /// Clears the value of `execution`. Subsequent reads from it will return its default value.
    package mutating func clearExecution() {self._execution = nil}

    /// The workflow author-defined name of the signal to send to the workflow.
    package var signalName: String = String()

    /// Serialized value(s) to provide with the signal.
    package var input: Api.Common.V1.Payloads {
      get {_input ?? Api.Common.V1.Payloads()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {self._input = nil}

    /// Deprecated
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var control: String = String()

    /// Set this to true if the workflow being cancelled is a child of the workflow originating this
    /// command. The request will be rejected if it is set to true and the target workflow is *not*
    /// a child of the requesting workflow.
    package var childWorkflowOnly: Bool = false

    /// Headers that are passed by the workflow that is sending a signal to the external 
    /// workflow that is receiving this signal.
    package var header: Api.Common.V1.Header {
      get {_header ?? Api.Common.V1.Header()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {self._header = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _execution: Api.Common.V1.WorkflowExecution? = nil
    fileprivate var _input: Api.Common.V1.Payloads? = nil
    fileprivate var _header: Api.Common.V1.Header? = nil
  }
}
extension Api.Command.V1 {


  package struct UpsertWorkflowSearchAttributesCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    package var hasSearchAttributes: Bool {self._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    package mutating func clearSearchAttributes() {self._searchAttributes = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
  }
}
extension Api.Command.V1 {


  package struct ModifyWorkflowPropertiesCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// If set, update the workflow memo with the provided values. The values will be merged with
    /// the existing memo. If the user wants to delete values, a default/empty Payload should be
    /// used as the value for the key being deleted.
    package var upsertedMemo: Api.Common.V1.Memo {
      get {_upsertedMemo ?? Api.Common.V1.Memo()}
      set {_upsertedMemo = newValue}
    }
    /// Returns true if `upsertedMemo` has been explicitly set.
    package var hasUpsertedMemo: Bool {self._upsertedMemo != nil}
    /// Clears the value of `upsertedMemo`. Subsequent reads from it will return its default value.
    package mutating func clearUpsertedMemo() {self._upsertedMemo = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _upsertedMemo: Api.Common.V1.Memo? = nil
  }
}
extension Api.Command.V1 {


  package struct RecordMarkerCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var markerName: String = String()

    package var details: Dictionary<String,Api.Common.V1.Payloads> = [:]

    package var header: Api.Common.V1.Header {
      get {_header ?? Api.Common.V1.Header()}
      set {_header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {self._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {self._header = nil}

    package var failure: Api.Failure.V1.Failure {
      get {_failure ?? Api.Failure.V1.Failure()}
      set {_failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {self._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {self._failure = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _header: Api.Common.V1.Header? = nil
    fileprivate var _failure: Api.Failure.V1.Failure? = nil
  }
}
extension Api.Command.V1 {


  package struct ContinueAsNewWorkflowExecutionCommandAttributes: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    package var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    package var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    package var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    package var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Timeout of a single workflow run.
    package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    package var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task.
    package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    package var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// How long the workflow start will be delayed - not really a "backoff" in the traditional sense.
    package var backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._backoffStartInterval ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._backoffStartInterval = newValue}
    }
    /// Returns true if `backoffStartInterval` has been explicitly set.
    package var hasBackoffStartInterval: Bool {_storage._backoffStartInterval != nil}
    /// Clears the value of `backoffStartInterval`. Subsequent reads from it will return its default value.
    package mutating func clearBackoffStartInterval() {_uniqueStorage()._backoffStartInterval = nil}

    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Should be removed
    package var initiator: Api.Enums.V1.ContinueAsNewInitiator {
      get {_storage._initiator}
      set {_uniqueStorage()._initiator = newValue}
    }

    /// Should be removed
    package var failure: Api.Failure.V1.Failure {
      get {_storage._failure ?? Api.Failure.V1.Failure()}
      set {_uniqueStorage()._failure = newValue}
    }
    /// Returns true if `failure` has been explicitly set.
    package var hasFailure: Bool {_storage._failure != nil}
    /// Clears the value of `failure`. Subsequent reads from it will return its default value.
    package mutating func clearFailure() {_uniqueStorage()._failure = nil}

    /// Should be removed
    package var lastCompletionResult: Api.Common.V1.Payloads {
      get {_storage._lastCompletionResult ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._lastCompletionResult = newValue}
    }
    /// Returns true if `lastCompletionResult` has been explicitly set.
    package var hasLastCompletionResult: Bool {_storage._lastCompletionResult != nil}
    /// Clears the value of `lastCompletionResult`. Subsequent reads from it will return its default value.
    package mutating func clearLastCompletionResult() {_uniqueStorage()._lastCompletionResult = nil}

    /// Should be removed. Not necessarily unused but unclear and not exposed by SDKs.
    package var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    package var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {_uniqueStorage()._header = nil}

    package var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    package var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    package mutating func clearMemo() {_uniqueStorage()._memo = nil}

    package var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    package var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    /// If this is set, the new execution inherits the Build ID of the current execution. Otherwise,
    /// the assignment rules will be used to independently assign a Build ID to the new execution.
    /// Deprecated. Only considered for versioning v0.2.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var inheritBuildID: Bool {
      get {_storage._inheritBuildID}
      set {_uniqueStorage()._inheritBuildID = newValue}
    }

    /// Experimental. Optionally decide the versioning behavior that the first task of the new run should use.
    /// For example, choose to AutoUpgrade on continue-as-new instead of inheriting the pinned version
    /// of the previous run.
    package var initialVersioningBehavior: Api.Enums.V1.ContinueAsNewVersioningBehavior {
      get {_storage._initialVersioningBehavior}
      set {_uniqueStorage()._initialVersioningBehavior = newValue}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Command.V1 {


  package struct StartChildWorkflowExecutionCommandAttributes: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var namespace: String {
      get {_storage._namespace}
      set {_uniqueStorage()._namespace = newValue}
    }

    package var workflowID: String {
      get {_storage._workflowID}
      set {_uniqueStorage()._workflowID = newValue}
    }

    package var workflowType: Api.Common.V1.WorkflowType {
      get {_storage._workflowType ?? Api.Common.V1.WorkflowType()}
      set {_uniqueStorage()._workflowType = newValue}
    }
    /// Returns true if `workflowType` has been explicitly set.
    package var hasWorkflowType: Bool {_storage._workflowType != nil}
    /// Clears the value of `workflowType`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowType() {_uniqueStorage()._workflowType = nil}

    package var taskQueue: Api.Taskqueue.V1.TaskQueue {
      get {_storage._taskQueue ?? Api.Taskqueue.V1.TaskQueue()}
      set {_uniqueStorage()._taskQueue = newValue}
    }
    /// Returns true if `taskQueue` has been explicitly set.
    package var hasTaskQueue: Bool {_storage._taskQueue != nil}
    /// Clears the value of `taskQueue`. Subsequent reads from it will return its default value.
    package mutating func clearTaskQueue() {_uniqueStorage()._taskQueue = nil}

    package var input: Api.Common.V1.Payloads {
      get {_storage._input ?? Api.Common.V1.Payloads()}
      set {_uniqueStorage()._input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {_storage._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {_uniqueStorage()._input = nil}

    /// Total workflow execution timeout including retries and continue as new.
    package var workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowExecutionTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowExecutionTimeout = newValue}
    }
    /// Returns true if `workflowExecutionTimeout` has been explicitly set.
    package var hasWorkflowExecutionTimeout: Bool {_storage._workflowExecutionTimeout != nil}
    /// Clears the value of `workflowExecutionTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowExecutionTimeout() {_uniqueStorage()._workflowExecutionTimeout = nil}

    /// Timeout of a single workflow run.
    package var workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowRunTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowRunTimeout = newValue}
    }
    /// Returns true if `workflowRunTimeout` has been explicitly set.
    package var hasWorkflowRunTimeout: Bool {_storage._workflowRunTimeout != nil}
    /// Clears the value of `workflowRunTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowRunTimeout() {_uniqueStorage()._workflowRunTimeout = nil}

    /// Timeout of a single workflow task.
    package var workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._workflowTaskTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._workflowTaskTimeout = newValue}
    }
    /// Returns true if `workflowTaskTimeout` has been explicitly set.
    package var hasWorkflowTaskTimeout: Bool {_storage._workflowTaskTimeout != nil}
    /// Clears the value of `workflowTaskTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowTaskTimeout() {_uniqueStorage()._workflowTaskTimeout = nil}

    /// Default: PARENT_CLOSE_POLICY_TERMINATE.
    package var parentClosePolicy: Api.Enums.V1.ParentClosePolicy {
      get {_storage._parentClosePolicy}
      set {_uniqueStorage()._parentClosePolicy = newValue}
    }

    package var control: String {
      get {_storage._control}
      set {_uniqueStorage()._control = newValue}
    }

    /// Default: WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE.
    package var workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy {
      get {_storage._workflowIDReusePolicy}
      set {_uniqueStorage()._workflowIDReusePolicy = newValue}
    }

    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Establish a cron schedule for the child workflow.
    package var cronSchedule: String {
      get {_storage._cronSchedule}
      set {_uniqueStorage()._cronSchedule = newValue}
    }

    package var header: Api.Common.V1.Header {
      get {_storage._header ?? Api.Common.V1.Header()}
      set {_uniqueStorage()._header = newValue}
    }
    /// Returns true if `header` has been explicitly set.
    package var hasHeader: Bool {_storage._header != nil}
    /// Clears the value of `header`. Subsequent reads from it will return its default value.
    package mutating func clearHeader() {_uniqueStorage()._header = nil}

    package var memo: Api.Common.V1.Memo {
      get {_storage._memo ?? Api.Common.V1.Memo()}
      set {_uniqueStorage()._memo = newValue}
    }
    /// Returns true if `memo` has been explicitly set.
    package var hasMemo: Bool {_storage._memo != nil}
    /// Clears the value of `memo`. Subsequent reads from it will return its default value.
    package mutating func clearMemo() {_uniqueStorage()._memo = nil}

    package var searchAttributes: Api.Common.V1.SearchAttributes {
      get {_storage._searchAttributes ?? Api.Common.V1.SearchAttributes()}
      set {_uniqueStorage()._searchAttributes = newValue}
    }
    /// Returns true if `searchAttributes` has been explicitly set.
    package var hasSearchAttributes: Bool {_storage._searchAttributes != nil}
    /// Clears the value of `searchAttributes`. Subsequent reads from it will return its default value.
    package mutating func clearSearchAttributes() {_uniqueStorage()._searchAttributes = nil}

    /// If this is set, the child workflow inherits the Build ID of the parent. Otherwise, the assignment
    /// rules of the child's Task Queue will be used to independently assign a Build ID to it.
    /// Deprecated. Only considered for versioning v0.2.
    ///
    /// NOTE: This field was marked as deprecated in the .proto file.
    package var inheritBuildID: Bool {
      get {_storage._inheritBuildID}
      set {_uniqueStorage()._inheritBuildID = newValue}
    }

    /// Priority metadata. If this message is not present, or any fields are not
    /// present, they inherit the values from the workflow.
    package var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    package var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    package mutating func clearPriority() {_uniqueStorage()._priority = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Api.Command.V1 {


  package struct ProtocolMessageCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The message ID of the message to which this command is a pointer.
    package var messageID: String = String()

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Command.V1 {


  package struct ScheduleNexusOperationCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Endpoint name, must exist in the endpoint registry or this command will fail.
    package var endpoint: String = String()

    /// Service name.
    package var service: String = String()

    /// Operation name.
    package var operation: String = String()

    /// Input for the operation. The server converts this into Nexus request content and the appropriate content headers
    /// internally when sending the StartOperation request. On the handler side, if it is also backed by Temporal, the
    /// content is transformed back to the original Payload sent in this command.
    package var input: Api.Common.V1.Payload {
      get {_input ?? Api.Common.V1.Payload()}
      set {_input = newValue}
    }
    /// Returns true if `input` has been explicitly set.
    package var hasInput: Bool {self._input != nil}
    /// Clears the value of `input`. Subsequent reads from it will return its default value.
    package mutating func clearInput() {self._input = nil}

    /// Schedule-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for operation completion.
    /// Calls are retried internally by the server.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {self._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {self._scheduleToCloseTimeout = nil}

    /// Header to attach to the Nexus request.
    /// Users are responsible for encrypting sensitive data in this header as it is stored in workflow history and
    /// transmitted to external services as-is.
    /// This is useful for propagating tracing information.
    /// Note these headers are not the same as Temporal headers on internal activities and child workflows, these are
    /// transmitted to Nexus operations that may be external and are not traditional payloads.
    package var nexusHeader: Dictionary<String,String> = [:]

    /// Schedule-to-start timeout for this operation.
    /// Indicates how long the caller is willing to wait for the operation to be started (or completed if synchronous)
    /// by the handler. If the operation is not started within this timeout, it will fail with
    /// TIMEOUT_TYPE_SCHEDULE_TO_START.
    /// If not set or zero, no schedule-to-start timeout is enforced.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    /// Requires server version 1.31.0 or later.
    package var scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_scheduleToStartTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_scheduleToStartTimeout = newValue}
    }
    /// Returns true if `scheduleToStartTimeout` has been explicitly set.
    package var hasScheduleToStartTimeout: Bool {self._scheduleToStartTimeout != nil}
    /// Clears the value of `scheduleToStartTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToStartTimeout() {self._scheduleToStartTimeout = nil}

    /// Start-to-close timeout for this operation.
    /// Indicates how long the caller is willing to wait for an asynchronous operation to complete after it has been
    /// started. If the operation does not complete within this timeout after starting, it will fail with
    /// TIMEOUT_TYPE_START_TO_CLOSE.
    /// Only applies to asynchronous operations. Synchronous operations ignore this timeout.
    /// If not set or zero, no start-to-close timeout is enforced.
    /// (-- api-linter: core::0140::prepositions=disabled
    ///     aip.dev/not-precedent: "to" is used to indicate interval. --)
    /// Requires server version 1.31.0 or later.
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {self._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {self._startToCloseTimeout = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _input: Api.Common.V1.Payload? = nil
    fileprivate var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    fileprivate var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
  }
}
extension Api.Command.V1 {


  package struct RequestCancelNexusOperationCommandAttributes: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The `NEXUS_OPERATION_SCHEDULED` event ID (a unique identifier) for the operation to be canceled.
    /// The operation may ignore cancellation and end up with any completion state.
    package var scheduledEventID: Int64 = 0

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}
extension Api.Command.V1 {


  package struct Command: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var commandType: Api.Enums.V1.CommandType {
      get {_storage._commandType}
      set {_uniqueStorage()._commandType = newValue}
    }

    /// Metadata on the command. This is sometimes carried over to the history event if one is
    /// created as a result of the command. Most commands won't have this information, and how this
    /// information is used is dependent upon the interface that reads it.
    ///
    /// Current well-known uses:
    ///  * start_child_workflow_execution_command_attributes - populates
    ///    temporal.api.workflow.v1.WorkflowExecutionInfo.user_metadata where the summary and details
    ///    are used by user interfaces to show fixed as-of-start workflow summary and details.
    ///  * start_timer_command_attributes - populates temporal.api.history.v1.HistoryEvent for timer
    ///    started where the summary is used to identify the timer.
    package var userMetadata: Api.Sdk.V1.UserMetadata {
      get {_storage._userMetadata ?? Api.Sdk.V1.UserMetadata()}
      set {_uniqueStorage()._userMetadata = newValue}
    }
    /// Returns true if `userMetadata` has been explicitly set.
    package var hasUserMetadata: Bool {_storage._userMetadata != nil}
    /// Clears the value of `userMetadata`. Subsequent reads from it will return its default value.
    package mutating func clearUserMetadata() {_uniqueStorage()._userMetadata = nil}

    /// The command details. The type must match that in `command_type`.
    package var attributes: OneOf_Attributes? {
      get {return _storage._attributes}
      set {_uniqueStorage()._attributes = newValue}
    }

    package var scheduleActivityTaskCommandAttributes: Api.Command.V1.ScheduleActivityTaskCommandAttributes {
      get {
        if case .scheduleActivityTaskCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.ScheduleActivityTaskCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .scheduleActivityTaskCommandAttributes(newValue)}
    }

    package var startTimerCommandAttributes: Api.Command.V1.StartTimerCommandAttributes {
      get {
        if case .startTimerCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.StartTimerCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .startTimerCommandAttributes(newValue)}
    }

    package var completeWorkflowExecutionCommandAttributes: Api.Command.V1.CompleteWorkflowExecutionCommandAttributes {
      get {
        if case .completeWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.CompleteWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .completeWorkflowExecutionCommandAttributes(newValue)}
    }

    package var failWorkflowExecutionCommandAttributes: Api.Command.V1.FailWorkflowExecutionCommandAttributes {
      get {
        if case .failWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.FailWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .failWorkflowExecutionCommandAttributes(newValue)}
    }

    package var requestCancelActivityTaskCommandAttributes: Api.Command.V1.RequestCancelActivityTaskCommandAttributes {
      get {
        if case .requestCancelActivityTaskCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.RequestCancelActivityTaskCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .requestCancelActivityTaskCommandAttributes(newValue)}
    }

    package var cancelTimerCommandAttributes: Api.Command.V1.CancelTimerCommandAttributes {
      get {
        if case .cancelTimerCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.CancelTimerCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .cancelTimerCommandAttributes(newValue)}
    }

    package var cancelWorkflowExecutionCommandAttributes: Api.Command.V1.CancelWorkflowExecutionCommandAttributes {
      get {
        if case .cancelWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.CancelWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .cancelWorkflowExecutionCommandAttributes(newValue)}
    }

    package var requestCancelExternalWorkflowExecutionCommandAttributes: Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes {
      get {
        if case .requestCancelExternalWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .requestCancelExternalWorkflowExecutionCommandAttributes(newValue)}
    }

    package var recordMarkerCommandAttributes: Api.Command.V1.RecordMarkerCommandAttributes {
      get {
        if case .recordMarkerCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.RecordMarkerCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .recordMarkerCommandAttributes(newValue)}
    }

    package var continueAsNewWorkflowExecutionCommandAttributes: Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes {
      get {
        if case .continueAsNewWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .continueAsNewWorkflowExecutionCommandAttributes(newValue)}
    }

    package var startChildWorkflowExecutionCommandAttributes: Api.Command.V1.StartChildWorkflowExecutionCommandAttributes {
      get {
        if case .startChildWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.StartChildWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .startChildWorkflowExecutionCommandAttributes(newValue)}
    }

    package var signalExternalWorkflowExecutionCommandAttributes: Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes {
      get {
        if case .signalExternalWorkflowExecutionCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .signalExternalWorkflowExecutionCommandAttributes(newValue)}
    }

    package var upsertWorkflowSearchAttributesCommandAttributes: Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes {
      get {
        if case .upsertWorkflowSearchAttributesCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .upsertWorkflowSearchAttributesCommandAttributes(newValue)}
    }

    package var protocolMessageCommandAttributes: Api.Command.V1.ProtocolMessageCommandAttributes {
      get {
        if case .protocolMessageCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.ProtocolMessageCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .protocolMessageCommandAttributes(newValue)}
    }

    /// 16 is available for use - it was used as part of a prototype that never made it into a release
    package var modifyWorkflowPropertiesCommandAttributes: Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes {
      get {
        if case .modifyWorkflowPropertiesCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .modifyWorkflowPropertiesCommandAttributes(newValue)}
    }

    package var scheduleNexusOperationCommandAttributes: Api.Command.V1.ScheduleNexusOperationCommandAttributes {
      get {
        if case .scheduleNexusOperationCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.ScheduleNexusOperationCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .scheduleNexusOperationCommandAttributes(newValue)}
    }

    package var requestCancelNexusOperationCommandAttributes: Api.Command.V1.RequestCancelNexusOperationCommandAttributes {
      get {
        if case .requestCancelNexusOperationCommandAttributes(let v)? = _storage._attributes {return v}
        return Api.Command.V1.RequestCancelNexusOperationCommandAttributes()
      }
      set {_uniqueStorage()._attributes = .requestCancelNexusOperationCommandAttributes(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    /// The command details. The type must match that in `command_type`.
    package enum OneOf_Attributes: Equatable, Sendable {
      case scheduleActivityTaskCommandAttributes(Api.Command.V1.ScheduleActivityTaskCommandAttributes)
      case startTimerCommandAttributes(Api.Command.V1.StartTimerCommandAttributes)
      case completeWorkflowExecutionCommandAttributes(Api.Command.V1.CompleteWorkflowExecutionCommandAttributes)
      case failWorkflowExecutionCommandAttributes(Api.Command.V1.FailWorkflowExecutionCommandAttributes)
      case requestCancelActivityTaskCommandAttributes(Api.Command.V1.RequestCancelActivityTaskCommandAttributes)
      case cancelTimerCommandAttributes(Api.Command.V1.CancelTimerCommandAttributes)
      case cancelWorkflowExecutionCommandAttributes(Api.Command.V1.CancelWorkflowExecutionCommandAttributes)
      case requestCancelExternalWorkflowExecutionCommandAttributes(Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes)
      case recordMarkerCommandAttributes(Api.Command.V1.RecordMarkerCommandAttributes)
      case continueAsNewWorkflowExecutionCommandAttributes(Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes)
      case startChildWorkflowExecutionCommandAttributes(Api.Command.V1.StartChildWorkflowExecutionCommandAttributes)
      case signalExternalWorkflowExecutionCommandAttributes(Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes)
      case upsertWorkflowSearchAttributesCommandAttributes(Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes)
      case protocolMessageCommandAttributes(Api.Command.V1.ProtocolMessageCommandAttributes)
      /// 16 is available for use - it was used as part of a prototype that never made it into a release
      case modifyWorkflowPropertiesCommandAttributes(Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes)
      case scheduleNexusOperationCommandAttributes(Api.Command.V1.ScheduleNexusOperationCommandAttributes)
      case requestCancelNexusOperationCommandAttributes(Api.Command.V1.RequestCancelNexusOperationCommandAttributes)

    }

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "temporal.api.command.v1"

extension Api.Command.V1.ScheduleActivityTaskCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleActivityTaskCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}activity_id\0\u{3}activity_type\0\u{4}\u{2}task_queue\0\u{1}header\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}request_eager_execution\0\u{3}use_workflow_build_id\0\u{1}priority\0\u{c}\u{3}\u{1}")

  fileprivate class _StorageClass {
    var _activityID: String = String()
    var _activityType: Api.Common.V1.ActivityType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _header: Api.Common.V1.Header? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _scheduleToStartTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _requestEagerExecution: Bool = false
    var _useWorkflowBuildID: Bool = false
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _activityID = source._activityID
      _activityType = source._activityType
      _taskQueue = source._taskQueue
      _header = source._header
      _input = source._input
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _scheduleToStartTimeout = source._scheduleToStartTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _requestEagerExecution = source._requestEagerExecution
      _useWorkflowBuildID = source._useWorkflowBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._activityType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToStartTimeout) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._requestEagerExecution) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._useWorkflowBuildID) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 1)
      }
      try { if let v = _storage._activityType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._scheduleToStartTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._requestEagerExecution != false {
        try visitor.visitSingularBoolField(value: _storage._requestEagerExecution, fieldNumber: 12)
      }
      if _storage._useWorkflowBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._useWorkflowBuildID, fieldNumber: 13)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.ScheduleActivityTaskCommandAttributes, rhs: Api.Command.V1.ScheduleActivityTaskCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._scheduleToStartTimeout != rhs_storage._scheduleToStartTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._requestEagerExecution != rhs_storage._requestEagerExecution {return false}
        if _storage._useWorkflowBuildID != rhs_storage._useWorkflowBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.RequestCancelActivityTaskCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelActivityTaskCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.RequestCancelActivityTaskCommandAttributes, rhs: Api.Command.V1.RequestCancelActivityTaskCommandAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.StartTimerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartTimerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0\u{3}start_to_fire_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._startToFireTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    try { if let v = self._startToFireTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.StartTimerCommandAttributes, rhs: Api.Command.V1.StartTimerCommandAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs._startToFireTimeout != rhs._startToFireTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.CompleteWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CompleteWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}result\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._result) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._result {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.CompleteWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.CompleteWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._result != rhs._result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.FailWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".FailWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.FailWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.FailWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.CancelTimerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelTimerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}timer_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.timerID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.timerID.isEmpty {
      try visitor.visitSingularStringField(value: self.timerID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.CancelTimerCommandAttributes, rhs: Api.Command.V1.CancelTimerCommandAttributes) -> Bool {
    if lhs.timerID != rhs.timerID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.CancelWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".CancelWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.CancelWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.CancelWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelExternalWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}run_id\0\u{1}control\0\u{3}child_workflow_only\0\u{1}reason\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.workflowID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.runID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    if !self.workflowID.isEmpty {
      try visitor.visitSingularStringField(value: self.workflowID, fieldNumber: 2)
    }
    if !self.runID.isEmpty {
      try visitor.visitSingularStringField(value: self.runID, fieldNumber: 3)
    }
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 4)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 5)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs.workflowID != rhs.workflowID {return false}
    if lhs.runID != rhs.runID {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".SignalExternalWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{1}execution\0\u{3}signal_name\0\u{1}input\0\u{1}control\0\u{3}child_workflow_only\0\u{1}header\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.namespace) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._execution) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.signalName) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.control) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.childWorkflowOnly) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.namespace.isEmpty {
      try visitor.visitSingularStringField(value: self.namespace, fieldNumber: 1)
    }
    try { if let v = self._execution {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.signalName.isEmpty {
      try visitor.visitSingularStringField(value: self.signalName, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.control.isEmpty {
      try visitor.visitSingularStringField(value: self.control, fieldNumber: 5)
    }
    if self.childWorkflowOnly != false {
      try visitor.visitSingularBoolField(value: self.childWorkflowOnly, fieldNumber: 6)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes) -> Bool {
    if lhs.namespace != rhs.namespace {return false}
    if lhs._execution != rhs._execution {return false}
    if lhs.signalName != rhs.signalName {return false}
    if lhs._input != rhs._input {return false}
    if lhs.control != rhs.control {return false}
    if lhs.childWorkflowOnly != rhs.childWorkflowOnly {return false}
    if lhs._header != rhs._header {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".UpsertWorkflowSearchAttributesCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}search_attributes\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._searchAttributes) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._searchAttributes {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes, rhs: Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes) -> Bool {
    if lhs._searchAttributes != rhs._searchAttributes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ModifyWorkflowPropertiesCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}upserted_memo\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._upsertedMemo) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upsertedMemo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes, rhs: Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes) -> Bool {
    if lhs._upsertedMemo != rhs._upsertedMemo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.RecordMarkerCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RecordMarkerCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}marker_name\0\u{1}details\0\u{1}header\0\u{1}failure\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.markerName) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payloads>.self, value: &self.details) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.markerName.isEmpty {
      try visitor.visitSingularStringField(value: self.markerName, fieldNumber: 1)
    }
    if !self.details.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payloads>.self, value: self.details, fieldNumber: 2)
    }
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.RecordMarkerCommandAttributes, rhs: Api.Command.V1.RecordMarkerCommandAttributes) -> Bool {
    if lhs.markerName != rhs.markerName {return false}
    if lhs.details != rhs.details {return false}
    if lhs._header != rhs._header {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ContinueAsNewWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}backoff_start_interval\0\u{3}retry_policy\0\u{1}initiator\0\u{1}failure\0\u{3}last_completion_result\0\u{3}cron_schedule\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}inherit_build_id\0\u{3}initial_versioning_behavior\0")

  fileprivate class _StorageClass {
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _backoffStartInterval: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _initiator: Api.Enums.V1.ContinueAsNewInitiator = .unspecified
    var _failure: Api.Failure.V1.Failure? = nil
    var _lastCompletionResult: Api.Common.V1.Payloads? = nil
    var _cronSchedule: String = String()
    var _header: Api.Common.V1.Header? = nil
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _inheritBuildID: Bool = false
    var _initialVersioningBehavior: Api.Enums.V1.ContinueAsNewVersioningBehavior = .unspecified

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _backoffStartInterval = source._backoffStartInterval
      _retryPolicy = source._retryPolicy
      _initiator = source._initiator
      _failure = source._failure
      _lastCompletionResult = source._lastCompletionResult
      _cronSchedule = source._cronSchedule
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
      _initialVersioningBehavior = source._initialVersioningBehavior
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._backoffStartInterval) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._initiator) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._failure) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._lastCompletionResult) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._initialVersioningBehavior) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._backoffStartInterval {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._initiator != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initiator, fieldNumber: 8)
      }
      try { if let v = _storage._failure {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._lastCompletionResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 11)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 15)
      }
      if _storage._initialVersioningBehavior != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._initialVersioningBehavior, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._backoffStartInterval != rhs_storage._backoffStartInterval {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._initiator != rhs_storage._initiator {return false}
        if _storage._failure != rhs_storage._failure {return false}
        if _storage._lastCompletionResult != rhs_storage._lastCompletionResult {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        if _storage._initialVersioningBehavior != rhs_storage._initialVersioningBehavior {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.StartChildWorkflowExecutionCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".StartChildWorkflowExecutionCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}namespace\0\u{3}workflow_id\0\u{3}workflow_type\0\u{3}task_queue\0\u{1}input\0\u{3}workflow_execution_timeout\0\u{3}workflow_run_timeout\0\u{3}workflow_task_timeout\0\u{3}parent_close_policy\0\u{1}control\0\u{3}workflow_id_reuse_policy\0\u{3}retry_policy\0\u{3}cron_schedule\0\u{1}header\0\u{1}memo\0\u{3}search_attributes\0\u{3}inherit_build_id\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _namespace: String = String()
    var _workflowID: String = String()
    var _workflowType: Api.Common.V1.WorkflowType? = nil
    var _taskQueue: Api.Taskqueue.V1.TaskQueue? = nil
    var _input: Api.Common.V1.Payloads? = nil
    var _workflowExecutionTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowRunTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _workflowTaskTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _parentClosePolicy: Api.Enums.V1.ParentClosePolicy = .unspecified
    var _control: String = String()
    var _workflowIDReusePolicy: Api.Enums.V1.WorkflowIdReusePolicy = .unspecified
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _cronSchedule: String = String()
    var _header: Api.Common.V1.Header? = nil
    var _memo: Api.Common.V1.Memo? = nil
    var _searchAttributes: Api.Common.V1.SearchAttributes? = nil
    var _inheritBuildID: Bool = false
    var _priority: Api.Common.V1.Priority? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _namespace = source._namespace
      _workflowID = source._workflowID
      _workflowType = source._workflowType
      _taskQueue = source._taskQueue
      _input = source._input
      _workflowExecutionTimeout = source._workflowExecutionTimeout
      _workflowRunTimeout = source._workflowRunTimeout
      _workflowTaskTimeout = source._workflowTaskTimeout
      _parentClosePolicy = source._parentClosePolicy
      _control = source._control
      _workflowIDReusePolicy = source._workflowIDReusePolicy
      _retryPolicy = source._retryPolicy
      _cronSchedule = source._cronSchedule
      _header = source._header
      _memo = source._memo
      _searchAttributes = source._searchAttributes
      _inheritBuildID = source._inheritBuildID
      _priority = source._priority
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._namespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taskQueue) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecutionTimeout) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._workflowRunTimeout) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._workflowTaskTimeout) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._parentClosePolicy) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._control) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._workflowIDReusePolicy) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._cronSchedule) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._header) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._memo) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._searchAttributes) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._inheritBuildID) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._namespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._namespace, fieldNumber: 1)
      }
      if !_storage._workflowID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowID, fieldNumber: 2)
      }
      try { if let v = _storage._workflowType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taskQueue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._workflowExecutionTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._workflowRunTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._workflowTaskTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if _storage._parentClosePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._parentClosePolicy, fieldNumber: 9)
      }
      if !_storage._control.isEmpty {
        try visitor.visitSingularStringField(value: _storage._control, fieldNumber: 10)
      }
      if _storage._workflowIDReusePolicy != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._workflowIDReusePolicy, fieldNumber: 11)
      }
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      if !_storage._cronSchedule.isEmpty {
        try visitor.visitSingularStringField(value: _storage._cronSchedule, fieldNumber: 13)
      }
      try { if let v = _storage._header {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._memo {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._searchAttributes {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._inheritBuildID != false {
        try visitor.visitSingularBoolField(value: _storage._inheritBuildID, fieldNumber: 17)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.StartChildWorkflowExecutionCommandAttributes, rhs: Api.Command.V1.StartChildWorkflowExecutionCommandAttributes) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._namespace != rhs_storage._namespace {return false}
        if _storage._workflowID != rhs_storage._workflowID {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._taskQueue != rhs_storage._taskQueue {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._workflowExecutionTimeout != rhs_storage._workflowExecutionTimeout {return false}
        if _storage._workflowRunTimeout != rhs_storage._workflowRunTimeout {return false}
        if _storage._workflowTaskTimeout != rhs_storage._workflowTaskTimeout {return false}
        if _storage._parentClosePolicy != rhs_storage._parentClosePolicy {return false}
        if _storage._control != rhs_storage._control {return false}
        if _storage._workflowIDReusePolicy != rhs_storage._workflowIDReusePolicy {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._cronSchedule != rhs_storage._cronSchedule {return false}
        if _storage._header != rhs_storage._header {return false}
        if _storage._memo != rhs_storage._memo {return false}
        if _storage._searchAttributes != rhs_storage._searchAttributes {return false}
        if _storage._inheritBuildID != rhs_storage._inheritBuildID {return false}
        if _storage._priority != rhs_storage._priority {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.ProtocolMessageCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ProtocolMessageCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.ProtocolMessageCommandAttributes, rhs: Api.Command.V1.ProtocolMessageCommandAttributes) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.ScheduleNexusOperationCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ScheduleNexusOperationCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}endpoint\0\u{1}service\0\u{1}operation\0\u{1}input\0\u{3}schedule_to_close_timeout\0\u{3}nexus_header\0\u{3}schedule_to_start_timeout\0\u{3}start_to_close_timeout\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.endpoint) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.service) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.operation) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._input) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._scheduleToCloseTimeout) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.nexusHeader) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._scheduleToStartTimeout) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._startToCloseTimeout) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.endpoint.isEmpty {
      try visitor.visitSingularStringField(value: self.endpoint, fieldNumber: 1)
    }
    if !self.service.isEmpty {
      try visitor.visitSingularStringField(value: self.service, fieldNumber: 2)
    }
    if !self.operation.isEmpty {
      try visitor.visitSingularStringField(value: self.operation, fieldNumber: 3)
    }
    try { if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._scheduleToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.nexusHeader.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.nexusHeader, fieldNumber: 6)
    }
    try { if let v = self._scheduleToStartTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._startToCloseTimeout {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.ScheduleNexusOperationCommandAttributes, rhs: Api.Command.V1.ScheduleNexusOperationCommandAttributes) -> Bool {
    if lhs.endpoint != rhs.endpoint {return false}
    if lhs.service != rhs.service {return false}
    if lhs.operation != rhs.operation {return false}
    if lhs._input != rhs._input {return false}
    if lhs._scheduleToCloseTimeout != rhs._scheduleToCloseTimeout {return false}
    if lhs.nexusHeader != rhs.nexusHeader {return false}
    if lhs._scheduleToStartTimeout != rhs._scheduleToStartTimeout {return false}
    if lhs._startToCloseTimeout != rhs._startToCloseTimeout {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.RequestCancelNexusOperationCommandAttributes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".RequestCancelNexusOperationCommandAttributes"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}scheduled_event_id\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.scheduledEventID) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scheduledEventID != 0 {
      try visitor.visitSingularInt64Field(value: self.scheduledEventID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.RequestCancelNexusOperationCommandAttributes, rhs: Api.Command.V1.RequestCancelNexusOperationCommandAttributes) -> Bool {
    if lhs.scheduledEventID != rhs.scheduledEventID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api.Command.V1.Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Command"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}command_type\0\u{3}schedule_activity_task_command_attributes\0\u{3}start_timer_command_attributes\0\u{3}complete_workflow_execution_command_attributes\0\u{3}fail_workflow_execution_command_attributes\0\u{3}request_cancel_activity_task_command_attributes\0\u{3}cancel_timer_command_attributes\0\u{3}cancel_workflow_execution_command_attributes\0\u{3}request_cancel_external_workflow_execution_command_attributes\0\u{3}record_marker_command_attributes\0\u{3}continue_as_new_workflow_execution_command_attributes\0\u{3}start_child_workflow_execution_command_attributes\0\u{3}signal_external_workflow_execution_command_attributes\0\u{3}upsert_workflow_search_attributes_command_attributes\0\u{3}protocol_message_command_attributes\0\u{4}\u{2}modify_workflow_properties_command_attributes\0\u{3}schedule_nexus_operation_command_attributes\0\u{3}request_cancel_nexus_operation_command_attributes\0\u{4}Z\u{4}user_metadata\0")

  fileprivate class _StorageClass {
    var _commandType: Api.Enums.V1.CommandType = .unspecified
    var _userMetadata: Api.Sdk.V1.UserMetadata? = nil
    var _attributes: Api.Command.V1.Command.OneOf_Attributes?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _commandType = source._commandType
      _userMetadata = source._userMetadata
      _attributes = source._attributes
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._commandType) }()
        case 2: try {
          var v: Api.Command.V1.ScheduleActivityTaskCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .scheduleActivityTaskCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .scheduleActivityTaskCommandAttributes(v)
          }
        }()
        case 3: try {
          var v: Api.Command.V1.StartTimerCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .startTimerCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .startTimerCommandAttributes(v)
          }
        }()
        case 4: try {
          var v: Api.Command.V1.CompleteWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .completeWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .completeWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 5: try {
          var v: Api.Command.V1.FailWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .failWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .failWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 6: try {
          var v: Api.Command.V1.RequestCancelActivityTaskCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .requestCancelActivityTaskCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .requestCancelActivityTaskCommandAttributes(v)
          }
        }()
        case 7: try {
          var v: Api.Command.V1.CancelTimerCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .cancelTimerCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .cancelTimerCommandAttributes(v)
          }
        }()
        case 8: try {
          var v: Api.Command.V1.CancelWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .cancelWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .cancelWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 9: try {
          var v: Api.Command.V1.RequestCancelExternalWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .requestCancelExternalWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .requestCancelExternalWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 10: try {
          var v: Api.Command.V1.RecordMarkerCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .recordMarkerCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .recordMarkerCommandAttributes(v)
          }
        }()
        case 11: try {
          var v: Api.Command.V1.ContinueAsNewWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .continueAsNewWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .continueAsNewWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 12: try {
          var v: Api.Command.V1.StartChildWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .startChildWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .startChildWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 13: try {
          var v: Api.Command.V1.SignalExternalWorkflowExecutionCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .signalExternalWorkflowExecutionCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .signalExternalWorkflowExecutionCommandAttributes(v)
          }
        }()
        case 14: try {
          var v: Api.Command.V1.UpsertWorkflowSearchAttributesCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .upsertWorkflowSearchAttributesCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .upsertWorkflowSearchAttributesCommandAttributes(v)
          }
        }()
        case 15: try {
          var v: Api.Command.V1.ProtocolMessageCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .protocolMessageCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .protocolMessageCommandAttributes(v)
          }
        }()
        case 17: try {
          var v: Api.Command.V1.ModifyWorkflowPropertiesCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .modifyWorkflowPropertiesCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .modifyWorkflowPropertiesCommandAttributes(v)
          }
        }()
        case 18: try {
          var v: Api.Command.V1.ScheduleNexusOperationCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .scheduleNexusOperationCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .scheduleNexusOperationCommandAttributes(v)
          }
        }()
        case 19: try {
          var v: Api.Command.V1.RequestCancelNexusOperationCommandAttributes?
          var hadOneofValue = false
          if let current = _storage._attributes {
            hadOneofValue = true
            if case .requestCancelNexusOperationCommandAttributes(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._attributes = .requestCancelNexusOperationCommandAttributes(v)
          }
        }()
        case 301: try { try decoder.decodeSingularMessageField(value: &_storage._userMetadata) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._commandType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._commandType, fieldNumber: 1)
      }
      switch _storage._attributes {
      case .scheduleActivityTaskCommandAttributes?: try {
        guard case .scheduleActivityTaskCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }()
      case .startTimerCommandAttributes?: try {
        guard case .startTimerCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }()
      case .completeWorkflowExecutionCommandAttributes?: try {
        guard case .completeWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .failWorkflowExecutionCommandAttributes?: try {
        guard case .failWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .requestCancelActivityTaskCommandAttributes?: try {
        guard case .requestCancelActivityTaskCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .cancelTimerCommandAttributes?: try {
        guard case .cancelTimerCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .cancelWorkflowExecutionCommandAttributes?: try {
        guard case .cancelWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .requestCancelExternalWorkflowExecutionCommandAttributes?: try {
        guard case .requestCancelExternalWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .recordMarkerCommandAttributes?: try {
        guard case .recordMarkerCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .continueAsNewWorkflowExecutionCommandAttributes?: try {
        guard case .continueAsNewWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .startChildWorkflowExecutionCommandAttributes?: try {
        guard case .startChildWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .signalExternalWorkflowExecutionCommandAttributes?: try {
        guard case .signalExternalWorkflowExecutionCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .upsertWorkflowSearchAttributesCommandAttributes?: try {
        guard case .upsertWorkflowSearchAttributesCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .protocolMessageCommandAttributes?: try {
        guard case .protocolMessageCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .modifyWorkflowPropertiesCommandAttributes?: try {
        guard case .modifyWorkflowPropertiesCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .scheduleNexusOperationCommandAttributes?: try {
        guard case .scheduleNexusOperationCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .requestCancelNexusOperationCommandAttributes?: try {
        guard case .requestCancelNexusOperationCommandAttributes(let v)? = _storage._attributes else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case nil: break
      }
      try { if let v = _storage._userMetadata {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 301)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Api.Command.V1.Command, rhs: Api.Command.V1.Command) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._commandType != rhs_storage._commandType {return false}
        if _storage._userMetadata != rhs_storage._userMetadata {return false}
        if _storage._attributes != rhs_storage._attributes {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
