// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: temporal/sdk/core/activity_task/activity_task.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

package import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}
extension Coresdk.ActivityTask {


  package enum ActivityCancelReason: SwiftProtobuf.Enum, Swift.CaseIterable {
    package typealias RawValue = Int

    /// The activity no longer exists according to server (may be already completed)
    case notFound // = 0

    /// Activity was explicitly cancelled
    case cancelled // = 1

    /// Activity timed out
    case timedOut // = 2

    /// Core is shutting down and the graceful timeout has elapsed
    case workerShutdown // = 3

    /// Activity was paused
    case paused // = 4

    /// Activity was reset
    case reset // = 5
    case UNRECOGNIZED(Int)

    package init() {
      self = .notFound
    }

    package init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notFound
      case 1: self = .cancelled
      case 2: self = .timedOut
      case 3: self = .workerShutdown
      case 4: self = .paused
      case 5: self = .reset
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    package var rawValue: Int {
      switch self {
      case .notFound: return 0
      case .cancelled: return 1
      case .timedOut: return 2
      case .workerShutdown: return 3
      case .paused: return 4
      case .reset: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    package static let allCases: [Coresdk.ActivityTask.ActivityCancelReason] = [
      .notFound,
      .cancelled,
      .timedOut,
      .workerShutdown,
      .paused,
      .reset,
    ]

  }
}
extension Coresdk.ActivityTask {


  package struct ActivityTask: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// A unique identifier for this task
    package var taskToken: Data = Data()

    package var variant: Coresdk.ActivityTask.ActivityTask.OneOf_Variant? = nil

    /// Start activity execution.
    package var start: Coresdk.ActivityTask.Start {
      get {
        if case .start(let v)? = variant {return v}
        return Coresdk.ActivityTask.Start()
      }
      set {variant = .start(newValue)}
    }

    /// Attempt to cancel activity execution.
    package var cancel: Coresdk.ActivityTask.Cancel {
      get {
        if case .cancel(let v)? = variant {return v}
        return Coresdk.ActivityTask.Cancel()
      }
      set {variant = .cancel(newValue)}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package enum OneOf_Variant: Equatable, Sendable {
      /// Start activity execution.
      case start(Coresdk.ActivityTask.Start)
      /// Attempt to cancel activity execution.
      case cancel(Coresdk.ActivityTask.Cancel)

    }

    package init() {}
  }
}
extension Coresdk.ActivityTask {


  /// Begin executing an activity
  package struct Start: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// The namespace the workflow lives in
    package var workflowNamespace: String {
      get {_storage._workflowNamespace}
      set {_uniqueStorage()._workflowNamespace = newValue}
    }

    /// The workflow's type name or function identifier
    package var workflowType: String {
      get {_storage._workflowType}
      set {_uniqueStorage()._workflowType = newValue}
    }

    /// The workflow execution which requested this activity
    package var workflowExecution: Api.Common.V1.WorkflowExecution {
      get {_storage._workflowExecution ?? Api.Common.V1.WorkflowExecution()}
      set {_uniqueStorage()._workflowExecution = newValue}
    }
    /// Returns true if `workflowExecution` has been explicitly set.
    package var hasWorkflowExecution: Bool {_storage._workflowExecution != nil}
    /// Clears the value of `workflowExecution`. Subsequent reads from it will return its default value.
    package mutating func clearWorkflowExecution() {_uniqueStorage()._workflowExecution = nil}

    /// The activity's ID
    package var activityID: String {
      get {_storage._activityID}
      set {_uniqueStorage()._activityID = newValue}
    }

    /// The activity's type name or function identifier
    package var activityType: String {
      get {_storage._activityType}
      set {_uniqueStorage()._activityType = newValue}
    }

    package var headerFields: Dictionary<String,Api.Common.V1.Payload> {
      get {_storage._headerFields}
      set {_uniqueStorage()._headerFields = newValue}
    }

    /// Arguments to the activity
    package var input: [Api.Common.V1.Payload] {
      get {_storage._input}
      set {_uniqueStorage()._input = newValue}
    }

    /// The last details that were recorded by a heartbeat when this task was generated
    package var heartbeatDetails: [Api.Common.V1.Payload] {
      get {_storage._heartbeatDetails}
      set {_uniqueStorage()._heartbeatDetails = newValue}
    }

    /// When the task was *first* scheduled
    package var scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._scheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._scheduledTime = newValue}
    }
    /// Returns true if `scheduledTime` has been explicitly set.
    package var hasScheduledTime: Bool {_storage._scheduledTime != nil}
    /// Clears the value of `scheduledTime`. Subsequent reads from it will return its default value.
    package mutating func clearScheduledTime() {_uniqueStorage()._scheduledTime = nil}

    /// When this current attempt at the task was scheduled
    package var currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._currentAttemptScheduledTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._currentAttemptScheduledTime = newValue}
    }
    /// Returns true if `currentAttemptScheduledTime` has been explicitly set.
    package var hasCurrentAttemptScheduledTime: Bool {_storage._currentAttemptScheduledTime != nil}
    /// Clears the value of `currentAttemptScheduledTime`. Subsequent reads from it will return its default value.
    package mutating func clearCurrentAttemptScheduledTime() {_uniqueStorage()._currentAttemptScheduledTime = nil}

    /// When this attempt was started, which is to say when core received it by polling.
    package var startedTime: SwiftProtobuf.Google_Protobuf_Timestamp {
      get {_storage._startedTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
      set {_uniqueStorage()._startedTime = newValue}
    }
    /// Returns true if `startedTime` has been explicitly set.
    package var hasStartedTime: Bool {_storage._startedTime != nil}
    /// Clears the value of `startedTime`. Subsequent reads from it will return its default value.
    package mutating func clearStartedTime() {_uniqueStorage()._startedTime = nil}

    package var attempt: UInt32 {
      get {_storage._attempt}
      set {_uniqueStorage()._attempt = newValue}
    }

    /// Timeout from the first schedule time to completion
    package var scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._scheduleToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._scheduleToCloseTimeout = newValue}
    }
    /// Returns true if `scheduleToCloseTimeout` has been explicitly set.
    package var hasScheduleToCloseTimeout: Bool {_storage._scheduleToCloseTimeout != nil}
    /// Clears the value of `scheduleToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearScheduleToCloseTimeout() {_uniqueStorage()._scheduleToCloseTimeout = nil}

    /// Timeout from starting an attempt to reporting its result
    package var startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._startToCloseTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._startToCloseTimeout = newValue}
    }
    /// Returns true if `startToCloseTimeout` has been explicitly set.
    package var hasStartToCloseTimeout: Bool {_storage._startToCloseTimeout != nil}
    /// Clears the value of `startToCloseTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearStartToCloseTimeout() {_uniqueStorage()._startToCloseTimeout = nil}

    /// If set a heartbeat must be reported within this interval
    package var heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration {
      get {_storage._heartbeatTimeout ?? SwiftProtobuf.Google_Protobuf_Duration()}
      set {_uniqueStorage()._heartbeatTimeout = newValue}
    }
    /// Returns true if `heartbeatTimeout` has been explicitly set.
    package var hasHeartbeatTimeout: Bool {_storage._heartbeatTimeout != nil}
    /// Clears the value of `heartbeatTimeout`. Subsequent reads from it will return its default value.
    package mutating func clearHeartbeatTimeout() {_uniqueStorage()._heartbeatTimeout = nil}

    /// This is an actual retry policy the service uses. It can be different from the one provided
    /// (or not) during activity scheduling as the service can override the provided one in case its
    /// values are not specified or exceed configured system limits.
    package var retryPolicy: Api.Common.V1.RetryPolicy {
      get {_storage._retryPolicy ?? Api.Common.V1.RetryPolicy()}
      set {_uniqueStorage()._retryPolicy = newValue}
    }
    /// Returns true if `retryPolicy` has been explicitly set.
    package var hasRetryPolicy: Bool {_storage._retryPolicy != nil}
    /// Clears the value of `retryPolicy`. Subsequent reads from it will return its default value.
    package mutating func clearRetryPolicy() {_uniqueStorage()._retryPolicy = nil}

    /// Priority of this activity. Local activities will always have this field set to the default.
    package var priority: Api.Common.V1.Priority {
      get {_storage._priority ?? Api.Common.V1.Priority()}
      set {_uniqueStorage()._priority = newValue}
    }
    /// Returns true if `priority` has been explicitly set.
    package var hasPriority: Bool {_storage._priority != nil}
    /// Clears the value of `priority`. Subsequent reads from it will return its default value.
    package mutating func clearPriority() {_uniqueStorage()._priority = nil}

    /// Set to true if this is a local activity. Note that heartbeating does not apply to local
    /// activities.
    package var isLocal: Bool {
      get {_storage._isLocal}
      set {_uniqueStorage()._isLocal = newValue}
    }

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }
}
extension Coresdk.ActivityTask {


  /// Attempt to cancel a running activity
  package struct Cancel: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Primary cancellation reason
    package var reason: Coresdk.ActivityTask.ActivityCancelReason = .notFound

    /// Activity cancellation details, surfaces all cancellation reasons.
    package var details: Coresdk.ActivityTask.ActivityCancellationDetails {
      get {_details ?? Coresdk.ActivityTask.ActivityCancellationDetails()}
      set {_details = newValue}
    }
    /// Returns true if `details` has been explicitly set.
    package var hasDetails: Bool {self._details != nil}
    /// Clears the value of `details`. Subsequent reads from it will return its default value.
    package mutating func clearDetails() {self._details = nil}

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}

    fileprivate var _details: Coresdk.ActivityTask.ActivityCancellationDetails? = nil
  }
}
extension Coresdk.ActivityTask {


  package struct ActivityCancellationDetails: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    package var isNotFound: Bool = false

    package var isCancelled: Bool = false

    package var isPaused: Bool = false

    package var isTimedOut: Bool = false

    package var isWorkerShutdown: Bool = false

    package var isReset: Bool = false

    package var unknownFields = SwiftProtobuf.UnknownStorage()

    package init() {}
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "coresdk.activity_task"

extension Coresdk.ActivityTask.ActivityCancelReason: SwiftProtobuf._ProtoNameProviding {
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NOT_FOUND\0\u{1}CANCELLED\0\u{1}TIMED_OUT\0\u{1}WORKER_SHUTDOWN\0\u{1}PAUSED\0\u{1}RESET\0")
}

extension Coresdk.ActivityTask.ActivityTask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityTask"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}task_token\0\u{2}\u{2}start\0\u{1}cancel\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.taskToken) }()
      case 3: try {
        var v: Coresdk.ActivityTask.Start?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .start(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .start(v)
        }
      }()
      case 4: try {
        var v: Coresdk.ActivityTask.Cancel?
        var hadOneofValue = false
        if let current = self.variant {
          hadOneofValue = true
          if case .cancel(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.variant = .cancel(v)
        }
      }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.taskToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.taskToken, fieldNumber: 1)
    }
    switch self.variant {
    case .start?: try {
      guard case .start(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .cancel?: try {
      guard case .cancel(let v)? = self.variant else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityTask.ActivityTask, rhs: Coresdk.ActivityTask.ActivityTask) -> Bool {
    if lhs.taskToken != rhs.taskToken {return false}
    if lhs.variant != rhs.variant {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityTask.Start: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Start"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}workflow_namespace\0\u{3}workflow_type\0\u{3}workflow_execution\0\u{3}activity_id\0\u{3}activity_type\0\u{3}header_fields\0\u{1}input\0\u{3}heartbeat_details\0\u{3}scheduled_time\0\u{3}current_attempt_scheduled_time\0\u{3}started_time\0\u{1}attempt\0\u{3}schedule_to_close_timeout\0\u{3}start_to_close_timeout\0\u{3}heartbeat_timeout\0\u{3}retry_policy\0\u{3}is_local\0\u{1}priority\0")

  fileprivate class _StorageClass {
    var _workflowNamespace: String = String()
    var _workflowType: String = String()
    var _workflowExecution: Api.Common.V1.WorkflowExecution? = nil
    var _activityID: String = String()
    var _activityType: String = String()
    var _headerFields: Dictionary<String,Api.Common.V1.Payload> = [:]
    var _input: [Api.Common.V1.Payload] = []
    var _heartbeatDetails: [Api.Common.V1.Payload] = []
    var _scheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _currentAttemptScheduledTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _startedTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _attempt: UInt32 = 0
    var _scheduleToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _startToCloseTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _heartbeatTimeout: SwiftProtobuf.Google_Protobuf_Duration? = nil
    var _retryPolicy: Api.Common.V1.RetryPolicy? = nil
    var _priority: Api.Common.V1.Priority? = nil
    var _isLocal: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _workflowNamespace = source._workflowNamespace
      _workflowType = source._workflowType
      _workflowExecution = source._workflowExecution
      _activityID = source._activityID
      _activityType = source._activityType
      _headerFields = source._headerFields
      _input = source._input
      _heartbeatDetails = source._heartbeatDetails
      _scheduledTime = source._scheduledTime
      _currentAttemptScheduledTime = source._currentAttemptScheduledTime
      _startedTime = source._startedTime
      _attempt = source._attempt
      _scheduleToCloseTimeout = source._scheduleToCloseTimeout
      _startToCloseTimeout = source._startToCloseTimeout
      _heartbeatTimeout = source._heartbeatTimeout
      _retryPolicy = source._retryPolicy
      _priority = source._priority
      _isLocal = source._isLocal
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._workflowNamespace) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._workflowType) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._workflowExecution) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._activityID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._activityType) }()
        case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: &_storage._headerFields) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._input) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._heartbeatDetails) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._scheduledTime) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._currentAttemptScheduledTime) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._startedTime) }()
        case 12: try { try decoder.decodeSingularUInt32Field(value: &_storage._attempt) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._scheduleToCloseTimeout) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._startToCloseTimeout) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeatTimeout) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._retryPolicy) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isLocal) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._priority) }()
        default: break
        }
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._workflowNamespace.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowNamespace, fieldNumber: 1)
      }
      if !_storage._workflowType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._workflowType, fieldNumber: 2)
      }
      try { if let v = _storage._workflowExecution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._activityID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityID, fieldNumber: 4)
      }
      if !_storage._activityType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._activityType, fieldNumber: 5)
      }
      if !_storage._headerFields.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Api.Common.V1.Payload>.self, value: _storage._headerFields, fieldNumber: 6)
      }
      if !_storage._input.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._input, fieldNumber: 7)
      }
      if !_storage._heartbeatDetails.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._heartbeatDetails, fieldNumber: 8)
      }
      try { if let v = _storage._scheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._currentAttemptScheduledTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._startedTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if _storage._attempt != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._attempt, fieldNumber: 12)
      }
      try { if let v = _storage._scheduleToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._startToCloseTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._heartbeatTimeout {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._retryPolicy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._isLocal != false {
        try visitor.visitSingularBoolField(value: _storage._isLocal, fieldNumber: 17)
      }
      try { if let v = _storage._priority {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityTask.Start, rhs: Coresdk.ActivityTask.Start) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._workflowNamespace != rhs_storage._workflowNamespace {return false}
        if _storage._workflowType != rhs_storage._workflowType {return false}
        if _storage._workflowExecution != rhs_storage._workflowExecution {return false}
        if _storage._activityID != rhs_storage._activityID {return false}
        if _storage._activityType != rhs_storage._activityType {return false}
        if _storage._headerFields != rhs_storage._headerFields {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._heartbeatDetails != rhs_storage._heartbeatDetails {return false}
        if _storage._scheduledTime != rhs_storage._scheduledTime {return false}
        if _storage._currentAttemptScheduledTime != rhs_storage._currentAttemptScheduledTime {return false}
        if _storage._startedTime != rhs_storage._startedTime {return false}
        if _storage._attempt != rhs_storage._attempt {return false}
        if _storage._scheduleToCloseTimeout != rhs_storage._scheduleToCloseTimeout {return false}
        if _storage._startToCloseTimeout != rhs_storage._startToCloseTimeout {return false}
        if _storage._heartbeatTimeout != rhs_storage._heartbeatTimeout {return false}
        if _storage._retryPolicy != rhs_storage._retryPolicy {return false}
        if _storage._priority != rhs_storage._priority {return false}
        if _storage._isLocal != rhs_storage._isLocal {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityTask.Cancel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".Cancel"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reason\0\u{1}details\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reason) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._details) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.reason != .notFound {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try { if let v = self._details {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityTask.Cancel, rhs: Coresdk.ActivityTask.Cancel) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs._details != rhs._details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coresdk.ActivityTask.ActivityCancellationDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  package static let protoMessageName: String = _protobuf_package + ".ActivityCancellationDetails"
  package static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}is_not_found\0\u{3}is_cancelled\0\u{3}is_paused\0\u{3}is_timed_out\0\u{3}is_worker_shutdown\0\u{3}is_reset\0")

  package mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isNotFound) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isCancelled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isPaused) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.isTimedOut) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.isWorkerShutdown) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isReset) }()
      default: break
      }
    }
  }

  package func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isNotFound != false {
      try visitor.visitSingularBoolField(value: self.isNotFound, fieldNumber: 1)
    }
    if self.isCancelled != false {
      try visitor.visitSingularBoolField(value: self.isCancelled, fieldNumber: 2)
    }
    if self.isPaused != false {
      try visitor.visitSingularBoolField(value: self.isPaused, fieldNumber: 3)
    }
    if self.isTimedOut != false {
      try visitor.visitSingularBoolField(value: self.isTimedOut, fieldNumber: 4)
    }
    if self.isWorkerShutdown != false {
      try visitor.visitSingularBoolField(value: self.isWorkerShutdown, fieldNumber: 5)
    }
    if self.isReset != false {
      try visitor.visitSingularBoolField(value: self.isReset, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  package static func ==(lhs: Coresdk.ActivityTask.ActivityCancellationDetails, rhs: Coresdk.ActivityTask.ActivityCancellationDetails) -> Bool {
    if lhs.isNotFound != rhs.isNotFound {return false}
    if lhs.isCancelled != rhs.isCancelled {return false}
    if lhs.isPaused != rhs.isPaused {return false}
    if lhs.isTimedOut != rhs.isTimedOut {return false}
    if lhs.isWorkerShutdown != rhs.isWorkerShutdown {return false}
    if lhs.isReset != rhs.isReset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
