//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Temporal SDK open source project
//
// Copyright (c) 2026 Apple Inc. and the Swift Temporal SDK project authors
// Licensed under MIT License
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Swift Temporal SDK project authors
//
// SPDX-License-Identifier: MIT
//
//===----------------------------------------------------------------------===//

// Swift reserved keywords that need to be escaped with backticks
private let swiftReservedKeywords: Set<String> = [
    // Declaration keywords
    "associatedtype", "class", "deinit", "enum", "extension", "fileprivate", "func", "import", "init",
    "inout", "internal", "let", "open", "operator", "private", "precedencegroup", "protocol", "public",
    "rethrows", "static", "struct", "subscript", "typealias", "var",

    // Statement keywords
    "break", "case", "catch", "continue", "default", "defer", "do", "else", "fallthrough", "for",
    "guard", "if", "in", "repeat", "return", "throw", "switch", "where", "while",

    // Expression and type keywords
    "Any", "as", "await", "catch", "false", "is", "nil", "self", "Self", "super", "throw", "throws",
    "true", "try",

    // Pattern keywords
    "_",

    // Keywords reserved in particular contexts
    "Protocol", "Type", "associativity", "convenience", "didSet", "dynamic", "final", "get", "indirect",
    "infix", "lazy", "left", "mutating", "none", "nonmutating", "optional", "override", "postfix",
    "precedence", "prefix", "required", "right", "set", "some", "unowned", "weak", "willSet",
]

private func escapeIfNeeded(_ name: String) -> String {
    if swiftReservedKeywords.contains(name) {
        return "`\(name)`"
    }
    return name
}

final class NamespaceNode {
    let name: String
    var accessLevel: AccessLevel
    var children: [String: NamespaceNode]

    init(name: String, accessLevel: AccessLevel) {
        self.name = name
        self.accessLevel = accessLevel
        self.children = [:]
    }
}

final class NamespaceTree {
    private var roots: [String: NamespaceNode] = [:]

    func insert(path: [String], accessLevel: AccessLevel) {
        guard !path.isEmpty else { return }

        let rootName = path[0]
        let root = roots[rootName] ?? NamespaceNode(name: rootName, accessLevel: accessLevel)
        roots[rootName] = root

        // public access level should propagate up (public wins over package)
        if accessLevel == .public {
            root.accessLevel = .public
        }

        var current = root
        for component in path.dropFirst() {
            if let existing = current.children[component] {
                if accessLevel == .public {
                    existing.accessLevel = .public
                }
                current = existing
            } else {
                let newNode = NamespaceNode(name: component, accessLevel: accessLevel)
                current.children[component] = newNode
                current = newNode
            }
        }
    }

    func generateSwiftCode() -> String {
        var output = """
            // DO NOT EDIT.
            // Generated by NamespaceRefactorTool
            // This file defines the namespace hierarchy for protobuf types.


            """

        let sortedRoots = roots.values.sorted { $0.name < $1.name }
        for (index, root) in sortedRoots.enumerated() {
            output += generateNode(root, depth: 0)
            if index < sortedRoots.count - 1 {
                output += "\n"
            }
        }

        return output
    }

    private func generateNode(_ node: NamespaceNode, depth: Int) -> String {
        let indent = String(repeating: "  ", count: depth)
        let escapedName = escapeIfNeeded(node.name)
        // Use the node's access level (public propagates up from contained types)
        let accessLevelStr = node.accessLevel == .public ? "public" : "package"
        var output = "\(indent)\(accessLevelStr) enum \(escapedName) {\n"

        let sortedChildren = node.children.values.sorted { $0.name < $1.name }
        for child in sortedChildren {
            output += generateNode(child, depth: depth + 1)
        }

        output += "\(indent)}\n"
        return output
    }
}
